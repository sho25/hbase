begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
operator|.
name|HBASE_MASTER_LOGCLEANER_PLUGINS
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServlet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletRequest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterMetrics
operator|.
name|Option
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterMetricsBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseInterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|InvalidFamilyOperationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaTableAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NamespaceDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|PleaseHoldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ReplicationPeerNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerMetricsBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableDescriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotDisabledException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ColumnFamilyDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ColumnFamilyDescriptorBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MasterSwitchType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptorBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|CoprocessorHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|MergeRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesPromoter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|http
operator|.
name|InfoServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|CoprocessorRpcUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|ServerNotRunningYetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|log
operator|.
name|HBaseMarkers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterRpcServices
operator|.
name|BalanceSwitchMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|AssignmentManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|MergeTableRegionsProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|RegionStates
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|RegionStates
operator|.
name|RegionStateNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|BalancerChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|BaseLoadBalancer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|ClusterStatusChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|LoadBalancerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|HFileCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|LogCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|ReplicationMetaCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|locking
operator|.
name|LockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|NormalizationPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|NormalizationPlan
operator|.
name|PlanType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|RegionNormalizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|RegionNormalizerChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|RegionNormalizerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|CreateTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|DeleteTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|DisableTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|EnableTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureEnv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ModifyTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ProcedurePrepareLatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|RecoverMetaProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|TruncateTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|AddPeerProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|DisablePeerProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|EnablePeerProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|ModifyPeerProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|RemovePeerProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|ReplicationPeerManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|UpdatePeerConfigProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|snapshot
operator|.
name|SnapshotManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mob
operator|.
name|MobConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MemoryBoundedLogMessageBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MonitoredTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|TaskMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure
operator|.
name|MasterProcedureManagerHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure
operator|.
name|flush
operator|.
name|MasterFlushTableProcedureManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|LockedResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|Procedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|RemoteProcedureDispatcher
operator|.
name|RemoteProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|RemoteProcedureException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|store
operator|.
name|wal
operator|.
name|WALProcedureStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|MasterQuotaManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|MasterSpaceQuotaObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|QuotaObserverChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|QuotaUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|SnapshotQuotaObserverChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|SpaceQuotaSnapshotNotifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|SpaceQuotaSnapshotNotifierFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|DefaultStoreEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegionServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RSRpcServices
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionCoprocessorHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionSplitPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|compactions
operator|.
name|ExploringCompactionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|compactions
operator|.
name|FIFOCompactionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationPeerConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationPeerDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|master
operator|.
name|ReplicationHFileCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|master
operator|.
name|ReplicationLogCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|master
operator|.
name|ReplicationPeerConfigUpgrader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|UserProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|trace
operator|.
name|TraceUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Addressing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CompressionTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EncryptionTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HFileArchiveUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HasThread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|IdLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ModifyRegionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|LoadBalancerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MasterAddressTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MasterMaintenanceModeTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RegionNormalizerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKClusterId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZNodePaths
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jetty
operator|.
name|server
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jetty
operator|.
name|server
operator|.
name|ServerConnector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jetty
operator|.
name|servlet
operator|.
name|ServletHolder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jetty
operator|.
name|webapp
operator|.
name|WebAppContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|GetRegionInfoResponse
operator|.
name|CompactionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|RegionServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|QuotaProtos
operator|.
name|Quotas
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|QuotaProtos
operator|.
name|SpaceViolationPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|SnapshotProtos
operator|.
name|SnapshotDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|WALProtos
import|;
end_import

begin_comment
comment|/**  * HMaster is the "master server" for HBase. An HBase cluster has one active  * master.  If many masters are started, all compete.  Whichever wins goes on to  * run the cluster.  All others park themselves in their constructor until  * master or cluster shutdown or until the active master loses its lease in  * zookeeper.  Thereafter, all running master jostle to take over master role.  *  *<p>The Master can be asked shutdown the cluster. See {@link #shutdown()}.  In  * this case it will tell all regionservers to go down and then wait on them  * all reporting in that they are down.  This master will then shut itself down.  *  *<p>You can also shutdown just this master.  Call {@link #stopMaster()}.  *  * @see org.apache.zookeeper.Watcher  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|TOOLS
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
class|class
name|HMaster
extends|extends
name|HRegionServer
implements|implements
name|MasterServices
block|{
specifier|private
specifier|static
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HMaster
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Protection against zombie master. Started once Master accepts active responsibility and    * starts taking over responsibilities. Allows a finite time window before giving up ownership.    */
specifier|private
specifier|static
class|class
name|InitializationMonitor
extends|extends
name|HasThread
block|{
comment|/** The amount of time in milliseconds to sleep before checking initialization status. */
specifier|public
specifier|static
specifier|final
name|String
name|TIMEOUT_KEY
init|=
literal|"hbase.master.initializationmonitor.timeout"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|TIMEOUT_DEFAULT
init|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
literal|15
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
decl_stmt|;
comment|/**      * When timeout expired and initialization has not complete, call {@link System#exit(int)} when      * true, do nothing otherwise.      */
specifier|public
specifier|static
specifier|final
name|String
name|HALT_KEY
init|=
literal|"hbase.master.initializationmonitor.haltontimeout"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|HALT_DEFAULT
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|HMaster
name|master
decl_stmt|;
specifier|private
specifier|final
name|long
name|timeout
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|haltOnTimeout
decl_stmt|;
comment|/** Creates a Thread that monitors the {@link #isInitialized()} state. */
name|InitializationMonitor
parameter_list|(
name|HMaster
name|master
parameter_list|)
block|{
name|super
argument_list|(
literal|"MasterInitializationMonitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|TIMEOUT_KEY
argument_list|,
name|TIMEOUT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|haltOnTimeout
operator|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|HALT_KEY
argument_list|,
name|HALT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
operator|!
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
name|master
operator|.
name|isActiveMaster
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|master
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initialization completed within allotted tolerance. Monitor exiting."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Master failed to complete initialization after "
operator|+
name|timeout
operator|+
literal|"ms. Please"
operator|+
literal|" consider submitting a bug report including a thread dump of this process."
argument_list|)
expr_stmt|;
if|if
condition|(
name|haltOnTimeout
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Zombie Master exiting. Thread dump to stdout"
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|printThreadInfo
argument_list|(
name|System
operator|.
name|out
argument_list|,
literal|"Zombie HMaster"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"InitMonitor thread interrupted. Existing."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// MASTER is name of the webapp and the attribute name used stuffing this
comment|//instance into web context.
specifier|public
specifier|static
specifier|final
name|String
name|MASTER
init|=
literal|"master"
decl_stmt|;
comment|// Manager and zk listener for master election
specifier|private
specifier|final
name|ActiveMasterManager
name|activeMasterManager
decl_stmt|;
comment|// Region server tracker
name|RegionServerTracker
name|regionServerTracker
decl_stmt|;
comment|// Draining region server tracker
specifier|private
name|DrainingServerTracker
name|drainingServerTracker
decl_stmt|;
comment|// Tracker for load balancer state
name|LoadBalancerTracker
name|loadBalancerTracker
decl_stmt|;
comment|// Tracker for split and merge state
specifier|private
name|SplitOrMergeTracker
name|splitOrMergeTracker
decl_stmt|;
comment|// Tracker for region normalizer state
specifier|private
name|RegionNormalizerTracker
name|regionNormalizerTracker
decl_stmt|;
comment|//Tracker for master maintenance mode setting
specifier|private
name|MasterMaintenanceModeTracker
name|maintenanceModeTracker
decl_stmt|;
specifier|private
name|ClusterSchemaService
name|clusterSchemaService
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|HBASE_MASTER_WAIT_ON_SERVICE_IN_SECONDS
init|=
literal|"hbase.master.wait.on.service.seconds"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_HBASE_MASTER_WAIT_ON_SERVICE_IN_SECONDS
init|=
literal|5
operator|*
literal|60
decl_stmt|;
comment|// Metrics for the HMaster
specifier|final
name|MetricsMaster
name|metricsMaster
decl_stmt|;
comment|// file system manager for the master FS operations
specifier|private
name|MasterFileSystem
name|fileSystemManager
decl_stmt|;
specifier|private
name|MasterWalManager
name|walManager
decl_stmt|;
comment|// server manager to deal with region server info
specifier|private
specifier|volatile
name|ServerManager
name|serverManager
decl_stmt|;
comment|// manager of assignment nodes in zookeeper
specifier|private
name|AssignmentManager
name|assignmentManager
decl_stmt|;
comment|// manager of replication
specifier|private
name|ReplicationPeerManager
name|replicationPeerManager
decl_stmt|;
comment|// buffer for "fatal error" notices from region servers
comment|// in the cluster. This is only used for assisting
comment|// operations/debugging.
name|MemoryBoundedLogMessageBuffer
name|rsFatals
decl_stmt|;
comment|// flag set after we become the active master (used for testing)
specifier|private
specifier|volatile
name|boolean
name|activeMaster
init|=
literal|false
decl_stmt|;
comment|// flag set after we complete initialization once active
specifier|private
specifier|final
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|initialized
init|=
operator|new
name|ProcedureEvent
argument_list|<>
argument_list|(
literal|"master initialized"
argument_list|)
decl_stmt|;
comment|// flag set after master services are started,
comment|// initialization may have not completed yet.
specifier|volatile
name|boolean
name|serviceStarted
init|=
literal|false
decl_stmt|;
comment|// flag set after we complete assignMeta.
specifier|private
specifier|final
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|serverCrashProcessingEnabled
init|=
operator|new
name|ProcedureEvent
argument_list|<>
argument_list|(
literal|"server crash processing"
argument_list|)
decl_stmt|;
comment|// Maximum time we should run balancer for
specifier|private
specifier|final
name|int
name|maxBlancingTime
decl_stmt|;
comment|// Maximum percent of regions in transition when balancing
specifier|private
specifier|final
name|double
name|maxRitPercent
decl_stmt|;
specifier|private
specifier|final
name|LockManager
name|lockManager
init|=
operator|new
name|LockManager
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|private
name|LoadBalancer
name|balancer
decl_stmt|;
specifier|private
name|RegionNormalizer
name|normalizer
decl_stmt|;
specifier|private
name|BalancerChore
name|balancerChore
decl_stmt|;
specifier|private
name|RegionNormalizerChore
name|normalizerChore
decl_stmt|;
specifier|private
name|ClusterStatusChore
name|clusterStatusChore
decl_stmt|;
specifier|private
name|ClusterStatusPublisher
name|clusterStatusPublisherChore
init|=
literal|null
decl_stmt|;
name|CatalogJanitor
name|catalogJanitorChore
decl_stmt|;
specifier|private
name|ReplicationMetaCleaner
name|replicationMetaCleaner
decl_stmt|;
specifier|private
name|LogCleaner
name|logCleaner
decl_stmt|;
specifier|private
name|HFileCleaner
name|hfileCleaner
decl_stmt|;
specifier|private
name|ExpiredMobFileCleanerChore
name|expiredMobFileCleanerChore
decl_stmt|;
specifier|private
name|MobCompactionChore
name|mobCompactChore
decl_stmt|;
specifier|private
name|MasterMobCompactionThread
name|mobCompactThread
decl_stmt|;
comment|// used to synchronize the mobCompactionStates
specifier|private
specifier|final
name|IdLock
name|mobCompactionLock
init|=
operator|new
name|IdLock
argument_list|()
decl_stmt|;
comment|// save the information of mob compactions in tables.
comment|// the key is table name, the value is the number of compactions in that table.
specifier|private
name|Map
argument_list|<
name|TableName
argument_list|,
name|AtomicInteger
argument_list|>
name|mobCompactionStates
init|=
name|Maps
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
name|MasterCoprocessorHost
name|cpHost
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|preLoadTableDescriptors
decl_stmt|;
comment|// Time stamps for when a hmaster became active
specifier|private
name|long
name|masterActiveTime
decl_stmt|;
comment|// Time stamp for when HMaster finishes becoming Active Master
specifier|private
name|long
name|masterFinishedInitializationTime
decl_stmt|;
comment|//should we check the compression codec type at master side, default true, HBASE-6370
specifier|private
specifier|final
name|boolean
name|masterCheckCompression
decl_stmt|;
comment|//should we check encryption settings at master side, default true
specifier|private
specifier|final
name|boolean
name|masterCheckEncryption
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Service
argument_list|>
name|coprocessorServiceHandlers
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
comment|// monitor for snapshot of hbase tables
name|SnapshotManager
name|snapshotManager
decl_stmt|;
comment|// monitor for distributed procedures
specifier|private
name|MasterProcedureManagerHost
name|mpmHost
decl_stmt|;
comment|// it is assigned after 'initialized' guard set to true, so should be volatile
specifier|private
specifier|volatile
name|MasterQuotaManager
name|quotaManager
decl_stmt|;
specifier|private
name|SpaceQuotaSnapshotNotifier
name|spaceQuotaSnapshotNotifier
decl_stmt|;
specifier|private
name|QuotaObserverChore
name|quotaObserverChore
decl_stmt|;
specifier|private
name|SnapshotQuotaObserverChore
name|snapshotQuotaChore
decl_stmt|;
specifier|private
name|ProcedureExecutor
argument_list|<
name|MasterProcedureEnv
argument_list|>
name|procedureExecutor
decl_stmt|;
specifier|private
name|WALProcedureStore
name|procedureStore
decl_stmt|;
comment|// handle table states
specifier|private
name|TableStateManager
name|tableStateManager
decl_stmt|;
specifier|private
name|long
name|splitPlanCount
decl_stmt|;
specifier|private
name|long
name|mergePlanCount
decl_stmt|;
comment|/* Handle favored nodes information */
specifier|private
name|FavoredNodesManager
name|favoredNodesManager
decl_stmt|;
comment|/** jetty server for master to redirect requests to regionserver infoServer */
specifier|private
name|Server
name|masterJettyServer
decl_stmt|;
specifier|public
specifier|static
class|class
name|RedirectServlet
extends|extends
name|HttpServlet
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2894774810058302473L
decl_stmt|;
specifier|private
specifier|final
name|int
name|regionServerInfoPort
decl_stmt|;
specifier|private
specifier|final
name|String
name|regionServerHostname
decl_stmt|;
comment|/**      * @param infoServer that we're trying to send all requests to      * @param hostname may be null. if given, will be used for redirects instead of host from client.      */
specifier|public
name|RedirectServlet
parameter_list|(
name|InfoServer
name|infoServer
parameter_list|,
name|String
name|hostname
parameter_list|)
block|{
name|regionServerInfoPort
operator|=
name|infoServer
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|regionServerHostname
operator|=
name|hostname
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|doGet
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|)
throws|throws
name|ServletException
throws|,
name|IOException
block|{
name|String
name|redirectHost
init|=
name|regionServerHostname
decl_stmt|;
if|if
condition|(
name|redirectHost
operator|==
literal|null
condition|)
block|{
name|redirectHost
operator|=
name|request
operator|.
name|getServerName
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Addressing
operator|.
name|isLocalAddress
argument_list|(
name|InetAddress
operator|.
name|getByName
argument_list|(
name|redirectHost
argument_list|)
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't resolve '"
operator|+
name|redirectHost
operator|+
literal|"' as an address local to this node and '"
operator|+
name|MASTER_HOSTNAME_KEY
operator|+
literal|"' is not set; client will get a HTTP 400 response. If "
operator|+
literal|"your HBase deployment relies on client accessible names that the region server process "
operator|+
literal|"can't resolve locally, then you should set the previously mentioned configuration variable "
operator|+
literal|"to an appropriate hostname."
argument_list|)
expr_stmt|;
comment|// no sending client provided input back to the client, so the goal host is just in the logs.
name|response
operator|.
name|sendError
argument_list|(
literal|400
argument_list|,
literal|"Request was to a host that I can't resolve for any of the network interfaces on "
operator|+
literal|"this node. If this is due to an intermediary such as an HTTP load balancer or other proxy, your HBase "
operator|+
literal|"administrator can set '"
operator|+
name|MASTER_HOSTNAME_KEY
operator|+
literal|"' to point to the correct hostname."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// TODO this scheme should come from looking at the scheme registered in the infoserver's http server for the
comment|// host and port we're using, but it's buried way too deep to do that ATM.
name|String
name|redirectUrl
init|=
name|request
operator|.
name|getScheme
argument_list|()
operator|+
literal|"://"
operator|+
name|redirectHost
operator|+
literal|":"
operator|+
name|regionServerInfoPort
operator|+
name|request
operator|.
name|getRequestURI
argument_list|()
decl_stmt|;
name|response
operator|.
name|sendRedirect
argument_list|(
name|redirectUrl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Initializes the HMaster. The steps are as follows:    *<p>    *<ol>    *<li>Initialize the local HRegionServer    *<li>Start the ActiveMasterManager.    *</ol>    *<p>    * Remaining steps of initialization occur in    * #finishActiveMasterInitialization(MonitoredTask) after    * the master becomes the active one.    */
specifier|public
name|HMaster
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|TraceUtil
operator|.
name|initTracer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|rsFatals
operator|=
operator|new
name|MemoryBoundedLogMessageBuffer
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.master.buffer.for.rs.fatals"
argument_list|,
literal|1
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"hbase.rootdir="
operator|+
name|getRootDir
argument_list|()
operator|+
literal|", hbase.cluster.distributed="
operator|+
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|CLUSTER_DISTRIBUTED
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Disable usage of meta replicas in the master
name|this
operator|.
name|conf
operator|.
name|setBoolean
argument_list|(
name|HConstants
operator|.
name|USE_META_REPLICAS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|decorateMasterConfiguration
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// Hack! Maps DFSClient => Master for logs.  HDFS made this
comment|// config param for task trackers, but we can piggyback off of it.
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"mapreduce.task.attempt.id"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"mapreduce.task.attempt.id"
argument_list|,
literal|"hb_m_"
operator|+
name|this
operator|.
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// should we check the compression codec type at master side, default true, HBASE-6370
name|this
operator|.
name|masterCheckCompression
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.check.compression"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// should we check encryption settings at master side, default true
name|this
operator|.
name|masterCheckEncryption
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.check.encryption"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|metricsMaster
operator|=
operator|new
name|MetricsMaster
argument_list|(
operator|new
name|MetricsMasterWrapperImpl
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|// preload table descriptor at startup
name|this
operator|.
name|preLoadTableDescriptors
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.preload.tabledescriptors"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxBlancingTime
operator|=
name|getMaxBalancingTime
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxRitPercent
operator|=
name|conf
operator|.
name|getDouble
argument_list|(
name|HConstants
operator|.
name|HBASE_MASTER_BALANCER_MAX_RIT_PERCENT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_MASTER_BALANCER_MAX_RIT_PERCENT
argument_list|)
expr_stmt|;
comment|// Do we publish the status?
name|boolean
name|shouldPublish
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|STATUS_PUBLISHED
argument_list|,
name|HConstants
operator|.
name|STATUS_PUBLISHED_DEFAULT
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|ClusterStatusPublisher
operator|.
name|Publisher
argument_list|>
name|publisherClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|ClusterStatusPublisher
operator|.
name|STATUS_PUBLISHER_CLASS
argument_list|,
name|ClusterStatusPublisher
operator|.
name|DEFAULT_STATUS_PUBLISHER_CLASS
argument_list|,
name|ClusterStatusPublisher
operator|.
name|Publisher
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldPublish
condition|)
block|{
if|if
condition|(
name|publisherClass
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|HConstants
operator|.
name|STATUS_PUBLISHED
operator|+
literal|" is true, but "
operator|+
name|ClusterStatusPublisher
operator|.
name|DEFAULT_STATUS_PUBLISHER_CLASS
operator|+
literal|" is not set - not publishing status"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clusterStatusPublisherChore
operator|=
operator|new
name|ClusterStatusPublisher
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|publisherClass
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|clusterStatusPublisherChore
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Some unit tests don't need a cluster, so no zookeeper at all
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.testing.nocluster"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|this
operator|.
name|activeMasterManager
operator|=
operator|new
name|ActiveMasterManager
argument_list|(
name|zooKeeper
argument_list|,
name|this
operator|.
name|serverName
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|activeMasterManager
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Make sure we log the exception. HMaster is often started via reflection and the
comment|// cause of failed startup is lost.
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed construction of Master"
argument_list|,
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getUseThisHostnameInstead
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|get
argument_list|(
name|MASTER_HOSTNAME_KEY
argument_list|)
return|;
block|}
comment|// Main run loop. Calls through to the regionserver run loop AFTER becoming active Master; will
comment|// block in here until then.
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.testing.nocluster"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
try|try
block|{
name|int
name|infoPort
init|=
name|putUpJettyServer
argument_list|()
decl_stmt|;
name|startActiveMasterManager
argument_list|(
name|infoPort
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Make sure we log the exception.
name|String
name|error
init|=
literal|"Failed to become Active Master"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|error
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// Abort should have been called already.
if|if
condition|(
operator|!
name|isAborted
argument_list|()
condition|)
block|{
name|abort
argument_list|(
name|error
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Fall in here even if we have been aborted. Need to run the shutdown services and
comment|// the super run call will do this for us.
name|super
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|this
operator|.
name|clusterSchemaService
operator|!=
literal|null
condition|)
block|{
comment|// If on way out, then we are no longer active master.
name|this
operator|.
name|clusterSchemaService
operator|.
name|stopAsync
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|clusterSchemaService
operator|.
name|awaitTerminated
argument_list|(
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|HBASE_MASTER_WAIT_ON_SERVICE_IN_SECONDS
argument_list|,
name|DEFAULT_HBASE_MASTER_WAIT_ON_SERVICE_IN_SECONDS
argument_list|)
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|te
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed shutdown of clusterSchemaService"
argument_list|,
name|te
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|activeMaster
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// return the actual infoPort, -1 means disable info server.
specifier|private
name|int
name|putUpJettyServer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.infoserver.redirect"
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
specifier|final
name|int
name|infoPort
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.info.port.orig"
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_INFOPORT
argument_list|)
decl_stmt|;
comment|// -1 is for disabling info server, so no redirecting
if|if
condition|(
name|infoPort
operator|<
literal|0
operator|||
name|infoServer
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|infoPort
operator|==
name|infoServer
operator|.
name|getPort
argument_list|()
condition|)
block|{
return|return
name|infoPort
return|;
block|}
specifier|final
name|String
name|addr
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.master.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Addressing
operator|.
name|isLocalAddress
argument_list|(
name|InetAddress
operator|.
name|getByName
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Failed to start redirecting jetty server. Address "
operator|+
name|addr
operator|+
literal|" does not belong to this host. Correct configuration parameter: "
operator|+
literal|"hbase.master.info.bindAddress"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|// TODO I'm pretty sure we could just add another binding to the InfoServer run by
comment|// the RegionServer and have it run the RedirectServlet instead of standing up
comment|// a second entire stack here.
name|masterJettyServer
operator|=
operator|new
name|Server
argument_list|()
expr_stmt|;
specifier|final
name|ServerConnector
name|connector
init|=
operator|new
name|ServerConnector
argument_list|(
name|masterJettyServer
argument_list|)
decl_stmt|;
name|connector
operator|.
name|setHost
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|connector
operator|.
name|setPort
argument_list|(
name|infoPort
argument_list|)
expr_stmt|;
name|masterJettyServer
operator|.
name|addConnector
argument_list|(
name|connector
argument_list|)
expr_stmt|;
name|masterJettyServer
operator|.
name|setStopAtShutdown
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|String
name|redirectHostname
init|=
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|useThisHostnameInstead
argument_list|)
condition|?
literal|null
else|:
name|useThisHostnameInstead
decl_stmt|;
specifier|final
name|RedirectServlet
name|redirect
init|=
operator|new
name|RedirectServlet
argument_list|(
name|infoServer
argument_list|,
name|redirectHostname
argument_list|)
decl_stmt|;
specifier|final
name|WebAppContext
name|context
init|=
operator|new
name|WebAppContext
argument_list|(
literal|null
argument_list|,
literal|"/"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|WebAppContext
operator|.
name|NO_SESSIONS
argument_list|)
decl_stmt|;
name|context
operator|.
name|addServlet
argument_list|(
operator|new
name|ServletHolder
argument_list|(
name|redirect
argument_list|)
argument_list|,
literal|"/*"
argument_list|)
expr_stmt|;
name|context
operator|.
name|setServer
argument_list|(
name|masterJettyServer
argument_list|)
expr_stmt|;
try|try
block|{
name|masterJettyServer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to start redirecting jetty server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|connector
operator|.
name|getLocalPort
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Function
argument_list|<
name|TableDescriptorBuilder
argument_list|,
name|TableDescriptorBuilder
argument_list|>
name|getMetaTableObserver
parameter_list|()
block|{
return|return
name|builder
lambda|->
name|builder
operator|.
name|setRegionReplication
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|META_REPLICAS_NUM
argument_list|,
name|HConstants
operator|.
name|DEFAULT_META_REPLICA_NUM
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * For compatibility, if failed with regionserver credentials, try the master one    */
annotation|@
name|Override
specifier|protected
name|void
name|login
parameter_list|(
name|UserProvider
name|user
parameter_list|,
name|String
name|host
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|super
operator|.
name|login
argument_list|(
name|user
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|user
operator|.
name|login
argument_list|(
literal|"hbase.master.keytab.file"
argument_list|,
literal|"hbase.master.kerberos.principal"
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * If configured to put regions on active master,    * wait till a backup master becomes active.    * Otherwise, loop till the server is stopped or aborted.    */
annotation|@
name|Override
specifier|protected
name|void
name|waitForMasterActive
parameter_list|()
block|{
name|boolean
name|tablesOnMaster
init|=
name|LoadBalancer
operator|.
name|isTablesOnMaster
argument_list|(
name|conf
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|tablesOnMaster
operator|&&
name|activeMaster
operator|)
operator|&&
operator|!
name|isStopped
argument_list|()
operator|&&
operator|!
name|isAborted
argument_list|()
condition|)
block|{
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|MasterRpcServices
name|getMasterRpcServices
parameter_list|()
block|{
return|return
operator|(
name|MasterRpcServices
operator|)
name|rpcServices
return|;
block|}
specifier|public
name|boolean
name|balanceSwitch
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getMasterRpcServices
argument_list|()
operator|.
name|switchBalancer
argument_list|(
name|b
argument_list|,
name|BalanceSwitchMode
operator|.
name|ASYNC
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getProcessName
parameter_list|()
block|{
return|return
name|MASTER
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|canCreateBaseZNode
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|canUpdateTableDescriptor
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RSRpcServices
name|createRpcServices
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|MasterRpcServices
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|configureInfoServer
parameter_list|()
block|{
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|"master-status"
argument_list|,
literal|"/master-status"
argument_list|,
name|MasterStatusServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
name|MASTER
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|LoadBalancer
operator|.
name|isTablesOnMaster
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|super
operator|.
name|configureInfoServer
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|Class
argument_list|<
name|?
extends|extends
name|HttpServlet
argument_list|>
name|getDumpServlet
parameter_list|()
block|{
return|return
name|MasterDumpServlet
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|MetricsMaster
name|getMasterMetrics
parameter_list|()
block|{
return|return
name|metricsMaster
return|;
block|}
comment|/**    * Initialize all ZK based system trackers.    */
name|void
name|initializeZKBasedSystemTrackers
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
throws|,
name|ReplicationException
block|{
name|this
operator|.
name|balancer
operator|=
name|LoadBalancerFactory
operator|.
name|getLoadBalancer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|normalizer
operator|=
name|RegionNormalizerFactory
operator|.
name|getRegionNormalizer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|normalizer
operator|.
name|setMasterServices
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|normalizer
operator|.
name|setMasterRpcServices
argument_list|(
operator|(
name|MasterRpcServices
operator|)
name|rpcServices
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadBalancerTracker
operator|=
operator|new
name|LoadBalancerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadBalancerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionNormalizerTracker
operator|=
operator|new
name|RegionNormalizerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionNormalizerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|splitOrMergeTracker
operator|=
operator|new
name|SplitOrMergeTracker
argument_list|(
name|zooKeeper
argument_list|,
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|splitOrMergeTracker
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Create Assignment Manager
name|this
operator|.
name|assignmentManager
operator|=
operator|new
name|AssignmentManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|replicationPeerManager
operator|=
name|ReplicationPeerManager
operator|.
name|create
argument_list|(
name|zooKeeper
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServerTracker
operator|=
operator|new
name|RegionServerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|serverManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|drainingServerTracker
operator|=
operator|new
name|DrainingServerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|serverManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|drainingServerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|maintenanceModeTracker
operator|=
operator|new
name|MasterMaintenanceModeTracker
argument_list|(
name|zooKeeper
argument_list|)
expr_stmt|;
name|this
operator|.
name|maintenanceModeTracker
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Set the cluster as up.  If new RSs, they'll be waiting on this before
comment|// going ahead with their startup.
name|boolean
name|wasUp
init|=
name|this
operator|.
name|clusterStatusTracker
operator|.
name|isClusterUp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|wasUp
condition|)
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterUp
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Active/primary master="
operator|+
name|this
operator|.
name|serverName
operator|+
literal|", sessionid=0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getSessionId
argument_list|()
argument_list|)
operator|+
literal|", setting cluster-up flag (Was="
operator|+
name|wasUp
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// create/initialize the snapshot manager and other procedure managers
name|this
operator|.
name|snapshotManager
operator|=
operator|new
name|SnapshotManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|=
operator|new
name|MasterProcedureManagerHost
argument_list|()
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|register
argument_list|(
name|this
operator|.
name|snapshotManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|register
argument_list|(
operator|new
name|MasterFlushTableProcedureManager
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|loadProcedures
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|initialize
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|metricsMaster
argument_list|)
expr_stmt|;
block|}
comment|/**    * Finish initialization of HMaster after becoming the primary master.    *    *<ol>    *<li>Initialize master components - file system manager, server manager,    *     assignment manager, region server tracker, etc</li>    *<li>Start necessary service threads - balancer, catalog janior,    *     executor services, etc</li>    *<li>Set cluster as UP in ZooKeeper</li>    *<li>Wait for RegionServers to check-in</li>    *<li>Split logs and perform data recovery, if necessary</li>    *<li>Ensure assignment of meta/namespace regions<li>    *<li>Handle either fresh cluster start or master failover</li>    *</ol>    */
specifier|private
name|void
name|finishActiveMasterInitialization
parameter_list|(
name|MonitoredTask
name|status
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
throws|,
name|ReplicationException
block|{
name|Thread
name|zombieDetector
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|InitializationMonitor
argument_list|(
name|this
argument_list|)
argument_list|,
literal|"ActiveMasterInitializationMonitor-"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
name|zombieDetector
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|zombieDetector
operator|.
name|start
argument_list|()
expr_stmt|;
comment|/*      * We are active master now... go initialize components we need to run.      */
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing Master file system"
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterActiveTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// TODO: Do this using Dependency Injection, using PicoContainer, Guice or Spring.
comment|// Initialize the chunkCreator
name|initializeMemStoreChunkCreator
argument_list|()
expr_stmt|;
name|this
operator|.
name|fileSystemManager
operator|=
operator|new
name|MasterFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|walManager
operator|=
operator|new
name|MasterWalManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// enable table descriptors cache
name|this
operator|.
name|tableDescriptors
operator|.
name|setCacheOn
argument_list|()
expr_stmt|;
comment|// warm-up HTDs cache on master initialization
if|if
condition|(
name|preLoadTableDescriptors
condition|)
block|{
name|status
operator|.
name|setStatus
argument_list|(
literal|"Pre-loading table descriptors"
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableDescriptors
operator|.
name|getAll
argument_list|()
expr_stmt|;
block|}
comment|// Publish cluster ID; set it in Master too. The superclass RegionServer does this later but
comment|// only after it has checked in with the Master. At least a few tests ask Master for clusterId
comment|// before it has called its run method and before RegionServer has done the reportForDuty.
name|ClusterId
name|clusterId
init|=
name|fileSystemManager
operator|.
name|getClusterId
argument_list|()
decl_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Publishing Cluster ID "
operator|+
name|clusterId
operator|+
literal|" in ZooKeeper"
argument_list|)
expr_stmt|;
name|ZKClusterId
operator|.
name|setClusterId
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|fileSystemManager
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterId
operator|=
name|clusterId
operator|.
name|toString
argument_list|()
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
name|createServerManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// This manager is started AFTER hbase:meta is confirmed on line.
comment|// See inside metaBootstrap.recoverMeta(); below. Shouldn't be so cryptic!
comment|// hbase.mirror.table.state.to.zookeeper is so hbase1 clients can connect. They read table
comment|// state from zookeeper while hbase2 reads it from hbase:meta. Disable if no hbase1 clients.
name|this
operator|.
name|tableStateManager
operator|=
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
name|MirroringTableStateManager
operator|.
name|MIRROR_TABLE_STATE_TO_ZK_KEY
argument_list|,
literal|true
argument_list|)
condition|?
operator|new
name|MirroringTableStateManager
argument_list|(
name|this
argument_list|)
else|:
operator|new
name|TableStateManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing ZK system trackers"
argument_list|)
expr_stmt|;
name|initializeZKBasedSystemTrackers
argument_list|()
expr_stmt|;
comment|// Set ourselves as active Master now our claim has succeeded up in zk.
name|this
operator|.
name|activeMaster
operator|=
literal|true
expr_stmt|;
comment|// This is for backwards compatibility
comment|// See HBASE-11393
name|status
operator|.
name|setStatus
argument_list|(
literal|"Update TableCFs node in ZNode"
argument_list|)
expr_stmt|;
name|ReplicationPeerConfigUpgrader
name|tableCFsUpdater
init|=
operator|new
name|ReplicationPeerConfigUpgrader
argument_list|(
name|zooKeeper
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|tableCFsUpdater
operator|.
name|copyTableCFs
argument_list|()
expr_stmt|;
comment|// Add the Observer to delete space quotas on table deletion before starting all CPs by
comment|// default with quota support, avoiding if user specifically asks to not load this Observer.
if|if
condition|(
name|QuotaUtil
operator|.
name|isQuotaEnabled
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|updateConfigurationForSpaceQuotaObserver
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// initialize master side coprocessors before we start handling requests
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing master coprocessors"
argument_list|)
expr_stmt|;
name|this
operator|.
name|cpHost
operator|=
operator|new
name|MasterCoprocessorHost
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// start up all service threads.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing master service threads"
argument_list|)
expr_stmt|;
name|startServiceThreads
argument_list|()
expr_stmt|;
comment|// Wake up this server to check in
name|sleeper
operator|.
name|skipSleepCycle
argument_list|()
expr_stmt|;
comment|// Wait for region servers to report in.
comment|// With this as part of master initialization, it precludes our being able to start a single
comment|// server that is both Master and RegionServer. Needs more thought. TODO.
name|String
name|statusStr
init|=
literal|"Wait for region servers to report in"
decl_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
name|statusStr
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|Objects
operator|.
name|toString
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|waitForRegionServers
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|balancer
operator|instanceof
name|FavoredNodesPromoter
condition|)
block|{
name|favoredNodesManager
operator|=
operator|new
name|FavoredNodesManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|//initialize load balancer
name|this
operator|.
name|balancer
operator|.
name|setMasterServices
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|.
name|setClusterMetrics
argument_list|(
name|getClusterMetricsWithoutCoprocessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|.
name|initialize
argument_list|()
expr_stmt|;
comment|// Make sure meta assigned before proceeding.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Recovering  Meta Region"
argument_list|)
expr_stmt|;
comment|// Check if master is shutting down because issue initializing regionservers or balancer.
if|if
condition|(
name|isStopped
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Bring up hbase:meta. recoverMeta is a blocking call waiting until hbase:meta is deployed.
comment|// It also starts the TableStateManager.
name|MasterMetaBootstrap
name|metaBootstrap
init|=
name|createMetaBootstrap
argument_list|(
name|this
argument_list|,
name|status
argument_list|)
decl_stmt|;
name|metaBootstrap
operator|.
name|recoverMeta
argument_list|()
expr_stmt|;
comment|//Initialize after meta as it scans meta
if|if
condition|(
name|favoredNodesManager
operator|!=
literal|null
condition|)
block|{
name|SnapshotOfRegionAssignmentFromMeta
name|snapshotOfRegionAssignment
init|=
operator|new
name|SnapshotOfRegionAssignmentFromMeta
argument_list|(
name|getConnection
argument_list|()
argument_list|)
decl_stmt|;
name|snapshotOfRegionAssignment
operator|.
name|initialize
argument_list|()
expr_stmt|;
name|favoredNodesManager
operator|.
name|initialize
argument_list|(
name|snapshotOfRegionAssignment
argument_list|)
expr_stmt|;
block|}
name|status
operator|.
name|setStatus
argument_list|(
literal|"Submitting log splitting work for previously failed region servers"
argument_list|)
expr_stmt|;
name|metaBootstrap
operator|.
name|processDeadServers
argument_list|()
expr_stmt|;
comment|// Fix up assignment manager status
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting assignment manager"
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|joinCluster
argument_list|()
expr_stmt|;
comment|// set cluster status again after user regions are assigned
name|this
operator|.
name|balancer
operator|.
name|setClusterMetrics
argument_list|(
name|getClusterMetricsWithoutCoprocessor
argument_list|()
argument_list|)
expr_stmt|;
comment|// Start balancer and meta catalog janitor after meta and regions have been assigned.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting balancer and catalog janitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterStatusChore
operator|=
operator|new
name|ClusterStatusChore
argument_list|(
name|this
argument_list|,
name|balancer
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|clusterStatusChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancerChore
operator|=
operator|new
name|BalancerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|balancerChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|normalizerChore
operator|=
operator|new
name|RegionNormalizerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|normalizerChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|catalogJanitorChore
operator|=
operator|new
name|CatalogJanitor
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|catalogJanitorChore
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting cluster schema service"
argument_list|)
expr_stmt|;
name|initClusterSchemaService
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|preMasterInitialization
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor preMasterInitialization() hook failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|status
operator|.
name|markComplete
argument_list|(
literal|"Initialization successful"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Master has completed initialization %.3fsec"
argument_list|,
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|masterActiveTime
operator|)
operator|/
literal|1000.0f
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterFinishedInitializationTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
operator|.
name|balancer
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
operator|.
name|hfileCleaner
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
operator|.
name|logCleaner
argument_list|)
expr_stmt|;
comment|// Set master as 'initialized'.
name|setInitialized
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assignmentManager
operator|.
name|checkIfShouldMoveSystemRegionAsync
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Assign meta replicas"
argument_list|)
expr_stmt|;
name|metaBootstrap
operator|.
name|assignMetaReplicas
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting quota manager"
argument_list|)
expr_stmt|;
name|initQuotaManager
argument_list|()
expr_stmt|;
if|if
condition|(
name|QuotaUtil
operator|.
name|isQuotaEnabled
argument_list|(
name|conf
argument_list|)
condition|)
block|{
comment|// Create the quota snapshot notifier
name|spaceQuotaSnapshotNotifier
operator|=
name|createQuotaSnapshotNotifier
argument_list|()
expr_stmt|;
name|spaceQuotaSnapshotNotifier
operator|.
name|initialize
argument_list|(
name|getClusterConnection
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|quotaObserverChore
operator|=
operator|new
name|QuotaObserverChore
argument_list|(
name|this
argument_list|,
name|getMasterMetrics
argument_list|()
argument_list|)
expr_stmt|;
comment|// Start the chore to read the region FS space reports and act on them
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|quotaObserverChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotQuotaChore
operator|=
operator|new
name|SnapshotQuotaObserverChore
argument_list|(
name|this
argument_list|,
name|getMasterMetrics
argument_list|()
argument_list|)
expr_stmt|;
comment|// Start the chore to read snapshots and add their usage to table/NS quotas
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|snapshotQuotaChore
argument_list|)
expr_stmt|;
block|}
comment|// clear the dead servers with same host name and port of online server because we are not
comment|// removing dead server with same hostname and port of rs which is trying to check in before
comment|// master initialization. See HBASE-5916.
name|this
operator|.
name|serverManager
operator|.
name|clearDeadServersWithSameHostNameAndPortOfOnlineServer
argument_list|()
expr_stmt|;
comment|// Check and set the znode ACLs if needed in case we are overtaking a non-secure configuration
name|status
operator|.
name|setStatus
argument_list|(
literal|"Checking ZNode ACLs"
argument_list|)
expr_stmt|;
name|zooKeeper
operator|.
name|checkAndSetZNodeAcls
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing MOB Cleaner"
argument_list|)
expr_stmt|;
name|initMobCleaner
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Calling postStartMaster coprocessors"
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
comment|// don't let cp initialization errors kill the master
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|postStartMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor postStartMaster() hook failed"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
name|zombieDetector
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|/**    * Adds the {@code MasterSpaceQuotaObserver} to the list of configured Master observers to    * automatically remove space quotas for a table when that table is deleted.    */
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|updateConfigurationForSpaceQuotaObserver
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// We're configured to not delete quotas on table deletion, so we don't need to add the obs.
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|MasterSpaceQuotaObserver
operator|.
name|REMOVE_QUOTA_ON_TABLE_DELETE
argument_list|,
name|MasterSpaceQuotaObserver
operator|.
name|REMOVE_QUOTA_ON_TABLE_DELETE_DEFAULT
argument_list|)
condition|)
block|{
return|return;
block|}
name|String
index|[]
name|masterCoprocs
init|=
name|conf
operator|.
name|getStrings
argument_list|(
name|CoprocessorHost
operator|.
name|MASTER_COPROCESSOR_CONF_KEY
argument_list|)
decl_stmt|;
specifier|final
name|int
name|length
init|=
literal|null
operator|==
name|masterCoprocs
condition|?
literal|0
else|:
name|masterCoprocs
operator|.
name|length
decl_stmt|;
name|String
index|[]
name|updatedCoprocs
init|=
operator|new
name|String
index|[
name|length
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|masterCoprocs
argument_list|,
literal|0
argument_list|,
name|updatedCoprocs
argument_list|,
literal|0
argument_list|,
name|masterCoprocs
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|updatedCoprocs
index|[
name|length
index|]
operator|=
name|MasterSpaceQuotaObserver
operator|.
name|class
operator|.
name|getName
argument_list|()
expr_stmt|;
name|conf
operator|.
name|setStrings
argument_list|(
name|CoprocessorHost
operator|.
name|MASTER_COPROCESSOR_CONF_KEY
argument_list|,
name|updatedCoprocs
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|initMobCleaner
parameter_list|()
block|{
name|this
operator|.
name|expiredMobFileCleanerChore
operator|=
operator|new
name|ExpiredMobFileCleanerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|expiredMobFileCleanerChore
argument_list|)
expr_stmt|;
name|int
name|mobCompactionPeriod
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|MobConstants
operator|.
name|MOB_COMPACTION_CHORE_PERIOD
argument_list|,
name|MobConstants
operator|.
name|DEFAULT_MOB_COMPACTION_CHORE_PERIOD
argument_list|)
decl_stmt|;
if|if
condition|(
name|mobCompactionPeriod
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|mobCompactChore
operator|=
operator|new
name|MobCompactionChore
argument_list|(
name|this
argument_list|,
name|mobCompactionPeriod
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|mobCompactChore
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The period is "
operator|+
name|mobCompactionPeriod
operator|+
literal|" seconds, MobCompactionChore is disabled"
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|mobCompactThread
operator|=
operator|new
name|MasterMobCompactionThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a {@link MasterMetaBootstrap} instance.    */
name|MasterMetaBootstrap
name|createMetaBootstrap
parameter_list|(
specifier|final
name|HMaster
name|master
parameter_list|,
specifier|final
name|MonitoredTask
name|status
parameter_list|)
block|{
comment|// We put this out here in a method so can do a Mockito.spy and stub it out
comment|// w/ a mocked up MasterMetaBootstrap.
return|return
operator|new
name|MasterMetaBootstrap
argument_list|(
name|master
argument_list|,
name|status
argument_list|)
return|;
block|}
comment|/**    * Create a {@link ServerManager} instance.    */
name|ServerManager
name|createServerManager
parameter_list|(
specifier|final
name|MasterServices
name|master
parameter_list|)
throws|throws
name|IOException
block|{
comment|// We put this out here in a method so can do a Mockito.spy and stub it out
comment|// w/ a mocked up ServerManager.
name|setupClusterConnection
argument_list|()
expr_stmt|;
return|return
operator|new
name|ServerManager
argument_list|(
name|master
argument_list|)
return|;
block|}
specifier|private
name|void
name|waitForRegionServers
parameter_list|(
specifier|final
name|MonitoredTask
name|status
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|serverManager
operator|.
name|waitForRegionServers
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// Check zk for region servers that are up but didn't register
for|for
control|(
name|ServerName
name|sn
range|:
name|this
operator|.
name|regionServerTracker
operator|.
name|getOnlineServers
argument_list|()
control|)
block|{
comment|// The isServerOnline check is opportunistic, correctness is handled inside
if|if
condition|(
operator|!
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
operator|&&
name|serverManager
operator|.
name|checkAndRecordNewServer
argument_list|(
name|sn
argument_list|,
operator|new
name|ServerLoad
argument_list|(
name|ServerMetricsBuilder
operator|.
name|of
argument_list|(
name|sn
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Registered server found up in zk but who has not yet reported in: "
operator|+
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|initClusterSchemaService
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|clusterSchemaService
operator|=
operator|new
name|ClusterSchemaServiceImpl
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterSchemaService
operator|.
name|startAsync
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|clusterSchemaService
operator|.
name|awaitRunning
argument_list|(
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|HBASE_MASTER_WAIT_ON_SERVICE_IN_SECONDS
argument_list|,
name|DEFAULT_HBASE_MASTER_WAIT_ON_SERVICE_IN_SECONDS
argument_list|)
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|toe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Timedout starting ClusterSchemaService"
argument_list|,
name|toe
argument_list|)
throw|;
block|}
block|}
name|void
name|initQuotaManager
parameter_list|()
throws|throws
name|IOException
block|{
name|MasterQuotaManager
name|quotaManager
init|=
operator|new
name|MasterQuotaManager
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|setRegionStateListener
argument_list|(
name|quotaManager
argument_list|)
expr_stmt|;
name|quotaManager
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|quotaManager
operator|=
name|quotaManager
expr_stmt|;
block|}
name|SpaceQuotaSnapshotNotifier
name|createQuotaSnapshotNotifier
parameter_list|()
block|{
name|SpaceQuotaSnapshotNotifier
name|notifier
init|=
name|SpaceQuotaSnapshotNotifierFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|create
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|notifier
return|;
block|}
name|boolean
name|isCatalogJanitorEnabled
parameter_list|()
block|{
return|return
name|catalogJanitorChore
operator|!=
literal|null
condition|?
name|catalogJanitorChore
operator|.
name|getEnabled
argument_list|()
else|:
literal|false
return|;
block|}
name|boolean
name|isCleanerChoreEnabled
parameter_list|()
block|{
name|boolean
name|hfileCleanerFlag
init|=
literal|true
decl_stmt|,
name|logCleanerFlag
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|hfileCleaner
operator|!=
literal|null
condition|)
block|{
name|hfileCleanerFlag
operator|=
name|hfileCleaner
operator|.
name|getEnabled
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|logCleaner
operator|!=
literal|null
condition|)
block|{
name|logCleanerFlag
operator|=
name|logCleaner
operator|.
name|getEnabled
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|hfileCleanerFlag
operator|&&
name|logCleanerFlag
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableDescriptors
name|getTableDescriptors
parameter_list|()
block|{
return|return
name|this
operator|.
name|tableDescriptors
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerManager
name|getServerManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterFileSystem
name|getMasterFileSystem
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileSystemManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterWalManager
name|getMasterWalManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|walManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableStateManager
name|getTableStateManager
parameter_list|()
block|{
return|return
name|tableStateManager
return|;
block|}
comment|/*    * Start up all services. If any of these threads gets an unhandled exception    * then they just die with a logged message.  This should be fine because    * in general, we do not expect the master to get such unhandled exceptions    *  as OOMEs; it should be lightly loaded. See what HRegionServer does if    *  need to install an unexpected exception handler.    */
specifier|private
name|void
name|startServiceThreads
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Start the executor service pools
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_OPEN_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.openregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_CLOSE_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.closeregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.serverops.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_META_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.meta.serverops.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|M_LOG_REPLAY_OPS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.logreplayops.threads"
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|// We depend on there being only one instance of this executor running
comment|// at a time.  To do concurrency, would need fencing of enable/disable of
comment|// tables.
comment|// Any time changing this maxThreads to> 1, pls see the comment at
comment|// AccessController#postCompletedCreateTableAction
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_TABLE_OPERATIONS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|startProcedureExecutor
argument_list|()
expr_stmt|;
comment|// Start log cleaner thread
name|int
name|cleanerInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.cleaner.interval"
argument_list|,
literal|600
operator|*
literal|1000
argument_list|)
decl_stmt|;
name|this
operator|.
name|logCleaner
operator|=
operator|new
name|LogCleaner
argument_list|(
name|cleanerInterval
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|getMasterWalManager
argument_list|()
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|getMasterWalManager
argument_list|()
operator|.
name|getOldLogDir
argument_list|()
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|logCleaner
argument_list|)
expr_stmt|;
comment|//start the hfile archive cleaner thread
name|Path
name|archiveDir
init|=
name|HFileArchiveUtil
operator|.
name|getArchivePath
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|params
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|params
operator|.
name|put
argument_list|(
name|MASTER
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|hfileCleaner
operator|=
operator|new
name|HFileCleaner
argument_list|(
name|cleanerInterval
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|getMasterFileSystem
argument_list|()
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|archiveDir
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|hfileCleaner
argument_list|)
expr_stmt|;
name|serviceStarted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Started service threads"
argument_list|)
expr_stmt|;
block|}
name|replicationMetaCleaner
operator|=
operator|new
name|ReplicationMetaCleaner
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|cleanerInterval
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|replicationMetaCleaner
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|stopServiceThreads
parameter_list|()
block|{
if|if
condition|(
name|masterJettyServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping master jetty server"
argument_list|)
expr_stmt|;
try|try
block|{
name|masterJettyServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to stop master jetty server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|super
operator|.
name|stopServiceThreads
argument_list|()
expr_stmt|;
name|stopChores
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopping service threads"
argument_list|)
expr_stmt|;
block|}
comment|// Clean up and close up shop
if|if
condition|(
name|this
operator|.
name|logCleaner
operator|!=
literal|null
condition|)
name|this
operator|.
name|logCleaner
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|hfileCleaner
operator|!=
literal|null
condition|)
name|this
operator|.
name|hfileCleaner
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicationMetaCleaner
operator|!=
literal|null
condition|)
name|this
operator|.
name|replicationMetaCleaner
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|quotaManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|quotaManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|activeMasterManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|activeMasterManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|serverManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|serverManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|assignmentManager
operator|.
name|stop
argument_list|()
expr_stmt|;
name|stopProcedureExecutor
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|walManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|walManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|fileSystemManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|fileSystemManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|mpmHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|mpmHost
operator|.
name|stop
argument_list|(
literal|"server shutting down."
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|startProcedureExecutor
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|MasterProcedureEnv
name|procEnv
init|=
operator|new
name|MasterProcedureEnv
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|procedureStore
operator|=
operator|new
name|WALProcedureStore
argument_list|(
name|conf
argument_list|,
operator|new
name|MasterProcedureEnv
operator|.
name|WALStoreLeaseRecovery
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|procedureStore
operator|.
name|registerListener
argument_list|(
operator|new
name|MasterProcedureEnv
operator|.
name|MasterProcedureStoreListener
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|MasterProcedureScheduler
name|procedureScheduler
init|=
name|procEnv
operator|.
name|getProcedureScheduler
argument_list|()
decl_stmt|;
name|procedureExecutor
operator|=
operator|new
name|ProcedureExecutor
argument_list|<>
argument_list|(
name|conf
argument_list|,
name|procEnv
argument_list|,
name|procedureStore
argument_list|,
name|procedureScheduler
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|procEnv
argument_list|)
expr_stmt|;
name|int
name|cpus
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|MasterProcedureConstants
operator|.
name|MASTER_PROCEDURE_THREADS
argument_list|,
name|Math
operator|.
name|max
argument_list|(
operator|(
name|cpus
operator|>
literal|0
condition|?
name|cpus
operator|/
literal|4
else|:
literal|0
operator|)
argument_list|,
name|MasterProcedureConstants
operator|.
name|DEFAULT_MIN_MASTER_PROCEDURE_THREADS
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|abortOnCorruption
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|MasterProcedureConstants
operator|.
name|EXECUTOR_ABORT_ON_CORRUPTION
argument_list|,
name|MasterProcedureConstants
operator|.
name|DEFAULT_EXECUTOR_ABORT_ON_CORRUPTION
argument_list|)
decl_stmt|;
name|procedureStore
operator|.
name|start
argument_list|(
name|numThreads
argument_list|)
expr_stmt|;
name|procedureExecutor
operator|.
name|start
argument_list|(
name|numThreads
argument_list|,
name|abortOnCorruption
argument_list|)
expr_stmt|;
name|procEnv
operator|.
name|getRemoteDispatcher
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|stopProcedureExecutor
parameter_list|()
block|{
if|if
condition|(
name|procedureExecutor
operator|!=
literal|null
condition|)
block|{
name|configurationManager
operator|.
name|deregisterObserver
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|)
expr_stmt|;
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getRemoteDispatcher
argument_list|()
operator|.
name|stop
argument_list|()
expr_stmt|;
name|procedureExecutor
operator|.
name|stop
argument_list|()
expr_stmt|;
name|procedureExecutor
operator|.
name|join
argument_list|()
expr_stmt|;
name|procedureExecutor
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|procedureStore
operator|!=
literal|null
condition|)
block|{
name|procedureStore
operator|.
name|stop
argument_list|(
name|isAborted
argument_list|()
argument_list|)
expr_stmt|;
name|procedureStore
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|stopChores
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|expiredMobFileCleanerChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|expiredMobFileCleanerChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|mobCompactChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|mobCompactChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|balancerChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|balancerChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|normalizerChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|normalizerChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|clusterStatusChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|clusterStatusChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|catalogJanitorChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|catalogJanitorChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|clusterStatusPublisherChore
operator|!=
literal|null
condition|)
block|{
name|clusterStatusPublisherChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|mobCompactThread
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|mobCompactThread
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|quotaObserverChore
operator|!=
literal|null
condition|)
block|{
name|quotaObserverChore
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|snapshotQuotaChore
operator|!=
literal|null
condition|)
block|{
name|snapshotQuotaChore
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @return Get remote side's InetAddress    */
name|InetAddress
name|getRemoteInetAddress
parameter_list|(
specifier|final
name|int
name|port
parameter_list|,
specifier|final
name|long
name|serverStartCode
parameter_list|)
throws|throws
name|UnknownHostException
block|{
comment|// Do it out here in its own little method so can fake an address when
comment|// mocking up in tests.
name|InetAddress
name|ia
init|=
name|RpcServer
operator|.
name|getRemoteIp
argument_list|()
decl_stmt|;
comment|// The call could be from the local regionserver,
comment|// in which case, there is no remote address.
if|if
condition|(
name|ia
operator|==
literal|null
operator|&&
name|serverStartCode
operator|==
name|startcode
condition|)
block|{
name|InetSocketAddress
name|isa
init|=
name|rpcServices
operator|.
name|getSocketAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|isa
operator|!=
literal|null
operator|&&
name|isa
operator|.
name|getPort
argument_list|()
operator|==
name|port
condition|)
block|{
name|ia
operator|=
name|isa
operator|.
name|getAddress
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|ia
return|;
block|}
comment|/**    * @return Maximum time we should run balancer for    */
specifier|private
name|int
name|getMaxBalancingTime
parameter_list|()
block|{
name|int
name|maxBalancingTime
init|=
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_BALANCER_MAX_BALANCING
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxBalancingTime
operator|==
operator|-
literal|1
condition|)
block|{
comment|// if max balancing time isn't set, defaulting it to period time
name|maxBalancingTime
operator|=
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_BALANCER_PERIOD
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_BALANCER_PERIOD
argument_list|)
expr_stmt|;
block|}
return|return
name|maxBalancingTime
return|;
block|}
comment|/**    * @return Maximum number of regions in transition    */
specifier|private
name|int
name|getMaxRegionsInTransition
parameter_list|()
block|{
name|int
name|numRegions
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionAssignments
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
return|return
name|Math
operator|.
name|max
argument_list|(
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|numRegions
operator|*
name|this
operator|.
name|maxRitPercent
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/**    * It first sleep to the next balance plan start time. Meanwhile, throttling by the max    * number regions in transition to protect availability.    * @param nextBalanceStartTime The next balance plan start time    * @param maxRegionsInTransition max number of regions in transition    * @param cutoffTime when to exit balancer    */
specifier|private
name|void
name|balanceThrottling
parameter_list|(
name|long
name|nextBalanceStartTime
parameter_list|,
name|int
name|maxRegionsInTransition
parameter_list|,
name|long
name|cutoffTime
parameter_list|)
block|{
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
comment|// Sleep to next balance plan start time
comment|// But if there are zero regions in transition, it can skip sleep to speed up.
while|while
condition|(
operator|!
name|interrupted
operator|&&
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|<
name|nextBalanceStartTime
operator|&&
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|hasRegionsInTransition
argument_list|()
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Throttling by max number regions in transition
while|while
condition|(
operator|!
name|interrupted
operator|&&
name|maxRegionsInTransition
operator|>
literal|0
operator|&&
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionsInTransitionCount
argument_list|()
operator|>=
name|maxRegionsInTransition
operator|&&
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|<=
name|cutoffTime
condition|)
block|{
try|try
block|{
comment|// sleep if the number of regions in transition exceeds the limit
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|interrupted
condition|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|balance
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|balance
argument_list|(
literal|false
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|balance
parameter_list|(
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if master not initialized, don't run balancer.
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Master has not been initialized, don't run balancer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Master is in maintenanceMode mode, don't run balancer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|maxRegionsInTransition
init|=
name|getMaxRegionsInTransition
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|balancer
init|)
block|{
comment|// If balance not true, don't run balancer.
if|if
condition|(
operator|!
name|this
operator|.
name|loadBalancerTracker
operator|.
name|isBalancerOn
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// Only allow one balance run at at time.
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|.
name|hasRegionsInTransition
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|RegionStateNode
argument_list|>
name|regionsInTransition
init|=
name|assignmentManager
operator|.
name|getRegionsInTransition
argument_list|()
decl_stmt|;
comment|// if hbase:meta region is in transition, result of assignment cannot be recorded
comment|// ignore the force flag in that case
name|boolean
name|metaInTransition
init|=
name|assignmentManager
operator|.
name|isMetaRegionInTransition
argument_list|()
decl_stmt|;
name|String
name|prefix
init|=
name|force
operator|&&
operator|!
name|metaInTransition
condition|?
literal|"R"
else|:
literal|"Not r"
decl_stmt|;
name|List
argument_list|<
name|RegionStateNode
argument_list|>
name|toPrint
init|=
name|regionsInTransition
decl_stmt|;
name|int
name|max
init|=
literal|5
decl_stmt|;
name|boolean
name|truncated
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|regionsInTransition
operator|.
name|size
argument_list|()
operator|>
name|max
condition|)
block|{
name|toPrint
operator|=
name|regionsInTransition
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|truncated
operator|=
literal|true
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|prefix
operator|+
literal|"unning balancer because "
operator|+
name|regionsInTransition
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) in transition: "
operator|+
name|toPrint
operator|+
operator|(
name|truncated
condition|?
literal|"(truncated list)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|||
name|metaInTransition
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|.
name|areDeadServersInProgress
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Not running balancer because processing dead regionserver(s): "
operator|+
name|this
operator|.
name|serverManager
operator|.
name|getDeadServers
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|this
operator|.
name|cpHost
operator|.
name|preBalance
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Coprocessor bypassing balancer request"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error invoking master coprocessor preBalance()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|boolean
name|isByTable
init|=
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.loadbalance.bytable"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|TableName
argument_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
argument_list|>
name|assignmentsByTable
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getAssignmentsByTable
argument_list|(
operator|!
name|isByTable
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|plans
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|//Give the balancer the current cluster state.
name|this
operator|.
name|balancer
operator|.
name|setClusterMetrics
argument_list|(
name|getClusterMetricsWithoutCoprocessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|.
name|setClusterLoad
argument_list|(
name|assignmentsByTable
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|serverMap
range|:
name|assignmentsByTable
operator|.
name|values
argument_list|()
control|)
block|{
name|serverMap
operator|.
name|keySet
argument_list|()
operator|.
name|removeAll
argument_list|(
name|this
operator|.
name|serverManager
operator|.
name|getDrainingServersList
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|TableName
argument_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
argument_list|>
name|e
range|:
name|assignmentsByTable
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|partialPlans
init|=
name|this
operator|.
name|balancer
operator|.
name|balanceCluster
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|partialPlans
operator|!=
literal|null
condition|)
name|plans
operator|.
name|addAll
argument_list|(
name|partialPlans
argument_list|)
expr_stmt|;
block|}
name|long
name|balanceStartTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|cutoffTime
init|=
name|balanceStartTime
operator|+
name|this
operator|.
name|maxBlancingTime
decl_stmt|;
name|int
name|rpCount
init|=
literal|0
decl_stmt|;
comment|// number of RegionPlans balanced so far
if|if
condition|(
name|plans
operator|!=
literal|null
operator|&&
operator|!
name|plans
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|balanceInterval
init|=
name|this
operator|.
name|maxBlancingTime
operator|/
name|plans
operator|.
name|size
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Balancer plans size is "
operator|+
name|plans
operator|.
name|size
argument_list|()
operator|+
literal|", the balance interval is "
operator|+
name|balanceInterval
operator|+
literal|" ms, and the max number regions in transition is "
operator|+
name|maxRegionsInTransition
argument_list|)
expr_stmt|;
for|for
control|(
name|RegionPlan
name|plan
range|:
name|plans
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"balance "
operator|+
name|plan
argument_list|)
expr_stmt|;
comment|//TODO: bulk assign
name|this
operator|.
name|assignmentManager
operator|.
name|moveAsync
argument_list|(
name|plan
argument_list|)
expr_stmt|;
name|rpCount
operator|++
expr_stmt|;
name|balanceThrottling
argument_list|(
name|balanceStartTime
operator|+
name|rpCount
operator|*
name|balanceInterval
argument_list|,
name|maxRegionsInTransition
argument_list|,
name|cutoffTime
argument_list|)
expr_stmt|;
comment|// if performing next balance exceeds cutoff time, exit the loop
if|if
condition|(
name|rpCount
argument_list|<
name|plans
operator|.
name|size
operator|(
operator|)
operator|&&
name|System
operator|.
name|currentTimeMillis
operator|(
operator|)
argument_list|>
name|cutoffTime
condition|)
block|{
comment|// TODO: After balance, there should not be a cutoff time (keeping it as
comment|// a security net for now)
name|LOG
operator|.
name|debug
argument_list|(
literal|"No more balancing till next balance run; maxBalanceTime="
operator|+
name|this
operator|.
name|maxBlancingTime
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|postBalance
argument_list|(
name|rpCount
operator|<
name|plans
operator|.
name|size
argument_list|()
condition|?
name|plans
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|rpCount
argument_list|)
else|:
name|plans
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// balancing already succeeded so don't change the result
name|LOG
operator|.
name|error
argument_list|(
literal|"Error invoking master coprocessor postBalance()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If LoadBalancer did not generate any plans, it means the cluster is already balanced.
comment|// Return true indicating a success.
return|return
literal|true
return|;
block|}
annotation|@
name|Override
annotation|@
name|VisibleForTesting
specifier|public
name|RegionNormalizer
name|getRegionNormalizer
parameter_list|()
block|{
return|return
name|this
operator|.
name|normalizer
return|;
block|}
comment|/**    * Perform normalization of cluster (invoked by {@link RegionNormalizerChore}).    *    * @return true if normalization step was performed successfully, false otherwise    *    (specifically, if HMaster hasn't been initialized properly or normalization    *    is globally disabled)    */
specifier|public
name|boolean
name|normalizeRegions
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Master has not been initialized, don't run region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Master is in maintenance mode, don't run region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|regionNormalizerTracker
operator|.
name|isNormalizerOn
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Region normalization is disabled, don't run region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|normalizer
init|)
block|{
comment|// Don't run the normalizer concurrently
name|List
argument_list|<
name|TableName
argument_list|>
name|allEnabledTables
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|tableStateManager
operator|.
name|getTablesInStates
argument_list|(
name|TableState
operator|.
name|State
operator|.
name|ENABLED
argument_list|)
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|allEnabledTables
argument_list|)
expr_stmt|;
for|for
control|(
name|TableName
name|table
range|:
name|allEnabledTables
control|)
block|{
if|if
condition|(
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Master is in maintenance mode, stop running region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|TableDescriptor
name|tblDesc
init|=
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|.
name|isSystemTable
argument_list|()
operator|||
operator|(
name|tblDesc
operator|!=
literal|null
operator|&&
operator|!
name|tblDesc
operator|.
name|isNormalizationEnabled
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping normalization for table: "
operator|+
name|table
operator|+
literal|", as it's either system"
operator|+
literal|" table or doesn't have auto normalization turned on"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|List
argument_list|<
name|NormalizationPlan
argument_list|>
name|plans
init|=
name|this
operator|.
name|normalizer
operator|.
name|computePlanForTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|plans
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|NormalizationPlan
name|plan
range|:
name|plans
control|)
block|{
name|plan
operator|.
name|execute
argument_list|(
name|clusterConnection
operator|.
name|getAdmin
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|plan
operator|.
name|getType
argument_list|()
operator|==
name|PlanType
operator|.
name|SPLIT
condition|)
block|{
name|splitPlanCount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plan
operator|.
name|getType
argument_list|()
operator|==
name|PlanType
operator|.
name|MERGE
condition|)
block|{
name|mergePlanCount
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// If Region did not generate any plans, it means the cluster is already balanced.
comment|// Return true indicating a success.
return|return
literal|true
return|;
block|}
comment|/**    * @return Client info for use as prefix on an audit log string; who did an action    */
annotation|@
name|Override
specifier|public
name|String
name|getClientIdAuditPrefix
parameter_list|()
block|{
return|return
literal|"Client="
operator|+
name|RpcServer
operator|.
name|getRequestUserName
argument_list|()
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
operator|+
literal|"/"
operator|+
name|RpcServer
operator|.
name|getRemoteAddress
argument_list|()
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|/**    * Switch for the background CatalogJanitor thread.    * Used for testing.  The thread will continue to run.  It will just be a noop    * if disabled.    * @param b If false, the catalog janitor won't do anything.    */
specifier|public
name|void
name|setCatalogJanitorEnabled
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
block|{
name|this
operator|.
name|catalogJanitorChore
operator|.
name|setEnabled
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|mergeRegions
parameter_list|(
specifier|final
name|RegionInfo
index|[]
name|regionsToMerge
parameter_list|,
specifier|final
name|boolean
name|forcible
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
assert|assert
operator|(
name|regionsToMerge
operator|.
name|length
operator|==
literal|2
operator|)
assert|;
name|TableName
name|tableName
init|=
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getTable
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
literal|"Can't merge regions without table associated"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|tableName
operator|.
name|equals
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getTable
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot merge regions from two different tables "
operator|+
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getTable
argument_list|()
operator|+
literal|" and "
operator|+
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getTable
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|RegionInfo
operator|.
name|COMPARATOR
operator|.
name|compare
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Cannot merge a region to itself "
operator|+
name|regionsToMerge
index|[
literal|0
index|]
operator|+
literal|", "
operator|+
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
throw|;
block|}
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preMergeRegions
argument_list|(
name|regionsToMerge
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" Merge regions "
operator|+
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" and "
operator|+
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|MergeTableRegionsProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|regionsToMerge
argument_list|,
name|forcible
argument_list|)
argument_list|)
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postMergeRegions
argument_list|(
name|regionsToMerge
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"MergeTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|splitRegion
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|byte
index|[]
name|splitRow
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preSplitRegion
argument_list|(
name|regionInfo
operator|.
name|getTable
argument_list|()
argument_list|,
name|splitRow
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" split "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Execute the operation asynchronously
name|submitProcedure
argument_list|(
name|getAssignmentManager
argument_list|()
operator|.
name|createSplitProcedure
argument_list|(
name|regionInfo
argument_list|,
name|splitRow
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"SplitTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|// Public so can be accessed by tests. Blocks until move is done.
comment|// Replace with an async implementation from which you can get
comment|// a success/failure result.
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|move
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|,
name|byte
index|[]
name|destServerName
parameter_list|)
throws|throws
name|HBaseIOException
block|{
name|RegionState
name|regionState
init|=
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionState
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
decl_stmt|;
name|RegionInfo
name|hri
decl_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
condition|)
block|{
name|hri
operator|=
name|regionState
operator|.
name|getRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
throw|;
block|}
name|ServerName
name|dest
decl_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|exclude
init|=
name|hri
operator|.
name|getTable
argument_list|()
operator|.
name|isSystemTable
argument_list|()
condition|?
name|assignmentManager
operator|.
name|getExcludedServersForSystemTable
argument_list|()
else|:
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|destServerName
operator|!=
literal|null
operator|&&
name|exclude
operator|.
name|contains
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|destServerName
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
operator|+
literal|" can not move to "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|destServerName
argument_list|)
operator|+
literal|" because the server is in exclude list"
argument_list|)
expr_stmt|;
name|destServerName
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|destServerName
operator|==
literal|null
operator|||
name|destServerName
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Passed destination servername is null/empty so "
operator|+
literal|"choosing a server at random"
argument_list|)
expr_stmt|;
name|exclude
operator|.
name|add
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|destServers
init|=
name|this
operator|.
name|serverManager
operator|.
name|createDestinationServersList
argument_list|(
name|exclude
argument_list|)
decl_stmt|;
name|dest
operator|=
name|balancer
operator|.
name|randomAssignment
argument_list|(
name|hri
argument_list|,
name|destServers
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to determine a plan to assign "
operator|+
name|hri
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|ServerName
name|candidate
init|=
name|ServerName
operator|.
name|valueOf
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|destServerName
argument_list|)
argument_list|)
decl_stmt|;
name|dest
operator|=
name|balancer
operator|.
name|randomAssignment
argument_list|(
name|hri
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to determine a plan to assign "
operator|+
name|hri
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// TODO: What is this? I don't get it.
if|if
condition|(
name|dest
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
operator|&&
name|balancer
operator|instanceof
name|BaseLoadBalancer
operator|&&
operator|!
operator|(
operator|(
name|BaseLoadBalancer
operator|)
name|balancer
operator|)
operator|.
name|shouldBeOnMaster
argument_list|(
name|hri
argument_list|)
condition|)
block|{
comment|// To avoid unnecessary region moving later by balancer. Don't put user
comment|// regions on master.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping move of region "
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to avoid unnecessary region moving later by load balancer,"
operator|+
literal|" because it should not be on master"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|dest
operator|.
name|equals
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping move of region "
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" because region already assigned to the same server "
operator|+
name|dest
operator|+
literal|"."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Now we can do the move
name|RegionPlan
name|rp
init|=
operator|new
name|RegionPlan
argument_list|(
name|hri
argument_list|,
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|,
name|dest
argument_list|)
decl_stmt|;
assert|assert
name|rp
operator|.
name|getDestination
argument_list|()
operator|!=
literal|null
operator|:
name|rp
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|dest
assert|;
assert|assert
name|rp
operator|.
name|getSource
argument_list|()
operator|!=
literal|null
operator|:
name|rp
operator|.
name|toString
argument_list|()
assert|;
try|try
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cpHost
operator|.
name|preMove
argument_list|(
name|hri
argument_list|,
name|rp
operator|.
name|getSource
argument_list|()
argument_list|,
name|rp
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Warmup the region on the destination before initiating the move. this call
comment|// is synchronous and takes some time. doing it before the source region gets
comment|// closed
name|serverManager
operator|.
name|sendRegionWarmup
argument_list|(
name|rp
operator|.
name|getDestination
argument_list|()
argument_list|,
name|hri
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" move "
operator|+
name|rp
operator|+
literal|", running balancer"
argument_list|)
expr_stmt|;
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
name|future
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|moveAsync
argument_list|(
name|rp
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Is this going to work? Will we throw exception on error?
comment|// TODO: CompletableFuture rather than this stunted Future.
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
decl||
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cpHost
operator|.
name|postMove
argument_list|(
name|hri
argument_list|,
name|rp
operator|.
name|getSource
argument_list|()
argument_list|,
name|rp
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|ioe
operator|instanceof
name|HBaseIOException
condition|)
block|{
throw|throw
operator|(
name|HBaseIOException
operator|)
name|ioe
throw|;
block|}
throw|throw
operator|new
name|HBaseIOException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|createTable
parameter_list|(
specifier|final
name|TableDescriptor
name|tableDescriptor
parameter_list|,
specifier|final
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|String
name|namespace
init|=
name|tableDescriptor
operator|.
name|getTableName
argument_list|()
operator|.
name|getNamespaceAsString
argument_list|()
decl_stmt|;
name|this
operator|.
name|clusterSchemaService
operator|.
name|getNamespace
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
name|RegionInfo
index|[]
name|newRegions
init|=
name|ModifyRegionUtils
operator|.
name|createRegionInfos
argument_list|(
name|tableDescriptor
argument_list|,
name|splitKeys
argument_list|)
decl_stmt|;
name|sanityCheckTableDescriptor
argument_list|(
name|tableDescriptor
argument_list|)
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preCreateTable
argument_list|(
name|tableDescriptor
argument_list|,
name|newRegions
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" create "
operator|+
name|tableDescriptor
argument_list|)
expr_stmt|;
comment|// TODO: We can handle/merge duplicate requests, and differentiate the case of
comment|//       TableExistsException by saying if the schema is the same or not.
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|()
decl_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|CreateTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableDescriptor
argument_list|,
name|newRegions
argument_list|,
name|latch
argument_list|)
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postCreateTable
argument_list|(
name|tableDescriptor
argument_list|,
name|newRegions
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"CreateTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|createSystemTable
parameter_list|(
specifier|final
name|TableDescriptor
name|tableDescriptor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isStopped
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
name|TableName
name|tableName
init|=
name|tableDescriptor
operator|.
name|getTableName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tableName
operator|.
name|isSystemTable
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Only system table creation can use this createSystemTable API"
argument_list|)
throw|;
block|}
name|RegionInfo
index|[]
name|newRegions
init|=
name|ModifyRegionUtils
operator|.
name|createRegionInfos
argument_list|(
name|tableDescriptor
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" create "
operator|+
name|tableDescriptor
argument_list|)
expr_stmt|;
comment|// This special create table is called locally to master.  Therefore, no RPC means no need
comment|// to use nonce to detect duplicated RPC call.
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|CreateTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableDescriptor
argument_list|,
name|newRegions
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|procId
return|;
block|}
comment|/**    * Checks whether the table conforms to some sane limits, and configured    * values (compression, etc) work. Throws an exception if something is wrong.    * @throws IOException    */
specifier|private
name|void
name|sanityCheckTableDescriptor
parameter_list|(
specifier|final
name|TableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|CONF_KEY
init|=
literal|"hbase.table.sanity.checks"
decl_stmt|;
name|boolean
name|logWarn
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|CONF_KEY
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|logWarn
operator|=
literal|true
expr_stmt|;
block|}
name|String
name|tableVal
init|=
name|htd
operator|.
name|getValue
argument_list|(
name|CONF_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableVal
operator|!=
literal|null
operator|&&
operator|!
name|Boolean
operator|.
name|valueOf
argument_list|(
name|tableVal
argument_list|)
condition|)
block|{
name|logWarn
operator|=
literal|true
expr_stmt|;
block|}
comment|// check max file size
name|long
name|maxFileSizeLowerLimit
init|=
literal|2
operator|*
literal|1024
operator|*
literal|1024L
decl_stmt|;
comment|// 2M is the default lower limit
name|long
name|maxFileSize
init|=
name|htd
operator|.
name|getMaxFileSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxFileSize
operator|<
literal|0
condition|)
block|{
name|maxFileSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HREGION_MAX_FILESIZE
argument_list|,
name|maxFileSizeLowerLimit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxFileSize
operator|<
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.hregion.max.filesize.limit"
argument_list|,
name|maxFileSizeLowerLimit
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"MAX_FILESIZE for table descriptor or "
operator|+
literal|"\"hbase.hregion.max.filesize\" ("
operator|+
name|maxFileSize
operator|+
literal|") is too small, which might cause over splitting into unmanageable "
operator|+
literal|"number of regions."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check flush size
name|long
name|flushSizeLowerLimit
init|=
literal|1024
operator|*
literal|1024L
decl_stmt|;
comment|// 1M is the default lower limit
name|long
name|flushSize
init|=
name|htd
operator|.
name|getMemStoreFlushSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|flushSize
operator|<
literal|0
condition|)
block|{
name|flushSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HREGION_MEMSTORE_FLUSH_SIZE
argument_list|,
name|flushSizeLowerLimit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flushSize
operator|<
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.hregion.memstore.flush.size.limit"
argument_list|,
name|flushSizeLowerLimit
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"MEMSTORE_FLUSHSIZE for table descriptor or "
operator|+
literal|"\"hbase.hregion.memstore.flush.size\" ("
operator|+
name|flushSize
operator|+
literal|") is too small, which might cause"
operator|+
literal|" very frequent flushing."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check that coprocessors and other specified plugin classes can be loaded
try|try
block|{
name|checkClassLoading
argument_list|(
name|conf
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check compression can be loaded
try|try
block|{
name|checkCompression
argument_list|(
name|htd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// check encryption can be loaded
try|try
block|{
name|checkEncryption
argument_list|(
name|conf
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Verify compaction policy
try|try
block|{
name|checkCompactionPolicy
argument_list|(
name|conf
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|warnOrThrowExceptionForFailure
argument_list|(
literal|false
argument_list|,
name|CONF_KEY
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// check that we have at least 1 CF
if|if
condition|(
name|htd
operator|.
name|getColumnFamilyCount
argument_list|()
operator|==
literal|0
condition|)
block|{
name|String
name|message
init|=
literal|"Table should have at least one column family."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ColumnFamilyDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
if|if
condition|(
name|hcd
operator|.
name|getTimeToLive
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|String
name|message
init|=
literal|"TTL for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|" must be positive."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check blockSize
if|if
condition|(
name|hcd
operator|.
name|getBlocksize
argument_list|()
operator|<
literal|1024
operator|||
name|hcd
operator|.
name|getBlocksize
argument_list|()
operator|>
literal|16
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
name|String
name|message
init|=
literal|"Block size for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"  must be between 1K and 16MB."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check versions
if|if
condition|(
name|hcd
operator|.
name|getMinVersions
argument_list|()
operator|<
literal|0
condition|)
block|{
name|String
name|message
init|=
literal|"Min versions for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"  must be positive."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// max versions already being checked
comment|// HBASE-13776 Setting illegal versions for ColumnFamilyDescriptor
comment|//  does not throw IllegalArgumentException
comment|// check minVersions<= maxVerions
if|if
condition|(
name|hcd
operator|.
name|getMinVersions
argument_list|()
operator|>
name|hcd
operator|.
name|getMaxVersions
argument_list|()
condition|)
block|{
name|String
name|message
init|=
literal|"Min versions for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|" must be less than the Max versions."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check replication scope
name|checkReplicationScope
argument_list|(
name|hcd
argument_list|)
expr_stmt|;
comment|// check data replication factor, it can be 0(default value) when user has not explicitly
comment|// set the value, in this case we use default replication factor set in the file system.
if|if
condition|(
name|hcd
operator|.
name|getDFSReplication
argument_list|()
operator|<
literal|0
condition|)
block|{
name|String
name|message
init|=
literal|"HFile Replication for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"  must be greater than zero."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// TODO: should we check coprocessors and encryption ?
block|}
block|}
specifier|private
name|void
name|checkReplicationScope
parameter_list|(
name|ColumnFamilyDescriptor
name|hcd
parameter_list|)
throws|throws
name|IOException
block|{
comment|// check replication scope
name|WALProtos
operator|.
name|ScopeType
name|scop
init|=
name|WALProtos
operator|.
name|ScopeType
operator|.
name|valueOf
argument_list|(
name|hcd
operator|.
name|getScope
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|scop
operator|==
literal|null
condition|)
block|{
name|String
name|message
init|=
literal|"Replication scope for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|" is "
operator|+
name|hcd
operator|.
name|getScope
argument_list|()
operator|+
literal|" which is invalid."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|checkCompactionPolicy
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|TableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
comment|// FIFO compaction has some requirements
comment|// Actually FCP ignores periodic major compactions
name|String
name|className
init|=
name|htd
operator|.
name|getValue
argument_list|(
name|DefaultStoreEngine
operator|.
name|DEFAULT_COMPACTION_POLICY_CLASS_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|className
operator|==
literal|null
condition|)
block|{
name|className
operator|=
name|conf
operator|.
name|get
argument_list|(
name|DefaultStoreEngine
operator|.
name|DEFAULT_COMPACTION_POLICY_CLASS_KEY
argument_list|,
name|ExploringCompactionPolicy
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|blockingFileCount
init|=
name|HStore
operator|.
name|DEFAULT_BLOCKING_STOREFILE_COUNT
decl_stmt|;
name|String
name|sv
init|=
name|htd
operator|.
name|getValue
argument_list|(
name|HStore
operator|.
name|BLOCKING_STOREFILES_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|sv
operator|!=
literal|null
condition|)
block|{
name|blockingFileCount
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blockingFileCount
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HStore
operator|.
name|BLOCKING_STOREFILES_KEY
argument_list|,
name|blockingFileCount
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ColumnFamilyDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
name|String
name|compactionPolicy
init|=
name|hcd
operator|.
name|getConfigurationValue
argument_list|(
name|DefaultStoreEngine
operator|.
name|DEFAULT_COMPACTION_POLICY_CLASS_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|compactionPolicy
operator|==
literal|null
condition|)
block|{
name|compactionPolicy
operator|=
name|className
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|compactionPolicy
operator|.
name|equals
argument_list|(
name|FIFOCompactionPolicy
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// FIFOCompaction
name|String
name|message
init|=
literal|null
decl_stmt|;
comment|// 1. Check TTL
if|if
condition|(
name|hcd
operator|.
name|getTimeToLive
argument_list|()
operator|==
name|ColumnFamilyDescriptorBuilder
operator|.
name|DEFAULT_TTL
condition|)
block|{
name|message
operator|=
literal|"Default TTL is not supported for FIFO compaction"
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|message
argument_list|)
throw|;
block|}
comment|// 2. Check min versions
if|if
condition|(
name|hcd
operator|.
name|getMinVersions
argument_list|()
operator|>
literal|0
condition|)
block|{
name|message
operator|=
literal|"MIN_VERSION> 0 is not supported for FIFO compaction"
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|message
argument_list|)
throw|;
block|}
comment|// 3. blocking file count
name|sv
operator|=
name|hcd
operator|.
name|getConfigurationValue
argument_list|(
name|HStore
operator|.
name|BLOCKING_STOREFILES_KEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|!=
literal|null
condition|)
block|{
name|blockingFileCount
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blockingFileCount
operator|<
literal|1000
condition|)
block|{
name|message
operator|=
literal|"Blocking file count '"
operator|+
name|HStore
operator|.
name|BLOCKING_STOREFILES_KEY
operator|+
literal|"' "
operator|+
name|blockingFileCount
operator|+
literal|" is below recommended minimum of 1000 for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
block|}
comment|// HBASE-13350 - Helper method to log warning on sanity check failures if checks disabled.
specifier|private
specifier|static
name|void
name|warnOrThrowExceptionForFailure
parameter_list|(
name|boolean
name|logWarn
parameter_list|,
name|String
name|confKey
parameter_list|,
name|String
name|message
parameter_list|,
name|Exception
name|cause
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|logWarn
condition|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
name|message
operator|+
literal|" Set "
operator|+
name|confKey
operator|+
literal|" to false at conf or table descriptor if you want to bypass sanity checks"
argument_list|,
name|cause
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|startActiveMasterManager
parameter_list|(
name|int
name|infoPort
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|backupZNode
init|=
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|zooKeeper
operator|.
name|znodePaths
operator|.
name|backupMasterAddressesZNode
argument_list|,
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|/*     * Add a ZNode for ourselves in the backup master directory since we     * may not become the active master. If so, we want the actual active     * master to know we are backup masters, so that it won't assign     * regions to us if so configured.     *     * If we become the active master later, ActiveMasterManager will delete     * this node explicitly.  If we crash before then, ZooKeeper will delete     * this node for us since it is ephemeral.     */
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding backup master ZNode "
operator|+
name|backupZNode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MasterAddressTracker
operator|.
name|setMasterAddress
argument_list|(
name|zooKeeper
argument_list|,
name|backupZNode
argument_list|,
name|serverName
argument_list|,
name|infoPort
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed create of "
operator|+
name|backupZNode
operator|+
literal|" by "
operator|+
name|serverName
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|activeMasterManager
operator|.
name|setInfoPort
argument_list|(
name|infoPort
argument_list|)
expr_stmt|;
name|int
name|timeout
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|ZK_SESSION_TIMEOUT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_ZK_SESSION_TIMEOUT
argument_list|)
decl_stmt|;
comment|// If we're a backup master, stall until a primary to write this address
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|MASTER_TYPE_BACKUP
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_TYPE_BACKUP
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"HMaster started in backup mode. Stalling until master znode is written."
argument_list|)
expr_stmt|;
comment|// This will only be a minute or so while the cluster starts up,
comment|// so don't worry about setting watches on the parent znode
while|while
condition|(
operator|!
name|activeMasterManager
operator|.
name|hasActiveMaster
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for master address and cluster state znode to be written."
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|sleep
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
name|MonitoredTask
name|status
init|=
name|TaskMonitor
operator|.
name|get
argument_list|()
operator|.
name|createStatus
argument_list|(
literal|"Master startup"
argument_list|)
decl_stmt|;
name|status
operator|.
name|setDescription
argument_list|(
literal|"Master startup"
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|activeMasterManager
operator|.
name|blockUntilBecomingActiveMaster
argument_list|(
name|timeout
argument_list|,
name|status
argument_list|)
condition|)
block|{
name|finishActiveMasterInitialization
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|status
operator|.
name|setStatus
argument_list|(
literal|"Failed to become active: "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|HBaseMarkers
operator|.
name|FATAL
argument_list|,
literal|"Failed to become active master"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// HBASE-5680: Likely hadoop23 vs hadoop 20.x/1.x incompatibility
if|if
condition|(
name|t
operator|instanceof
name|NoClassDefFoundError
operator|&&
name|t
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"org/apache/hadoop/hdfs/protocol/HdfsConstants$SafeModeAction"
argument_list|)
condition|)
block|{
comment|// improved error message for this special case
name|abort
argument_list|(
literal|"HBase is having a problem with its Hadoop jars.  You may need to recompile "
operator|+
literal|"HBase against Hadoop version "
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
operator|.
name|getVersion
argument_list|()
operator|+
literal|" or change your hadoop jars to start properly"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|abort
argument_list|(
literal|"Unhandled exception. Starting shutdown."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|status
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkCompression
parameter_list|(
specifier|final
name|TableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|masterCheckCompression
condition|)
return|return;
for|for
control|(
name|ColumnFamilyDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
name|checkCompression
argument_list|(
name|hcd
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkCompression
parameter_list|(
specifier|final
name|ColumnFamilyDescriptor
name|hcd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|masterCheckCompression
condition|)
return|return;
name|CompressionTest
operator|.
name|testCompression
argument_list|(
name|hcd
operator|.
name|getCompressionType
argument_list|()
argument_list|)
expr_stmt|;
name|CompressionTest
operator|.
name|testCompression
argument_list|(
name|hcd
operator|.
name|getCompactionCompressionType
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkEncryption
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|TableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|masterCheckEncryption
condition|)
return|return;
for|for
control|(
name|ColumnFamilyDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
name|checkEncryption
argument_list|(
name|conf
argument_list|,
name|hcd
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkEncryption
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|ColumnFamilyDescriptor
name|hcd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|masterCheckEncryption
condition|)
return|return;
name|EncryptionTest
operator|.
name|testEncryption
argument_list|(
name|conf
argument_list|,
name|hcd
operator|.
name|getEncryptionType
argument_list|()
argument_list|,
name|hcd
operator|.
name|getEncryptionKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkClassLoading
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|TableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionSplitPolicy
operator|.
name|getSplitPolicyClass
argument_list|(
name|htd
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|RegionCoprocessorHost
operator|.
name|testTableCoprocessorAttrs
argument_list|(
name|conf
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|isCatalogTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|tableName
operator|.
name|equals
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|deleteTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preDeleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" delete "
operator|+
name|tableName
argument_list|)
expr_stmt|;
comment|// TODO: We can handle/merge duplicate request
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|()
decl_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|DeleteTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|latch
argument_list|)
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postDeleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"DeleteTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|truncateTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|boolean
name|preserveSplits
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preTruncateTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" truncate "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|TruncateTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|preserveSplits
argument_list|,
name|latch
argument_list|)
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postTruncateTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"TruncateTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|addColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|ColumnFamilyDescriptor
name|column
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|checkTableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|TableDescriptor
name|old
init|=
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|.
name|hasColumnFamily
argument_list|(
name|column
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidFamilyOperationException
argument_list|(
literal|"Column family '"
operator|+
name|column
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"' in table '"
operator|+
name|tableName
operator|+
literal|"' already exists so cannot be added"
argument_list|)
throw|;
block|}
name|TableDescriptor
name|newDesc
init|=
name|TableDescriptorBuilder
operator|.
name|newBuilder
argument_list|(
name|old
argument_list|)
operator|.
name|addColumnFamily
argument_list|(
name|column
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|modifyTable
argument_list|(
name|tableName
argument_list|,
name|newDesc
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|modifyColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|ColumnFamilyDescriptor
name|descriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|checkTableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|TableDescriptor
name|old
init|=
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|old
operator|.
name|hasColumnFamily
argument_list|(
name|descriptor
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidFamilyOperationException
argument_list|(
literal|"Family '"
operator|+
name|descriptor
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"' does not exist, so it cannot be modified"
argument_list|)
throw|;
block|}
name|TableDescriptor
name|td
init|=
name|TableDescriptorBuilder
operator|.
name|newBuilder
argument_list|(
name|old
argument_list|)
operator|.
name|modifyColumnFamily
argument_list|(
name|descriptor
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|modifyTable
argument_list|(
name|tableName
argument_list|,
name|td
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|deleteColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnName
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|checkTableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|TableDescriptor
name|old
init|=
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|old
operator|.
name|hasColumnFamily
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidFamilyOperationException
argument_list|(
literal|"Family '"
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|columnName
argument_list|)
operator|+
literal|"' does not exist, so it cannot be deleted"
argument_list|)
throw|;
block|}
if|if
condition|(
name|old
operator|.
name|getColumnFamilyCount
argument_list|()
operator|==
literal|1
condition|)
block|{
throw|throw
operator|new
name|InvalidFamilyOperationException
argument_list|(
literal|"Family '"
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|columnName
argument_list|)
operator|+
literal|"' is the only column family in the table, so it cannot be deleted"
argument_list|)
throw|;
block|}
name|TableDescriptor
name|td
init|=
name|TableDescriptorBuilder
operator|.
name|newBuilder
argument_list|(
name|old
argument_list|)
operator|.
name|removeColumnFamily
argument_list|(
name|columnName
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|modifyTable
argument_list|(
name|tableName
argument_list|,
name|td
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|enableTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preEnableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// Normally, it would make sense for this authorization check to exist inside
comment|// AccessController, but because the authorization check is done based on internal state
comment|// (rather than explicit permissions) we'll do the check here instead of in the
comment|// coprocessor.
name|MasterQuotaManager
name|quotaManager
init|=
name|getMasterQuotaManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|quotaManager
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|quotaManager
operator|.
name|isQuotaInitialized
argument_list|()
condition|)
block|{
name|Quotas
name|quotaForTable
init|=
name|QuotaUtil
operator|.
name|getTableQuota
argument_list|(
name|getConnection
argument_list|()
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|quotaForTable
operator|!=
literal|null
operator|&&
name|quotaForTable
operator|.
name|hasSpace
argument_list|()
condition|)
block|{
name|SpaceViolationPolicy
name|policy
init|=
name|quotaForTable
operator|.
name|getSpace
argument_list|()
operator|.
name|getViolationPolicy
argument_list|()
decl_stmt|;
if|if
condition|(
name|SpaceViolationPolicy
operator|.
name|DISABLE
operator|==
name|policy
condition|)
block|{
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"Enabling the table '"
operator|+
name|tableName
operator|+
literal|"' is disallowed due to a violated space quota."
argument_list|)
throw|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Unable to check for space quotas as the MasterQuotaManager is not enabled"
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" enable "
operator|+
name|tableName
argument_list|)
expr_stmt|;
comment|// Execute the operation asynchronously - client will check the progress of the operation
comment|// In case the request is from a<1.1 client before returning,
comment|// we want to make sure that the table is prepared to be
comment|// enabled (the table is locked and the table state is set).
comment|// Note: if the procedure throws exception, we will catch it and rethrow.
specifier|final
name|ProcedurePrepareLatch
name|prepareLatch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|()
decl_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|EnableTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|,
name|prepareLatch
argument_list|)
argument_list|)
expr_stmt|;
name|prepareLatch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postEnableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"EnableTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|disableTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preDisableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" disable "
operator|+
name|tableName
argument_list|)
expr_stmt|;
comment|// Execute the operation asynchronously - client will check the progress of the operation
comment|// In case the request is from a<1.1 client before returning,
comment|// we want to make sure that the table is prepared to be
comment|// enabled (the table is locked and the table state is set).
comment|// Note: if the procedure throws exception, we will catch it and rethrow.
specifier|final
name|ProcedurePrepareLatch
name|prepareLatch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|()
decl_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|DisableTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|,
name|prepareLatch
argument_list|)
argument_list|)
expr_stmt|;
name|prepareLatch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postDisableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"DisableTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Return the region and current deployment for the region containing    * the given row. If the region cannot be found, returns null. If it    * is found, but not currently deployed, the second element of the pair    * may be null.    */
annotation|@
name|VisibleForTesting
comment|// Used by TestMaster.
name|Pair
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
name|getTableRegionForRow
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|rowKey
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|MetaTableAccessor
operator|.
name|Visitor
name|visitor
init|=
operator|new
name|MetaTableAccessor
operator|.
name|Visitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|visit
parameter_list|(
name|Result
name|data
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|==
literal|null
operator|||
name|data
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Pair
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
operator|new
name|Pair
argument_list|<>
argument_list|(
name|MetaTableAccessor
operator|.
name|getRegionInfo
argument_list|(
name|data
argument_list|)
argument_list|,
name|MetaTableAccessor
operator|.
name|getServerName
argument_list|(
name|data
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result
operator|.
name|set
argument_list|(
name|pair
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|MetaTableAccessor
operator|.
name|scanMeta
argument_list|(
name|clusterConnection
argument_list|,
name|visitor
argument_list|,
name|tableName
argument_list|,
name|rowKey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|modifyTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|TableDescriptor
name|descriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|sanityCheckTableDescriptor
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preModifyTable
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" modify "
operator|+
name|tableName
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation completes before continuing.
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|ModifyTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|descriptor
argument_list|,
name|latch
argument_list|)
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postModifyTable
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"ModifyTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|public
name|long
name|restoreSnapshot
parameter_list|(
specifier|final
name|SnapshotDescription
name|snapshotDesc
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|,
specifier|final
name|boolean
name|restoreAcl
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|getSnapshotManager
argument_list|()
operator|.
name|checkSnapshotSupport
argument_list|()
expr_stmt|;
comment|// Ensure namespace exists. Will throw exception if non-known NS.
specifier|final
name|TableName
name|dstTable
init|=
name|TableName
operator|.
name|valueOf
argument_list|(
name|snapshotDesc
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
name|getClusterSchema
argument_list|()
operator|.
name|getNamespace
argument_list|(
name|dstTable
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|setProcId
argument_list|(
name|getSnapshotManager
argument_list|()
operator|.
name|restoreOrCloneSnapshot
argument_list|(
name|snapshotDesc
argument_list|,
name|getNonceKey
argument_list|()
argument_list|,
name|restoreAcl
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"RestoreSnapshotProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|private
name|void
name|checkTableExists
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|TableNotFoundException
block|{
if|if
condition|(
operator|!
name|MetaTableAccessor
operator|.
name|tableExists
argument_list|(
name|getConnection
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkTableModifiable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|TableNotFoundException
throws|,
name|TableNotDisabledException
block|{
if|if
condition|(
name|isCatalogTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't modify catalog tables"
argument_list|)
throw|;
block|}
name|checkTableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|tableName
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|DISABLED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotDisabledException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
block|}
specifier|public
name|ClusterMetrics
name|getClusterMetricsWithoutCoprocessor
parameter_list|()
throws|throws
name|InterruptedIOException
block|{
return|return
name|getClusterMetricsWithoutCoprocessor
argument_list|(
name|EnumSet
operator|.
name|allOf
argument_list|(
name|Option
operator|.
name|class
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|ClusterMetrics
name|getClusterMetricsWithoutCoprocessor
parameter_list|(
name|EnumSet
argument_list|<
name|Option
argument_list|>
name|options
parameter_list|)
throws|throws
name|InterruptedIOException
block|{
name|ClusterMetricsBuilder
name|builder
init|=
name|ClusterMetricsBuilder
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
comment|// given that hbase1 can't submit the request with Option,
comment|// we return all information to client if the list of Option is empty.
if|if
condition|(
name|options
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|options
operator|=
name|EnumSet
operator|.
name|allOf
argument_list|(
name|Option
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Option
name|opt
range|:
name|options
control|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|HBASE_VERSION
case|:
name|builder
operator|.
name|setHBaseVersion
argument_list|(
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLUSTER_ID
case|:
name|builder
operator|.
name|setClusterId
argument_list|(
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|MASTER
case|:
name|builder
operator|.
name|setMasterName
argument_list|(
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKUP_MASTERS
case|:
name|builder
operator|.
name|setBackerMasterNames
argument_list|(
name|getBackupMasters
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIVE_SERVERS
case|:
block|{
if|if
condition|(
name|serverManager
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setLiveServerMetrics
argument_list|(
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toMap
argument_list|(
name|e
lambda|->
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
lambda|->
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DEAD_SERVERS
case|:
block|{
if|if
condition|(
name|serverManager
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setDeadServerNames
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|serverManager
operator|.
name|getDeadServers
argument_list|()
operator|.
name|copyServerNames
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MASTER_COPROCESSORS
case|:
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setMasterCoprocessorNames
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|getMasterCoprocessors
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|REGIONS_IN_TRANSITION
case|:
block|{
if|if
condition|(
name|assignmentManager
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setRegionsInTransition
argument_list|(
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionsStateInTransition
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|BALANCER_ON
case|:
block|{
if|if
condition|(
name|loadBalancerTracker
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setBalancerOn
argument_list|(
name|loadBalancerTracker
operator|.
name|isBalancerOn
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MASTER_INFO_PORT
case|:
block|{
if|if
condition|(
name|infoServer
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setMasterInfoPort
argument_list|(
name|infoServer
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * @return cluster status    */
specifier|public
name|ClusterMetrics
name|getClusterMetrics
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getClusterMetrics
argument_list|(
name|EnumSet
operator|.
name|allOf
argument_list|(
name|Option
operator|.
name|class
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|ClusterMetrics
name|getClusterMetrics
parameter_list|(
name|EnumSet
argument_list|<
name|Option
argument_list|>
name|options
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetClusterMetrics
argument_list|()
expr_stmt|;
block|}
name|ClusterMetrics
name|status
init|=
name|getClusterMetricsWithoutCoprocessor
argument_list|(
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetClusterMetrics
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
specifier|private
name|List
argument_list|<
name|ServerName
argument_list|>
name|getBackupMasters
parameter_list|()
throws|throws
name|InterruptedIOException
block|{
comment|// Build Set of backup masters from ZK nodes
name|List
argument_list|<
name|String
argument_list|>
name|backupMasterStrings
decl_stmt|;
try|try
block|{
name|backupMasterStrings
operator|=
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
operator|.
name|zooKeeper
operator|.
name|znodePaths
operator|.
name|backupMasterAddressesZNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|prefix
argument_list|(
literal|"Unable to list backup servers"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|backupMasterStrings
operator|=
literal|null
expr_stmt|;
block|}
name|List
argument_list|<
name|ServerName
argument_list|>
name|backupMasters
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
if|if
condition|(
name|backupMasterStrings
operator|!=
literal|null
operator|&&
operator|!
name|backupMasterStrings
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|backupMasters
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|backupMasterStrings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|backupMasterStrings
control|)
block|{
try|try
block|{
name|byte
index|[]
name|bytes
decl_stmt|;
try|try
block|{
name|bytes
operator|=
name|ZKUtil
operator|.
name|getData
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|znodePaths
operator|.
name|backupMasterAddressesZNode
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
block|}
if|if
condition|(
name|bytes
operator|!=
literal|null
condition|)
block|{
name|ServerName
name|sn
decl_stmt|;
try|try
block|{
name|sn
operator|=
name|ProtobufUtil
operator|.
name|parseServerNameFrom
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed parse, skipping registering backup server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|backupMasters
operator|.
name|add
argument_list|(
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|prefix
argument_list|(
literal|"Unable to get information about "
operator|+
literal|"backup servers"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|backupMasters
argument_list|,
operator|new
name|Comparator
argument_list|<
name|ServerName
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|ServerName
name|s1
parameter_list|,
name|ServerName
name|s2
parameter_list|)
block|{
return|return
name|s1
operator|.
name|getServerName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|s2
operator|.
name|getServerName
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|backupMasters
return|;
block|}
comment|/**    * The set of loaded coprocessors is stored in a static set. Since it's    * statically allocated, it does not require that HMaster's cpHost be    * initialized prior to accessing it.    * @return a String representation of the set of names of the loaded coprocessors.    */
specifier|public
specifier|static
name|String
name|getLoadedCoprocessors
parameter_list|()
block|{
return|return
name|CoprocessorHost
operator|.
name|getLoadedCoprocessors
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @return timestamp in millis when HMaster was started.    */
specifier|public
name|long
name|getMasterStartTime
parameter_list|()
block|{
return|return
name|startcode
return|;
block|}
comment|/**    * @return timestamp in millis when HMaster became the active master.    */
specifier|public
name|long
name|getMasterActiveTime
parameter_list|()
block|{
return|return
name|masterActiveTime
return|;
block|}
comment|/**    * @return timestamp in millis when HMaster finished becoming the active master    */
specifier|public
name|long
name|getMasterFinishedInitializationTime
parameter_list|()
block|{
return|return
name|masterFinishedInitializationTime
return|;
block|}
specifier|public
name|int
name|getNumWALFiles
parameter_list|()
block|{
return|return
name|procedureStore
operator|!=
literal|null
condition|?
name|procedureStore
operator|.
name|getActiveLogs
argument_list|()
operator|.
name|size
argument_list|()
else|:
literal|0
return|;
block|}
specifier|public
name|WALProcedureStore
name|getWalProcedureStore
parameter_list|()
block|{
return|return
name|procedureStore
return|;
block|}
specifier|public
name|int
name|getRegionServerInfoPort
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
name|RegionServerInfo
name|info
init|=
name|this
operator|.
name|regionServerTracker
operator|.
name|getRegionServerInfo
argument_list|(
name|sn
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
operator|||
name|info
operator|.
name|getInfoPort
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|REGIONSERVER_INFO_PORT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_REGIONSERVER_INFOPORT
argument_list|)
return|;
block|}
return|return
name|info
operator|.
name|getInfoPort
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getRegionServerVersion
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
name|RegionServerInfo
name|info
init|=
name|this
operator|.
name|regionServerTracker
operator|.
name|getRegionServerInfo
argument_list|(
name|sn
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|hasVersionInfo
argument_list|()
condition|)
block|{
return|return
name|info
operator|.
name|getVersionInfo
argument_list|()
operator|.
name|getVersion
argument_list|()
return|;
block|}
return|return
literal|"0.0.0"
return|;
comment|//Lowest version to prevent move system region to unknown version RS.
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkIfShouldMoveSystemRegionAsync
parameter_list|()
block|{
name|assignmentManager
operator|.
name|checkIfShouldMoveSystemRegionAsync
argument_list|()
expr_stmt|;
block|}
comment|/**    * @return array of coprocessor SimpleNames.    */
specifier|public
name|String
index|[]
name|getMasterCoprocessors
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|masterCoprocessors
init|=
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|getCoprocessors
argument_list|()
decl_stmt|;
return|return
name|masterCoprocessors
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|masterCoprocessors
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|reason
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
if|if
condition|(
name|isAborted
argument_list|()
operator|||
name|isStopped
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
comment|// HBASE-4014: dump a list of loaded coprocessors.
name|LOG
operator|.
name|error
argument_list|(
name|HBaseMarkers
operator|.
name|FATAL
argument_list|,
literal|"Master server abort: loaded coprocessors are: "
operator|+
name|getLoadedCoprocessors
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|msg
init|=
literal|"***** ABORTING master "
operator|+
name|this
operator|+
literal|": "
operator|+
name|reason
operator|+
literal|" *****"
decl_stmt|;
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|HBaseMarkers
operator|.
name|FATAL
argument_list|,
name|msg
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
name|HBaseMarkers
operator|.
name|FATAL
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|stopMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception occurred while stopping master"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ZKWatcher
name|getZooKeeper
parameter_list|()
block|{
return|return
name|zooKeeper
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterCoprocessorHost
name|getMasterCoprocessorHost
parameter_list|()
block|{
return|return
name|cpHost
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterQuotaManager
name|getMasterQuotaManager
parameter_list|()
block|{
return|return
name|quotaManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|ProcedureExecutor
argument_list|<
name|MasterProcedureEnv
argument_list|>
name|getMasterProcedureExecutor
parameter_list|()
block|{
return|return
name|procedureExecutor
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerName
name|getServerName
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverName
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssignmentManager
name|getAssignmentManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|assignmentManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|CatalogJanitor
name|getCatalogJanitor
parameter_list|()
block|{
return|return
name|this
operator|.
name|catalogJanitorChore
return|;
block|}
specifier|public
name|MemoryBoundedLogMessageBuffer
name|getRegionServerFatalLogBuffer
parameter_list|()
block|{
return|return
name|rsFatals
return|;
block|}
comment|/**    * Shutdown the cluster.    * Master runs a coordinated stop of all RegionServers and then itself.    */
specifier|public
name|void
name|shutdown
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preShutdown
argument_list|()
expr_stmt|;
block|}
comment|// Tell the servermanager cluster shutdown has been called. This makes it so when Master is
comment|// last running server, it'll stop itself. Next, we broadcast the cluster shutdown by setting
comment|// the cluster status as down. RegionServers will notice this change in state and will start
comment|// shutting themselves down. When last has exited, Master can go down.
if|if
condition|(
name|this
operator|.
name|serverManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|serverManager
operator|.
name|shutdownCluster
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|clusterStatusTracker
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterDown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ZooKeeper exception trying to set cluster as down in ZK"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Stop the procedure executor. Will stop any ongoing assign, unassign, server crash etc.,
comment|// processing so we can go down.
if|if
condition|(
name|this
operator|.
name|procedureExecutor
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|procedureExecutor
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
comment|// Shutdown our cluster connection. This will kill any hosted RPCs that might be going on;
comment|// this is what we want especially if the Master is in startup phase doing call outs to
comment|// hbase:meta, etc. when cluster is down. Without ths connection close, we'd have to wait on
comment|// the rpc to timeout.
if|if
condition|(
name|this
operator|.
name|clusterConnection
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|clusterConnection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|stopMaster
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preStopMaster
argument_list|()
expr_stmt|;
block|}
name|stop
argument_list|(
literal|"Stopped by "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isStopped
argument_list|()
condition|)
block|{
name|super
operator|.
name|stop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|activeMasterManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|activeMasterManager
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|void
name|checkServiceStarted
parameter_list|()
throws|throws
name|ServerNotRunningYetException
block|{
if|if
condition|(
operator|!
name|serviceStarted
condition|)
block|{
throw|throw
operator|new
name|ServerNotRunningYetException
argument_list|(
literal|"Server is not running yet"
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
class|class
name|MasterStoppedException
extends|extends
name|DoNotRetryIOException
block|{
name|MasterStoppedException
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|checkInitialized
parameter_list|()
throws|throws
name|PleaseHoldException
throws|,
name|ServerNotRunningYetException
throws|,
name|MasterNotRunningException
throws|,
name|MasterStoppedException
block|{
name|checkServiceStarted
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PleaseHoldException
argument_list|(
literal|"Master is initializing"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isStopped
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MasterStoppedException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Report whether this master is currently the active master or not.    * If not active master, we are parked on ZK waiting to become active.    *    * This method is used for testing.    *    * @return true if active master, false if not.    */
annotation|@
name|Override
specifier|public
name|boolean
name|isActiveMaster
parameter_list|()
block|{
return|return
name|activeMaster
return|;
block|}
comment|/**    * Report whether this master has completed with its initialization and is    * ready.  If ready, the master is also the active master.  A standby master    * is never ready.    *    * This method is used for testing.    *    * @return true if master is ready to go, false if not.    */
annotation|@
name|Override
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
return|return
name|initialized
operator|.
name|isReady
argument_list|()
return|;
block|}
comment|/**    * Report whether this master is in maintenance mode.    *    * @return true if master is in maintenanceMode    */
annotation|@
name|Override
specifier|public
name|boolean
name|isInMaintenanceMode
parameter_list|()
block|{
return|return
name|maintenanceModeTracker
operator|.
name|isInMaintenanceMode
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|setInitialized
parameter_list|(
name|boolean
name|isInitialized
parameter_list|)
block|{
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
operator|.
name|setEventReady
argument_list|(
name|initialized
argument_list|,
name|isInitialized
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|getInitializedEvent
parameter_list|()
block|{
return|return
name|initialized
return|;
block|}
comment|/**    * ServerCrashProcessingEnabled is set false before completing assignMeta to prevent processing    * of crashed servers.    * @return true if assignMeta has completed;    */
annotation|@
name|Override
specifier|public
name|boolean
name|isServerCrashProcessingEnabled
parameter_list|()
block|{
return|return
name|serverCrashProcessingEnabled
operator|.
name|isReady
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|setServerCrashProcessingEnabled
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
block|{
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
operator|.
name|setEventReady
argument_list|(
name|serverCrashProcessingEnabled
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|getServerCrashProcessingEnabledEvent
parameter_list|()
block|{
return|return
name|serverCrashProcessingEnabled
return|;
block|}
comment|/**    * Compute the average load across all region servers.    * Currently, this uses a very naive computation - just uses the number of    * regions being served, ignoring stats about number of requests.    * @return the average load    */
specifier|public
name|double
name|getAverageLoad
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|RegionStates
name|regionStates
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionStates
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|regionStates
operator|.
name|getAverageLoad
argument_list|()
return|;
block|}
comment|/*    * @return the count of region split plans executed    */
specifier|public
name|long
name|getSplitPlanCount
parameter_list|()
block|{
return|return
name|splitPlanCount
return|;
block|}
comment|/*    * @return the count of region merge plans executed    */
specifier|public
name|long
name|getMergePlanCount
parameter_list|()
block|{
return|return
name|mergePlanCount
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|registerService
parameter_list|(
name|Service
name|instance
parameter_list|)
block|{
comment|/*      * No stacking of instances is allowed for a single service name      */
name|Descriptors
operator|.
name|ServiceDescriptor
name|serviceDesc
init|=
name|instance
operator|.
name|getDescriptorForType
argument_list|()
decl_stmt|;
name|String
name|serviceName
init|=
name|CoprocessorRpcUtils
operator|.
name|getServiceName
argument_list|(
name|serviceDesc
argument_list|)
decl_stmt|;
if|if
condition|(
name|coprocessorServiceHandlers
operator|.
name|containsKey
argument_list|(
name|serviceName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor service "
operator|+
name|serviceName
operator|+
literal|" already registered, rejecting request from "
operator|+
name|instance
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|coprocessorServiceHandlers
operator|.
name|put
argument_list|(
name|serviceName
argument_list|,
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Registered master coprocessor service: service="
operator|+
name|serviceName
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Utility for constructing an instance of the passed HMaster class.    * @param masterClass    * @return HMaster instance.    */
specifier|public
specifier|static
name|HMaster
name|constructMaster
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|masterClass
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|c
init|=
name|masterClass
operator|.
name|getConstructor
argument_list|(
name|Configuration
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|c
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Throwable
name|error
init|=
name|e
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|InvocationTargetException
operator|&&
operator|(
operator|(
name|InvocationTargetException
operator|)
name|e
operator|)
operator|.
name|getTargetException
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|error
operator|=
operator|(
operator|(
name|InvocationTargetException
operator|)
name|e
operator|)
operator|.
name|getTargetException
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of Master: "
operator|+
name|masterClass
operator|.
name|toString
argument_list|()
operator|+
literal|". "
argument_list|,
name|error
argument_list|)
throw|;
block|}
block|}
comment|/**    * @see org.apache.hadoop.hbase.master.HMasterCommandLine    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"STARTING service "
operator|+
name|HMaster
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|VersionInfo
operator|.
name|logVersion
argument_list|()
expr_stmt|;
operator|new
name|HMasterCommandLine
argument_list|(
name|HMaster
operator|.
name|class
argument_list|)
operator|.
name|doMain
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
specifier|public
name|HFileCleaner
name|getHFileCleaner
parameter_list|()
block|{
return|return
name|this
operator|.
name|hfileCleaner
return|;
block|}
specifier|public
name|LogCleaner
name|getLogCleaner
parameter_list|()
block|{
return|return
name|this
operator|.
name|logCleaner
return|;
block|}
comment|/**    * @return the underlying snapshot manager    */
annotation|@
name|Override
specifier|public
name|SnapshotManager
name|getSnapshotManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotManager
return|;
block|}
comment|/**    * @return the underlying MasterProcedureManagerHost    */
annotation|@
name|Override
specifier|public
name|MasterProcedureManagerHost
name|getMasterProcedureManagerHost
parameter_list|()
block|{
return|return
name|mpmHost
return|;
block|}
annotation|@
name|Override
specifier|public
name|ClusterSchema
name|getClusterSchema
parameter_list|()
block|{
return|return
name|this
operator|.
name|clusterSchemaService
return|;
block|}
comment|/**    * Create a new Namespace.    * @param namespaceDescriptor descriptor for new Namespace    * @param nonceGroup Identifier for the source of the request, a client or process.    * @param nonce A unique identifier for this operation from the client or process identified by    *<code>nonceGroup</code> (the source must ensure each operation gets a unique id).    * @return procedure id    */
name|long
name|createNamespace
parameter_list|(
specifier|final
name|NamespaceDescriptor
name|namespaceDescriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|TableName
operator|.
name|isLegalNamespaceName
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|namespaceDescriptor
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preCreateNamespace
argument_list|(
name|namespaceDescriptor
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" creating "
operator|+
name|namespaceDescriptor
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation to complete before
comment|// continuing.
name|setProcId
argument_list|(
name|getClusterSchema
argument_list|()
operator|.
name|createNamespace
argument_list|(
name|namespaceDescriptor
argument_list|,
name|getNonceKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postCreateNamespace
argument_list|(
name|namespaceDescriptor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"CreateNamespaceProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Modify an existing Namespace.    * @param nonceGroup Identifier for the source of the request, a client or process.    * @param nonce A unique identifier for this operation from the client or process identified by    *<code>nonceGroup</code> (the source must ensure each operation gets a unique id).    * @return procedure id    */
name|long
name|modifyNamespace
parameter_list|(
specifier|final
name|NamespaceDescriptor
name|namespaceDescriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|TableName
operator|.
name|isLegalNamespaceName
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|namespaceDescriptor
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preModifyNamespace
argument_list|(
name|namespaceDescriptor
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" modify "
operator|+
name|namespaceDescriptor
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation to complete before
comment|// continuing.
name|setProcId
argument_list|(
name|getClusterSchema
argument_list|()
operator|.
name|modifyNamespace
argument_list|(
name|namespaceDescriptor
argument_list|,
name|getNonceKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postModifyNamespace
argument_list|(
name|namespaceDescriptor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"ModifyNamespaceProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Delete an existing Namespace. Only empty Namespaces (no tables) can be removed.    * @param nonceGroup Identifier for the source of the request, a client or process.    * @param nonce A unique identifier for this operation from the client or process identified by    *<code>nonceGroup</code> (the source must ensure each operation gets a unique id).    * @return procedure id    */
name|long
name|deleteNamespace
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preDeleteNamespace
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" delete "
operator|+
name|name
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation to complete before
comment|// continuing.
name|setProcId
argument_list|(
name|getClusterSchema
argument_list|()
operator|.
name|deleteNamespace
argument_list|(
name|name
argument_list|,
name|getNonceKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postDeleteNamespace
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"DeleteNamespaceProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Get a Namespace    * @param name Name of the Namespace    * @return Namespace descriptor for<code>name</code>    */
name|NamespaceDescriptor
name|getNamespace
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|cpHost
operator|.
name|preGetNamespaceDescriptor
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|NamespaceDescriptor
name|nsd
init|=
name|this
operator|.
name|clusterSchemaService
operator|.
name|getNamespace
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|cpHost
operator|.
name|postGetNamespaceDescriptor
argument_list|(
name|nsd
argument_list|)
expr_stmt|;
return|return
name|nsd
return|;
block|}
comment|/**    * Get all Namespaces    * @return All Namespace descriptors    */
name|List
argument_list|<
name|NamespaceDescriptor
argument_list|>
name|getNamespaces
parameter_list|()
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|NamespaceDescriptor
argument_list|>
name|nsds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preListNamespaceDescriptors
argument_list|(
name|nsds
argument_list|)
expr_stmt|;
block|}
name|nsds
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|clusterSchemaService
operator|.
name|getNamespaces
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cpHost
operator|.
name|postListNamespaceDescriptors
argument_list|(
name|nsds
argument_list|)
expr_stmt|;
block|}
return|return
name|nsds
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|TableName
argument_list|>
name|listTableNamesByNamespace
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|listTableNames
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|TableDescriptor
argument_list|>
name|listTableDescriptorsByNamespace
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|listTableDescriptors
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|abortProcedure
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|,
specifier|final
name|boolean
name|mayInterruptIfRunning
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preAbortProcedure
argument_list|(
name|this
operator|.
name|procedureExecutor
argument_list|,
name|procId
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|result
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|abort
argument_list|(
name|procId
argument_list|,
name|mayInterruptIfRunning
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postAbortProcedure
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Procedure
argument_list|<
name|?
argument_list|>
argument_list|>
name|getProcedures
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetProcedures
argument_list|()
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|Procedure
argument_list|<
name|?
argument_list|>
argument_list|>
name|procList
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|getProcedures
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetProcedures
argument_list|(
name|procList
argument_list|)
expr_stmt|;
block|}
return|return
name|procList
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|LockedResource
argument_list|>
name|getLocks
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetLocks
argument_list|()
expr_stmt|;
block|}
name|MasterProcedureScheduler
name|procedureScheduler
init|=
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getProcedureScheduler
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|LockedResource
argument_list|>
name|lockedResources
init|=
name|procedureScheduler
operator|.
name|getLocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetLocks
argument_list|(
name|lockedResources
argument_list|)
expr_stmt|;
block|}
return|return
name|lockedResources
return|;
block|}
comment|/**    * Returns the list of table descriptors that match the specified request    * @param namespace the namespace to query, or null if querying for all    * @param regex The regular expression to match against, or null if querying for all    * @param tableNameList the list of table names, or null if querying for all    * @param includeSysTables False to match only against userspace tables    * @return the list of table descriptors    */
specifier|public
name|List
argument_list|<
name|TableDescriptor
argument_list|>
name|listTableDescriptors
parameter_list|(
specifier|final
name|String
name|namespace
parameter_list|,
specifier|final
name|String
name|regex
parameter_list|,
specifier|final
name|List
argument_list|<
name|TableName
argument_list|>
name|tableNameList
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|TableDescriptor
argument_list|>
name|htds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetTableDescriptors
argument_list|(
name|tableNameList
argument_list|,
name|htds
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
name|htds
operator|=
name|getTableDescriptors
argument_list|(
name|htds
argument_list|,
name|namespace
argument_list|,
name|regex
argument_list|,
name|tableNameList
argument_list|,
name|includeSysTables
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetTableDescriptors
argument_list|(
name|tableNameList
argument_list|,
name|htds
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
return|return
name|htds
return|;
block|}
comment|/**    * Returns the list of table names that match the specified request    * @param regex The regular expression to match against, or null if querying for all    * @param namespace the namespace to query, or null if querying for all    * @param includeSysTables False to match only against userspace tables    * @return the list of table names    */
specifier|public
name|List
argument_list|<
name|TableName
argument_list|>
name|listTableNames
parameter_list|(
specifier|final
name|String
name|namespace
parameter_list|,
specifier|final
name|String
name|regex
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|TableDescriptor
argument_list|>
name|htds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetTableNames
argument_list|(
name|htds
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
name|htds
operator|=
name|getTableDescriptors
argument_list|(
name|htds
argument_list|,
name|namespace
argument_list|,
name|regex
argument_list|,
literal|null
argument_list|,
name|includeSysTables
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetTableNames
argument_list|(
name|htds
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|TableName
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|htds
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|TableDescriptor
name|htd
range|:
name|htds
control|)
name|result
operator|.
name|add
argument_list|(
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * @return list of table table descriptors after filtering by regex and whether to include system    *    tables, etc.    * @throws IOException    */
specifier|private
name|List
argument_list|<
name|TableDescriptor
argument_list|>
name|getTableDescriptors
parameter_list|(
specifier|final
name|List
argument_list|<
name|TableDescriptor
argument_list|>
name|htds
parameter_list|,
specifier|final
name|String
name|namespace
parameter_list|,
specifier|final
name|String
name|regex
parameter_list|,
specifier|final
name|List
argument_list|<
name|TableName
argument_list|>
name|tableNameList
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableNameList
operator|==
literal|null
operator|||
name|tableNameList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// request for all TableDescriptors
name|Collection
argument_list|<
name|TableDescriptor
argument_list|>
name|allHtds
decl_stmt|;
if|if
condition|(
name|namespace
operator|!=
literal|null
operator|&&
name|namespace
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Do a check on the namespace existence. Will fail if does not exist.
name|this
operator|.
name|clusterSchemaService
operator|.
name|getNamespace
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
name|allHtds
operator|=
name|tableDescriptors
operator|.
name|getByNamespace
argument_list|(
name|namespace
argument_list|)
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|allHtds
operator|=
name|tableDescriptors
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|TableDescriptor
name|desc
range|:
name|allHtds
control|)
block|{
if|if
condition|(
name|tableStateManager
operator|.
name|isTablePresent
argument_list|(
name|desc
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|&&
operator|(
name|includeSysTables
operator|||
operator|!
name|desc
operator|.
name|getTableName
argument_list|()
operator|.
name|isSystemTable
argument_list|()
operator|)
condition|)
block|{
name|htds
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|TableName
name|s
range|:
name|tableNameList
control|)
block|{
if|if
condition|(
name|tableStateManager
operator|.
name|isTablePresent
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|TableDescriptor
name|desc
init|=
name|tableDescriptors
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
name|htds
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Retains only those matched by regular expression.
if|if
condition|(
name|regex
operator|!=
literal|null
condition|)
name|filterTablesByRegex
argument_list|(
name|htds
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|htds
return|;
block|}
comment|/**    * Removes the table descriptors that don't match the pattern.    * @param descriptors list of table descriptors to filter    * @param pattern the regex to use    */
specifier|private
specifier|static
name|void
name|filterTablesByRegex
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|TableDescriptor
argument_list|>
name|descriptors
parameter_list|,
specifier|final
name|Pattern
name|pattern
parameter_list|)
block|{
specifier|final
name|String
name|defaultNS
init|=
name|NamespaceDescriptor
operator|.
name|DEFAULT_NAMESPACE_NAME_STR
decl_stmt|;
name|Iterator
argument_list|<
name|TableDescriptor
argument_list|>
name|itr
init|=
name|descriptors
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|TableDescriptor
name|htd
init|=
name|itr
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|tableName
init|=
name|htd
operator|.
name|getTableName
argument_list|()
operator|.
name|getNameAsString
argument_list|()
decl_stmt|;
name|boolean
name|matched
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|tableName
argument_list|)
operator|.
name|matches
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|matched
operator|&&
name|htd
operator|.
name|getTableName
argument_list|()
operator|.
name|getNamespaceAsString
argument_list|()
operator|.
name|equals
argument_list|(
name|defaultNS
argument_list|)
condition|)
block|{
name|matched
operator|=
name|pattern
operator|.
name|matcher
argument_list|(
name|defaultNS
operator|+
name|TableName
operator|.
name|NAMESPACE_DELIM
operator|+
name|tableName
argument_list|)
operator|.
name|matches
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|itr
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLastMajorCompactionTimestamp
parameter_list|(
name|TableName
name|table
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getClusterMetrics
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|Option
operator|.
name|LIVE_SERVERS
argument_list|)
argument_list|)
operator|.
name|getLastMajorCompactionTimestamp
argument_list|(
name|table
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLastMajorCompactionTimestampForRegion
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getClusterMetrics
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|Option
operator|.
name|LIVE_SERVERS
argument_list|)
argument_list|)
operator|.
name|getLastMajorCompactionTimestamp
argument_list|(
name|regionName
argument_list|)
return|;
block|}
comment|/**    * Gets the mob file compaction state for a specific table.    * Whether all the mob files are selected is known during the compaction execution, but    * the statistic is done just before compaction starts, it is hard to know the compaction    * type at that time, so the rough statistics are chosen for the mob file compaction. Only two    * compaction states are available, CompactionState.MAJOR_AND_MINOR and CompactionState.NONE.    * @param tableName The current table name.    * @return If a given table is in mob file compaction now.    */
specifier|public
name|CompactionState
name|getMobCompactionState
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
name|AtomicInteger
name|compactionsCount
init|=
name|mobCompactionStates
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|compactionsCount
operator|!=
literal|null
operator|&&
name|compactionsCount
operator|.
name|get
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|CompactionState
operator|.
name|MAJOR_AND_MINOR
return|;
block|}
return|return
name|CompactionState
operator|.
name|NONE
return|;
block|}
specifier|public
name|void
name|reportMobCompactionStart
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|IdLock
operator|.
name|Entry
name|lockEntry
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockEntry
operator|=
name|mobCompactionLock
operator|.
name|getLockEntry
argument_list|(
name|tableName
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|AtomicInteger
name|compactionsCount
init|=
name|mobCompactionStates
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|compactionsCount
operator|==
literal|null
condition|)
block|{
name|compactionsCount
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mobCompactionStates
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|compactionsCount
argument_list|)
expr_stmt|;
block|}
name|compactionsCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|lockEntry
operator|!=
literal|null
condition|)
block|{
name|mobCompactionLock
operator|.
name|releaseLockEntry
argument_list|(
name|lockEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|reportMobCompactionEnd
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|IdLock
operator|.
name|Entry
name|lockEntry
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockEntry
operator|=
name|mobCompactionLock
operator|.
name|getLockEntry
argument_list|(
name|tableName
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|AtomicInteger
name|compactionsCount
init|=
name|mobCompactionStates
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|compactionsCount
operator|!=
literal|null
condition|)
block|{
name|int
name|count
init|=
name|compactionsCount
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
comment|// remove the entry if the count is 0.
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|mobCompactionStates
operator|.
name|remove
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|lockEntry
operator|!=
literal|null
condition|)
block|{
name|mobCompactionLock
operator|.
name|releaseLockEntry
argument_list|(
name|lockEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Requests mob compaction.    * @param tableName The table the compact.    * @param columns The compacted columns.    * @param allFiles Whether add all mob files into the compaction.    */
specifier|public
name|void
name|requestMobCompaction
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|List
argument_list|<
name|ColumnFamilyDescriptor
argument_list|>
name|columns
parameter_list|,
name|boolean
name|allFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|mobCompactThread
operator|.
name|requestMobCompaction
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|tableName
argument_list|,
name|columns
argument_list|,
name|allFiles
argument_list|)
expr_stmt|;
block|}
comment|/**    * Queries the state of the {@link LoadBalancerTracker}. If the balancer is not initialized,    * false is returned.    *    * @return The state of the load balancer, or false if the load balancer isn't defined.    */
specifier|public
name|boolean
name|isBalancerOn
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|==
name|loadBalancerTracker
operator|||
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|loadBalancerTracker
operator|.
name|isBalancerOn
argument_list|()
return|;
block|}
comment|/**    * Queries the state of the {@link RegionNormalizerTracker}. If it's not initialized,    * false is returned.    */
specifier|public
name|boolean
name|isNormalizerOn
parameter_list|()
block|{
return|return
operator|(
literal|null
operator|==
name|regionNormalizerTracker
operator|||
name|isInMaintenanceMode
argument_list|()
operator|)
condition|?
literal|false
else|:
name|regionNormalizerTracker
operator|.
name|isNormalizerOn
argument_list|()
return|;
block|}
comment|/**    * Queries the state of the {@link SplitOrMergeTracker}. If it is not initialized,    * false is returned. If switchType is illegal, false will return.    * @param switchType see {@link org.apache.hadoop.hbase.client.MasterSwitchType}    * @return The state of the switch    */
annotation|@
name|Override
specifier|public
name|boolean
name|isSplitOrMergeEnabled
parameter_list|(
name|MasterSwitchType
name|switchType
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|splitOrMergeTracker
operator|||
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|splitOrMergeTracker
operator|.
name|isSplitOrMergeEnabled
argument_list|(
name|switchType
argument_list|)
return|;
block|}
comment|/**    * Fetch the configured {@link LoadBalancer} class name. If none is set, a default is returned.    *    * @return The name of the {@link LoadBalancer} in use.    */
specifier|public
name|String
name|getLoadBalancerClassName
parameter_list|()
block|{
return|return
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_MASTER_LOADBALANCER_CLASS
argument_list|,
name|LoadBalancerFactory
operator|.
name|getDefaultLoadBalancerClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return RegionNormalizerTracker instance    */
specifier|public
name|RegionNormalizerTracker
name|getRegionNormalizerTracker
parameter_list|()
block|{
return|return
name|regionNormalizerTracker
return|;
block|}
specifier|public
name|SplitOrMergeTracker
name|getSplitOrMergeTracker
parameter_list|()
block|{
return|return
name|splitOrMergeTracker
return|;
block|}
annotation|@
name|Override
specifier|public
name|LoadBalancer
name|getLoadBalancer
parameter_list|()
block|{
return|return
name|balancer
return|;
block|}
annotation|@
name|Override
specifier|public
name|FavoredNodesManager
name|getFavoredNodesManager
parameter_list|()
block|{
return|return
name|favoredNodesManager
return|;
block|}
specifier|private
name|long
name|executePeerProcedure
parameter_list|(
name|ModifyPeerProcedure
name|procedure
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|procId
init|=
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
name|procedure
argument_list|)
decl_stmt|;
name|procedure
operator|.
name|getLatch
argument_list|()
operator|.
name|await
argument_list|()
expr_stmt|;
return|return
name|procId
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|addReplicationPeer
parameter_list|(
name|String
name|peerId
parameter_list|,
name|ReplicationPeerConfig
name|peerConfig
parameter_list|,
name|boolean
name|enabled
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" creating replication peer, id="
operator|+
name|peerId
operator|+
literal|", config="
operator|+
name|peerConfig
operator|+
literal|", state="
operator|+
operator|(
name|enabled
condition|?
literal|"ENABLED"
else|:
literal|"DISABLED"
operator|)
argument_list|)
expr_stmt|;
return|return
name|executePeerProcedure
argument_list|(
operator|new
name|AddPeerProcedure
argument_list|(
name|peerId
argument_list|,
name|peerConfig
argument_list|,
name|enabled
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|removeReplicationPeer
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" removing replication peer, id="
operator|+
name|peerId
argument_list|)
expr_stmt|;
return|return
name|executePeerProcedure
argument_list|(
operator|new
name|RemovePeerProcedure
argument_list|(
name|peerId
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|enableReplicationPeer
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" enable replication peer, id="
operator|+
name|peerId
argument_list|)
expr_stmt|;
return|return
name|executePeerProcedure
argument_list|(
operator|new
name|EnablePeerProcedure
argument_list|(
name|peerId
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|disableReplicationPeer
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" disable replication peer, id="
operator|+
name|peerId
argument_list|)
expr_stmt|;
return|return
name|executePeerProcedure
argument_list|(
operator|new
name|DisablePeerProcedure
argument_list|(
name|peerId
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReplicationPeerConfig
name|getReplicationPeerConfig
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetReplicationPeerConfig
argument_list|(
name|peerId
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" get replication peer config, id="
operator|+
name|peerId
argument_list|)
expr_stmt|;
name|ReplicationPeerConfig
name|peerConfig
init|=
name|this
operator|.
name|replicationPeerManager
operator|.
name|getPeerConfig
argument_list|(
name|peerId
argument_list|)
operator|.
name|orElseThrow
argument_list|(
parameter_list|()
lambda|->
operator|new
name|ReplicationPeerNotFoundException
argument_list|(
name|peerId
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetReplicationPeerConfig
argument_list|(
name|peerId
argument_list|)
expr_stmt|;
block|}
return|return
name|peerConfig
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|updateReplicationPeerConfig
parameter_list|(
name|String
name|peerId
parameter_list|,
name|ReplicationPeerConfig
name|peerConfig
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" update replication peer config, id="
operator|+
name|peerId
operator|+
literal|", config="
operator|+
name|peerConfig
argument_list|)
expr_stmt|;
return|return
name|executePeerProcedure
argument_list|(
operator|new
name|UpdatePeerConfigProcedure
argument_list|(
name|peerId
argument_list|,
name|peerConfig
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ReplicationPeerDescription
argument_list|>
name|listReplicationPeers
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preListReplicationPeers
argument_list|(
name|regex
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" list replication peers, regex="
operator|+
name|regex
argument_list|)
expr_stmt|;
name|Pattern
name|pattern
init|=
name|regex
operator|==
literal|null
condition|?
literal|null
else|:
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ReplicationPeerDescription
argument_list|>
name|peers
init|=
name|this
operator|.
name|replicationPeerManager
operator|.
name|listPeers
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postListReplicationPeers
argument_list|(
name|regex
argument_list|)
expr_stmt|;
block|}
return|return
name|peers
return|;
block|}
comment|/**    * Mark region server(s) as decommissioned (previously called 'draining') to prevent additional    * regions from getting assigned to them. Also unload the regions on the servers asynchronously.0    * @param servers Region servers to decommission.    * @throws HBaseIOException    */
specifier|public
name|void
name|decommissionRegionServers
parameter_list|(
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|,
specifier|final
name|boolean
name|offload
parameter_list|)
throws|throws
name|HBaseIOException
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|serversAdded
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|servers
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Place the decommission marker first.
name|String
name|parentZnode
init|=
name|getZooKeeper
argument_list|()
operator|.
name|znodePaths
operator|.
name|drainingZNode
decl_stmt|;
for|for
control|(
name|ServerName
name|server
range|:
name|servers
control|)
block|{
try|try
block|{
name|String
name|node
init|=
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|parentZnode
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
argument_list|)
decl_stmt|;
name|ZKUtil
operator|.
name|createAndFailSilent
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|prefix
argument_list|(
literal|"Unable to decommission '"
operator|+
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|"'."
argument_list|)
argument_list|,
name|ke
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|.
name|addServerToDrainList
argument_list|(
name|server
argument_list|)
condition|)
block|{
name|serversAdded
operator|.
name|add
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Move the regions off the decommissioned servers.
if|if
condition|(
name|offload
condition|)
block|{
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|destServers
init|=
name|this
operator|.
name|serverManager
operator|.
name|createDestinationServersList
argument_list|()
decl_stmt|;
for|for
control|(
name|ServerName
name|server
range|:
name|serversAdded
control|)
block|{
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|regionsOnServer
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getServerRegionInfoSet
argument_list|(
name|server
argument_list|)
decl_stmt|;
for|for
control|(
name|RegionInfo
name|hri
range|:
name|regionsOnServer
control|)
block|{
name|ServerName
name|dest
init|=
name|balancer
operator|.
name|randomAssignment
argument_list|(
name|hri
argument_list|,
name|destServers
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
literal|"Unable to determine a plan to move "
operator|+
name|hri
argument_list|)
throw|;
block|}
name|RegionPlan
name|rp
init|=
operator|new
name|RegionPlan
argument_list|(
name|hri
argument_list|,
name|server
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|moveAsync
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * List region servers marked as decommissioned (previously called 'draining') to not get regions    * assigned to them.    * @return List of decommissioned servers.    */
specifier|public
name|List
argument_list|<
name|ServerName
argument_list|>
name|listDecommissionedRegionServers
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverManager
operator|.
name|getDrainingServersList
argument_list|()
return|;
block|}
comment|/**    * Remove decommission marker (previously called 'draining') from a region server to allow regions    * assignments. Load regions onto the server asynchronously if a list of regions is given    * @param server Region server to remove decommission marker from.    * @throws HBaseIOException    */
specifier|public
name|void
name|recommissionRegionServer
parameter_list|(
specifier|final
name|ServerName
name|server
parameter_list|,
specifier|final
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|encodedRegionNames
parameter_list|)
throws|throws
name|HBaseIOException
block|{
comment|// Remove the server from decommissioned (draining) server list.
name|String
name|parentZnode
init|=
name|getZooKeeper
argument_list|()
operator|.
name|znodePaths
operator|.
name|drainingZNode
decl_stmt|;
name|String
name|node
init|=
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|parentZnode
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|ZKUtil
operator|.
name|deleteNodeFailSilent
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|prefix
argument_list|(
literal|"Unable to recommission '"
operator|+
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|"'."
argument_list|)
argument_list|,
name|ke
argument_list|)
throw|;
block|}
name|this
operator|.
name|serverManager
operator|.
name|removeServerFromDrainList
argument_list|(
name|server
argument_list|)
expr_stmt|;
comment|// Load the regions onto the server if we are given a list of regions.
if|if
condition|(
name|encodedRegionNames
operator|==
literal|null
operator|||
name|encodedRegionNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|server
argument_list|)
condition|)
block|{
return|return;
block|}
for|for
control|(
name|byte
index|[]
name|encodedRegionName
range|:
name|encodedRegionNames
control|)
block|{
name|RegionState
name|regionState
init|=
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionState
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionState
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown region "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RegionInfo
name|hri
init|=
name|regionState
operator|.
name|getRegion
argument_list|()
decl_stmt|;
if|if
condition|(
name|server
operator|.
name|equals
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping move of region "
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" because region already assigned to the same server "
operator|+
name|server
operator|+
literal|"."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RegionPlan
name|rp
init|=
operator|new
name|RegionPlan
argument_list|(
name|hri
argument_list|,
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|,
name|server
argument_list|)
decl_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|moveAsync
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|LockManager
name|getLockManager
parameter_list|()
block|{
return|return
name|lockManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|recoverMeta
parameter_list|()
throws|throws
name|IOException
block|{
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Running RecoverMetaProcedure to ensure proper hbase:meta deploy."
argument_list|)
expr_stmt|;
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|RecoverMetaProcedure
argument_list|(
literal|null
argument_list|,
literal|true
argument_list|,
name|latch
argument_list|)
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"hbase:meta deployed at="
operator|+
name|getMetaTableLocator
argument_list|()
operator|.
name|getMetaRegionLocation
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|assignmentManager
operator|.
name|isMetaInitialized
argument_list|()
return|;
block|}
specifier|public
name|QuotaObserverChore
name|getQuotaObserverChore
parameter_list|()
block|{
return|return
name|this
operator|.
name|quotaObserverChore
return|;
block|}
specifier|public
name|SpaceQuotaSnapshotNotifier
name|getSpaceQuotaSnapshotNotifier
parameter_list|()
block|{
return|return
name|this
operator|.
name|spaceQuotaSnapshotNotifier
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|RemoteProcedure
argument_list|<
name|MasterProcedureEnv
argument_list|,
name|?
argument_list|>
name|getRemoteProcedure
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
init|=
name|procedureExecutor
operator|.
name|getProcedure
argument_list|(
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|procedure
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
assert|assert
name|procedure
operator|instanceof
name|RemoteProcedure
assert|;
return|return
operator|(
name|RemoteProcedure
argument_list|<
name|MasterProcedureEnv
argument_list|,
name|?
argument_list|>
operator|)
name|procedure
return|;
block|}
specifier|public
name|void
name|remoteProcedureCompleted
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|RemoteProcedure
argument_list|<
name|MasterProcedureEnv
argument_list|,
name|?
argument_list|>
name|procedure
init|=
name|getRemoteProcedure
argument_list|(
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|procedure
operator|!=
literal|null
condition|)
block|{
name|procedure
operator|.
name|remoteOperationCompleted
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|remoteProcedureFailed
parameter_list|(
name|long
name|procId
parameter_list|,
name|RemoteProcedureException
name|error
parameter_list|)
block|{
name|RemoteProcedure
argument_list|<
name|MasterProcedureEnv
argument_list|,
name|?
argument_list|>
name|procedure
init|=
name|getRemoteProcedure
argument_list|(
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|procedure
operator|!=
literal|null
condition|)
block|{
name|procedure
operator|.
name|remoteOperationFailed
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ReplicationPeerManager
name|getReplicationPeerManager
parameter_list|()
block|{
return|return
name|replicationPeerManager
return|;
block|}
comment|/**    * This method modifies the master's configuration in order to inject replication-related features    */
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
name|void
name|decorateMasterConfiguration
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|plugins
init|=
name|conf
operator|.
name|get
argument_list|(
name|HBASE_MASTER_LOGCLEANER_PLUGINS
argument_list|)
decl_stmt|;
name|String
name|cleanerClass
init|=
name|ReplicationLogCleaner
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|plugins
operator|.
name|contains
argument_list|(
name|cleanerClass
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|HBASE_MASTER_LOGCLEANER_PLUGINS
argument_list|,
name|plugins
operator|+
literal|","
operator|+
name|cleanerClass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ReplicationUtils
operator|.
name|isReplicationForBulkLoadDataEnabled
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|plugins
operator|=
name|conf
operator|.
name|get
argument_list|(
name|HFileCleaner
operator|.
name|MASTER_HFILE_CLEANER_PLUGINS
argument_list|)
expr_stmt|;
name|cleanerClass
operator|=
name|ReplicationHFileCleaner
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|plugins
operator|.
name|contains
argument_list|(
name|cleanerClass
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|HFileCleaner
operator|.
name|MASTER_HFILE_CLEANER_PLUGINS
argument_list|,
name|plugins
operator|+
literal|","
operator|+
name|cleanerClass
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

