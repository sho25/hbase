begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServlet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletRequest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CoordinatedStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CoordinatedStateManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaTableAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NamespaceDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NamespaceNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|PleaseHoldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableDescriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotDisabledException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitorBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|CoprocessorHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RequestContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|ServerNotRunningYetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterRpcServices
operator|.
name|BalanceSwitchMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|BalancerChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|BaseLoadBalancer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|ClusterStatusChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|LoadBalancerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|HFileCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|LogCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|CreateTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|DeleteTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|DisableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|DispatchMergingRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|EnableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|ModifyTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TableAddFamilyHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TableDeleteFamilyHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TableModifyFamilyHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TruncateTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|snapshot
operator|.
name|SnapshotManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MemoryBoundedLogMessageBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MonitoredTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|TaskMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure
operator|.
name|MasterProcedureManagerHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure
operator|.
name|flush
operator|.
name|MasterFlushTableProcedureManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|RegionServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ZooKeeperProtos
operator|.
name|SplitLogTask
operator|.
name|RecoveryMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|MasterQuotaManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegionServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RSRpcServices
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionCoprocessorHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionSplitPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|regionserver
operator|.
name|Replication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|UserProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Addressing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CompressionTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EncryptionTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HFileArchiveUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HasThread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ZKDataMigrator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|DrainingServerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|LoadBalancerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MasterAddressTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MetaTableLocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RegionServerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKClusterId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mortbay
operator|.
name|jetty
operator|.
name|Connector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mortbay
operator|.
name|jetty
operator|.
name|nio
operator|.
name|SelectChannelConnector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mortbay
operator|.
name|jetty
operator|.
name|servlet
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Service
import|;
end_import

begin_comment
comment|/**  * HMaster is the "master server" for HBase. An HBase cluster has one active  * master.  If many masters are started, all compete.  Whichever wins goes on to  * run the cluster.  All others park themselves in their constructor until  * master or cluster shutdown or until the active master loses its lease in  * zookeeper.  Thereafter, all running master jostle to take over master role.  *  *<p>The Master can be asked shutdown the cluster. See {@link #shutdown()}.  In  * this case it will tell all regionservers to go down and then wait on them  * all reporting in that they are down.  This master will then shut itself down.  *  *<p>You can also shutdown just this master.  Call {@link #stopMaster()}.  *  * @see org.apache.zookeeper.Watcher  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
class|class
name|HMaster
extends|extends
name|HRegionServer
implements|implements
name|MasterServices
implements|,
name|Server
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HMaster
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Protection against zombie master. Started once Master accepts active responsibility and    * starts taking over responsibilities. Allows a finite time window before giving up ownership.    */
specifier|private
specifier|static
class|class
name|InitializationMonitor
extends|extends
name|HasThread
block|{
comment|/** The amount of time in milliseconds to sleep before checking initialization status. */
specifier|public
specifier|static
specifier|final
name|String
name|TIMEOUT_KEY
init|=
literal|"hbase.master.initializationmonitor.timeout"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|TIMEOUT_DEFAULT
init|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
literal|15
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
decl_stmt|;
comment|/**      * When timeout expired and initialization has not complete, call {@link System#exit(int)} when      * true, do nothing otherwise.      */
specifier|public
specifier|static
specifier|final
name|String
name|HALT_KEY
init|=
literal|"hbase.master.initializationmonitor.haltontimeout"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|HALT_DEFAULT
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|HMaster
name|master
decl_stmt|;
specifier|private
specifier|final
name|long
name|timeout
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|haltOnTimeout
decl_stmt|;
comment|/** Creates a Thread that monitors the {@link #isInitialized()} state. */
name|InitializationMonitor
parameter_list|(
name|HMaster
name|master
parameter_list|)
block|{
name|super
argument_list|(
literal|"MasterInitializationMonitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|TIMEOUT_KEY
argument_list|,
name|TIMEOUT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|haltOnTimeout
operator|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|HALT_KEY
argument_list|,
name|HALT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
operator|!
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
name|master
operator|.
name|isActiveMaster
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|master
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initialization completed within allotted tolerance. Monitor exiting."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Master failed to complete initialization after "
operator|+
name|timeout
operator|+
literal|"ms. Please"
operator|+
literal|" consider submitting a bug report including a thread dump of this process."
argument_list|)
expr_stmt|;
if|if
condition|(
name|haltOnTimeout
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Zombie Master exiting. Thread dump to stdout"
argument_list|)
expr_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
operator|.
name|printThreadInfo
argument_list|(
operator|new
name|PrintWriter
argument_list|(
name|System
operator|.
name|out
argument_list|)
argument_list|,
literal|"Zombie HMaster"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"InitMonitor thread interrupted. Existing."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// MASTER is name of the webapp and the attribute name used stuffing this
comment|//instance into web context.
specifier|public
specifier|static
specifier|final
name|String
name|MASTER
init|=
literal|"master"
decl_stmt|;
comment|// Manager and zk listener for master election
specifier|private
name|ActiveMasterManager
name|activeMasterManager
decl_stmt|;
comment|// Region server tracker
name|RegionServerTracker
name|regionServerTracker
decl_stmt|;
comment|// Draining region server tracker
specifier|private
name|DrainingServerTracker
name|drainingServerTracker
decl_stmt|;
comment|// Tracker for load balancer state
name|LoadBalancerTracker
name|loadBalancerTracker
decl_stmt|;
comment|/** Namespace stuff */
specifier|private
name|TableNamespaceManager
name|tableNamespaceManager
decl_stmt|;
comment|// Metrics for the HMaster
specifier|final
name|MetricsMaster
name|metricsMaster
decl_stmt|;
comment|// file system manager for the master FS operations
specifier|private
name|MasterFileSystem
name|fileSystemManager
decl_stmt|;
comment|// server manager to deal with region server info
specifier|volatile
name|ServerManager
name|serverManager
decl_stmt|;
comment|// manager of assignment nodes in zookeeper
name|AssignmentManager
name|assignmentManager
decl_stmt|;
comment|// buffer for "fatal error" notices from region servers
comment|// in the cluster. This is only used for assisting
comment|// operations/debugging.
name|MemoryBoundedLogMessageBuffer
name|rsFatals
decl_stmt|;
comment|// flag set after we become the active master (used for testing)
specifier|private
specifier|volatile
name|boolean
name|isActiveMaster
init|=
literal|false
decl_stmt|;
comment|// flag set after we complete initialization once active,
comment|// it is not private since it's used in unit tests
specifier|volatile
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
comment|// flag set after master services are started,
comment|// initialization may have not completed yet.
specifier|volatile
name|boolean
name|serviceStarted
init|=
literal|false
decl_stmt|;
comment|// flag set after we complete assignMeta.
specifier|private
specifier|volatile
name|boolean
name|serverShutdownHandlerEnabled
init|=
literal|false
decl_stmt|;
name|LoadBalancer
name|balancer
decl_stmt|;
specifier|private
name|BalancerChore
name|balancerChore
decl_stmt|;
specifier|private
name|ClusterStatusChore
name|clusterStatusChore
decl_stmt|;
specifier|private
name|ClusterStatusPublisher
name|clusterStatusPublisherChore
init|=
literal|null
decl_stmt|;
name|CatalogJanitor
name|catalogJanitorChore
decl_stmt|;
specifier|private
name|LogCleaner
name|logCleaner
decl_stmt|;
specifier|private
name|HFileCleaner
name|hfileCleaner
decl_stmt|;
name|MasterCoprocessorHost
name|cpHost
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|preLoadTableDescriptors
decl_stmt|;
comment|// Time stamps for when a hmaster became active
specifier|private
name|long
name|masterActiveTime
decl_stmt|;
comment|//should we check the compression codec type at master side, default true, HBASE-6370
specifier|private
specifier|final
name|boolean
name|masterCheckCompression
decl_stmt|;
comment|//should we check encryption settings at master side, default true
specifier|private
specifier|final
name|boolean
name|masterCheckEncryption
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Service
argument_list|>
name|coprocessorServiceHandlers
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
comment|// monitor for snapshot of hbase tables
name|SnapshotManager
name|snapshotManager
decl_stmt|;
comment|// monitor for distributed procedures
name|MasterProcedureManagerHost
name|mpmHost
decl_stmt|;
specifier|private
name|MasterQuotaManager
name|quotaManager
decl_stmt|;
comment|// handle table states
specifier|private
name|TableStateManager
name|tableStateManager
decl_stmt|;
comment|/** flag used in test cases in order to simulate RS failures during master initialization */
specifier|private
specifier|volatile
name|boolean
name|initializationBeforeMetaAssignment
init|=
literal|false
decl_stmt|;
comment|/** jetty server for master to redirect requests to regionserver infoServer */
specifier|private
name|org
operator|.
name|mortbay
operator|.
name|jetty
operator|.
name|Server
name|masterJettyServer
decl_stmt|;
specifier|private
name|int
name|masterInfoPort
decl_stmt|;
specifier|public
specifier|static
class|class
name|RedirectServlet
extends|extends
name|HttpServlet
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2894774810058302472L
decl_stmt|;
specifier|private
specifier|static
name|int
name|regionServerInfoPort
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|doGet
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|)
throws|throws
name|ServletException
throws|,
name|IOException
block|{
name|String
name|redirectUrl
init|=
name|request
operator|.
name|getScheme
argument_list|()
operator|+
literal|"://"
operator|+
name|request
operator|.
name|getServerName
argument_list|()
operator|+
literal|":"
operator|+
name|regionServerInfoPort
operator|+
name|request
operator|.
name|getRequestURI
argument_list|()
decl_stmt|;
name|response
operator|.
name|sendRedirect
argument_list|(
name|redirectUrl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Initializes the HMaster. The steps are as follows:    *<p>    *<ol>    *<li>Initialize the local HRegionServer    *<li>Start the ActiveMasterManager.    *</ol>    *<p>    * Remaining steps of initialization occur in    * #finishActiveMasterInitialization(MonitoredTask) after    * the master becomes the active one.    *    * @throws KeeperException    * @throws IOException    */
specifier|public
name|HMaster
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
name|CoordinatedStateManager
name|csm
parameter_list|)
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|csm
argument_list|)
expr_stmt|;
name|this
operator|.
name|rsFatals
operator|=
operator|new
name|MemoryBoundedLogMessageBuffer
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.master.buffer.for.rs.fatals"
argument_list|,
literal|1
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"hbase.rootdir="
operator|+
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|this
operator|.
name|conf
argument_list|)
operator|+
literal|", hbase.cluster.distributed="
operator|+
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|CLUSTER_DISTRIBUTED
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|Replication
operator|.
name|decorateMasterConfiguration
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// Hack! Maps DFSClient => Master for logs.  HDFS made this
comment|// config param for task trackers, but we can piggyback off of it.
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"mapreduce.task.attempt.id"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"mapreduce.task.attempt.id"
argument_list|,
literal|"hb_m_"
operator|+
name|this
operator|.
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// should we check the compression codec type at master side, default true, HBASE-6370
name|this
operator|.
name|masterCheckCompression
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.check.compression"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// should we check encryption settings at master side, default true
name|this
operator|.
name|masterCheckEncryption
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.check.encryption"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|metricsMaster
operator|=
operator|new
name|MetricsMaster
argument_list|(
operator|new
name|MetricsMasterWrapperImpl
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|// preload table descriptor at startup
name|this
operator|.
name|preLoadTableDescriptors
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.preload.tabledescriptors"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Do we publish the status?
name|boolean
name|shouldPublish
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|STATUS_PUBLISHED
argument_list|,
name|HConstants
operator|.
name|STATUS_PUBLISHED_DEFAULT
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|ClusterStatusPublisher
operator|.
name|Publisher
argument_list|>
name|publisherClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|ClusterStatusPublisher
operator|.
name|STATUS_PUBLISHER_CLASS
argument_list|,
name|ClusterStatusPublisher
operator|.
name|DEFAULT_STATUS_PUBLISHER_CLASS
argument_list|,
name|ClusterStatusPublisher
operator|.
name|Publisher
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldPublish
condition|)
block|{
if|if
condition|(
name|publisherClass
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|HConstants
operator|.
name|STATUS_PUBLISHED
operator|+
literal|" is true, but "
operator|+
name|ClusterStatusPublisher
operator|.
name|DEFAULT_STATUS_PUBLISHER_CLASS
operator|+
literal|" is not set - not publishing status"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clusterStatusPublisherChore
operator|=
operator|new
name|ClusterStatusPublisher
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|publisherClass
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|clusterStatusPublisherChore
operator|.
name|getThread
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|startActiveMasterManager
argument_list|()
expr_stmt|;
name|putUpJettyServer
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|putUpJettyServer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.infoserver.redirect"
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return;
block|}
name|int
name|infoPort
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.info.port.orig"
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_INFOPORT
argument_list|)
decl_stmt|;
comment|// -1 is for disabling info server, so no redirecting
if|if
condition|(
name|infoPort
operator|<
literal|0
operator|||
name|infoServer
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|String
name|addr
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.master.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Addressing
operator|.
name|isLocalAddress
argument_list|(
name|InetAddress
operator|.
name|getByName
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Failed to start redirecting jetty server. Address "
operator|+
name|addr
operator|+
literal|" does not belong to this host. Correct configuration parameter: "
operator|+
literal|"hbase.master.info.bindAddress"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|RedirectServlet
operator|.
name|regionServerInfoPort
operator|=
name|infoServer
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|masterJettyServer
operator|=
operator|new
name|org
operator|.
name|mortbay
operator|.
name|jetty
operator|.
name|Server
argument_list|()
expr_stmt|;
name|Connector
name|connector
init|=
operator|new
name|SelectChannelConnector
argument_list|()
decl_stmt|;
name|connector
operator|.
name|setHost
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|connector
operator|.
name|setPort
argument_list|(
name|infoPort
argument_list|)
expr_stmt|;
name|masterJettyServer
operator|.
name|addConnector
argument_list|(
name|connector
argument_list|)
expr_stmt|;
name|masterJettyServer
operator|.
name|setStopAtShutdown
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Context
name|context
init|=
operator|new
name|Context
argument_list|(
name|masterJettyServer
argument_list|,
literal|"/"
argument_list|,
name|Context
operator|.
name|NO_SESSIONS
argument_list|)
decl_stmt|;
name|context
operator|.
name|addServlet
argument_list|(
name|RedirectServlet
operator|.
name|class
argument_list|,
literal|"/*"
argument_list|)
expr_stmt|;
try|try
block|{
name|masterJettyServer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to start redirecting jetty server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|masterInfoPort
operator|=
name|connector
operator|.
name|getPort
argument_list|()
expr_stmt|;
block|}
comment|/**    * For compatibility, if failed with regionserver credentials, try the master one    */
specifier|protected
name|void
name|login
parameter_list|(
name|UserProvider
name|user
parameter_list|,
name|String
name|host
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|super
operator|.
name|login
argument_list|(
name|user
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|user
operator|.
name|login
argument_list|(
literal|"hbase.master.keytab.file"
argument_list|,
literal|"hbase.master.kerberos.principal"
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * If configured to put regions on active master,    * wait till a backup master becomes active.    * Otherwise, loop till the server is stopped or aborted.    */
specifier|protected
name|void
name|waitForMasterActive
parameter_list|()
block|{
name|boolean
name|tablesOnMaster
init|=
name|BaseLoadBalancer
operator|.
name|tablesOnMaster
argument_list|(
name|conf
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|tablesOnMaster
operator|&&
name|isActiveMaster
operator|)
operator|&&
operator|!
name|isStopped
argument_list|()
operator|&&
operator|!
name|isAborted
argument_list|()
condition|)
block|{
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|MasterRpcServices
name|getMasterRpcServices
parameter_list|()
block|{
return|return
operator|(
name|MasterRpcServices
operator|)
name|rpcServices
return|;
block|}
specifier|public
name|boolean
name|balanceSwitch
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getMasterRpcServices
argument_list|()
operator|.
name|switchBalancer
argument_list|(
name|b
argument_list|,
name|BalanceSwitchMode
operator|.
name|ASYNC
argument_list|)
return|;
block|}
specifier|protected
name|String
name|getProcessName
parameter_list|()
block|{
return|return
name|MASTER
return|;
block|}
specifier|protected
name|boolean
name|canCreateBaseZNode
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|protected
name|boolean
name|canUpdateTableDescriptor
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|protected
name|RSRpcServices
name|createRpcServices
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|MasterRpcServices
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|protected
name|void
name|configureInfoServer
parameter_list|()
block|{
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|"master-status"
argument_list|,
literal|"/master-status"
argument_list|,
name|MasterStatusServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
name|MASTER
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|BaseLoadBalancer
operator|.
name|tablesOnMaster
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|super
operator|.
name|configureInfoServer
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
name|Class
argument_list|<
name|?
extends|extends
name|HttpServlet
argument_list|>
name|getDumpServlet
parameter_list|()
block|{
return|return
name|MasterDumpServlet
operator|.
name|class
return|;
block|}
comment|/**    * Emit the HMaster metrics, such as region in transition metrics.    * Surrounding in a try block just to be sure metrics doesn't abort HMaster.    */
specifier|protected
name|void
name|doMetrics
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|assignmentManager
operator|!=
literal|null
condition|)
block|{
name|assignmentManager
operator|.
name|updateRegionsInTransitionMetrics
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Couldn't update metrics: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|MetricsMaster
name|getMasterMetrics
parameter_list|()
block|{
return|return
name|metricsMaster
return|;
block|}
comment|/**    * Initialize all ZK based system trackers.    * @throws IOException    * @throws InterruptedException    * @throws KeeperException    * @throws CoordinatedStateException    */
name|void
name|initializeZKBasedSystemTrackers
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
throws|,
name|CoordinatedStateException
block|{
name|this
operator|.
name|balancer
operator|=
name|LoadBalancerFactory
operator|.
name|getLoadBalancer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadBalancerTracker
operator|=
operator|new
name|LoadBalancerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadBalancerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|=
operator|new
name|AssignmentManager
argument_list|(
name|this
argument_list|,
name|serverManager
argument_list|,
name|this
operator|.
name|balancer
argument_list|,
name|this
operator|.
name|service
argument_list|,
name|this
operator|.
name|metricsMaster
argument_list|,
name|this
operator|.
name|tableLockManager
argument_list|,
name|tableStateManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServerTracker
operator|=
operator|new
name|RegionServerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|serverManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|drainingServerTracker
operator|=
operator|new
name|DrainingServerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|serverManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|drainingServerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Set the cluster as up.  If new RSs, they'll be waiting on this before
comment|// going ahead with their startup.
name|boolean
name|wasUp
init|=
name|this
operator|.
name|clusterStatusTracker
operator|.
name|isClusterUp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|wasUp
condition|)
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterUp
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Server active/primary master="
operator|+
name|this
operator|.
name|serverName
operator|+
literal|", sessionid=0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getSessionId
argument_list|()
argument_list|)
operator|+
literal|", setting cluster-up flag (Was="
operator|+
name|wasUp
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// create/initialize the snapshot manager and other procedure managers
name|this
operator|.
name|snapshotManager
operator|=
operator|new
name|SnapshotManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|=
operator|new
name|MasterProcedureManagerHost
argument_list|()
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|register
argument_list|(
name|this
operator|.
name|snapshotManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|register
argument_list|(
operator|new
name|MasterFlushTableProcedureManager
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|loadProcedures
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|initialize
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|metricsMaster
argument_list|)
expr_stmt|;
comment|// migrating existent table state from zk
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|TableName
argument_list|,
name|TableState
operator|.
name|State
argument_list|>
name|entry
range|:
name|ZKDataMigrator
operator|.
name|queryForTableStates
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Converting state from zk to new states:"
operator|+
name|entry
argument_list|)
expr_stmt|;
name|tableStateManager
operator|.
name|setTableState
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ZKUtil
operator|.
name|deleteChildrenRecursively
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|getZooKeeper
argument_list|()
operator|.
name|tableZNode
argument_list|)
expr_stmt|;
block|}
comment|/**    * Finish initialization of HMaster after becoming the primary master.    *    *<ol>    *<li>Initialize master components - file system manager, server manager,    *     assignment manager, region server tracker, etc</li>    *<li>Start necessary service threads - balancer, catalog janior,    *     executor services, etc</li>    *<li>Set cluster as UP in ZooKeeper</li>    *<li>Wait for RegionServers to check-in</li>    *<li>Split logs and perform data recovery, if necessary</li>    *<li>Ensure assignment of meta/namespace regions<li>    *<li>Handle either fresh cluster start or master failover</li>    *</ol>    *    * @throws IOException    * @throws InterruptedException    * @throws KeeperException    * @throws CoordinatedStateException    */
specifier|private
name|void
name|finishActiveMasterInitialization
parameter_list|(
name|MonitoredTask
name|status
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
throws|,
name|CoordinatedStateException
block|{
name|isActiveMaster
operator|=
literal|true
expr_stmt|;
name|Thread
name|zombieDetector
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|InitializationMonitor
argument_list|(
name|this
argument_list|)
argument_list|)
decl_stmt|;
name|zombieDetector
operator|.
name|start
argument_list|()
expr_stmt|;
comment|/*      * We are active master now... go initialize components we need to run.      * Note, there may be dross in zk from previous runs; it'll get addressed      * below after we determine if cluster startup or failover.      */
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing Master file system"
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterActiveTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// TODO: Do this using Dependency Injection, using PicoContainer, Guice or Spring.
name|this
operator|.
name|fileSystemManager
operator|=
operator|new
name|MasterFileSystem
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// enable table descriptors cache
name|this
operator|.
name|tableDescriptors
operator|.
name|setCacheOn
argument_list|()
expr_stmt|;
comment|// warm-up HTDs cache on master initialization
if|if
condition|(
name|preLoadTableDescriptors
condition|)
block|{
name|status
operator|.
name|setStatus
argument_list|(
literal|"Pre-loading table descriptors"
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableDescriptors
operator|.
name|getAll
argument_list|()
expr_stmt|;
block|}
comment|// publish cluster ID
name|status
operator|.
name|setStatus
argument_list|(
literal|"Publishing Cluster ID in ZooKeeper"
argument_list|)
expr_stmt|;
name|ZKClusterId
operator|.
name|setClusterId
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|fileSystemManager
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
name|createServerManager
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|setupClusterConnection
argument_list|()
expr_stmt|;
comment|// Invalidate all write locks held previously
name|this
operator|.
name|tableLockManager
operator|.
name|reapWriteLocks
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableStateManager
operator|=
operator|new
name|TableStateManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableStateManager
operator|.
name|start
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing ZK system trackers"
argument_list|)
expr_stmt|;
name|initializeZKBasedSystemTrackers
argument_list|()
expr_stmt|;
comment|// initialize master side coprocessors before we start handling requests
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing master coprocessors"
argument_list|)
expr_stmt|;
name|this
operator|.
name|cpHost
operator|=
operator|new
name|MasterCoprocessorHost
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// start up all service threads.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing master service threads"
argument_list|)
expr_stmt|;
name|startServiceThreads
argument_list|()
expr_stmt|;
comment|// Wake up this server to check in
name|sleeper
operator|.
name|skipSleepCycle
argument_list|()
expr_stmt|;
comment|// Wait for region servers to report in
name|this
operator|.
name|serverManager
operator|.
name|waitForRegionServers
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// Check zk for region servers that are up but didn't register
for|for
control|(
name|ServerName
name|sn
range|:
name|this
operator|.
name|regionServerTracker
operator|.
name|getOnlineServers
argument_list|()
control|)
block|{
comment|// The isServerOnline check is opportunistic, correctness is handled inside
if|if
condition|(
operator|!
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
operator|&&
name|serverManager
operator|.
name|checkAndRecordNewServer
argument_list|(
name|sn
argument_list|,
name|ServerLoad
operator|.
name|EMPTY_SERVERLOAD
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Registered server found up in zk but who has not yet reported in: "
operator|+
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
comment|// get a list for previously failed RS which need log splitting work
comment|// we recover hbase:meta region servers inside master initialization and
comment|// handle other failed servers in SSH in order to start up master node ASAP
name|Set
argument_list|<
name|ServerName
argument_list|>
name|previouslyFailedServers
init|=
name|this
operator|.
name|fileSystemManager
operator|.
name|getFailedServersFromLogFolders
argument_list|()
decl_stmt|;
comment|// remove stale recovering regions from previous run
name|this
operator|.
name|fileSystemManager
operator|.
name|removeStaleRecoveringRegionsFromZK
argument_list|(
name|previouslyFailedServers
argument_list|)
expr_stmt|;
comment|// log splitting for hbase:meta server
name|ServerName
name|oldMetaServerLocation
init|=
name|metaTableLocator
operator|.
name|getMetaRegionLocation
argument_list|(
name|this
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldMetaServerLocation
operator|!=
literal|null
operator|&&
name|previouslyFailedServers
operator|.
name|contains
argument_list|(
name|oldMetaServerLocation
argument_list|)
condition|)
block|{
name|splitMetaLogBeforeAssignment
argument_list|(
name|oldMetaServerLocation
argument_list|)
expr_stmt|;
comment|// Note: we can't remove oldMetaServerLocation from previousFailedServers list because it
comment|// may also host user regions
block|}
name|Set
argument_list|<
name|ServerName
argument_list|>
name|previouslyFailedMetaRSs
init|=
name|getPreviouselyFailedMetaServersFromZK
argument_list|()
decl_stmt|;
comment|// need to use union of previouslyFailedMetaRSs recorded in ZK and previouslyFailedServers
comment|// instead of previouslyFailedMetaRSs alone to address the following two situations:
comment|// 1) the chained failure situation(recovery failed multiple times in a row).
comment|// 2) master get killed right before it could delete the recovering hbase:meta from ZK while the
comment|// same server still has non-meta wals to be replayed so that
comment|// removeStaleRecoveringRegionsFromZK can't delete the stale hbase:meta region
comment|// Passing more servers into splitMetaLog is all right. If a server doesn't have hbase:meta wal,
comment|// there is no op for the server.
name|previouslyFailedMetaRSs
operator|.
name|addAll
argument_list|(
name|previouslyFailedServers
argument_list|)
expr_stmt|;
name|this
operator|.
name|initializationBeforeMetaAssignment
operator|=
literal|true
expr_stmt|;
comment|// Wait for regionserver to finish initialization.
if|if
condition|(
name|BaseLoadBalancer
operator|.
name|tablesOnMaster
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|waitForServerOnline
argument_list|()
expr_stmt|;
block|}
comment|//initialize load balancer
name|this
operator|.
name|balancer
operator|.
name|setClusterStatus
argument_list|(
name|getClusterStatus
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|.
name|setMasterServices
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|.
name|initialize
argument_list|()
expr_stmt|;
comment|// Check if master is shutting down because of some issue
comment|// in initializing the regionserver or the balancer.
if|if
condition|(
name|isStopped
argument_list|()
condition|)
return|return;
comment|// Make sure meta assigned before proceeding.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Assigning Meta Region"
argument_list|)
expr_stmt|;
name|assignMeta
argument_list|(
name|status
argument_list|,
name|previouslyFailedMetaRSs
argument_list|)
expr_stmt|;
comment|// check if master is shutting down because above assignMeta could return even hbase:meta isn't
comment|// assigned when master is shutting down
if|if
condition|(
name|isStopped
argument_list|()
condition|)
return|return;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Submitting log splitting work for previously failed region servers"
argument_list|)
expr_stmt|;
comment|// Master has recovered hbase:meta region server and we put
comment|// other failed region servers in a queue to be handled later by SSH
for|for
control|(
name|ServerName
name|tmpServer
range|:
name|previouslyFailedServers
control|)
block|{
name|this
operator|.
name|serverManager
operator|.
name|processDeadServer
argument_list|(
name|tmpServer
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Fix up assignment manager status
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting assignment manager"
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|joinCluster
argument_list|()
expr_stmt|;
comment|//set cluster status again after user regions are assigned
name|this
operator|.
name|balancer
operator|.
name|setClusterStatus
argument_list|(
name|getClusterStatus
argument_list|()
argument_list|)
expr_stmt|;
comment|// Start balancer and meta catalog janitor after meta and regions have
comment|// been assigned.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting balancer and catalog janitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterStatusChore
operator|=
operator|new
name|ClusterStatusChore
argument_list|(
name|this
argument_list|,
name|balancer
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|clusterStatusChore
operator|.
name|getThread
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancerChore
operator|=
operator|new
name|BalancerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|balancerChore
operator|.
name|getThread
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|catalogJanitorChore
operator|=
operator|new
name|CatalogJanitor
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|catalogJanitorChore
operator|.
name|getThread
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting namespace manager"
argument_list|)
expr_stmt|;
name|initNamespace
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting quota manager"
argument_list|)
expr_stmt|;
name|initQuotaManager
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|preMasterInitialization
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor preMasterInitialization() hook failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|status
operator|.
name|markComplete
argument_list|(
literal|"Initialization successful"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Master has completed initialization"
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
operator|.
name|balancer
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|true
expr_stmt|;
comment|// clear the dead servers with same host name and port of online server because we are not
comment|// removing dead server with same hostname and port of rs which is trying to check in before
comment|// master initialization. See HBASE-5916.
name|this
operator|.
name|serverManager
operator|.
name|clearDeadServersWithSameHostNameAndPortOfOnlineServer
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
comment|// don't let cp initialization errors kill the master
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|postStartMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor postStartMaster() hook failed"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
name|zombieDetector
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|/**    * Create a {@link ServerManager} instance.    * @param master    * @param services    * @return An instance of {@link ServerManager}    * @throws org.apache.hadoop.hbase.ZooKeeperConnectionException    * @throws IOException    */
name|ServerManager
name|createServerManager
parameter_list|(
specifier|final
name|Server
name|master
parameter_list|,
specifier|final
name|MasterServices
name|services
parameter_list|)
throws|throws
name|IOException
block|{
comment|// We put this out here in a method so can do a Mockito.spy and stub it out
comment|// w/ a mocked up ServerManager.
return|return
operator|new
name|ServerManager
argument_list|(
name|master
argument_list|,
name|services
argument_list|)
return|;
block|}
comment|/**    * Check<code>hbase:meta</code> is assigned. If not, assign it.    * @param status MonitoredTask    * @param previouslyFailedMetaRSs    * @throws InterruptedException    * @throws IOException    * @throws KeeperException    */
name|void
name|assignMeta
parameter_list|(
name|MonitoredTask
name|status
parameter_list|,
name|Set
argument_list|<
name|ServerName
argument_list|>
name|previouslyFailedMetaRSs
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
throws|,
name|KeeperException
block|{
comment|// Work on meta region
name|int
name|assigned
init|=
literal|0
decl_stmt|;
name|long
name|timeout
init|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.catalog.verification.timeout"
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Assigning hbase:meta region"
argument_list|)
expr_stmt|;
comment|// Get current meta state from zk.
name|RegionState
name|metaState
init|=
name|MetaTableLocator
operator|.
name|getMetaRegionState
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|)
decl_stmt|;
name|RegionStates
name|regionStates
init|=
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
name|regionStates
operator|.
name|createRegionState
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|,
name|metaState
operator|.
name|getState
argument_list|()
argument_list|,
name|metaState
operator|.
name|getServerName
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|metaState
operator|.
name|isOpened
argument_list|()
operator|||
operator|!
name|metaTableLocator
operator|.
name|verifyMetaRegionLocation
argument_list|(
name|this
operator|.
name|getConnection
argument_list|()
argument_list|,
name|this
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
name|ServerName
name|currentMetaServer
init|=
name|metaState
operator|.
name|getServerName
argument_list|()
decl_stmt|;
if|if
condition|(
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|currentMetaServer
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Meta was in transition on "
operator|+
name|currentMetaServer
argument_list|)
expr_stmt|;
name|assignmentManager
operator|.
name|processRegionsInTransition
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|metaState
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currentMetaServer
operator|!=
literal|null
condition|)
block|{
name|splitMetaLogBeforeAssignment
argument_list|(
name|currentMetaServer
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|logSplit
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
expr_stmt|;
name|previouslyFailedMetaRSs
operator|.
name|add
argument_list|(
name|currentMetaServer
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Re-assigning hbase:meta, it was on "
operator|+
name|currentMetaServer
argument_list|)
expr_stmt|;
name|assignmentManager
operator|.
name|assignMeta
argument_list|()
expr_stmt|;
block|}
name|assigned
operator|++
expr_stmt|;
block|}
name|enableMeta
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|RecoveryMode
operator|.
name|LOG_REPLAY
operator|==
name|this
operator|.
name|getMasterFileSystem
argument_list|()
operator|.
name|getLogRecoveryMode
argument_list|()
operator|)
operator|&&
operator|(
operator|!
name|previouslyFailedMetaRSs
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
comment|// replay WAL edits mode need new hbase:meta RS is assigned firstly
name|status
operator|.
name|setStatus
argument_list|(
literal|"replaying log for Meta Region"
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileSystemManager
operator|.
name|splitMetaLog
argument_list|(
name|previouslyFailedMetaRSs
argument_list|)
expr_stmt|;
block|}
comment|// Make sure a hbase:meta location is set. We need to enable SSH here since
comment|// if the meta region server is died at this time, we need it to be re-assigned
comment|// by SSH so that system tables can be assigned.
comment|// No need to wait for meta is assigned = 0 when meta is just verified.
name|enableServerShutdownHandler
argument_list|(
name|assigned
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"hbase:meta assigned="
operator|+
name|assigned
operator|+
literal|", location="
operator|+
name|metaTableLocator
operator|.
name|getMetaRegionLocation
argument_list|(
name|this
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"META assigned."
argument_list|)
expr_stmt|;
block|}
name|void
name|initNamespace
parameter_list|()
throws|throws
name|IOException
block|{
comment|//create namespace manager
name|tableNamespaceManager
operator|=
operator|new
name|TableNamespaceManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|tableNamespaceManager
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|void
name|initQuotaManager
parameter_list|()
throws|throws
name|IOException
block|{
name|quotaManager
operator|=
operator|new
name|MasterQuotaManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|quotaManager
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|boolean
name|isCatalogJanitorEnabled
parameter_list|()
block|{
return|return
name|catalogJanitorChore
operator|!=
literal|null
condition|?
name|catalogJanitorChore
operator|.
name|getEnabled
argument_list|()
else|:
literal|false
return|;
block|}
specifier|private
name|void
name|splitMetaLogBeforeAssignment
parameter_list|(
name|ServerName
name|currentMetaServer
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|RecoveryMode
operator|.
name|LOG_REPLAY
operator|==
name|this
operator|.
name|getMasterFileSystem
argument_list|()
operator|.
name|getLogRecoveryMode
argument_list|()
condition|)
block|{
comment|// In log replay mode, we mark hbase:meta region as recovering in ZK
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
operator|new
name|HashSet
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|regions
operator|.
name|add
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileSystemManager
operator|.
name|prepareLogReplay
argument_list|(
name|currentMetaServer
argument_list|,
name|regions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// In recovered.edits mode: create recovered edits file for hbase:meta server
name|this
operator|.
name|fileSystemManager
operator|.
name|splitMetaLog
argument_list|(
name|currentMetaServer
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|enableServerShutdownHandler
parameter_list|(
specifier|final
name|boolean
name|waitForMeta
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// If ServerShutdownHandler is disabled, we enable it and expire those dead
comment|// but not expired servers. This is required so that if meta is assigning to
comment|// a server which dies after assignMeta starts assignment,
comment|// SSH can re-assign it. Otherwise, we will be
comment|// stuck here waiting forever if waitForMeta is specified.
if|if
condition|(
operator|!
name|serverShutdownHandlerEnabled
condition|)
block|{
name|serverShutdownHandlerEnabled
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|serverManager
operator|.
name|processQueuedDeadServers
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|waitForMeta
condition|)
block|{
name|metaTableLocator
operator|.
name|waitMetaRegionLocation
argument_list|(
name|this
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|enableMeta
parameter_list|(
name|TableName
name|metaTableName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|tableStateManager
operator|.
name|isTableState
argument_list|(
name|metaTableName
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|ENABLED
argument_list|)
condition|)
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|setEnabledTable
argument_list|(
name|metaTableName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This function returns a set of region server names under hbase:meta recovering region ZK node    * @return Set of meta server names which were recorded in ZK    * @throws KeeperException    */
specifier|private
name|Set
argument_list|<
name|ServerName
argument_list|>
name|getPreviouselyFailedMetaServersFromZK
parameter_list|()
throws|throws
name|KeeperException
block|{
name|Set
argument_list|<
name|ServerName
argument_list|>
name|result
init|=
operator|new
name|HashSet
argument_list|<
name|ServerName
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|metaRecoveringZNode
init|=
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|zooKeeper
operator|.
name|recoveringRegionsZNode
argument_list|,
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|regionFailedServers
init|=
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|zooKeeper
argument_list|,
name|metaRecoveringZNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionFailedServers
operator|==
literal|null
condition|)
return|return
name|result
return|;
for|for
control|(
name|String
name|failedServer
range|:
name|regionFailedServers
control|)
block|{
name|ServerName
name|server
init|=
name|ServerName
operator|.
name|parseServerName
argument_list|(
name|failedServer
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableDescriptors
name|getTableDescriptors
parameter_list|()
block|{
return|return
name|this
operator|.
name|tableDescriptors
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerManager
name|getServerManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterFileSystem
name|getMasterFileSystem
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileSystemManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableStateManager
name|getTableStateManager
parameter_list|()
block|{
return|return
name|tableStateManager
return|;
block|}
comment|/*    * Start up all services. If any of these threads gets an unhandled exception    * then they just die with a logged message.  This should be fine because    * in general, we do not expect the master to get such unhandled exceptions    *  as OOMEs; it should be lightly loaded. See what HRegionServer does if    *  need to install an unexpected exception handler.    */
specifier|private
name|void
name|startServiceThreads
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Start the executor service pools
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_OPEN_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.openregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_CLOSE_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.closeregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.serverops.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_META_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.serverops.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|M_LOG_REPLAY_OPS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.logreplayops.threads"
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|// We depend on there being only one instance of this executor running
comment|// at a time.  To do concurrency, would need fencing of enable/disable of
comment|// tables.
comment|// Any time changing this maxThreads to> 1, pls see the comment at
comment|// AccessController#postCreateTableHandler
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_TABLE_OPERATIONS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Start log cleaner thread
name|int
name|cleanerInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.cleaner.interval"
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
decl_stmt|;
name|this
operator|.
name|logCleaner
operator|=
operator|new
name|LogCleaner
argument_list|(
name|cleanerInterval
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|getMasterFileSystem
argument_list|()
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|getMasterFileSystem
argument_list|()
operator|.
name|getOldLogDir
argument_list|()
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|logCleaner
operator|.
name|getThread
argument_list|()
argument_list|,
name|getServerName
argument_list|()
operator|.
name|toShortString
argument_list|()
operator|+
literal|".oldLogCleaner"
argument_list|)
expr_stmt|;
comment|//start the hfile archive cleaner thread
name|Path
name|archiveDir
init|=
name|HFileArchiveUtil
operator|.
name|getArchivePath
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|hfileCleaner
operator|=
operator|new
name|HFileCleaner
argument_list|(
name|cleanerInterval
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|getMasterFileSystem
argument_list|()
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|archiveDir
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|hfileCleaner
operator|.
name|getThread
argument_list|()
argument_list|,
name|getServerName
argument_list|()
operator|.
name|toShortString
argument_list|()
operator|+
literal|".archivedHFileCleaner"
argument_list|)
expr_stmt|;
name|serviceStarted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Started service threads"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|stopServiceThreads
parameter_list|()
block|{
if|if
condition|(
name|masterJettyServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping master jetty server"
argument_list|)
expr_stmt|;
try|try
block|{
name|masterJettyServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to stop master jetty server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|super
operator|.
name|stopServiceThreads
argument_list|()
expr_stmt|;
name|stopChores
argument_list|()
expr_stmt|;
comment|// Wait for all the remaining region servers to report in IFF we were
comment|// running a cluster shutdown AND we were NOT aborting.
if|if
condition|(
operator|!
name|isAborted
argument_list|()
operator|&&
name|this
operator|.
name|serverManager
operator|!=
literal|null
operator|&&
name|this
operator|.
name|serverManager
operator|.
name|isClusterShutdown
argument_list|()
condition|)
block|{
name|this
operator|.
name|serverManager
operator|.
name|letRegionServersShutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopping service threads"
argument_list|)
expr_stmt|;
block|}
comment|// Clean up and close up shop
if|if
condition|(
name|this
operator|.
name|logCleaner
operator|!=
literal|null
condition|)
name|this
operator|.
name|logCleaner
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|hfileCleaner
operator|!=
literal|null
condition|)
name|this
operator|.
name|hfileCleaner
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|quotaManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|quotaManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|activeMasterManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|activeMasterManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|serverManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|serverManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|assignmentManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|fileSystemManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|fileSystemManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|mpmHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|mpmHost
operator|.
name|stop
argument_list|(
literal|"server shutting down."
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|stopChores
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|balancerChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|balancerChore
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|clusterStatusChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|clusterStatusChore
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|catalogJanitorChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|catalogJanitorChore
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|clusterStatusPublisherChore
operator|!=
literal|null
condition|)
block|{
name|clusterStatusPublisherChore
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @return Get remote side's InetAddress    * @throws UnknownHostException    */
name|InetAddress
name|getRemoteInetAddress
parameter_list|(
specifier|final
name|int
name|port
parameter_list|,
specifier|final
name|long
name|serverStartCode
parameter_list|)
throws|throws
name|UnknownHostException
block|{
comment|// Do it out here in its own little method so can fake an address when
comment|// mocking up in tests.
name|InetAddress
name|ia
init|=
name|RpcServer
operator|.
name|getRemoteIp
argument_list|()
decl_stmt|;
comment|// The call could be from the local regionserver,
comment|// in which case, there is no remote address.
if|if
condition|(
name|ia
operator|==
literal|null
operator|&&
name|serverStartCode
operator|==
name|startcode
condition|)
block|{
name|InetSocketAddress
name|isa
init|=
name|rpcServices
operator|.
name|getSocketAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|isa
operator|!=
literal|null
operator|&&
name|isa
operator|.
name|getPort
argument_list|()
operator|==
name|port
condition|)
block|{
name|ia
operator|=
name|isa
operator|.
name|getAddress
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|ia
return|;
block|}
comment|/**    * @return Maximum time we should run balancer for    */
specifier|private
name|int
name|getBalancerCutoffTime
parameter_list|()
block|{
name|int
name|balancerCutoffTime
init|=
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.balancer.max.balancing"
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|balancerCutoffTime
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No time period set so create one
name|int
name|balancerPeriod
init|=
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.balancer.period"
argument_list|,
literal|300000
argument_list|)
decl_stmt|;
name|balancerCutoffTime
operator|=
name|balancerPeriod
expr_stmt|;
comment|// If nonsense period, set it to balancerPeriod
if|if
condition|(
name|balancerCutoffTime
operator|<=
literal|0
condition|)
name|balancerCutoffTime
operator|=
name|balancerPeriod
expr_stmt|;
block|}
return|return
name|balancerCutoffTime
return|;
block|}
specifier|public
name|boolean
name|balance
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if master not initialized, don't run balancer.
if|if
condition|(
operator|!
name|this
operator|.
name|initialized
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Master has not been initialized, don't run balancer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Do this call outside of synchronized block.
name|int
name|maximumBalanceTime
init|=
name|getBalancerCutoffTime
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|balancer
init|)
block|{
comment|// If balance not true, don't run balancer.
if|if
condition|(
operator|!
name|this
operator|.
name|loadBalancerTracker
operator|.
name|isBalancerOn
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// Only allow one balance run at at time.
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|isRegionsInTransition
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|regionsInTransition
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionsInTransition
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not running balancer because "
operator|+
name|regionsInTransition
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) in transition: "
operator|+
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
operator|.
name|abbreviate
argument_list|(
name|regionsInTransition
operator|.
name|toString
argument_list|()
argument_list|,
literal|256
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|.
name|areDeadServersInProgress
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not running balancer because processing dead regionserver(s): "
operator|+
name|this
operator|.
name|serverManager
operator|.
name|getDeadServers
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|this
operator|.
name|cpHost
operator|.
name|preBalance
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Coprocessor bypassing balancer request"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error invoking master coprocessor preBalance()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|Map
argument_list|<
name|TableName
argument_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|>
name|assignmentsByTable
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getAssignmentsByTable
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|plans
init|=
operator|new
name|ArrayList
argument_list|<
name|RegionPlan
argument_list|>
argument_list|()
decl_stmt|;
comment|//Give the balancer the current cluster state.
name|this
operator|.
name|balancer
operator|.
name|setClusterStatus
argument_list|(
name|getClusterStatus
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|assignments
range|:
name|assignmentsByTable
operator|.
name|values
argument_list|()
control|)
block|{
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|partialPlans
init|=
name|this
operator|.
name|balancer
operator|.
name|balanceCluster
argument_list|(
name|assignments
argument_list|)
decl_stmt|;
if|if
condition|(
name|partialPlans
operator|!=
literal|null
condition|)
name|plans
operator|.
name|addAll
argument_list|(
name|partialPlans
argument_list|)
expr_stmt|;
block|}
name|long
name|cutoffTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|maximumBalanceTime
decl_stmt|;
name|int
name|rpCount
init|=
literal|0
decl_stmt|;
comment|// number of RegionPlans balanced so far
name|long
name|totalRegPlanExecTime
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|plans
operator|!=
literal|null
operator|&&
operator|!
name|plans
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|RegionPlan
name|plan
range|:
name|plans
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"balance "
operator|+
name|plan
argument_list|)
expr_stmt|;
name|long
name|balStartTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|//TODO: bulk assign
name|this
operator|.
name|assignmentManager
operator|.
name|balance
argument_list|(
name|plan
argument_list|)
expr_stmt|;
name|totalRegPlanExecTime
operator|+=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|balStartTime
expr_stmt|;
name|rpCount
operator|++
expr_stmt|;
if|if
condition|(
name|rpCount
operator|<
name|plans
operator|.
name|size
argument_list|()
operator|&&
comment|// if performing next balance exceeds cutoff time, exit the loop
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
operator|(
name|totalRegPlanExecTime
operator|/
name|rpCount
operator|)
operator|)
operator|>
name|cutoffTime
condition|)
block|{
comment|//TODO: After balance, there should not be a cutoff time (keeping it as a security net for now)
name|LOG
operator|.
name|debug
argument_list|(
literal|"No more balancing till next balance run; maximumBalanceTime="
operator|+
name|maximumBalanceTime
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|postBalance
argument_list|(
name|rpCount
operator|<
name|plans
operator|.
name|size
argument_list|()
condition|?
name|plans
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|rpCount
argument_list|)
else|:
name|plans
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// balancing already succeeded so don't change the result
name|LOG
operator|.
name|error
argument_list|(
literal|"Error invoking master coprocessor postBalance()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If LoadBalancer did not generate any plans, it means the cluster is already balanced.
comment|// Return true indicating a success.
return|return
literal|true
return|;
block|}
comment|/**    * @return Client info for use as prefix on an audit log string; who did an action    */
name|String
name|getClientIdAuditPrefix
parameter_list|()
block|{
return|return
literal|"Client="
operator|+
name|RequestContext
operator|.
name|getRequestUserName
argument_list|()
operator|+
literal|"/"
operator|+
name|RequestContext
operator|.
name|get
argument_list|()
operator|.
name|getRemoteAddress
argument_list|()
return|;
block|}
comment|/**    * Switch for the background CatalogJanitor thread.    * Used for testing.  The thread will continue to run.  It will just be a noop    * if disabled.    * @param b If false, the catalog janitor won't do anything.    */
specifier|public
name|void
name|setCatalogJanitorEnabled
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
block|{
name|this
operator|.
name|catalogJanitorChore
operator|.
name|setEnabled
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|dispatchMergingRegions
parameter_list|(
specifier|final
name|HRegionInfo
name|region_a
parameter_list|,
specifier|final
name|HRegionInfo
name|region_b
parameter_list|,
specifier|final
name|boolean
name|forcible
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
operator|new
name|DispatchMergingRegionHandler
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|catalogJanitorChore
argument_list|,
name|region_a
argument_list|,
name|region_b
argument_list|,
name|forcible
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|move
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|destServerName
parameter_list|)
throws|throws
name|HBaseIOException
block|{
name|RegionState
name|regionState
init|=
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionState
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionState
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
throw|;
block|}
name|HRegionInfo
name|hri
init|=
name|regionState
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|ServerName
name|dest
decl_stmt|;
if|if
condition|(
name|destServerName
operator|==
literal|null
operator|||
name|destServerName
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Passed destination servername is null/empty so "
operator|+
literal|"choosing a server at random"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|destServers
init|=
name|this
operator|.
name|serverManager
operator|.
name|createDestinationServersList
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
decl_stmt|;
name|dest
operator|=
name|balancer
operator|.
name|randomAssignment
argument_list|(
name|hri
argument_list|,
name|destServers
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to determine a plan to assign "
operator|+
name|hri
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|dest
operator|=
name|ServerName
operator|.
name|valueOf
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|destServerName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
operator|&&
name|balancer
operator|instanceof
name|BaseLoadBalancer
operator|&&
operator|!
operator|(
operator|(
name|BaseLoadBalancer
operator|)
name|balancer
operator|)
operator|.
name|shouldBeOnMaster
argument_list|(
name|hri
argument_list|)
condition|)
block|{
comment|// To avoid unnecessary region moving later by balancer. Don't put user
comment|// regions on master. Regions on master could be put on other region
comment|// server intentionally by test however.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping move of region "
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to avoid unnecessary region moving later by load balancer,"
operator|+
literal|" because it should not be on master"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|dest
operator|.
name|equals
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping move of region "
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" because region already assigned to the same server "
operator|+
name|dest
operator|+
literal|"."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Now we can do the move
name|RegionPlan
name|rp
init|=
operator|new
name|RegionPlan
argument_list|(
name|hri
argument_list|,
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|,
name|dest
argument_list|)
decl_stmt|;
try|try
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|cpHost
operator|.
name|preMove
argument_list|(
name|hri
argument_list|,
name|rp
operator|.
name|getSource
argument_list|()
argument_list|,
name|rp
operator|.
name|getDestination
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" move "
operator|+
name|rp
operator|+
literal|", running balancer"
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|balance
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cpHost
operator|.
name|postMove
argument_list|(
name|hri
argument_list|,
name|rp
operator|.
name|getSource
argument_list|()
argument_list|,
name|rp
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|ioe
operator|instanceof
name|HBaseIOException
condition|)
block|{
throw|throw
operator|(
name|HBaseIOException
operator|)
name|ioe
throw|;
block|}
throw|throw
operator|new
name|HBaseIOException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|hTableDescriptor
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isStopped
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
name|String
name|namespace
init|=
name|hTableDescriptor
operator|.
name|getTableName
argument_list|()
operator|.
name|getNamespaceAsString
argument_list|()
decl_stmt|;
name|ensureNamespaceExists
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
name|HRegionInfo
index|[]
name|newRegions
init|=
name|getHRegionInfos
argument_list|(
name|hTableDescriptor
argument_list|,
name|splitKeys
argument_list|)
decl_stmt|;
name|checkInitialized
argument_list|()
expr_stmt|;
name|sanityCheckTableDescriptor
argument_list|(
name|hTableDescriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preCreateTable
argument_list|(
name|hTableDescriptor
argument_list|,
name|newRegions
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" create "
operator|+
name|hTableDescriptor
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
operator|new
name|CreateTableHandler
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|fileSystemManager
argument_list|,
name|hTableDescriptor
argument_list|,
name|conf
argument_list|,
name|newRegions
argument_list|,
name|this
argument_list|)
operator|.
name|prepare
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postCreateTable
argument_list|(
name|hTableDescriptor
argument_list|,
name|newRegions
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Checks whether the table conforms to some sane limits, and configured    * values (compression, etc) work. Throws an exception if something is wrong.    * @throws IOException    */
specifier|private
name|void
name|sanityCheckTableDescriptor
parameter_list|(
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|CONF_KEY
init|=
literal|"hbase.table.sanity.checks"
decl_stmt|;
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|CONF_KEY
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return;
block|}
name|String
name|tableVal
init|=
name|htd
operator|.
name|getConfigurationValue
argument_list|(
name|CONF_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableVal
operator|!=
literal|null
operator|&&
operator|!
name|Boolean
operator|.
name|valueOf
argument_list|(
name|tableVal
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// check max file size
name|long
name|maxFileSizeLowerLimit
init|=
literal|2
operator|*
literal|1024
operator|*
literal|1024L
decl_stmt|;
comment|// 2M is the default lower limit
name|long
name|maxFileSize
init|=
name|htd
operator|.
name|getMaxFileSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxFileSize
operator|<
literal|0
condition|)
block|{
name|maxFileSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HREGION_MAX_FILESIZE
argument_list|,
name|maxFileSizeLowerLimit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxFileSize
operator|<
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.hregion.max.filesize.limit"
argument_list|,
name|maxFileSizeLowerLimit
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
literal|"MAX_FILESIZE for table descriptor or "
operator|+
literal|"\"hbase.hregion.max.filesize\" ("
operator|+
name|maxFileSize
operator|+
literal|") is too small, which might cause over splitting into unmanageable "
operator|+
literal|"number of regions. Set "
operator|+
name|CONF_KEY
operator|+
literal|" to false at conf or table descriptor "
operator|+
literal|"if you want to bypass sanity checks"
argument_list|)
throw|;
block|}
comment|// check flush size
name|long
name|flushSizeLowerLimit
init|=
literal|1024
operator|*
literal|1024L
decl_stmt|;
comment|// 1M is the default lower limit
name|long
name|flushSize
init|=
name|htd
operator|.
name|getMemStoreFlushSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|flushSize
operator|<
literal|0
condition|)
block|{
name|flushSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HREGION_MEMSTORE_FLUSH_SIZE
argument_list|,
name|flushSizeLowerLimit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flushSize
operator|<
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.hregion.memstore.flush.size.limit"
argument_list|,
name|flushSizeLowerLimit
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
literal|"MEMSTORE_FLUSHSIZE for table descriptor or "
operator|+
literal|"\"hbase.hregion.memstore.flush.size\" ("
operator|+
name|flushSize
operator|+
literal|") is too small, which might cause"
operator|+
literal|" very frequent flushing. Set "
operator|+
name|CONF_KEY
operator|+
literal|" to false at conf or table descriptor "
operator|+
literal|"if you want to bypass sanity checks"
argument_list|)
throw|;
block|}
comment|// check that coprocessors and other specified plugin classes can be loaded
try|try
block|{
name|checkClassLoading
argument_list|(
name|conf
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
comment|// check compression can be loaded
try|try
block|{
name|checkCompression
argument_list|(
name|htd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// check encryption can be loaded
try|try
block|{
name|checkEncryption
argument_list|(
name|conf
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// check that we have at least 1 CF
if|if
condition|(
name|htd
operator|.
name|getColumnFamilies
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
literal|"Table should have at least one column family "
operator|+
literal|"Set "
operator|+
name|CONF_KEY
operator|+
literal|" at conf or table descriptor if you want to bypass sanity checks"
argument_list|)
throw|;
block|}
for|for
control|(
name|HColumnDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
if|if
condition|(
name|hcd
operator|.
name|getTimeToLive
argument_list|()
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
literal|"TTL for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"  must be positive. Set "
operator|+
name|CONF_KEY
operator|+
literal|" to false at conf or table descriptor "
operator|+
literal|"if you want to bypass sanity checks"
argument_list|)
throw|;
block|}
comment|// check blockSize
if|if
condition|(
name|hcd
operator|.
name|getBlocksize
argument_list|()
operator|<
literal|1024
operator|||
name|hcd
operator|.
name|getBlocksize
argument_list|()
operator|>
literal|16
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
literal|"Block size for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"  must be between 1K and 16MB Set "
operator|+
name|CONF_KEY
operator|+
literal|" to false at conf or table descriptor "
operator|+
literal|"if you want to bypass sanity checks"
argument_list|)
throw|;
block|}
comment|// check versions
if|if
condition|(
name|hcd
operator|.
name|getMinVersions
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
literal|"Min versions for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"  must be positive. Set "
operator|+
name|CONF_KEY
operator|+
literal|" to false at conf or table descriptor "
operator|+
literal|"if you want to bypass sanity checks"
argument_list|)
throw|;
block|}
comment|// max versions already being checked
comment|// check replication scope
if|if
condition|(
name|hcd
operator|.
name|getScope
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
literal|"Replication scope for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"  must be positive. Set "
operator|+
name|CONF_KEY
operator|+
literal|" to false at conf "
operator|+
literal|"or table descriptor if you want to bypass sanity checks"
argument_list|)
throw|;
block|}
comment|// TODO: should we check coprocessors and encryption ?
block|}
block|}
specifier|private
name|void
name|startActiveMasterManager
parameter_list|()
throws|throws
name|KeeperException
block|{
name|String
name|backupZNode
init|=
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|zooKeeper
operator|.
name|backupMasterAddressesZNode
argument_list|,
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|/*     * Add a ZNode for ourselves in the backup master directory since we     * may not become the active master. If so, we want the actual active     * master to know we are backup masters, so that it won't assign     * regions to us if so configured.     *     * If we become the active master later, ActiveMasterManager will delete     * this node explicitly.  If we crash before then, ZooKeeper will delete     * this node for us since it is ephemeral.     */
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding backup master ZNode "
operator|+
name|backupZNode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MasterAddressTracker
operator|.
name|setMasterAddress
argument_list|(
name|zooKeeper
argument_list|,
name|backupZNode
argument_list|,
name|serverName
argument_list|,
name|masterInfoPort
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed create of "
operator|+
name|backupZNode
operator|+
literal|" by "
operator|+
name|serverName
argument_list|)
expr_stmt|;
block|}
name|activeMasterManager
operator|=
operator|new
name|ActiveMasterManager
argument_list|(
name|zooKeeper
argument_list|,
name|this
operator|.
name|serverName
argument_list|,
name|masterInfoPort
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Start a thread to try to become the active master, so we won't block here
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|int
name|timeout
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|ZK_SESSION_TIMEOUT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_ZK_SESSION_TIMEOUT
argument_list|)
decl_stmt|;
comment|// If we're a backup master, stall until a primary to writes his address
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|MASTER_TYPE_BACKUP
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_TYPE_BACKUP
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"HMaster started in backup mode. "
operator|+
literal|"Stalling until master znode is written."
argument_list|)
expr_stmt|;
comment|// This will only be a minute or so while the cluster starts up,
comment|// so don't worry about setting watches on the parent znode
while|while
condition|(
operator|!
name|activeMasterManager
operator|.
name|hasActiveMaster
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for master address ZNode to be written "
operator|+
literal|"(Also watching cluster state node)"
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|sleep
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
name|MonitoredTask
name|status
init|=
name|TaskMonitor
operator|.
name|get
argument_list|()
operator|.
name|createStatus
argument_list|(
literal|"Master startup"
argument_list|)
decl_stmt|;
name|status
operator|.
name|setDescription
argument_list|(
literal|"Master startup"
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|activeMasterManager
operator|.
name|blockUntilBecomingActiveMaster
argument_list|(
name|timeout
argument_list|,
name|status
argument_list|)
condition|)
block|{
name|finishActiveMasterInitialization
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|status
operator|.
name|setStatus
argument_list|(
literal|"Failed to become active: "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Failed to become active master"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// HBASE-5680: Likely hadoop23 vs hadoop 20.x/1.x incompatibility
if|if
condition|(
name|t
operator|instanceof
name|NoClassDefFoundError
operator|&&
name|t
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"org/apache/hadoop/hdfs/protocol/FSConstants$SafeModeAction"
argument_list|)
condition|)
block|{
comment|// improved error message for this special case
name|abort
argument_list|(
literal|"HBase is having a problem with its Hadoop jars.  You may need to "
operator|+
literal|"recompile HBase against Hadoop version "
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
operator|.
name|getVersion
argument_list|()
operator|+
literal|" or change your hadoop jars to start properly"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|abort
argument_list|(
literal|"Unhandled exception. Starting shutdown."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|status
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|,
name|getServerName
argument_list|()
operator|.
name|toShortString
argument_list|()
operator|+
literal|".activeMasterManager"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkCompression
parameter_list|(
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|masterCheckCompression
condition|)
return|return;
for|for
control|(
name|HColumnDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
name|checkCompression
argument_list|(
name|hcd
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkCompression
parameter_list|(
specifier|final
name|HColumnDescriptor
name|hcd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|masterCheckCompression
condition|)
return|return;
name|CompressionTest
operator|.
name|testCompression
argument_list|(
name|hcd
operator|.
name|getCompression
argument_list|()
argument_list|)
expr_stmt|;
name|CompressionTest
operator|.
name|testCompression
argument_list|(
name|hcd
operator|.
name|getCompactionCompression
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkEncryption
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|masterCheckEncryption
condition|)
return|return;
for|for
control|(
name|HColumnDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
name|checkEncryption
argument_list|(
name|conf
argument_list|,
name|hcd
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkEncryption
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|HColumnDescriptor
name|hcd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|masterCheckEncryption
condition|)
return|return;
name|EncryptionTest
operator|.
name|testEncryption
argument_list|(
name|conf
argument_list|,
name|hcd
operator|.
name|getEncryptionType
argument_list|()
argument_list|,
name|hcd
operator|.
name|getEncryptionKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkClassLoading
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionSplitPolicy
operator|.
name|getSplitPolicyClass
argument_list|(
name|htd
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|RegionCoprocessorHost
operator|.
name|testTableCoprocessorAttrs
argument_list|(
name|conf
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
specifier|private
name|HRegionInfo
index|[]
name|getHRegionInfos
parameter_list|(
name|HTableDescriptor
name|hTableDescriptor
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
block|{
name|long
name|regionId
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|HRegionInfo
index|[]
name|hRegionInfos
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|splitKeys
operator|==
literal|null
operator|||
name|splitKeys
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|hRegionInfos
operator|=
operator|new
name|HRegionInfo
index|[]
block|{
operator|new
name|HRegionInfo
argument_list|(
name|hTableDescriptor
operator|.
name|getTableName
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|regionId
argument_list|)
block|}
expr_stmt|;
block|}
else|else
block|{
name|int
name|numRegions
init|=
name|splitKeys
operator|.
name|length
operator|+
literal|1
decl_stmt|;
name|hRegionInfos
operator|=
operator|new
name|HRegionInfo
index|[
name|numRegions
index|]
expr_stmt|;
name|byte
index|[]
name|startKey
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|endKey
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
name|endKey
operator|=
operator|(
name|i
operator|==
name|splitKeys
operator|.
name|length
operator|)
condition|?
literal|null
else|:
name|splitKeys
index|[
name|i
index|]
expr_stmt|;
name|hRegionInfos
index|[
name|i
index|]
operator|=
operator|new
name|HRegionInfo
argument_list|(
name|hTableDescriptor
operator|.
name|getTableName
argument_list|()
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
literal|false
argument_list|,
name|regionId
argument_list|)
expr_stmt|;
name|startKey
operator|=
name|endKey
expr_stmt|;
block|}
block|}
return|return
name|hRegionInfos
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isCatalogTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|tableName
operator|.
name|equals
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preDeleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" delete "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
operator|new
name|DeleteTableHandler
argument_list|(
name|tableName
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|prepare
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postDeleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|truncateTable
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|boolean
name|preserveSplits
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preTruncateTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" truncate "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|TruncateTableHandler
name|handler
init|=
operator|new
name|TruncateTableHandler
argument_list|(
name|tableName
argument_list|,
name|this
argument_list|,
name|this
argument_list|,
name|preserveSplits
argument_list|)
decl_stmt|;
name|handler
operator|.
name|prepare
argument_list|()
expr_stmt|;
name|handler
operator|.
name|process
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postTruncateTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|addColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|HColumnDescriptor
name|columnDescriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|checkCompression
argument_list|(
name|columnDescriptor
argument_list|)
expr_stmt|;
name|checkEncryption
argument_list|(
name|conf
argument_list|,
name|columnDescriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preAddColumn
argument_list|(
name|tableName
argument_list|,
name|columnDescriptor
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
comment|//TODO: we should process this (and some others) in an executor
operator|new
name|TableAddFamilyHandler
argument_list|(
name|tableName
argument_list|,
name|columnDescriptor
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|prepare
argument_list|()
operator|.
name|process
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postAddColumn
argument_list|(
name|tableName
argument_list|,
name|columnDescriptor
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|modifyColumn
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|checkCompression
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
name|checkEncryption
argument_list|(
name|conf
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preModifyColumn
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" modify "
operator|+
name|descriptor
argument_list|)
expr_stmt|;
operator|new
name|TableModifyFamilyHandler
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|prepare
argument_list|()
operator|.
name|process
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postModifyColumn
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|deleteColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preDeleteColumn
argument_list|(
name|tableName
argument_list|,
name|columnName
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" delete "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|columnName
argument_list|)
argument_list|)
expr_stmt|;
operator|new
name|TableDeleteFamilyHandler
argument_list|(
name|tableName
argument_list|,
name|columnName
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|prepare
argument_list|()
operator|.
name|process
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postDeleteColumn
argument_list|(
name|tableName
argument_list|,
name|columnName
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|enableTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preEnableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" enable "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
operator|new
name|EnableTableHandler
argument_list|(
name|this
argument_list|,
name|tableName
argument_list|,
name|assignmentManager
argument_list|,
name|tableLockManager
argument_list|,
literal|false
argument_list|)
operator|.
name|prepare
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postEnableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|disableTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preDisableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" disable "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
operator|new
name|DisableTableHandler
argument_list|(
name|this
argument_list|,
name|tableName
argument_list|,
name|assignmentManager
argument_list|,
name|tableLockManager
argument_list|,
literal|false
argument_list|)
operator|.
name|prepare
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postDisableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return the region and current deployment for the region containing    * the given row. If the region cannot be found, returns null. If it    * is found, but not currently deployed, the second element of the pair    * may be null.    */
annotation|@
name|VisibleForTesting
comment|// Used by TestMaster.
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|getTableRegionForRow
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|rowKey
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitorBase
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|data
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|==
literal|null
operator|||
name|data
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|HRegionInfo
operator|.
name|getHRegionInfoAndServerName
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result
operator|.
name|set
argument_list|(
name|pair
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|visitor
argument_list|,
name|tableName
argument_list|,
name|rowKey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|modifyTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|HTableDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|sanityCheckTableDescriptor
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preModifyTable
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" modify "
operator|+
name|tableName
argument_list|)
expr_stmt|;
operator|new
name|ModifyTableHandler
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|prepare
argument_list|()
operator|.
name|process
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postModifyTable
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkTableModifiable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|TableNotFoundException
throws|,
name|TableNotDisabledException
block|{
if|if
condition|(
name|isCatalogTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't modify catalog tables"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|MetaTableAccessor
operator|.
name|tableExists
argument_list|(
name|getConnection
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|getAssignmentManager
argument_list|()
operator|.
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|tableName
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|DISABLED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotDisabledException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return cluster status    */
specifier|public
name|ClusterStatus
name|getClusterStatus
parameter_list|()
throws|throws
name|InterruptedIOException
block|{
comment|// Build Set of backup masters from ZK nodes
name|List
argument_list|<
name|String
argument_list|>
name|backupMasterStrings
decl_stmt|;
try|try
block|{
name|backupMasterStrings
operator|=
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
operator|.
name|zooKeeper
operator|.
name|backupMasterAddressesZNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|prefix
argument_list|(
literal|"Unable to list backup servers"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|backupMasterStrings
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ServerName
argument_list|>
name|backupMasters
init|=
operator|new
name|ArrayList
argument_list|<
name|ServerName
argument_list|>
argument_list|(
name|backupMasterStrings
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|backupMasterStrings
control|)
block|{
try|try
block|{
name|byte
index|[]
name|bytes
decl_stmt|;
try|try
block|{
name|bytes
operator|=
name|ZKUtil
operator|.
name|getData
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|backupMasterAddressesZNode
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
block|}
if|if
condition|(
name|bytes
operator|!=
literal|null
condition|)
block|{
name|ServerName
name|sn
decl_stmt|;
try|try
block|{
name|sn
operator|=
name|ServerName
operator|.
name|parseFrom
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed parse, skipping registering backup server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|backupMasters
operator|.
name|add
argument_list|(
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|prefix
argument_list|(
literal|"Unable to get information about "
operator|+
literal|"backup servers"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|backupMasters
argument_list|,
operator|new
name|Comparator
argument_list|<
name|ServerName
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|ServerName
name|s1
parameter_list|,
name|ServerName
name|s2
parameter_list|)
block|{
return|return
name|s1
operator|.
name|getServerName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|s2
operator|.
name|getServerName
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|String
name|clusterId
init|=
name|fileSystemManager
operator|!=
literal|null
condition|?
name|fileSystemManager
operator|.
name|getClusterId
argument_list|()
operator|.
name|toString
argument_list|()
else|:
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|regionsInTransition
init|=
name|assignmentManager
operator|!=
literal|null
condition|?
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionsInTransition
argument_list|()
else|:
literal|null
decl_stmt|;
name|String
index|[]
name|coprocessors
init|=
name|cpHost
operator|!=
literal|null
condition|?
name|getMasterCoprocessors
argument_list|()
else|:
literal|null
decl_stmt|;
name|boolean
name|balancerOn
init|=
name|loadBalancerTracker
operator|!=
literal|null
condition|?
name|loadBalancerTracker
operator|.
name|isBalancerOn
argument_list|()
else|:
literal|false
decl_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|ServerLoad
argument_list|>
name|onlineServers
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|ServerName
argument_list|>
name|deadServers
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|serverManager
operator|!=
literal|null
condition|)
block|{
name|deadServers
operator|=
name|serverManager
operator|.
name|getDeadServers
argument_list|()
operator|.
name|copyServerNames
argument_list|()
expr_stmt|;
name|onlineServers
operator|=
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|ClusterStatus
argument_list|(
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|,
name|clusterId
argument_list|,
name|onlineServers
argument_list|,
name|deadServers
argument_list|,
name|serverName
argument_list|,
name|backupMasters
argument_list|,
name|regionsInTransition
argument_list|,
name|coprocessors
argument_list|,
name|balancerOn
argument_list|)
return|;
block|}
comment|/**    * The set of loaded coprocessors is stored in a static set. Since it's    * statically allocated, it does not require that HMaster's cpHost be    * initialized prior to accessing it.    * @return a String representation of the set of names of the loaded    * coprocessors.    */
specifier|public
specifier|static
name|String
name|getLoadedCoprocessors
parameter_list|()
block|{
return|return
name|CoprocessorHost
operator|.
name|getLoadedCoprocessors
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @return timestamp in millis when HMaster was started.    */
specifier|public
name|long
name|getMasterStartTime
parameter_list|()
block|{
return|return
name|startcode
return|;
block|}
comment|/**    * @return timestamp in millis when HMaster became the active master.    */
specifier|public
name|long
name|getMasterActiveTime
parameter_list|()
block|{
return|return
name|masterActiveTime
return|;
block|}
specifier|public
name|int
name|getRegionServerInfoPort
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
name|RegionServerInfo
name|info
init|=
name|this
operator|.
name|regionServerTracker
operator|.
name|getRegionServerInfo
argument_list|(
name|sn
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
operator|||
name|info
operator|.
name|getInfoPort
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|REGIONSERVER_INFO_PORT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_REGIONSERVER_INFOPORT
argument_list|)
return|;
block|}
return|return
name|info
operator|.
name|getInfoPort
argument_list|()
return|;
block|}
comment|/**    * @return array of coprocessor SimpleNames.    */
specifier|public
name|String
index|[]
name|getMasterCoprocessors
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|masterCoprocessors
init|=
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|getCoprocessors
argument_list|()
decl_stmt|;
return|return
name|masterCoprocessors
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|masterCoprocessors
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|,
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|isAborted
argument_list|()
operator|||
name|isStopped
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
comment|// HBASE-4014: dump a list of loaded coprocessors.
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Master server abort: loaded coprocessors are: "
operator|+
name|getLoadedCoprocessors
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|stop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|ZooKeeperWatcher
name|getZooKeeper
parameter_list|()
block|{
return|return
name|zooKeeper
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterCoprocessorHost
name|getMasterCoprocessorHost
parameter_list|()
block|{
return|return
name|cpHost
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterQuotaManager
name|getMasterQuotaManager
parameter_list|()
block|{
return|return
name|quotaManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerName
name|getServerName
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverName
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssignmentManager
name|getAssignmentManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|assignmentManager
return|;
block|}
specifier|public
name|MemoryBoundedLogMessageBuffer
name|getRegionServerFatalLogBuffer
parameter_list|()
block|{
return|return
name|rsFatals
return|;
block|}
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|cpHost
operator|.
name|preShutdown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error call master coprocessor preShutdown()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|serverManager
operator|.
name|shutdownCluster
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|clusterStatusTracker
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterDown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ZooKeeper exception trying to set cluster as down in ZK"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|stopMaster
parameter_list|()
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|cpHost
operator|.
name|preStopMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error call master coprocessor preStopMaster()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
name|stop
argument_list|(
literal|"Stopped by "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|void
name|checkServiceStarted
parameter_list|()
throws|throws
name|ServerNotRunningYetException
block|{
if|if
condition|(
operator|!
name|serviceStarted
condition|)
block|{
throw|throw
operator|new
name|ServerNotRunningYetException
argument_list|(
literal|"Server is not running yet"
argument_list|)
throw|;
block|}
block|}
name|void
name|checkInitialized
parameter_list|()
throws|throws
name|PleaseHoldException
throws|,
name|ServerNotRunningYetException
block|{
name|checkServiceStarted
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|initialized
condition|)
block|{
throw|throw
operator|new
name|PleaseHoldException
argument_list|(
literal|"Master is initializing"
argument_list|)
throw|;
block|}
block|}
name|void
name|checkNamespaceManagerReady
parameter_list|()
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|tableNamespaceManager
operator|==
literal|null
operator|||
operator|!
name|tableNamespaceManager
operator|.
name|isTableAvailableAndInitialized
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Table Namespace Manager not ready yet, try again later"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Report whether this master is currently the active master or not.    * If not active master, we are parked on ZK waiting to become active.    *    * This method is used for testing.    *    * @return true if active master, false if not.    */
specifier|public
name|boolean
name|isActiveMaster
parameter_list|()
block|{
return|return
name|isActiveMaster
return|;
block|}
comment|/**    * Report whether this master has completed with its initialization and is    * ready.  If ready, the master is also the active master.  A standby master    * is never ready.    *    * This method is used for testing.    *    * @return true if master is ready to go, false if not.    */
annotation|@
name|Override
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
return|return
name|initialized
return|;
block|}
comment|/**    * ServerShutdownHandlerEnabled is set false before completing    * assignMeta to prevent processing of ServerShutdownHandler.    * @return true if assignMeta has completed;    */
annotation|@
name|Override
specifier|public
name|boolean
name|isServerShutdownHandlerEnabled
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverShutdownHandlerEnabled
return|;
block|}
comment|/**    * Report whether this master has started initialization and is about to do meta region assignment    * @return true if master is in initialization& about to assign hbase:meta regions    */
specifier|public
name|boolean
name|isInitializationStartsMetaRegionAssignment
parameter_list|()
block|{
return|return
name|this
operator|.
name|initializationBeforeMetaAssignment
return|;
block|}
specifier|public
name|void
name|assignRegion
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|assignmentManager
operator|.
name|assign
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compute the average load across all region servers.    * Currently, this uses a very naive computation - just uses the number of    * regions being served, ignoring stats about number of requests.    * @return the average load    */
specifier|public
name|double
name|getAverageLoad
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|RegionStates
name|regionStates
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionStates
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|regionStates
operator|.
name|getAverageLoad
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|registerService
parameter_list|(
name|Service
name|instance
parameter_list|)
block|{
comment|/*      * No stacking of instances is allowed for a single service name      */
name|Descriptors
operator|.
name|ServiceDescriptor
name|serviceDesc
init|=
name|instance
operator|.
name|getDescriptorForType
argument_list|()
decl_stmt|;
if|if
condition|(
name|coprocessorServiceHandlers
operator|.
name|containsKey
argument_list|(
name|serviceDesc
operator|.
name|getFullName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor service "
operator|+
name|serviceDesc
operator|.
name|getFullName
argument_list|()
operator|+
literal|" already registered, rejecting request from "
operator|+
name|instance
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|coprocessorServiceHandlers
operator|.
name|put
argument_list|(
name|serviceDesc
operator|.
name|getFullName
argument_list|()
argument_list|,
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Registered master coprocessor service: service="
operator|+
name|serviceDesc
operator|.
name|getFullName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Utility for constructing an instance of the passed HMaster class.    * @param masterClass    * @param conf    * @return HMaster instance.    */
specifier|public
specifier|static
name|HMaster
name|constructMaster
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|masterClass
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|CoordinatedStateManager
name|cp
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|c
init|=
name|masterClass
operator|.
name|getConstructor
argument_list|(
name|Configuration
operator|.
name|class
argument_list|,
name|CoordinatedStateManager
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|c
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|,
name|cp
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|ite
parameter_list|)
block|{
name|Throwable
name|target
init|=
name|ite
operator|.
name|getTargetException
argument_list|()
operator|!=
literal|null
condition|?
name|ite
operator|.
name|getTargetException
argument_list|()
else|:
name|ite
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
condition|)
name|target
operator|=
name|target
operator|.
name|getCause
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of Master: "
operator|+
name|masterClass
operator|.
name|toString
argument_list|()
argument_list|,
name|target
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of Master: "
operator|+
name|masterClass
operator|.
name|toString
argument_list|()
operator|+
operator|(
operator|(
name|e
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
operator|)
condition|?
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
else|:
literal|""
operator|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * @see org.apache.hadoop.hbase.master.HMasterCommandLine    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|VersionInfo
operator|.
name|logVersion
argument_list|()
expr_stmt|;
operator|new
name|HMasterCommandLine
argument_list|(
name|HMaster
operator|.
name|class
argument_list|)
operator|.
name|doMain
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
specifier|public
name|HFileCleaner
name|getHFileCleaner
parameter_list|()
block|{
return|return
name|this
operator|.
name|hfileCleaner
return|;
block|}
comment|/**    * Exposed for TESTING!    * @return the underlying snapshot manager    */
specifier|public
name|SnapshotManager
name|getSnapshotManagerForTesting
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|createNamespace
parameter_list|(
name|NamespaceDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|TableName
operator|.
name|isLegalNamespaceName
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|descriptor
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|checkNamespaceManagerReady
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preCreateNamespace
argument_list|(
name|descriptor
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" creating "
operator|+
name|descriptor
argument_list|)
expr_stmt|;
name|tableNamespaceManager
operator|.
name|create
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postCreateNamespace
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|modifyNamespace
parameter_list|(
name|NamespaceDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|TableName
operator|.
name|isLegalNamespaceName
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|descriptor
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|checkNamespaceManagerReady
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preModifyNamespace
argument_list|(
name|descriptor
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" modify "
operator|+
name|descriptor
argument_list|)
expr_stmt|;
name|tableNamespaceManager
operator|.
name|update
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postModifyNamespace
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|deleteNamespace
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNamespaceManagerReady
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preDeleteNamespace
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" delete "
operator|+
name|name
argument_list|)
expr_stmt|;
name|tableNamespaceManager
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postDeleteNamespace
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Ensure that the specified namespace exists, otherwise throws a NamespaceNotFoundException    *    * @param name the namespace to check    * @throws IOException if the namespace manager is not ready yet.    * @throws NamespaceNotFoundException if the namespace does not exists    */
specifier|private
name|void
name|ensureNamespaceExists
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IOException
throws|,
name|NamespaceNotFoundException
block|{
name|checkNamespaceManagerReady
argument_list|()
expr_stmt|;
name|NamespaceDescriptor
name|nsd
init|=
name|tableNamespaceManager
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nsd
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NamespaceNotFoundException
argument_list|(
name|name
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|NamespaceDescriptor
name|getNamespaceDescriptor
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNamespaceManagerReady
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetNamespaceDescriptor
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|NamespaceDescriptor
name|nsd
init|=
name|tableNamespaceManager
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nsd
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NamespaceNotFoundException
argument_list|(
name|name
argument_list|)
throw|;
block|}
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetNamespaceDescriptor
argument_list|(
name|nsd
argument_list|)
expr_stmt|;
block|}
return|return
name|nsd
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|NamespaceDescriptor
argument_list|>
name|listNamespaceDescriptors
parameter_list|()
throws|throws
name|IOException
block|{
name|checkNamespaceManagerReady
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|NamespaceDescriptor
argument_list|>
name|descriptors
init|=
operator|new
name|ArrayList
argument_list|<
name|NamespaceDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|bypass
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|bypass
operator|=
name|cpHost
operator|.
name|preListNamespaceDescriptors
argument_list|(
name|descriptors
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bypass
condition|)
block|{
name|descriptors
operator|.
name|addAll
argument_list|(
name|tableNamespaceManager
operator|.
name|list
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postListNamespaceDescriptors
argument_list|(
name|descriptors
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|descriptors
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|listTableDescriptorsByNamespace
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureNamespaceExists
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|listTableDescriptors
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|TableName
argument_list|>
name|listTableNamesByNamespace
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureNamespaceExists
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|listTableNames
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Returns the list of table descriptors that match the specified request    *    * @param namespace the namespace to query, or null if querying for all    * @param regex The regular expression to match against, or null if querying for all    * @param tableNameList the list of table names, or null if querying for all    * @param includeSysTables False to match only against userspace tables    * @return the list of table descriptors    */
specifier|public
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|listTableDescriptors
parameter_list|(
specifier|final
name|String
name|namespace
parameter_list|,
specifier|final
name|String
name|regex
parameter_list|,
specifier|final
name|List
argument_list|<
name|TableName
argument_list|>
name|tableNameList
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|descriptors
init|=
operator|new
name|ArrayList
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|bypass
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|bypass
operator|=
name|cpHost
operator|.
name|preGetTableDescriptors
argument_list|(
name|tableNameList
argument_list|,
name|descriptors
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bypass
condition|)
block|{
if|if
condition|(
name|tableNameList
operator|==
literal|null
operator|||
name|tableNameList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// request for all TableDescriptors
name|Collection
argument_list|<
name|HTableDescriptor
argument_list|>
name|htds
decl_stmt|;
if|if
condition|(
name|namespace
operator|!=
literal|null
operator|&&
name|namespace
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|htds
operator|=
name|tableDescriptors
operator|.
name|getByNamespace
argument_list|(
name|namespace
argument_list|)
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|htds
operator|=
name|tableDescriptors
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|HTableDescriptor
name|desc
range|:
name|htds
control|)
block|{
if|if
condition|(
name|includeSysTables
operator|||
operator|!
name|desc
operator|.
name|getTableName
argument_list|()
operator|.
name|isSystemTable
argument_list|()
condition|)
block|{
name|descriptors
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|TableName
name|s
range|:
name|tableNameList
control|)
block|{
name|HTableDescriptor
name|desc
init|=
name|tableDescriptors
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
name|descriptors
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Retains only those matched by regular expression.
if|if
condition|(
name|regex
operator|!=
literal|null
condition|)
block|{
name|filterTablesByRegex
argument_list|(
name|descriptors
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetTableDescriptors
argument_list|(
name|tableNameList
argument_list|,
name|descriptors
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|descriptors
return|;
block|}
comment|/**    * Returns the list of table names that match the specified request    * @param regex The regular expression to match against, or null if querying for all    * @param namespace the namespace to query, or null if querying for all    * @param includeSysTables False to match only against userspace tables    * @return the list of table names    */
specifier|public
name|List
argument_list|<
name|TableName
argument_list|>
name|listTableNames
parameter_list|(
specifier|final
name|String
name|namespace
parameter_list|,
specifier|final
name|String
name|regex
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|descriptors
init|=
operator|new
name|ArrayList
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|bypass
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|bypass
operator|=
name|cpHost
operator|.
name|preGetTableNames
argument_list|(
name|descriptors
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bypass
condition|)
block|{
comment|// get all descriptors
name|Collection
argument_list|<
name|HTableDescriptor
argument_list|>
name|htds
decl_stmt|;
if|if
condition|(
name|namespace
operator|!=
literal|null
operator|&&
name|namespace
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|htds
operator|=
name|tableDescriptors
operator|.
name|getByNamespace
argument_list|(
name|namespace
argument_list|)
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|htds
operator|=
name|tableDescriptors
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|HTableDescriptor
name|htd
range|:
name|htds
control|)
block|{
if|if
condition|(
name|includeSysTables
operator|||
operator|!
name|htd
operator|.
name|getTableName
argument_list|()
operator|.
name|isSystemTable
argument_list|()
condition|)
block|{
name|descriptors
operator|.
name|add
argument_list|(
name|htd
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Retains only those matched by regular expression.
if|if
condition|(
name|regex
operator|!=
literal|null
condition|)
block|{
name|filterTablesByRegex
argument_list|(
name|descriptors
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetTableNames
argument_list|(
name|descriptors
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|TableName
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|(
name|descriptors
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|HTableDescriptor
name|htd
range|:
name|descriptors
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Removes the table descriptors that don't match the pattern.    * @param descriptors list of table descriptors to filter    * @param pattern the regex to use    */
specifier|private
specifier|static
name|void
name|filterTablesByRegex
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|HTableDescriptor
argument_list|>
name|descriptors
parameter_list|,
specifier|final
name|Pattern
name|pattern
parameter_list|)
block|{
specifier|final
name|String
name|defaultNS
init|=
name|NamespaceDescriptor
operator|.
name|DEFAULT_NAMESPACE_NAME_STR
decl_stmt|;
name|Iterator
argument_list|<
name|HTableDescriptor
argument_list|>
name|itr
init|=
name|descriptors
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|HTableDescriptor
name|htd
init|=
name|itr
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|tableName
init|=
name|htd
operator|.
name|getTableName
argument_list|()
operator|.
name|getNameAsString
argument_list|()
decl_stmt|;
name|boolean
name|matched
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|tableName
argument_list|)
operator|.
name|matches
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|matched
operator|&&
name|htd
operator|.
name|getTableName
argument_list|()
operator|.
name|getNamespaceAsString
argument_list|()
operator|.
name|equals
argument_list|(
name|defaultNS
argument_list|)
condition|)
block|{
name|matched
operator|=
name|pattern
operator|.
name|matcher
argument_list|(
name|defaultNS
operator|+
name|TableName
operator|.
name|NAMESPACE_DELIM
operator|+
name|tableName
argument_list|)
operator|.
name|matches
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|itr
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

