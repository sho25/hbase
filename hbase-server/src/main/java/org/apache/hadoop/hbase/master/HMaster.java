begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
operator|.
name|DEFAULT_HBASE_SPLIT_COORDINATED_BY_ZK
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
operator|.
name|HBASE_MASTER_LOGCLEANER_PLUGINS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
operator|.
name|HBASE_SPLIT_WAL_COORDINATED_BY_ZK
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServlet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletRequest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ChoreService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterMetrics
operator|.
name|Option
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterMetricsBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseInterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|InvalidFamilyOperationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaTableAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NamespaceDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|PleaseHoldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ReplicationPeerNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotDisabledException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ColumnFamilyDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MasterSwitchType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfoBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionStatesCount
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptorBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|CoprocessorHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesPromoter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|http
operator|.
name|InfoServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|CoprocessorRpcUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|ServerNotRunningYetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|log
operator|.
name|HBaseMarkers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterRpcServices
operator|.
name|BalanceSwitchMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|AssignmentManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|MergeTableRegionsProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|RegionStateNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|RegionStates
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|TransitRegionStateProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|BalancerChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|BaseLoadBalancer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|ClusterStatusChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|LoadBalancerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|DirScanPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|HFileCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|LogCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|ReplicationBarrierCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|SnapshotCleanerChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|locking
operator|.
name|LockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|NormalizationPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|NormalizationPlan
operator|.
name|PlanType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|RegionNormalizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|RegionNormalizerChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|RegionNormalizerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|CreateTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|DeleteNamespaceProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|DeleteTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|DisableTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|EnableTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|InitMetaProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureEnv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ModifyTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ProcedurePrepareLatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ProcedureSyncWait
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ReopenTableRegionsProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ServerCrashProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|TruncateTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|AbstractPeerProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|AddPeerProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|DisablePeerProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|EnablePeerProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|RemovePeerProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|ReplicationPeerManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|SyncReplicationReplayWALManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|TransitPeerSyncReplicationStateProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|replication
operator|.
name|UpdatePeerConfigProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|snapshot
operator|.
name|SnapshotManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|zksyncer
operator|.
name|MasterAddressSyncer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|zksyncer
operator|.
name|MetaLocationSyncer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mob
operator|.
name|MobConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MemoryBoundedLogMessageBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MonitoredTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|TaskMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure
operator|.
name|MasterProcedureManagerHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure
operator|.
name|flush
operator|.
name|MasterFlushTableProcedureManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|LockedResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|Procedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|RemoteProcedureDispatcher
operator|.
name|RemoteProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|RemoteProcedureException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|store
operator|.
name|ProcedureStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|store
operator|.
name|ProcedureStore
operator|.
name|ProcedureStoreListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|store
operator|.
name|region
operator|.
name|RegionProcedureStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|MasterQuotaManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|MasterQuotasObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|QuotaObserverChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|QuotaTableUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|QuotaUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|SnapshotQuotaObserverChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|SpaceQuotaSnapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|SpaceQuotaSnapshot
operator|.
name|SpaceQuotaStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|SpaceQuotaSnapshotNotifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|SpaceQuotaSnapshotNotifierFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|SpaceViolationPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegionServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RSRpcServices
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationLoadSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationPeerConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationPeerDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|SyncReplicationState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|master
operator|.
name|ReplicationHFileCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|master
operator|.
name|ReplicationLogCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|master
operator|.
name|ReplicationPeerConfigUpgrader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|regionserver
operator|.
name|ReplicationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|SecurityConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|UserProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|trace
operator|.
name|TraceUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Addressing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FutureUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HBaseFsck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HFileArchiveUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HasThread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|IdLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ModifyRegionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|RetryCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|RetryCounterFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|TableDescriptorChecker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|LoadBalancerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MasterAddressTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RegionNormalizerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|SnapshotCleanupTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKClusterId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZNodePaths
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jetty
operator|.
name|server
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jetty
operator|.
name|server
operator|.
name|ServerConnector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jetty
operator|.
name|servlet
operator|.
name|ServletHolder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jetty
operator|.
name|webapp
operator|.
name|WebAppContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|RequestConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|GetRegionInfoResponse
operator|.
name|CompactionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|SnapshotProtos
operator|.
name|SnapshotDescription
import|;
end_import

begin_comment
comment|/**  * HMaster is the "master server" for HBase. An HBase cluster has one active  * master.  If many masters are started, all compete.  Whichever wins goes on to  * run the cluster.  All others park themselves in their constructor until  * master or cluster shutdown or until the active master loses its lease in  * zookeeper.  Thereafter, all running master jostle to take over master role.  *  *<p>The Master can be asked shutdown the cluster. See {@link #shutdown()}.  In  * this case it will tell all regionservers to go down and then wait on them  * all reporting in that they are down.  This master will then shut itself down.  *  *<p>You can also shutdown just this master.  Call {@link #stopMaster()}.  *  * @see org.apache.zookeeper.Watcher  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|TOOLS
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
class|class
name|HMaster
extends|extends
name|HRegionServer
implements|implements
name|MasterServices
block|{
specifier|private
specifier|static
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HMaster
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Protection against zombie master. Started once Master accepts active responsibility and    * starts taking over responsibilities. Allows a finite time window before giving up ownership.    */
specifier|private
specifier|static
class|class
name|InitializationMonitor
extends|extends
name|HasThread
block|{
comment|/** The amount of time in milliseconds to sleep before checking initialization status. */
specifier|public
specifier|static
specifier|final
name|String
name|TIMEOUT_KEY
init|=
literal|"hbase.master.initializationmonitor.timeout"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|TIMEOUT_DEFAULT
init|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
literal|15
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
decl_stmt|;
comment|/**      * When timeout expired and initialization has not complete, call {@link System#exit(int)} when      * true, do nothing otherwise.      */
specifier|public
specifier|static
specifier|final
name|String
name|HALT_KEY
init|=
literal|"hbase.master.initializationmonitor.haltontimeout"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|HALT_DEFAULT
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|HMaster
name|master
decl_stmt|;
specifier|private
specifier|final
name|long
name|timeout
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|haltOnTimeout
decl_stmt|;
comment|/** Creates a Thread that monitors the {@link #isInitialized()} state. */
name|InitializationMonitor
parameter_list|(
name|HMaster
name|master
parameter_list|)
block|{
name|super
argument_list|(
literal|"MasterInitializationMonitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|TIMEOUT_KEY
argument_list|,
name|TIMEOUT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|haltOnTimeout
operator|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|HALT_KEY
argument_list|,
name|HALT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
operator|!
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
name|master
operator|.
name|isActiveMaster
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|master
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initialization completed within allotted tolerance. Monitor exiting."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Master failed to complete initialization after "
operator|+
name|timeout
operator|+
literal|"ms. Please"
operator|+
literal|" consider submitting a bug report including a thread dump of this process."
argument_list|)
expr_stmt|;
if|if
condition|(
name|haltOnTimeout
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Zombie Master exiting. Thread dump to stdout"
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|printThreadInfo
argument_list|(
name|System
operator|.
name|out
argument_list|,
literal|"Zombie HMaster"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"InitMonitor thread interrupted. Existing."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// MASTER is name of the webapp and the attribute name used stuffing this
comment|//instance into web context.
specifier|public
specifier|static
specifier|final
name|String
name|MASTER
init|=
literal|"master"
decl_stmt|;
comment|// Manager and zk listener for master election
specifier|private
specifier|final
name|ActiveMasterManager
name|activeMasterManager
decl_stmt|;
comment|// Region server tracker
specifier|private
name|RegionServerTracker
name|regionServerTracker
decl_stmt|;
comment|// Draining region server tracker
specifier|private
name|DrainingServerTracker
name|drainingServerTracker
decl_stmt|;
comment|// Tracker for load balancer state
name|LoadBalancerTracker
name|loadBalancerTracker
decl_stmt|;
comment|// Tracker for meta location, if any client ZK quorum specified
name|MetaLocationSyncer
name|metaLocationSyncer
decl_stmt|;
comment|// Tracker for active master location, if any client ZK quorum specified
name|MasterAddressSyncer
name|masterAddressSyncer
decl_stmt|;
comment|// Tracker for auto snapshot cleanup state
name|SnapshotCleanupTracker
name|snapshotCleanupTracker
decl_stmt|;
comment|// Tracker for split and merge state
specifier|private
name|SplitOrMergeTracker
name|splitOrMergeTracker
decl_stmt|;
comment|// Tracker for region normalizer state
specifier|private
name|RegionNormalizerTracker
name|regionNormalizerTracker
decl_stmt|;
specifier|private
name|ClusterSchemaService
name|clusterSchemaService
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|HBASE_MASTER_WAIT_ON_SERVICE_IN_SECONDS
init|=
literal|"hbase.master.wait.on.service.seconds"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_HBASE_MASTER_WAIT_ON_SERVICE_IN_SECONDS
init|=
literal|5
operator|*
literal|60
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|HBASE_MASTER_CLEANER_INTERVAL
init|=
literal|"hbase.master.cleaner.interval"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_HBASE_MASTER_CLEANER_INTERVAL
init|=
literal|600
operator|*
literal|1000
decl_stmt|;
comment|// Metrics for the HMaster
specifier|final
name|MetricsMaster
name|metricsMaster
decl_stmt|;
comment|// file system manager for the master FS operations
specifier|private
name|MasterFileSystem
name|fileSystemManager
decl_stmt|;
specifier|private
name|MasterWalManager
name|walManager
decl_stmt|;
comment|// manager to manage procedure-based WAL splitting, can be null if current
comment|// is zk-based WAL splitting. SplitWALManager will replace SplitLogManager
comment|// and MasterWalManager, which means zk-based WAL splitting code will be
comment|// useless after we switch to the procedure-based one. our eventual goal
comment|// is to remove all the zk-based WAL splitting code.
specifier|private
name|SplitWALManager
name|splitWALManager
decl_stmt|;
comment|// server manager to deal with region server info
specifier|private
specifier|volatile
name|ServerManager
name|serverManager
decl_stmt|;
comment|// manager of assignment nodes in zookeeper
specifier|private
name|AssignmentManager
name|assignmentManager
decl_stmt|;
comment|// manager of replication
specifier|private
name|ReplicationPeerManager
name|replicationPeerManager
decl_stmt|;
specifier|private
name|SyncReplicationReplayWALManager
name|syncReplicationReplayWALManager
decl_stmt|;
comment|// buffer for "fatal error" notices from region servers
comment|// in the cluster. This is only used for assisting
comment|// operations/debugging.
name|MemoryBoundedLogMessageBuffer
name|rsFatals
decl_stmt|;
comment|// flag set after we become the active master (used for testing)
specifier|private
specifier|volatile
name|boolean
name|activeMaster
init|=
literal|false
decl_stmt|;
comment|// flag set after we complete initialization once active
specifier|private
specifier|final
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|initialized
init|=
operator|new
name|ProcedureEvent
argument_list|<>
argument_list|(
literal|"master initialized"
argument_list|)
decl_stmt|;
comment|// flag set after master services are started,
comment|// initialization may have not completed yet.
specifier|volatile
name|boolean
name|serviceStarted
init|=
literal|false
decl_stmt|;
comment|// Maximum time we should run balancer for
specifier|private
specifier|final
name|int
name|maxBlancingTime
decl_stmt|;
comment|// Maximum percent of regions in transition when balancing
specifier|private
specifier|final
name|double
name|maxRitPercent
decl_stmt|;
specifier|private
specifier|final
name|LockManager
name|lockManager
init|=
operator|new
name|LockManager
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|private
name|LoadBalancer
name|balancer
decl_stmt|;
specifier|private
name|RegionNormalizer
name|normalizer
decl_stmt|;
specifier|private
name|BalancerChore
name|balancerChore
decl_stmt|;
specifier|private
name|RegionNormalizerChore
name|normalizerChore
decl_stmt|;
specifier|private
name|ClusterStatusChore
name|clusterStatusChore
decl_stmt|;
specifier|private
name|ClusterStatusPublisher
name|clusterStatusPublisherChore
init|=
literal|null
decl_stmt|;
specifier|private
name|SnapshotCleanerChore
name|snapshotCleanerChore
init|=
literal|null
decl_stmt|;
specifier|private
name|HbckChore
name|hbckChore
decl_stmt|;
name|CatalogJanitor
name|catalogJanitorChore
decl_stmt|;
specifier|private
name|DirScanPool
name|cleanerPool
decl_stmt|;
specifier|private
name|LogCleaner
name|logCleaner
decl_stmt|;
specifier|private
name|HFileCleaner
name|hfileCleaner
decl_stmt|;
specifier|private
name|ReplicationBarrierCleaner
name|replicationBarrierCleaner
decl_stmt|;
specifier|private
name|ExpiredMobFileCleanerChore
name|expiredMobFileCleanerChore
decl_stmt|;
specifier|private
name|MobCompactionChore
name|mobCompactChore
decl_stmt|;
specifier|private
name|MasterMobCompactionThread
name|mobCompactThread
decl_stmt|;
comment|// used to synchronize the mobCompactionStates
specifier|private
specifier|final
name|IdLock
name|mobCompactionLock
init|=
operator|new
name|IdLock
argument_list|()
decl_stmt|;
comment|// save the information of mob compactions in tables.
comment|// the key is table name, the value is the number of compactions in that table.
specifier|private
name|Map
argument_list|<
name|TableName
argument_list|,
name|AtomicInteger
argument_list|>
name|mobCompactionStates
init|=
name|Maps
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
name|MasterCoprocessorHost
name|cpHost
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|preLoadTableDescriptors
decl_stmt|;
comment|// Time stamps for when a hmaster became active
specifier|private
name|long
name|masterActiveTime
decl_stmt|;
comment|// Time stamp for when HMaster finishes becoming Active Master
specifier|private
name|long
name|masterFinishedInitializationTime
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Service
argument_list|>
name|coprocessorServiceHandlers
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
comment|// monitor for snapshot of hbase tables
name|SnapshotManager
name|snapshotManager
decl_stmt|;
comment|// monitor for distributed procedures
specifier|private
name|MasterProcedureManagerHost
name|mpmHost
decl_stmt|;
specifier|private
name|RegionsRecoveryChore
name|regionsRecoveryChore
init|=
literal|null
decl_stmt|;
specifier|private
name|RegionsRecoveryConfigManager
name|regionsRecoveryConfigManager
init|=
literal|null
decl_stmt|;
comment|// it is assigned after 'initialized' guard set to true, so should be volatile
specifier|private
specifier|volatile
name|MasterQuotaManager
name|quotaManager
decl_stmt|;
specifier|private
name|SpaceQuotaSnapshotNotifier
name|spaceQuotaSnapshotNotifier
decl_stmt|;
specifier|private
name|QuotaObserverChore
name|quotaObserverChore
decl_stmt|;
specifier|private
name|SnapshotQuotaObserverChore
name|snapshotQuotaChore
decl_stmt|;
specifier|private
name|ProcedureExecutor
argument_list|<
name|MasterProcedureEnv
argument_list|>
name|procedureExecutor
decl_stmt|;
specifier|private
name|ProcedureStore
name|procedureStore
decl_stmt|;
comment|// handle table states
specifier|private
name|TableStateManager
name|tableStateManager
decl_stmt|;
specifier|private
name|long
name|splitPlanCount
decl_stmt|;
specifier|private
name|long
name|mergePlanCount
decl_stmt|;
comment|/* Handle favored nodes information */
specifier|private
name|FavoredNodesManager
name|favoredNodesManager
decl_stmt|;
comment|/** jetty server for master to redirect requests to regionserver infoServer */
specifier|private
name|Server
name|masterJettyServer
decl_stmt|;
comment|// Determine if we should do normal startup or minimal "single-user" mode with no region
comment|// servers and no user tables. Useful for repair and recovery of hbase:meta
specifier|private
specifier|final
name|boolean
name|maintenanceMode
decl_stmt|;
specifier|static
specifier|final
name|String
name|MAINTENANCE_MODE
init|=
literal|"hbase.master.maintenance_mode"
decl_stmt|;
comment|// Cached clusterId on stand by masters to serve clusterID requests from clients.
specifier|private
specifier|final
name|CachedClusterId
name|cachedClusterId
decl_stmt|;
specifier|public
specifier|static
class|class
name|RedirectServlet
extends|extends
name|HttpServlet
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2894774810058302473L
decl_stmt|;
specifier|private
specifier|final
name|int
name|regionServerInfoPort
decl_stmt|;
specifier|private
specifier|final
name|String
name|regionServerHostname
decl_stmt|;
comment|/**      * @param infoServer that we're trying to send all requests to      * @param hostname may be null. if given, will be used for redirects instead of host from client.      */
specifier|public
name|RedirectServlet
parameter_list|(
name|InfoServer
name|infoServer
parameter_list|,
name|String
name|hostname
parameter_list|)
block|{
name|regionServerInfoPort
operator|=
name|infoServer
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|regionServerHostname
operator|=
name|hostname
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|doGet
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|)
throws|throws
name|ServletException
throws|,
name|IOException
block|{
name|String
name|redirectHost
init|=
name|regionServerHostname
decl_stmt|;
if|if
condition|(
name|redirectHost
operator|==
literal|null
condition|)
block|{
name|redirectHost
operator|=
name|request
operator|.
name|getServerName
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Addressing
operator|.
name|isLocalAddress
argument_list|(
name|InetAddress
operator|.
name|getByName
argument_list|(
name|redirectHost
argument_list|)
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't resolve '"
operator|+
name|redirectHost
operator|+
literal|"' as an address local to this node and '"
operator|+
name|MASTER_HOSTNAME_KEY
operator|+
literal|"' is not set; client will get an HTTP 400 response. If "
operator|+
literal|"your HBase deployment relies on client accessible names that the region server process "
operator|+
literal|"can't resolve locally, then you should set the previously mentioned configuration variable "
operator|+
literal|"to an appropriate hostname."
argument_list|)
expr_stmt|;
comment|// no sending client provided input back to the client, so the goal host is just in the logs.
name|response
operator|.
name|sendError
argument_list|(
literal|400
argument_list|,
literal|"Request was to a host that I can't resolve for any of the network interfaces on "
operator|+
literal|"this node. If this is due to an intermediary such as an HTTP load balancer or other proxy, your HBase "
operator|+
literal|"administrator can set '"
operator|+
name|MASTER_HOSTNAME_KEY
operator|+
literal|"' to point to the correct hostname."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// TODO this scheme should come from looking at the scheme registered in the infoserver's http server for the
comment|// host and port we're using, but it's buried way too deep to do that ATM.
name|String
name|redirectUrl
init|=
name|request
operator|.
name|getScheme
argument_list|()
operator|+
literal|"://"
operator|+
name|redirectHost
operator|+
literal|":"
operator|+
name|regionServerInfoPort
operator|+
name|request
operator|.
name|getRequestURI
argument_list|()
decl_stmt|;
name|response
operator|.
name|sendRedirect
argument_list|(
name|redirectUrl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Initializes the HMaster. The steps are as follows:    *<p>    *<ol>    *<li>Initialize the local HRegionServer    *<li>Start the ActiveMasterManager.    *</ol>    *<p>    * Remaining steps of initialization occur in    * #finishActiveMasterInitialization(MonitoredTask) after    * the master becomes the active one.    */
specifier|public
name|HMaster
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|TraceUtil
operator|.
name|initTracer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|MAINTENANCE_MODE
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Detected {}=true via configuration."
argument_list|,
name|MAINTENANCE_MODE
argument_list|)
expr_stmt|;
name|maintenanceMode
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Boolean
operator|.
name|getBoolean
argument_list|(
name|MAINTENANCE_MODE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Detected {}=true via environment variables."
argument_list|,
name|MAINTENANCE_MODE
argument_list|)
expr_stmt|;
name|maintenanceMode
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|maintenanceMode
operator|=
literal|false
expr_stmt|;
block|}
name|this
operator|.
name|rsFatals
operator|=
operator|new
name|MemoryBoundedLogMessageBuffer
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.master.buffer.for.rs.fatals"
argument_list|,
literal|1
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"hbase.rootdir={}, hbase.cluster.distributed={}"
argument_list|,
name|getDataRootDir
argument_list|()
argument_list|,
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|CLUSTER_DISTRIBUTED
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Disable usage of meta replicas in the master
name|this
operator|.
name|conf
operator|.
name|setBoolean
argument_list|(
name|HConstants
operator|.
name|USE_META_REPLICAS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|decorateMasterConfiguration
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// Hack! Maps DFSClient => Master for logs.  HDFS made this
comment|// config param for task trackers, but we can piggyback off of it.
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"mapreduce.task.attempt.id"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"mapreduce.task.attempt.id"
argument_list|,
literal|"hb_m_"
operator|+
name|this
operator|.
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|metricsMaster
operator|=
operator|new
name|MetricsMaster
argument_list|(
operator|new
name|MetricsMasterWrapperImpl
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|// preload table descriptor at startup
name|this
operator|.
name|preLoadTableDescriptors
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.preload.tabledescriptors"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxBlancingTime
operator|=
name|getMaxBalancingTime
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxRitPercent
operator|=
name|conf
operator|.
name|getDouble
argument_list|(
name|HConstants
operator|.
name|HBASE_MASTER_BALANCER_MAX_RIT_PERCENT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_MASTER_BALANCER_MAX_RIT_PERCENT
argument_list|)
expr_stmt|;
comment|// Do we publish the status?
name|boolean
name|shouldPublish
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|STATUS_PUBLISHED
argument_list|,
name|HConstants
operator|.
name|STATUS_PUBLISHED_DEFAULT
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|ClusterStatusPublisher
operator|.
name|Publisher
argument_list|>
name|publisherClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|ClusterStatusPublisher
operator|.
name|STATUS_PUBLISHER_CLASS
argument_list|,
name|ClusterStatusPublisher
operator|.
name|DEFAULT_STATUS_PUBLISHER_CLASS
argument_list|,
name|ClusterStatusPublisher
operator|.
name|Publisher
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldPublish
condition|)
block|{
if|if
condition|(
name|publisherClass
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|HConstants
operator|.
name|STATUS_PUBLISHED
operator|+
literal|" is true, but "
operator|+
name|ClusterStatusPublisher
operator|.
name|DEFAULT_STATUS_PUBLISHER_CLASS
operator|+
literal|" is not set - not publishing status"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clusterStatusPublisherChore
operator|=
operator|new
name|ClusterStatusPublisher
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|publisherClass
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|clusterStatusPublisherChore
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Some unit tests don't need a cluster, so no zookeeper at all
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.testing.nocluster"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|this
operator|.
name|activeMasterManager
operator|=
operator|new
name|ActiveMasterManager
argument_list|(
name|zooKeeper
argument_list|,
name|this
operator|.
name|serverName
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|activeMasterManager
operator|=
literal|null
expr_stmt|;
block|}
name|cachedClusterId
operator|=
operator|new
name|CachedClusterId
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Make sure we log the exception. HMaster is often started via reflection and the
comment|// cause of failed startup is lost.
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed construction of Master"
argument_list|,
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getUseThisHostnameInstead
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|get
argument_list|(
name|MASTER_HOSTNAME_KEY
argument_list|)
return|;
block|}
comment|// Main run loop. Calls through to the regionserver run loop AFTER becoming active Master; will
comment|// block in here until then.
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.testing.nocluster"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
operator|new
name|Thread
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
name|int
name|infoPort
init|=
name|putUpJettyServer
argument_list|()
decl_stmt|;
name|startActiveMasterManager
argument_list|(
name|infoPort
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Make sure we log the exception.
name|String
name|error
init|=
literal|"Failed to become Active Master"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|error
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// Abort should have been called already.
if|if
condition|(
operator|!
name|isAborted
argument_list|()
condition|)
block|{
name|abort
argument_list|(
name|error
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
argument_list|,
name|getName
argument_list|()
operator|+
literal|":becomeActiveMaster"
argument_list|)
expr_stmt|;
block|}
comment|// Fall in here even if we have been aborted. Need to run the shutdown services and
comment|// the super run call will do this for us.
name|super
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|this
operator|.
name|clusterSchemaService
operator|!=
literal|null
condition|)
block|{
comment|// If on way out, then we are no longer active master.
name|this
operator|.
name|clusterSchemaService
operator|.
name|stopAsync
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|clusterSchemaService
operator|.
name|awaitTerminated
argument_list|(
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|HBASE_MASTER_WAIT_ON_SERVICE_IN_SECONDS
argument_list|,
name|DEFAULT_HBASE_MASTER_WAIT_ON_SERVICE_IN_SECONDS
argument_list|)
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|te
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed shutdown of clusterSchemaService"
argument_list|,
name|te
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|activeMaster
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// return the actual infoPort, -1 means disable info server.
specifier|private
name|int
name|putUpJettyServer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.infoserver.redirect"
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
specifier|final
name|int
name|infoPort
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.info.port.orig"
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_INFOPORT
argument_list|)
decl_stmt|;
comment|// -1 is for disabling info server, so no redirecting
if|if
condition|(
name|infoPort
operator|<
literal|0
operator|||
name|infoServer
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|infoPort
operator|==
name|infoServer
operator|.
name|getPort
argument_list|()
condition|)
block|{
return|return
name|infoPort
return|;
block|}
specifier|final
name|String
name|addr
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.master.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Addressing
operator|.
name|isLocalAddress
argument_list|(
name|InetAddress
operator|.
name|getByName
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Failed to start redirecting jetty server. Address "
operator|+
name|addr
operator|+
literal|" does not belong to this host. Correct configuration parameter: "
operator|+
literal|"hbase.master.info.bindAddress"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|// TODO I'm pretty sure we could just add another binding to the InfoServer run by
comment|// the RegionServer and have it run the RedirectServlet instead of standing up
comment|// a second entire stack here.
name|masterJettyServer
operator|=
operator|new
name|Server
argument_list|()
expr_stmt|;
specifier|final
name|ServerConnector
name|connector
init|=
operator|new
name|ServerConnector
argument_list|(
name|masterJettyServer
argument_list|)
decl_stmt|;
name|connector
operator|.
name|setHost
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|connector
operator|.
name|setPort
argument_list|(
name|infoPort
argument_list|)
expr_stmt|;
name|masterJettyServer
operator|.
name|addConnector
argument_list|(
name|connector
argument_list|)
expr_stmt|;
name|masterJettyServer
operator|.
name|setStopAtShutdown
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|String
name|redirectHostname
init|=
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|useThisHostnameInstead
argument_list|)
condition|?
literal|null
else|:
name|useThisHostnameInstead
decl_stmt|;
specifier|final
name|RedirectServlet
name|redirect
init|=
operator|new
name|RedirectServlet
argument_list|(
name|infoServer
argument_list|,
name|redirectHostname
argument_list|)
decl_stmt|;
specifier|final
name|WebAppContext
name|context
init|=
operator|new
name|WebAppContext
argument_list|(
literal|null
argument_list|,
literal|"/"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|WebAppContext
operator|.
name|NO_SESSIONS
argument_list|)
decl_stmt|;
name|context
operator|.
name|addServlet
argument_list|(
operator|new
name|ServletHolder
argument_list|(
name|redirect
argument_list|)
argument_list|,
literal|"/*"
argument_list|)
expr_stmt|;
name|context
operator|.
name|setServer
argument_list|(
name|masterJettyServer
argument_list|)
expr_stmt|;
try|try
block|{
name|masterJettyServer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to start redirecting jetty server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|connector
operator|.
name|getLocalPort
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Function
argument_list|<
name|TableDescriptorBuilder
argument_list|,
name|TableDescriptorBuilder
argument_list|>
name|getMetaTableObserver
parameter_list|()
block|{
return|return
name|builder
lambda|->
name|builder
operator|.
name|setRegionReplication
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|META_REPLICAS_NUM
argument_list|,
name|HConstants
operator|.
name|DEFAULT_META_REPLICA_NUM
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * For compatibility, if failed with regionserver credentials, try the master one    */
annotation|@
name|Override
specifier|protected
name|void
name|login
parameter_list|(
name|UserProvider
name|user
parameter_list|,
name|String
name|host
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|super
operator|.
name|login
argument_list|(
name|user
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|user
operator|.
name|login
argument_list|(
name|SecurityConstants
operator|.
name|MASTER_KRB_KEYTAB_FILE
argument_list|,
name|SecurityConstants
operator|.
name|MASTER_KRB_PRINCIPAL
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * If configured to put regions on active master,    * wait till a backup master becomes active.    * Otherwise, loop till the server is stopped or aborted.    */
annotation|@
name|Override
specifier|protected
name|void
name|waitForMasterActive
parameter_list|()
block|{
if|if
condition|(
name|maintenanceMode
condition|)
block|{
return|return;
block|}
name|boolean
name|tablesOnMaster
init|=
name|LoadBalancer
operator|.
name|isTablesOnMaster
argument_list|(
name|conf
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|tablesOnMaster
operator|&&
name|activeMaster
operator|)
operator|&&
operator|!
name|isStopped
argument_list|()
operator|&&
operator|!
name|isAborted
argument_list|()
condition|)
block|{
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|MasterRpcServices
name|getMasterRpcServices
parameter_list|()
block|{
return|return
operator|(
name|MasterRpcServices
operator|)
name|rpcServices
return|;
block|}
specifier|public
name|boolean
name|balanceSwitch
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getMasterRpcServices
argument_list|()
operator|.
name|switchBalancer
argument_list|(
name|b
argument_list|,
name|BalanceSwitchMode
operator|.
name|ASYNC
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getProcessName
parameter_list|()
block|{
return|return
name|MASTER
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|canCreateBaseZNode
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|canUpdateTableDescriptor
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RSRpcServices
name|createRpcServices
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|MasterRpcServices
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|configureInfoServer
parameter_list|()
block|{
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|"master-status"
argument_list|,
literal|"/master-status"
argument_list|,
name|MasterStatusServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
name|MASTER
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|LoadBalancer
operator|.
name|isTablesOnMaster
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|super
operator|.
name|configureInfoServer
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|Class
argument_list|<
name|?
extends|extends
name|HttpServlet
argument_list|>
name|getDumpServlet
parameter_list|()
block|{
return|return
name|MasterDumpServlet
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|MetricsMaster
name|getMasterMetrics
parameter_list|()
block|{
return|return
name|metricsMaster
return|;
block|}
comment|/**    *<p>    * Initialize all ZK based system trackers. But do not include {@link RegionServerTracker}, it    * should have already been initialized along with {@link ServerManager}.    *</p>    *<p>    * Will be overridden in tests.    *</p>    */
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|initializeZKBasedSystemTrackers
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
throws|,
name|ReplicationException
block|{
name|this
operator|.
name|balancer
operator|=
name|LoadBalancerFactory
operator|.
name|getLoadBalancer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|normalizer
operator|=
name|RegionNormalizerFactory
operator|.
name|getRegionNormalizer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|normalizer
operator|.
name|setMasterServices
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|normalizer
operator|.
name|setMasterRpcServices
argument_list|(
operator|(
name|MasterRpcServices
operator|)
name|rpcServices
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadBalancerTracker
operator|=
operator|new
name|LoadBalancerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadBalancerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionNormalizerTracker
operator|=
operator|new
name|RegionNormalizerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionNormalizerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|splitOrMergeTracker
operator|=
operator|new
name|SplitOrMergeTracker
argument_list|(
name|zooKeeper
argument_list|,
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|splitOrMergeTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|replicationPeerManager
operator|=
name|ReplicationPeerManager
operator|.
name|create
argument_list|(
name|zooKeeper
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|drainingServerTracker
operator|=
operator|new
name|DrainingServerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|serverManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|drainingServerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|snapshotCleanupTracker
operator|=
operator|new
name|SnapshotCleanupTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotCleanupTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|String
name|clientQuorumServers
init|=
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|CLIENT_ZOOKEEPER_QUORUM
argument_list|)
decl_stmt|;
name|boolean
name|clientZkObserverMode
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|CLIENT_ZOOKEEPER_OBSERVER_MODE
argument_list|,
name|HConstants
operator|.
name|DEFAULT_CLIENT_ZOOKEEPER_OBSERVER_MODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|clientQuorumServers
operator|!=
literal|null
operator|&&
operator|!
name|clientZkObserverMode
condition|)
block|{
comment|// we need to take care of the ZK information synchronization
comment|// if given client ZK are not observer nodes
name|ZKWatcher
name|clientZkWatcher
init|=
operator|new
name|ZKWatcher
argument_list|(
name|conf
argument_list|,
name|getProcessName
argument_list|()
operator|+
literal|":"
operator|+
name|rpcServices
operator|.
name|getSocketAddress
argument_list|()
operator|.
name|getPort
argument_list|()
operator|+
literal|"-clientZK"
argument_list|,
name|this
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|this
operator|.
name|metaLocationSyncer
operator|=
operator|new
name|MetaLocationSyncer
argument_list|(
name|zooKeeper
argument_list|,
name|clientZkWatcher
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|metaLocationSyncer
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|masterAddressSyncer
operator|=
operator|new
name|MasterAddressSyncer
argument_list|(
name|zooKeeper
argument_list|,
name|clientZkWatcher
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterAddressSyncer
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// set cluster id is a one-go effort
name|ZKClusterId
operator|.
name|setClusterId
argument_list|(
name|clientZkWatcher
argument_list|,
name|fileSystemManager
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Set the cluster as up.  If new RSs, they'll be waiting on this before
comment|// going ahead with their startup.
name|boolean
name|wasUp
init|=
name|this
operator|.
name|clusterStatusTracker
operator|.
name|isClusterUp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|wasUp
condition|)
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterUp
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Active/primary master="
operator|+
name|this
operator|.
name|serverName
operator|+
literal|", sessionid=0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getSessionId
argument_list|()
argument_list|)
operator|+
literal|", setting cluster-up flag (Was="
operator|+
name|wasUp
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// create/initialize the snapshot manager and other procedure managers
name|this
operator|.
name|snapshotManager
operator|=
operator|new
name|SnapshotManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|=
operator|new
name|MasterProcedureManagerHost
argument_list|()
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|register
argument_list|(
name|this
operator|.
name|snapshotManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|register
argument_list|(
operator|new
name|MasterFlushTableProcedureManager
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|loadProcedures
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|initialize
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|metricsMaster
argument_list|)
expr_stmt|;
block|}
comment|// Will be overriden in test to inject customized AssignmentManager
annotation|@
name|VisibleForTesting
specifier|protected
name|AssignmentManager
name|createAssignmentManager
parameter_list|(
name|MasterServices
name|master
parameter_list|)
block|{
return|return
operator|new
name|AssignmentManager
argument_list|(
name|master
argument_list|)
return|;
block|}
comment|/**    * Finish initialization of HMaster after becoming the primary master.    *<p/>    * The startup order is a bit complicated but very important, do not change it unless you know    * what you are doing.    *<ol>    *<li>Initialize file system based components - file system manager, wal manager, table    * descriptors, etc</li>    *<li>Publish cluster id</li>    *<li>Here comes the most complicated part - initialize server manager, assignment manager and    * region server tracker    *<ol type='i'>    *<li>Create server manager</li>    *<li>Create procedure executor, load the procedures, but do not start workers. We will start it    * later after we finish scheduling SCPs to avoid scheduling duplicated SCPs for the same    * server</li>    *<li>Create assignment manager and start it, load the meta region state, but do not load data    * from meta region</li>    *<li>Start region server tracker, construct the online servers set and find out dead servers and    * schedule SCP for them. The online servers will be constructed by scanning zk, and we will also    * scan the wal directory to find out possible live region servers, and the differences between    * these two sets are the dead servers</li>    *</ol>    *</li>    *<li>If this is a new deploy, schedule a InitMetaProcedure to initialize meta</li>    *<li>Start necessary service threads - balancer, catalog janior, executor services, and also the    * procedure executor, etc. Notice that the balancer must be created first as assignment manager    * may use it when assigning regions.</li>    *<li>Wait for meta to be initialized if necesssary, start table state manager.</li>    *<li>Wait for enough region servers to check-in</li>    *<li>Let assignment manager load data from meta and construct region states</li>    *<li>Start all other things such as chore services, etc</li>    *</ol>    *<p/>    * Notice that now we will not schedule a special procedure to make meta online(unless the first    * time where meta has not been created yet), we will rely on SCP to bring meta online.    */
specifier|private
name|void
name|finishActiveMasterInitialization
parameter_list|(
name|MonitoredTask
name|status
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
throws|,
name|ReplicationException
block|{
comment|/*      * We are active master now... go initialize components we need to run.      */
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing Master file system"
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterActiveTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// TODO: Do this using Dependency Injection, using PicoContainer, Guice or Spring.
comment|// always initialize the MemStoreLAB as we use a region to store procedure now.
name|initializeMemStoreChunkCreator
argument_list|()
expr_stmt|;
name|this
operator|.
name|fileSystemManager
operator|=
operator|new
name|MasterFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|walManager
operator|=
operator|new
name|MasterWalManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// enable table descriptors cache
name|this
operator|.
name|tableDescriptors
operator|.
name|setCacheOn
argument_list|()
expr_stmt|;
comment|// warm-up HTDs cache on master initialization
if|if
condition|(
name|preLoadTableDescriptors
condition|)
block|{
name|status
operator|.
name|setStatus
argument_list|(
literal|"Pre-loading table descriptors"
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableDescriptors
operator|.
name|getAll
argument_list|()
expr_stmt|;
block|}
comment|// Publish cluster ID; set it in Master too. The superclass RegionServer does this later but
comment|// only after it has checked in with the Master. At least a few tests ask Master for clusterId
comment|// before it has called its run method and before RegionServer has done the reportForDuty.
name|ClusterId
name|clusterId
init|=
name|fileSystemManager
operator|.
name|getClusterId
argument_list|()
decl_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Publishing Cluster ID "
operator|+
name|clusterId
operator|+
literal|" in ZooKeeper"
argument_list|)
expr_stmt|;
name|ZKClusterId
operator|.
name|setClusterId
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|fileSystemManager
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterId
operator|=
name|clusterId
operator|.
name|toString
argument_list|()
expr_stmt|;
comment|// Precaution. Put in place the old hbck1 lock file to fence out old hbase1s running their
comment|// hbck1s against an hbase2 cluster; it could do damage. To skip this behavior, set
comment|// hbase.write.hbck1.lock.file to false.
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.write.hbck1.lock.file"
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|HBaseFsck
operator|.
name|checkAndMarkRunningHbck
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|HBaseFsck
operator|.
name|createLockRetryCounterFactory
argument_list|(
name|this
operator|.
name|conf
argument_list|)
operator|.
name|create
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initialize ServerManager and schedule SCP for crash servers"
argument_list|)
expr_stmt|;
comment|// The below two managers must be created before loading procedures, as they will be used during
comment|// loading.
name|this
operator|.
name|serverManager
operator|=
name|createServerManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|syncReplicationReplayWALManager
operator|=
operator|new
name|SyncReplicationReplayWALManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|HBASE_SPLIT_WAL_COORDINATED_BY_ZK
argument_list|,
name|DEFAULT_HBASE_SPLIT_COORDINATED_BY_ZK
argument_list|)
condition|)
block|{
name|this
operator|.
name|splitWALManager
operator|=
operator|new
name|SplitWALManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|createProcedureExecutor
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|List
argument_list|<
name|Procedure
argument_list|<
name|MasterProcedureEnv
argument_list|>
argument_list|>
argument_list|>
name|procsByType
init|=
name|procedureExecutor
operator|.
name|getActiveProceduresNoCopy
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|groupingBy
argument_list|(
name|p
lambda|->
name|p
operator|.
name|getClass
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// Create Assignment Manager
name|this
operator|.
name|assignmentManager
operator|=
name|createAssignmentManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// TODO: TRSP can perform as the sub procedure for other procedures, so even if it is marked as
comment|// completed, it could still be in the procedure list. This is a bit strange but is another
comment|// story, need to verify the implementation for ProcedureExecutor and ProcedureStore.
name|List
argument_list|<
name|TransitRegionStateProcedure
argument_list|>
name|ritList
init|=
name|procsByType
operator|.
name|getOrDefault
argument_list|(
name|TransitRegionStateProcedure
operator|.
name|class
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|p
lambda|->
operator|!
name|p
operator|.
name|isFinished
argument_list|()
argument_list|)
operator|.
name|map
argument_list|(
name|p
lambda|->
operator|(
name|TransitRegionStateProcedure
operator|)
name|p
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|setupRIT
argument_list|(
name|ritList
argument_list|)
expr_stmt|;
comment|// Start RegionServerTracker with listing of servers found with exiting SCPs -- these should
comment|// be registered in the deadServers set -- and with the list of servernames out on the
comment|// filesystem that COULD BE 'alive' (we'll schedule SCPs for each and let SCP figure it out).
comment|// We also pass dirs that are already 'splitting'... so we can do some checks down in tracker.
comment|// TODO: Generate the splitting and live Set in one pass instead of two as we currently do.
name|this
operator|.
name|regionServerTracker
operator|=
operator|new
name|RegionServerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|serverManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServerTracker
operator|.
name|start
argument_list|(
name|procsByType
operator|.
name|getOrDefault
argument_list|(
name|ServerCrashProcedure
operator|.
name|class
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|p
lambda|->
operator|(
name|ServerCrashProcedure
operator|)
name|p
argument_list|)
operator|.
name|map
argument_list|(
name|p
lambda|->
name|p
operator|.
name|getServerName
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toSet
argument_list|()
argument_list|)
argument_list|,
name|walManager
operator|.
name|getLiveServersFromWALDir
argument_list|()
argument_list|,
name|walManager
operator|.
name|getSplittingServersFromWALDir
argument_list|()
argument_list|)
expr_stmt|;
comment|// This manager will be started AFTER hbase:meta is confirmed on line.
comment|// hbase.mirror.table.state.to.zookeeper is so hbase1 clients can connect. They read table
comment|// state from zookeeper while hbase2 reads it from hbase:meta. Disable if no hbase1 clients.
name|this
operator|.
name|tableStateManager
operator|=
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
name|MirroringTableStateManager
operator|.
name|MIRROR_TABLE_STATE_TO_ZK_KEY
argument_list|,
literal|true
argument_list|)
condition|?
operator|new
name|MirroringTableStateManager
argument_list|(
name|this
argument_list|)
else|:
operator|new
name|TableStateManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing ZK system trackers"
argument_list|)
expr_stmt|;
name|initializeZKBasedSystemTrackers
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Loading last flushed sequence id of regions"
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|serverManager
operator|.
name|loadLastFlushedSequenceIds
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to load last flushed sequence id of regions"
operator|+
literal|" from file system"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Set ourselves as active Master now our claim has succeeded up in zk.
name|this
operator|.
name|activeMaster
operator|=
literal|true
expr_stmt|;
comment|// Start the Zombie master detector after setting master as active, see HBASE-21535
name|Thread
name|zombieDetector
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|InitializationMonitor
argument_list|(
name|this
argument_list|)
argument_list|,
literal|"ActiveMasterInitializationMonitor-"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
name|zombieDetector
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|zombieDetector
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// This is for backwards compatibility
comment|// See HBASE-11393
name|status
operator|.
name|setStatus
argument_list|(
literal|"Update TableCFs node in ZNode"
argument_list|)
expr_stmt|;
name|ReplicationPeerConfigUpgrader
name|tableCFsUpdater
init|=
operator|new
name|ReplicationPeerConfigUpgrader
argument_list|(
name|zooKeeper
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|tableCFsUpdater
operator|.
name|copyTableCFs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|maintenanceMode
condition|)
block|{
comment|// Add the Observer to delete quotas on table deletion before starting all CPs by
comment|// default with quota support, avoiding if user specifically asks to not load this Observer.
if|if
condition|(
name|QuotaUtil
operator|.
name|isQuotaEnabled
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|updateConfigurationForQuotasObserver
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// initialize master side coprocessors before we start handling requests
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing master coprocessors"
argument_list|)
expr_stmt|;
name|this
operator|.
name|cpHost
operator|=
operator|new
name|MasterCoprocessorHost
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// Checking if meta needs initializing.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing meta table if this is a new deploy"
argument_list|)
expr_stmt|;
name|InitMetaProcedure
name|initMetaProc
init|=
literal|null
decl_stmt|;
comment|// Print out state of hbase:meta on startup; helps debugging.
name|RegionState
name|rs
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionState
argument_list|(
name|RegionInfoBuilder
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"hbase:meta {}"
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|!=
literal|null
operator|&&
name|rs
operator|.
name|isOffline
argument_list|()
condition|)
block|{
name|Optional
argument_list|<
name|InitMetaProcedure
argument_list|>
name|optProc
init|=
name|procedureExecutor
operator|.
name|getProcedures
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|p
lambda|->
name|p
operator|instanceof
name|InitMetaProcedure
argument_list|)
operator|.
name|map
argument_list|(
name|o
lambda|->
operator|(
name|InitMetaProcedure
operator|)
name|o
argument_list|)
operator|.
name|findAny
argument_list|()
decl_stmt|;
name|initMetaProc
operator|=
name|optProc
operator|.
name|orElseGet
argument_list|(
parameter_list|()
lambda|->
block|{
comment|// schedule an init meta procedure if meta has not been deployed yet
name|InitMetaProcedure
name|temp
init|=
operator|new
name|InitMetaProcedure
argument_list|()
decl_stmt|;
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|balancer
operator|instanceof
name|FavoredNodesPromoter
condition|)
block|{
name|favoredNodesManager
operator|=
operator|new
name|FavoredNodesManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// initialize load balancer
name|this
operator|.
name|balancer
operator|.
name|setMasterServices
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|.
name|setClusterMetrics
argument_list|(
name|getClusterMetricsWithoutCoprocessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|.
name|initialize
argument_list|()
expr_stmt|;
comment|// start up all service threads.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing master service threads"
argument_list|)
expr_stmt|;
name|startServiceThreads
argument_list|()
expr_stmt|;
comment|// wait meta to be initialized after we start procedure executor
if|if
condition|(
name|initMetaProc
operator|!=
literal|null
condition|)
block|{
name|initMetaProc
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
comment|// Wake up this server to check in
name|sleeper
operator|.
name|skipSleepCycle
argument_list|()
expr_stmt|;
comment|// Wait for region servers to report in.
comment|// With this as part of master initialization, it precludes our being able to start a single
comment|// server that is both Master and RegionServer. Needs more thought. TODO.
name|String
name|statusStr
init|=
literal|"Wait for region servers to report in"
decl_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
name|statusStr
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|Objects
operator|.
name|toString
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|waitForRegionServers
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// Check if master is shutting down because issue initializing regionservers or balancer.
if|if
condition|(
name|isStopped
argument_list|()
condition|)
block|{
return|return;
block|}
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting assignment manager"
argument_list|)
expr_stmt|;
comment|// FIRST HBASE:META READ!!!!
comment|// The below cannot make progress w/o hbase:meta being online.
comment|// This is the FIRST attempt at going to hbase:meta. Meta on-lining is going on in background
comment|// as procedures run -- in particular SCPs for crashed servers... One should put up hbase:meta
comment|// if it is down. It may take a while to come online. So, wait here until meta if for sure
comment|// available. That's what waitForMetaOnline does.
if|if
condition|(
operator|!
name|waitForMetaOnline
argument_list|()
condition|)
block|{
return|return;
block|}
name|this
operator|.
name|assignmentManager
operator|.
name|joinCluster
argument_list|()
expr_stmt|;
comment|// The below depends on hbase:meta being online.
name|this
operator|.
name|tableStateManager
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Below has to happen after tablestatemanager has started in the case where this hbase-2.x
comment|// is being started over an hbase-1.x dataset. tablestatemanager runs a migration as part
comment|// of its 'start' moving table state from zookeeper to hbase:meta. This migration needs to
comment|// complete before we do this next step processing offline regions else it fails reading
comment|// table states messing up master launch (namespace table, etc., are not assigned).
name|this
operator|.
name|assignmentManager
operator|.
name|processOfflineRegions
argument_list|()
expr_stmt|;
comment|// Initialize after meta is up as below scans meta
if|if
condition|(
name|favoredNodesManager
operator|!=
literal|null
operator|&&
operator|!
name|maintenanceMode
condition|)
block|{
name|SnapshotOfRegionAssignmentFromMeta
name|snapshotOfRegionAssignment
init|=
operator|new
name|SnapshotOfRegionAssignmentFromMeta
argument_list|(
name|getConnection
argument_list|()
argument_list|)
decl_stmt|;
name|snapshotOfRegionAssignment
operator|.
name|initialize
argument_list|()
expr_stmt|;
name|favoredNodesManager
operator|.
name|initialize
argument_list|(
name|snapshotOfRegionAssignment
argument_list|)
expr_stmt|;
block|}
comment|// set cluster status again after user regions are assigned
name|this
operator|.
name|balancer
operator|.
name|setClusterMetrics
argument_list|(
name|getClusterMetricsWithoutCoprocessor
argument_list|()
argument_list|)
expr_stmt|;
comment|// Start balancer and meta catalog janitor after meta and regions have been assigned.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting balancer and catalog janitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterStatusChore
operator|=
operator|new
name|ClusterStatusChore
argument_list|(
name|this
argument_list|,
name|balancer
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|clusterStatusChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancerChore
operator|=
operator|new
name|BalancerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|balancerChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|normalizerChore
operator|=
operator|new
name|RegionNormalizerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|normalizerChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|catalogJanitorChore
operator|=
operator|new
name|CatalogJanitor
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|catalogJanitorChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|hbckChore
operator|=
operator|new
name|HbckChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|hbckChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverManager
operator|.
name|startChore
argument_list|()
expr_stmt|;
comment|// Only for rolling upgrade, where we need to migrate the data in namespace table to meta table.
if|if
condition|(
operator|!
name|waitForNamespaceOnline
argument_list|()
condition|)
block|{
return|return;
block|}
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting cluster schema service"
argument_list|)
expr_stmt|;
name|initClusterSchemaService
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|preMasterInitialization
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor preMasterInitialization() hook failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|status
operator|.
name|markComplete
argument_list|(
literal|"Initialization successful"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Master has completed initialization %.3fsec"
argument_list|,
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|masterActiveTime
operator|)
operator|/
literal|1000.0f
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterFinishedInitializationTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
operator|.
name|balancer
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
operator|.
name|cleanerPool
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
operator|.
name|hfileCleaner
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
operator|.
name|logCleaner
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
operator|.
name|regionsRecoveryConfigManager
argument_list|)
expr_stmt|;
comment|// Set master as 'initialized'.
name|setInitialized
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|maintenanceMode
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Detected repair mode, skipping final initialization steps."
argument_list|)
expr_stmt|;
return|return;
block|}
name|assignmentManager
operator|.
name|checkIfShouldMoveSystemRegionAsync
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Assign meta replicas"
argument_list|)
expr_stmt|;
name|MasterMetaBootstrap
name|metaBootstrap
init|=
name|createMetaBootstrap
argument_list|()
decl_stmt|;
name|metaBootstrap
operator|.
name|assignMetaReplicas
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting quota manager"
argument_list|)
expr_stmt|;
name|initQuotaManager
argument_list|()
expr_stmt|;
if|if
condition|(
name|QuotaUtil
operator|.
name|isQuotaEnabled
argument_list|(
name|conf
argument_list|)
condition|)
block|{
comment|// Create the quota snapshot notifier
name|spaceQuotaSnapshotNotifier
operator|=
name|createQuotaSnapshotNotifier
argument_list|()
expr_stmt|;
name|spaceQuotaSnapshotNotifier
operator|.
name|initialize
argument_list|(
name|getConnection
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|quotaObserverChore
operator|=
operator|new
name|QuotaObserverChore
argument_list|(
name|this
argument_list|,
name|getMasterMetrics
argument_list|()
argument_list|)
expr_stmt|;
comment|// Start the chore to read the region FS space reports and act on them
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|quotaObserverChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotQuotaChore
operator|=
operator|new
name|SnapshotQuotaObserverChore
argument_list|(
name|this
argument_list|,
name|getMasterMetrics
argument_list|()
argument_list|)
expr_stmt|;
comment|// Start the chore to read snapshots and add their usage to table/NS quotas
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|snapshotQuotaChore
argument_list|)
expr_stmt|;
block|}
comment|// clear the dead servers with same host name and port of online server because we are not
comment|// removing dead server with same hostname and port of rs which is trying to check in before
comment|// master initialization. See HBASE-5916.
name|this
operator|.
name|serverManager
operator|.
name|clearDeadServersWithSameHostNameAndPortOfOnlineServer
argument_list|()
expr_stmt|;
comment|// Check and set the znode ACLs if needed in case we are overtaking a non-secure configuration
name|status
operator|.
name|setStatus
argument_list|(
literal|"Checking ZNode ACLs"
argument_list|)
expr_stmt|;
name|zooKeeper
operator|.
name|checkAndSetZNodeAcls
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing MOB Cleaner"
argument_list|)
expr_stmt|;
name|initMobCleaner
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Calling postStartMaster coprocessors"
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
comment|// don't let cp initialization errors kill the master
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|postStartMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor postStartMaster() hook failed"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
name|zombieDetector
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|/*      * After master has started up, lets do balancer post startup initialization. Since this runs      * in activeMasterManager thread, it should be fine.      */
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|this
operator|.
name|balancer
operator|.
name|postMasterStartupInitialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Balancer post startup initialization complete, took "
operator|+
operator|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|/
literal|1000
operator|)
operator|+
literal|" seconds"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Check hbase:meta is up and ready for reading. For use during Master startup only.    * @return True if meta is UP and online and startup can progress. Otherwise, meta is not online    *   and we will hold here until operator intervention.    */
annotation|@
name|VisibleForTesting
specifier|public
name|boolean
name|waitForMetaOnline
parameter_list|()
throws|throws
name|InterruptedException
block|{
return|return
name|isRegionOnline
argument_list|(
name|RegionInfoBuilder
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
return|;
block|}
comment|/**    * @return True if region is online and scannable else false if an error or shutdown (Otherwise    *   we just block in here holding up all forward-progess).    */
specifier|private
name|boolean
name|isRegionOnline
parameter_list|(
name|RegionInfo
name|ri
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|RetryCounter
name|rc
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|!
name|isStopped
argument_list|()
condition|)
block|{
name|RegionState
name|rs
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionState
argument_list|(
name|ri
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|isOpened
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|getServerManager
argument_list|()
operator|.
name|isServerOnline
argument_list|(
name|rs
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// Region is not OPEN.
name|Optional
argument_list|<
name|Procedure
argument_list|<
name|MasterProcedureEnv
argument_list|>
argument_list|>
name|optProc
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|getProcedures
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|p
lambda|->
name|p
operator|instanceof
name|ServerCrashProcedure
argument_list|)
operator|.
name|findAny
argument_list|()
decl_stmt|;
comment|// TODO: Add a page to refguide on how to do repair. Have this log message point to it.
comment|// Page will talk about loss of edits, how to schedule at least the meta WAL recovery, and
comment|// then how to assign including how to break region lock if one held.
name|LOG
operator|.
name|warn
argument_list|(
literal|"{} is NOT online; state={}; ServerCrashProcedures={}. Master startup cannot "
operator|+
literal|"progress, in holding-pattern until region onlined."
argument_list|,
name|ri
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|,
name|rs
argument_list|,
name|optProc
operator|.
name|isPresent
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check once-a-minute.
if|if
condition|(
name|rc
operator|==
literal|null
condition|)
block|{
name|rc
operator|=
operator|new
name|RetryCounterFactory
argument_list|(
literal|1000
argument_list|)
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
name|Threads
operator|.
name|sleep
argument_list|(
name|rc
operator|.
name|getBackoffTimeAndIncrementAttempts
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Check hbase:namespace table is assigned. If not, startup will hang looking for the ns table    *<p/>    * This is for rolling upgrading, later we will migrate the data in ns table to the ns family of    * meta table. And if this is a new clsuter, this method will return immediately as there will be    * no namespace table/region.    * @return True if namespace table is up/online.    */
specifier|private
name|boolean
name|waitForNamespaceOnline
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|TableState
name|nsTableState
init|=
name|MetaTableAccessor
operator|.
name|getTableState
argument_list|(
name|getConnection
argument_list|()
argument_list|,
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|nsTableState
operator|==
literal|null
operator|||
name|nsTableState
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
comment|// this means we have already migrated the data and disabled or deleted the namespace table,
comment|// or this is a new depliy which does not have a namespace table from the beginning.
return|return
literal|true
return|;
block|}
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|ris
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionsOfTable
argument_list|(
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|ris
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// maybe this will not happen any more, but anyway, no harm to add a check here...
return|return
literal|true
return|;
block|}
comment|// Else there are namespace regions up in meta. Ensure they are assigned before we go on.
for|for
control|(
name|RegionInfo
name|ri
range|:
name|ris
control|)
block|{
name|isRegionOnline
argument_list|(
name|ri
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Adds the {@code MasterQuotasObserver} to the list of configured Master observers to    * automatically remove quotas for a table when that table is deleted.    */
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|updateConfigurationForQuotasObserver
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// We're configured to not delete quotas on table deletion, so we don't need to add the obs.
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|MasterQuotasObserver
operator|.
name|REMOVE_QUOTA_ON_TABLE_DELETE
argument_list|,
name|MasterQuotasObserver
operator|.
name|REMOVE_QUOTA_ON_TABLE_DELETE_DEFAULT
argument_list|)
condition|)
block|{
return|return;
block|}
name|String
index|[]
name|masterCoprocs
init|=
name|conf
operator|.
name|getStrings
argument_list|(
name|CoprocessorHost
operator|.
name|MASTER_COPROCESSOR_CONF_KEY
argument_list|)
decl_stmt|;
specifier|final
name|int
name|length
init|=
literal|null
operator|==
name|masterCoprocs
condition|?
literal|0
else|:
name|masterCoprocs
operator|.
name|length
decl_stmt|;
name|String
index|[]
name|updatedCoprocs
init|=
operator|new
name|String
index|[
name|length
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|masterCoprocs
argument_list|,
literal|0
argument_list|,
name|updatedCoprocs
argument_list|,
literal|0
argument_list|,
name|masterCoprocs
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|updatedCoprocs
index|[
name|length
index|]
operator|=
name|MasterQuotasObserver
operator|.
name|class
operator|.
name|getName
argument_list|()
expr_stmt|;
name|conf
operator|.
name|setStrings
argument_list|(
name|CoprocessorHost
operator|.
name|MASTER_COPROCESSOR_CONF_KEY
argument_list|,
name|updatedCoprocs
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|initMobCleaner
parameter_list|()
block|{
name|this
operator|.
name|expiredMobFileCleanerChore
operator|=
operator|new
name|ExpiredMobFileCleanerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|expiredMobFileCleanerChore
argument_list|)
expr_stmt|;
name|int
name|mobCompactionPeriod
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|MobConstants
operator|.
name|MOB_COMPACTION_CHORE_PERIOD
argument_list|,
name|MobConstants
operator|.
name|DEFAULT_MOB_COMPACTION_CHORE_PERIOD
argument_list|)
decl_stmt|;
name|this
operator|.
name|mobCompactChore
operator|=
operator|new
name|MobCompactionChore
argument_list|(
name|this
argument_list|,
name|mobCompactionPeriod
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|mobCompactChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|mobCompactThread
operator|=
operator|new
name|MasterMobCompactionThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    *<p>    * Create a {@link MasterMetaBootstrap} instance.    *</p>    *<p>    * Will be overridden in tests.    *</p>    */
annotation|@
name|VisibleForTesting
specifier|protected
name|MasterMetaBootstrap
name|createMetaBootstrap
parameter_list|()
block|{
comment|// We put this out here in a method so can do a Mockito.spy and stub it out
comment|// w/ a mocked up MasterMetaBootstrap.
return|return
operator|new
name|MasterMetaBootstrap
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    *<p>    * Create a {@link ServerManager} instance.    *</p>    *<p>    * Will be overridden in tests.    *</p>    */
annotation|@
name|VisibleForTesting
specifier|protected
name|ServerManager
name|createServerManager
parameter_list|(
specifier|final
name|MasterServices
name|master
parameter_list|)
throws|throws
name|IOException
block|{
comment|// We put this out here in a method so can do a Mockito.spy and stub it out
comment|// w/ a mocked up ServerManager.
name|setupClusterConnection
argument_list|()
expr_stmt|;
return|return
operator|new
name|ServerManager
argument_list|(
name|master
argument_list|)
return|;
block|}
specifier|private
name|void
name|waitForRegionServers
parameter_list|(
specifier|final
name|MonitoredTask
name|status
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|serverManager
operator|.
name|waitForRegionServers
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
comment|// Will be overridden in tests
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|initClusterSchemaService
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|clusterSchemaService
operator|=
operator|new
name|ClusterSchemaServiceImpl
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterSchemaService
operator|.
name|startAsync
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|clusterSchemaService
operator|.
name|awaitRunning
argument_list|(
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|HBASE_MASTER_WAIT_ON_SERVICE_IN_SECONDS
argument_list|,
name|DEFAULT_HBASE_MASTER_WAIT_ON_SERVICE_IN_SECONDS
argument_list|)
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|toe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Timedout starting ClusterSchemaService"
argument_list|,
name|toe
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|initQuotaManager
parameter_list|()
throws|throws
name|IOException
block|{
name|MasterQuotaManager
name|quotaManager
init|=
operator|new
name|MasterQuotaManager
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|quotaManager
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|quotaManager
operator|=
name|quotaManager
expr_stmt|;
block|}
specifier|private
name|SpaceQuotaSnapshotNotifier
name|createQuotaSnapshotNotifier
parameter_list|()
block|{
name|SpaceQuotaSnapshotNotifier
name|notifier
init|=
name|SpaceQuotaSnapshotNotifierFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|create
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|notifier
return|;
block|}
name|boolean
name|isCatalogJanitorEnabled
parameter_list|()
block|{
return|return
name|catalogJanitorChore
operator|!=
literal|null
condition|?
name|catalogJanitorChore
operator|.
name|getEnabled
argument_list|()
else|:
literal|false
return|;
block|}
name|boolean
name|isCleanerChoreEnabled
parameter_list|()
block|{
name|boolean
name|hfileCleanerFlag
init|=
literal|true
decl_stmt|,
name|logCleanerFlag
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|hfileCleaner
operator|!=
literal|null
condition|)
block|{
name|hfileCleanerFlag
operator|=
name|hfileCleaner
operator|.
name|getEnabled
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|logCleaner
operator|!=
literal|null
condition|)
block|{
name|logCleanerFlag
operator|=
name|logCleaner
operator|.
name|getEnabled
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|hfileCleanerFlag
operator|&&
name|logCleanerFlag
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerManager
name|getServerManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterFileSystem
name|getMasterFileSystem
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileSystemManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterWalManager
name|getMasterWalManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|walManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|SplitWALManager
name|getSplitWALManager
parameter_list|()
block|{
return|return
name|splitWALManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableStateManager
name|getTableStateManager
parameter_list|()
block|{
return|return
name|tableStateManager
return|;
block|}
comment|/*    * Start up all services. If any of these threads gets an unhandled exception    * then they just die with a logged message.  This should be fine because    * in general, we do not expect the master to get such unhandled exceptions    *  as OOMEs; it should be lightly loaded. See what HRegionServer does if    *  need to install an unexpected exception handler.    */
specifier|private
name|void
name|startServiceThreads
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Start the executor service pools
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_OPEN_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|MASTER_OPEN_REGION_THREADS
argument_list|,
name|HConstants
operator|.
name|MASTER_OPEN_REGION_THREADS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_CLOSE_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|MASTER_CLOSE_REGION_THREADS
argument_list|,
name|HConstants
operator|.
name|MASTER_CLOSE_REGION_THREADS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|MASTER_SERVER_OPERATIONS_THREADS
argument_list|,
name|HConstants
operator|.
name|MASTER_SERVER_OPERATIONS_THREADS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_META_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|MASTER_META_SERVER_OPERATIONS_THREADS
argument_list|,
name|HConstants
operator|.
name|MASTER_META_SERVER_OPERATIONS_THREADS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|M_LOG_REPLAY_OPS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|MASTER_LOG_REPLAY_OPS_THREADS
argument_list|,
name|HConstants
operator|.
name|MASTER_LOG_REPLAY_OPS_THREADS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_SNAPSHOT_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|SnapshotManager
operator|.
name|SNAPSHOT_POOL_THREADS_KEY
argument_list|,
name|SnapshotManager
operator|.
name|SNAPSHOT_POOL_THREADS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
comment|// We depend on there being only one instance of this executor running
comment|// at a time. To do concurrency, would need fencing of enable/disable of
comment|// tables.
comment|// Any time changing this maxThreads to> 1, pls see the comment at
comment|// AccessController#postCompletedCreateTableAction
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_TABLE_OPERATIONS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|startProcedureExecutor
argument_list|()
expr_stmt|;
comment|// Start log cleaner thread
name|int
name|cleanerInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HBASE_MASTER_CLEANER_INTERVAL
argument_list|,
name|DEFAULT_HBASE_MASTER_CLEANER_INTERVAL
argument_list|)
decl_stmt|;
name|this
operator|.
name|logCleaner
operator|=
operator|new
name|LogCleaner
argument_list|(
name|cleanerInterval
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|getMasterWalManager
argument_list|()
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|getMasterWalManager
argument_list|()
operator|.
name|getOldLogDir
argument_list|()
argument_list|,
name|cleanerPool
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|logCleaner
argument_list|)
expr_stmt|;
comment|// start the hfile archive cleaner thread
name|Path
name|archiveDir
init|=
name|HFileArchiveUtil
operator|.
name|getArchivePath
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|params
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|params
operator|.
name|put
argument_list|(
name|MASTER
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|hfileCleaner
operator|=
operator|new
name|HFileCleaner
argument_list|(
name|cleanerInterval
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|getMasterFileSystem
argument_list|()
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|archiveDir
argument_list|,
name|cleanerPool
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|hfileCleaner
argument_list|)
expr_stmt|;
comment|// Regions Reopen based on very high storeFileRefCount is considered enabled
comment|// only if hbase.regions.recovery.store.file.ref.count has value> 0
specifier|final
name|int
name|maxStoreFileRefCount
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|STORE_FILE_REF_COUNT_THRESHOLD
argument_list|,
name|HConstants
operator|.
name|DEFAULT_STORE_FILE_REF_COUNT_THRESHOLD
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxStoreFileRefCount
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|regionsRecoveryChore
operator|=
operator|new
name|RegionsRecoveryChore
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|this
operator|.
name|regionsRecoveryChore
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reopening regions with very high storeFileRefCount is disabled. "
operator|+
literal|"Provide threshold value> 0 for {} to enable it."
argument_list|,
name|HConstants
operator|.
name|STORE_FILE_REF_COUNT_THRESHOLD
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|regionsRecoveryConfigManager
operator|=
operator|new
name|RegionsRecoveryConfigManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|replicationBarrierCleaner
operator|=
operator|new
name|ReplicationBarrierCleaner
argument_list|(
name|conf
argument_list|,
name|this
argument_list|,
name|getConnection
argument_list|()
argument_list|,
name|replicationPeerManager
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|replicationBarrierCleaner
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|isSnapshotChoreEnabled
init|=
name|this
operator|.
name|snapshotCleanupTracker
operator|.
name|isSnapshotCleanupEnabled
argument_list|()
decl_stmt|;
name|this
operator|.
name|snapshotCleanerChore
operator|=
operator|new
name|SnapshotCleanerChore
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|getSnapshotManager
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSnapshotChoreEnabled
condition|)
block|{
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|this
operator|.
name|snapshotCleanerChore
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Snapshot Cleaner Chore is disabled. Not starting up the chore.."
argument_list|)
expr_stmt|;
block|}
block|}
name|serviceStarted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Started service threads"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|stopServiceThreads
parameter_list|()
block|{
if|if
condition|(
name|masterJettyServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping master jetty server"
argument_list|)
expr_stmt|;
try|try
block|{
name|masterJettyServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to stop master jetty server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|stopChores
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|mobCompactThread
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|mobCompactThread
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|stopServiceThreads
argument_list|()
expr_stmt|;
if|if
condition|(
name|cleanerPool
operator|!=
literal|null
condition|)
block|{
name|cleanerPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|cleanerPool
operator|=
literal|null
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopping service threads"
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|quotaManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|quotaManager
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|activeMasterManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|activeMasterManager
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|serverManager
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|stopProcedureExecutor
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|walManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|walManager
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|fileSystemManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|fileSystemManager
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|mpmHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|mpmHost
operator|.
name|stop
argument_list|(
literal|"server shutting down."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|regionServerTracker
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|regionServerTracker
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|createProcedureExecutor
parameter_list|()
throws|throws
name|IOException
block|{
name|MasterProcedureEnv
name|procEnv
init|=
operator|new
name|MasterProcedureEnv
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|// Create cleaner thread pool
name|cleanerPool
operator|=
operator|new
name|DirScanPool
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|procedureStore
operator|=
operator|new
name|RegionProcedureStore
argument_list|(
name|this
argument_list|,
name|cleanerPool
argument_list|,
operator|new
name|MasterProcedureEnv
operator|.
name|FsUtilsLeaseRecovery
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|procedureStore
operator|.
name|registerListener
argument_list|(
operator|new
name|ProcedureStoreListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|abortProcess
parameter_list|()
block|{
name|abort
argument_list|(
literal|"The Procedure Store lost the lease"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|MasterProcedureScheduler
name|procedureScheduler
init|=
name|procEnv
operator|.
name|getProcedureScheduler
argument_list|()
decl_stmt|;
name|procedureExecutor
operator|=
operator|new
name|ProcedureExecutor
argument_list|<>
argument_list|(
name|conf
argument_list|,
name|procEnv
argument_list|,
name|procedureStore
argument_list|,
name|procedureScheduler
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|procEnv
argument_list|)
expr_stmt|;
name|int
name|cpus
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|MasterProcedureConstants
operator|.
name|MASTER_PROCEDURE_THREADS
argument_list|,
name|Math
operator|.
name|max
argument_list|(
operator|(
name|cpus
operator|>
literal|0
condition|?
name|cpus
operator|/
literal|4
else|:
literal|0
operator|)
argument_list|,
name|MasterProcedureConstants
operator|.
name|DEFAULT_MIN_MASTER_PROCEDURE_THREADS
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|abortOnCorruption
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|MasterProcedureConstants
operator|.
name|EXECUTOR_ABORT_ON_CORRUPTION
argument_list|,
name|MasterProcedureConstants
operator|.
name|DEFAULT_EXECUTOR_ABORT_ON_CORRUPTION
argument_list|)
decl_stmt|;
name|procedureStore
operator|.
name|start
argument_list|(
name|numThreads
argument_list|)
expr_stmt|;
comment|// Just initialize it but do not start the workers, we will start the workers later by calling
comment|// startProcedureExecutor. See the javadoc for finishActiveMasterInitialization for more
comment|// details.
name|procedureExecutor
operator|.
name|init
argument_list|(
name|numThreads
argument_list|,
name|abortOnCorruption
argument_list|)
expr_stmt|;
name|procEnv
operator|.
name|getRemoteDispatcher
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|startProcedureExecutor
parameter_list|()
throws|throws
name|IOException
block|{
name|procedureExecutor
operator|.
name|startWorkers
argument_list|()
expr_stmt|;
block|}
comment|/**    * Turn on/off Snapshot Cleanup Chore    *    * @param on indicates whether Snapshot Cleanup Chore is to be run    */
name|void
name|switchSnapshotCleanup
parameter_list|(
specifier|final
name|boolean
name|on
parameter_list|,
specifier|final
name|boolean
name|synchronous
parameter_list|)
block|{
if|if
condition|(
name|synchronous
condition|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|snapshotCleanerChore
init|)
block|{
name|switchSnapshotCleanup
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|switchSnapshotCleanup
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|switchSnapshotCleanup
parameter_list|(
specifier|final
name|boolean
name|on
parameter_list|)
block|{
try|try
block|{
name|snapshotCleanupTracker
operator|.
name|setSnapshotCleanupEnabled
argument_list|(
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
if|if
condition|(
operator|!
name|getChoreService
argument_list|()
operator|.
name|isChoreScheduled
argument_list|(
name|this
operator|.
name|snapshotCleanerChore
argument_list|)
condition|)
block|{
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|this
operator|.
name|snapshotCleanerChore
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|getChoreService
argument_list|()
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|snapshotCleanerChore
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error updating snapshot cleanup mode to {}"
argument_list|,
name|on
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|stopProcedureExecutor
parameter_list|()
block|{
if|if
condition|(
name|procedureExecutor
operator|!=
literal|null
condition|)
block|{
name|configurationManager
operator|.
name|deregisterObserver
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|)
expr_stmt|;
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getRemoteDispatcher
argument_list|()
operator|.
name|stop
argument_list|()
expr_stmt|;
name|procedureExecutor
operator|.
name|stop
argument_list|()
expr_stmt|;
name|procedureExecutor
operator|.
name|join
argument_list|()
expr_stmt|;
name|procedureExecutor
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|procedureStore
operator|!=
literal|null
condition|)
block|{
name|procedureStore
operator|.
name|stop
argument_list|(
name|isAborted
argument_list|()
argument_list|)
expr_stmt|;
name|procedureStore
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|stopChores
parameter_list|()
block|{
name|ChoreService
name|choreService
init|=
name|getChoreService
argument_list|()
decl_stmt|;
if|if
condition|(
name|choreService
operator|!=
literal|null
condition|)
block|{
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|expiredMobFileCleanerChore
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|mobCompactChore
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|balancerChore
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|normalizerChore
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|clusterStatusChore
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|catalogJanitorChore
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|clusterStatusPublisherChore
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|snapshotQuotaChore
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|logCleaner
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|hfileCleaner
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|replicationBarrierCleaner
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|snapshotCleanerChore
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|hbckChore
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|cancelChore
argument_list|(
name|this
operator|.
name|regionsRecoveryChore
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return Get remote side's InetAddress    */
name|InetAddress
name|getRemoteInetAddress
parameter_list|(
specifier|final
name|int
name|port
parameter_list|,
specifier|final
name|long
name|serverStartCode
parameter_list|)
throws|throws
name|UnknownHostException
block|{
comment|// Do it out here in its own little method so can fake an address when
comment|// mocking up in tests.
name|InetAddress
name|ia
init|=
name|RpcServer
operator|.
name|getRemoteIp
argument_list|()
decl_stmt|;
comment|// The call could be from the local regionserver,
comment|// in which case, there is no remote address.
if|if
condition|(
name|ia
operator|==
literal|null
operator|&&
name|serverStartCode
operator|==
name|startcode
condition|)
block|{
name|InetSocketAddress
name|isa
init|=
name|rpcServices
operator|.
name|getSocketAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|isa
operator|!=
literal|null
operator|&&
name|isa
operator|.
name|getPort
argument_list|()
operator|==
name|port
condition|)
block|{
name|ia
operator|=
name|isa
operator|.
name|getAddress
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|ia
return|;
block|}
comment|/**    * @return Maximum time we should run balancer for    */
specifier|private
name|int
name|getMaxBalancingTime
parameter_list|()
block|{
comment|// if max balancing time isn't set, defaulting it to period time
name|int
name|maxBalancingTime
init|=
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_BALANCER_MAX_BALANCING
argument_list|,
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_BALANCER_PERIOD
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_BALANCER_PERIOD
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|maxBalancingTime
return|;
block|}
comment|/**    * @return Maximum number of regions in transition    */
specifier|private
name|int
name|getMaxRegionsInTransition
parameter_list|()
block|{
name|int
name|numRegions
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionAssignments
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
return|return
name|Math
operator|.
name|max
argument_list|(
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|numRegions
operator|*
name|this
operator|.
name|maxRitPercent
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/**    * It first sleep to the next balance plan start time. Meanwhile, throttling by the max    * number regions in transition to protect availability.    * @param nextBalanceStartTime The next balance plan start time    * @param maxRegionsInTransition max number of regions in transition    * @param cutoffTime when to exit balancer    */
specifier|private
name|void
name|balanceThrottling
parameter_list|(
name|long
name|nextBalanceStartTime
parameter_list|,
name|int
name|maxRegionsInTransition
parameter_list|,
name|long
name|cutoffTime
parameter_list|)
block|{
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
comment|// Sleep to next balance plan start time
comment|// But if there are zero regions in transition, it can skip sleep to speed up.
while|while
condition|(
operator|!
name|interrupted
operator|&&
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|<
name|nextBalanceStartTime
operator|&&
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|hasRegionsInTransition
argument_list|()
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Throttling by max number regions in transition
while|while
condition|(
operator|!
name|interrupted
operator|&&
name|maxRegionsInTransition
operator|>
literal|0
operator|&&
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionsInTransitionCount
argument_list|()
operator|>=
name|maxRegionsInTransition
operator|&&
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|<=
name|cutoffTime
condition|)
block|{
try|try
block|{
comment|// sleep if the number of regions in transition exceeds the limit
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|interrupted
condition|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|balance
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|balance
argument_list|(
literal|false
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|balance
parameter_list|(
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if master not initialized, don't run balancer.
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Master has not been initialized, don't run balancer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Master is in maintenanceMode mode, don't run balancer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|balancer
init|)
block|{
comment|// If balance not true, don't run balancer.
if|if
condition|(
operator|!
name|this
operator|.
name|loadBalancerTracker
operator|.
name|isBalancerOn
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// Only allow one balance run at at time.
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|.
name|hasRegionsInTransition
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|RegionStateNode
argument_list|>
name|regionsInTransition
init|=
name|assignmentManager
operator|.
name|getRegionsInTransition
argument_list|()
decl_stmt|;
comment|// if hbase:meta region is in transition, result of assignment cannot be recorded
comment|// ignore the force flag in that case
name|boolean
name|metaInTransition
init|=
name|assignmentManager
operator|.
name|isMetaRegionInTransition
argument_list|()
decl_stmt|;
name|String
name|prefix
init|=
name|force
operator|&&
operator|!
name|metaInTransition
condition|?
literal|"R"
else|:
literal|"Not r"
decl_stmt|;
name|List
argument_list|<
name|RegionStateNode
argument_list|>
name|toPrint
init|=
name|regionsInTransition
decl_stmt|;
name|int
name|max
init|=
literal|5
decl_stmt|;
name|boolean
name|truncated
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|regionsInTransition
operator|.
name|size
argument_list|()
operator|>
name|max
condition|)
block|{
name|toPrint
operator|=
name|regionsInTransition
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|truncated
operator|=
literal|true
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|prefix
operator|+
literal|"unning balancer because "
operator|+
name|regionsInTransition
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) in transition: "
operator|+
name|toPrint
operator|+
operator|(
name|truncated
condition|?
literal|"(truncated list)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|||
name|metaInTransition
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|.
name|areDeadServersInProgress
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Not running balancer because processing dead regionserver(s): "
operator|+
name|this
operator|.
name|serverManager
operator|.
name|getDeadServers
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|this
operator|.
name|cpHost
operator|.
name|preBalance
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Coprocessor bypassing balancer request"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error invoking master coprocessor preBalance()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|boolean
name|isByTable
init|=
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.loadbalance.bytable"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|TableName
argument_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
argument_list|>
name|assignments
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getAssignmentsForBalancer
argument_list|(
name|tableStateManager
argument_list|,
name|this
operator|.
name|serverManager
operator|.
name|getOnlineServersList
argument_list|()
argument_list|,
name|isByTable
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|serverMap
range|:
name|assignments
operator|.
name|values
argument_list|()
control|)
block|{
name|serverMap
operator|.
name|keySet
argument_list|()
operator|.
name|removeAll
argument_list|(
name|this
operator|.
name|serverManager
operator|.
name|getDrainingServersList
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//Give the balancer the current cluster state.
name|this
operator|.
name|balancer
operator|.
name|setClusterMetrics
argument_list|(
name|getClusterMetricsWithoutCoprocessor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|.
name|setClusterLoad
argument_list|(
name|assignments
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|plans
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|TableName
argument_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
argument_list|>
name|e
range|:
name|assignments
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|partialPlans
init|=
name|this
operator|.
name|balancer
operator|.
name|balanceCluster
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|partialPlans
operator|!=
literal|null
condition|)
block|{
name|plans
operator|.
name|addAll
argument_list|(
name|partialPlans
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|sucRPs
init|=
name|executeRegionPlansWithThrottling
argument_list|(
name|plans
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|postBalance
argument_list|(
name|sucRPs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// balancing already succeeded so don't change the result
name|LOG
operator|.
name|error
argument_list|(
literal|"Error invoking master coprocessor postBalance()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If LoadBalancer did not generate any plans, it means the cluster is already balanced.
comment|// Return true indicating a success.
return|return
literal|true
return|;
block|}
specifier|public
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|executeRegionPlansWithThrottling
parameter_list|(
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|plans
parameter_list|)
block|{
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|sucRPs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|maxRegionsInTransition
init|=
name|getMaxRegionsInTransition
argument_list|()
decl_stmt|;
name|long
name|balanceStartTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|cutoffTime
init|=
name|balanceStartTime
operator|+
name|this
operator|.
name|maxBlancingTime
decl_stmt|;
name|int
name|rpCount
init|=
literal|0
decl_stmt|;
comment|// number of RegionPlans balanced so far
if|if
condition|(
name|plans
operator|!=
literal|null
operator|&&
operator|!
name|plans
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|balanceInterval
init|=
name|this
operator|.
name|maxBlancingTime
operator|/
name|plans
operator|.
name|size
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Balancer plans size is "
operator|+
name|plans
operator|.
name|size
argument_list|()
operator|+
literal|", the balance interval is "
operator|+
name|balanceInterval
operator|+
literal|" ms, and the max number regions in transition is "
operator|+
name|maxRegionsInTransition
argument_list|)
expr_stmt|;
for|for
control|(
name|RegionPlan
name|plan
range|:
name|plans
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"balance "
operator|+
name|plan
argument_list|)
expr_stmt|;
comment|//TODO: bulk assign
try|try
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|moveAsync
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|hioe
parameter_list|)
block|{
comment|//should ignore failed plans here, avoiding the whole balance plans be aborted
comment|//later calls of balance() can fetch up the failed and skipped plans
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed balance plan {}, skipping..."
argument_list|,
name|plan
argument_list|,
name|hioe
argument_list|)
expr_stmt|;
block|}
comment|//rpCount records balance plans processed, does not care if a plan succeeds
name|rpCount
operator|++
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|maxBlancingTime
operator|>
literal|0
condition|)
block|{
name|balanceThrottling
argument_list|(
name|balanceStartTime
operator|+
name|rpCount
operator|*
name|balanceInterval
argument_list|,
name|maxRegionsInTransition
argument_list|,
name|cutoffTime
argument_list|)
expr_stmt|;
block|}
comment|// if performing next balance exceeds cutoff time, exit the loop
if|if
condition|(
name|this
operator|.
name|maxBlancingTime
operator|>
literal|0
operator|&&
name|rpCount
argument_list|<
name|plans
operator|.
name|size
operator|(
operator|)
operator|&&
name|System
operator|.
name|currentTimeMillis
operator|(
operator|)
argument_list|>
name|cutoffTime
condition|)
block|{
comment|// TODO: After balance, there should not be a cutoff time (keeping it as
comment|// a security net for now)
name|LOG
operator|.
name|debug
argument_list|(
literal|"No more balancing till next balance run; maxBalanceTime="
operator|+
name|this
operator|.
name|maxBlancingTime
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|sucRPs
return|;
block|}
annotation|@
name|Override
annotation|@
name|VisibleForTesting
specifier|public
name|RegionNormalizer
name|getRegionNormalizer
parameter_list|()
block|{
return|return
name|this
operator|.
name|normalizer
return|;
block|}
comment|/**    * Perform normalization of cluster (invoked by {@link RegionNormalizerChore}).    *    * @return true if normalization step was performed successfully, false otherwise    *    (specifically, if HMaster hasn't been initialized properly or normalization    *    is globally disabled)    */
specifier|public
name|boolean
name|normalizeRegions
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Master has not been initialized, don't run region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|getServerManager
argument_list|()
operator|.
name|isClusterShutdown
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cluster is shutting down, don't run region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Master is in maintenance mode, don't run region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|regionNormalizerTracker
operator|.
name|isNormalizerOn
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Region normalization is disabled, don't run region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|normalizer
init|)
block|{
comment|// Don't run the normalizer concurrently
name|List
argument_list|<
name|TableName
argument_list|>
name|allEnabledTables
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|tableStateManager
operator|.
name|getTablesInStates
argument_list|(
name|TableState
operator|.
name|State
operator|.
name|ENABLED
argument_list|)
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|allEnabledTables
argument_list|)
expr_stmt|;
for|for
control|(
name|TableName
name|table
range|:
name|allEnabledTables
control|)
block|{
if|if
condition|(
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Master is in maintenance mode, stop running region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|TableDescriptor
name|tblDesc
init|=
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|.
name|isSystemTable
argument_list|()
operator|||
operator|(
name|tblDesc
operator|!=
literal|null
operator|&&
operator|!
name|tblDesc
operator|.
name|isNormalizationEnabled
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping normalization for {}, as it's either system"
operator|+
literal|" table or doesn't have auto normalization turned on"
argument_list|,
name|table
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|List
argument_list|<
name|NormalizationPlan
argument_list|>
name|plans
init|=
name|this
operator|.
name|normalizer
operator|.
name|computePlanForTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|plans
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|NormalizationPlan
name|plan
range|:
name|plans
control|)
block|{
name|plan
operator|.
name|execute
argument_list|(
name|asyncClusterConnection
operator|.
name|toConnection
argument_list|()
operator|.
name|getAdmin
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|plan
operator|.
name|getType
argument_list|()
operator|==
name|PlanType
operator|.
name|SPLIT
condition|)
block|{
name|splitPlanCount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plan
operator|.
name|getType
argument_list|()
operator|==
name|PlanType
operator|.
name|MERGE
condition|)
block|{
name|mergePlanCount
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// If Region did not generate any plans, it means the cluster is already balanced.
comment|// Return true indicating a success.
return|return
literal|true
return|;
block|}
comment|/**    * @return Client info for use as prefix on an audit log string; who did an action    */
annotation|@
name|Override
specifier|public
name|String
name|getClientIdAuditPrefix
parameter_list|()
block|{
return|return
literal|"Client="
operator|+
name|RpcServer
operator|.
name|getRequestUserName
argument_list|()
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
operator|+
literal|"/"
operator|+
name|RpcServer
operator|.
name|getRemoteAddress
argument_list|()
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|/**    * Switch for the background CatalogJanitor thread.    * Used for testing.  The thread will continue to run.  It will just be a noop    * if disabled.    * @param b If false, the catalog janitor won't do anything.    */
specifier|public
name|void
name|setCatalogJanitorEnabled
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
block|{
name|this
operator|.
name|catalogJanitorChore
operator|.
name|setEnabled
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|mergeRegions
parameter_list|(
specifier|final
name|RegionInfo
index|[]
name|regionsToMerge
parameter_list|,
specifier|final
name|boolean
name|forcible
parameter_list|,
specifier|final
name|long
name|ng
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
specifier|final
name|String
name|mergeRegionsStr
init|=
name|Arrays
operator|.
name|stream
argument_list|(
name|regionsToMerge
argument_list|)
operator|.
name|map
argument_list|(
name|r
lambda|->
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|r
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|", "
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|ng
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preMergeRegions
argument_list|(
name|regionsToMerge
argument_list|)
expr_stmt|;
name|String
name|aid
init|=
name|getClientIdAuditPrefix
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} merge regions {}"
argument_list|,
name|aid
argument_list|,
name|mergeRegionsStr
argument_list|)
expr_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|MergeTableRegionsProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|regionsToMerge
argument_list|,
name|forcible
argument_list|)
argument_list|)
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postMergeRegions
argument_list|(
name|regionsToMerge
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"MergeTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|splitRegion
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|byte
index|[]
name|splitRow
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preSplitRegion
argument_list|(
name|regionInfo
operator|.
name|getTable
argument_list|()
argument_list|,
name|splitRow
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" split "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Execute the operation asynchronously
name|submitProcedure
argument_list|(
name|getAssignmentManager
argument_list|()
operator|.
name|createSplitProcedure
argument_list|(
name|regionInfo
argument_list|,
name|splitRow
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"SplitTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|private
name|void
name|warmUpRegion
parameter_list|(
name|ServerName
name|server
parameter_list|,
name|RegionInfo
name|region
parameter_list|)
block|{
name|FutureUtils
operator|.
name|addListener
argument_list|(
name|asyncClusterConnection
operator|.
name|getRegionServerAdmin
argument_list|(
name|server
argument_list|)
operator|.
name|warmupRegion
argument_list|(
name|RequestConverter
operator|.
name|buildWarmupRegionRequest
argument_list|(
name|region
argument_list|)
argument_list|)
argument_list|,
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to warm up region {} on server {}"
argument_list|,
name|region
argument_list|,
name|server
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// Public so can be accessed by tests. Blocks until move is done.
comment|// Replace with an async implementation from which you can get
comment|// a success/failure result.
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|move
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|,
name|byte
index|[]
name|destServerName
parameter_list|)
throws|throws
name|HBaseIOException
block|{
name|RegionState
name|regionState
init|=
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionState
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
decl_stmt|;
name|RegionInfo
name|hri
decl_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
condition|)
block|{
name|hri
operator|=
name|regionState
operator|.
name|getRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
throw|;
block|}
name|ServerName
name|dest
decl_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|exclude
init|=
name|hri
operator|.
name|getTable
argument_list|()
operator|.
name|isSystemTable
argument_list|()
condition|?
name|assignmentManager
operator|.
name|getExcludedServersForSystemTable
argument_list|()
else|:
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|destServerName
operator|!=
literal|null
operator|&&
name|exclude
operator|.
name|contains
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|destServerName
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
operator|+
literal|" can not move to "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|destServerName
argument_list|)
operator|+
literal|" because the server is in exclude list"
argument_list|)
expr_stmt|;
name|destServerName
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|destServerName
operator|==
literal|null
operator|||
name|destServerName
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Passed destination servername is null/empty so "
operator|+
literal|"choosing a server at random"
argument_list|)
expr_stmt|;
name|exclude
operator|.
name|add
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|destServers
init|=
name|this
operator|.
name|serverManager
operator|.
name|createDestinationServersList
argument_list|(
name|exclude
argument_list|)
decl_stmt|;
name|dest
operator|=
name|balancer
operator|.
name|randomAssignment
argument_list|(
name|hri
argument_list|,
name|destServers
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to determine a plan to assign "
operator|+
name|hri
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|ServerName
name|candidate
init|=
name|ServerName
operator|.
name|valueOf
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|destServerName
argument_list|)
argument_list|)
decl_stmt|;
name|dest
operator|=
name|balancer
operator|.
name|randomAssignment
argument_list|(
name|hri
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to determine a plan to assign "
operator|+
name|hri
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// TODO: What is this? I don't get it.
if|if
condition|(
name|dest
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
operator|&&
name|balancer
operator|instanceof
name|BaseLoadBalancer
operator|&&
operator|!
operator|(
operator|(
name|BaseLoadBalancer
operator|)
name|balancer
operator|)
operator|.
name|shouldBeOnMaster
argument_list|(
name|hri
argument_list|)
condition|)
block|{
comment|// To avoid unnecessary region moving later by balancer. Don't put user
comment|// regions on master.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping move of region "
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to avoid unnecessary region moving later by load balancer,"
operator|+
literal|" because it should not be on master"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|dest
operator|.
name|equals
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping move of region "
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" because region already assigned to the same server "
operator|+
name|dest
operator|+
literal|"."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Now we can do the move
name|RegionPlan
name|rp
init|=
operator|new
name|RegionPlan
argument_list|(
name|hri
argument_list|,
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|,
name|dest
argument_list|)
decl_stmt|;
assert|assert
name|rp
operator|.
name|getDestination
argument_list|()
operator|!=
literal|null
operator|:
name|rp
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|dest
assert|;
try|try
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cpHost
operator|.
name|preMove
argument_list|(
name|hri
argument_list|,
name|rp
operator|.
name|getSource
argument_list|()
argument_list|,
name|rp
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|TransitRegionStateProcedure
name|proc
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|createMoveRegionProcedure
argument_list|(
name|rp
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|rp
operator|.
name|getDestination
argument_list|()
argument_list|)
decl_stmt|;
comment|// Warmup the region on the destination before initiating the move.
comment|// A region server could reject the close request because it either does not
comment|// have the specified region or the region is being split.
name|warmUpRegion
argument_list|(
name|rp
operator|.
name|getDestination
argument_list|()
argument_list|,
name|hri
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" move "
operator|+
name|rp
operator|+
literal|", running balancer"
argument_list|)
expr_stmt|;
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
name|future
init|=
name|ProcedureSyncWait
operator|.
name|submitProcedure
argument_list|(
name|this
operator|.
name|procedureExecutor
argument_list|,
name|proc
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Is this going to work? Will we throw exception on error?
comment|// TODO: CompletableFuture rather than this stunted Future.
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
decl||
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cpHost
operator|.
name|postMove
argument_list|(
name|hri
argument_list|,
name|rp
operator|.
name|getSource
argument_list|()
argument_list|,
name|rp
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|ioe
operator|instanceof
name|HBaseIOException
condition|)
block|{
throw|throw
operator|(
name|HBaseIOException
operator|)
name|ioe
throw|;
block|}
throw|throw
operator|new
name|HBaseIOException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|createTable
parameter_list|(
specifier|final
name|TableDescriptor
name|tableDescriptor
parameter_list|,
specifier|final
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|TableDescriptor
name|desc
init|=
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preCreateTableRegionsInfos
argument_list|(
name|tableDescriptor
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Creation for "
operator|+
name|tableDescriptor
operator|+
literal|" is canceled by CP"
argument_list|)
throw|;
block|}
name|String
name|namespace
init|=
name|desc
operator|.
name|getTableName
argument_list|()
operator|.
name|getNamespaceAsString
argument_list|()
decl_stmt|;
name|this
operator|.
name|clusterSchemaService
operator|.
name|getNamespace
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
name|RegionInfo
index|[]
name|newRegions
init|=
name|ModifyRegionUtils
operator|.
name|createRegionInfos
argument_list|(
name|desc
argument_list|,
name|splitKeys
argument_list|)
decl_stmt|;
name|TableDescriptorChecker
operator|.
name|sanityCheck
argument_list|(
name|conf
argument_list|,
name|desc
argument_list|)
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preCreateTable
argument_list|(
name|desc
argument_list|,
name|newRegions
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" create "
operator|+
name|desc
argument_list|)
expr_stmt|;
comment|// TODO: We can handle/merge duplicate requests, and differentiate the case of
comment|// TableExistsException by saying if the schema is the same or not.
comment|//
comment|// We need to wait for the procedure to potentially fail due to "prepare" sanity
comment|// checks. This will block only the beginning of the procedure. See HBASE-19953.
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createBlockingLatch
argument_list|()
decl_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|CreateTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|desc
argument_list|,
name|newRegions
argument_list|,
name|latch
argument_list|)
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postCreateTable
argument_list|(
name|desc
argument_list|,
name|newRegions
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"CreateTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|createSystemTable
parameter_list|(
specifier|final
name|TableDescriptor
name|tableDescriptor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isStopped
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
name|TableName
name|tableName
init|=
name|tableDescriptor
operator|.
name|getTableName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tableName
operator|.
name|isSystemTable
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Only system table creation can use this createSystemTable API"
argument_list|)
throw|;
block|}
name|RegionInfo
index|[]
name|newRegions
init|=
name|ModifyRegionUtils
operator|.
name|createRegionInfos
argument_list|(
name|tableDescriptor
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" create "
operator|+
name|tableDescriptor
argument_list|)
expr_stmt|;
comment|// This special create table is called locally to master.  Therefore, no RPC means no need
comment|// to use nonce to detect duplicated RPC call.
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|CreateTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableDescriptor
argument_list|,
name|newRegions
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|procId
return|;
block|}
specifier|private
name|void
name|startActiveMasterManager
parameter_list|(
name|int
name|infoPort
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|backupZNode
init|=
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|zooKeeper
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|backupMasterAddressesZNode
argument_list|,
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|/*     * Add a ZNode for ourselves in the backup master directory since we     * may not become the active master. If so, we want the actual active     * master to know we are backup masters, so that it won't assign     * regions to us if so configured.     *     * If we become the active master later, ActiveMasterManager will delete     * this node explicitly.  If we crash before then, ZooKeeper will delete     * this node for us since it is ephemeral.     */
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding backup master ZNode "
operator|+
name|backupZNode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MasterAddressTracker
operator|.
name|setMasterAddress
argument_list|(
name|zooKeeper
argument_list|,
name|backupZNode
argument_list|,
name|serverName
argument_list|,
name|infoPort
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed create of "
operator|+
name|backupZNode
operator|+
literal|" by "
operator|+
name|serverName
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|activeMasterManager
operator|.
name|setInfoPort
argument_list|(
name|infoPort
argument_list|)
expr_stmt|;
name|int
name|timeout
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|ZK_SESSION_TIMEOUT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_ZK_SESSION_TIMEOUT
argument_list|)
decl_stmt|;
comment|// If we're a backup master, stall until a primary to write this address
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|MASTER_TYPE_BACKUP
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_TYPE_BACKUP
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"HMaster started in backup mode. Stalling until master znode is written."
argument_list|)
expr_stmt|;
comment|// This will only be a minute or so while the cluster starts up,
comment|// so don't worry about setting watches on the parent znode
while|while
condition|(
operator|!
name|activeMasterManager
operator|.
name|hasActiveMaster
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for master address and cluster state znode to be written."
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|sleep
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
name|MonitoredTask
name|status
init|=
name|TaskMonitor
operator|.
name|get
argument_list|()
operator|.
name|createStatus
argument_list|(
literal|"Master startup"
argument_list|)
decl_stmt|;
name|status
operator|.
name|setDescription
argument_list|(
literal|"Master startup"
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|activeMasterManager
operator|.
name|blockUntilBecomingActiveMaster
argument_list|(
name|timeout
argument_list|,
name|status
argument_list|)
condition|)
block|{
name|finishActiveMasterInitialization
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|status
operator|.
name|setStatus
argument_list|(
literal|"Failed to become active: "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|HBaseMarkers
operator|.
name|FATAL
argument_list|,
literal|"Failed to become active master"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// HBASE-5680: Likely hadoop23 vs hadoop 20.x/1.x incompatibility
if|if
condition|(
name|t
operator|instanceof
name|NoClassDefFoundError
operator|&&
name|t
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"org/apache/hadoop/hdfs/protocol/HdfsConstants$SafeModeAction"
argument_list|)
condition|)
block|{
comment|// improved error message for this special case
name|abort
argument_list|(
literal|"HBase is having a problem with its Hadoop jars.  You may need to recompile "
operator|+
literal|"HBase against Hadoop version "
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
operator|.
name|getVersion
argument_list|()
operator|+
literal|" or change your hadoop jars to start properly"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|abort
argument_list|(
literal|"Unhandled exception. Starting shutdown."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|status
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isCatalogTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|tableName
operator|.
name|equals
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|deleteTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preDeleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" delete "
operator|+
name|tableName
argument_list|)
expr_stmt|;
comment|// TODO: We can handle/merge duplicate request
comment|//
comment|// We need to wait for the procedure to potentially fail due to "prepare" sanity
comment|// checks. This will block only the beginning of the procedure. See HBASE-19953.
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createBlockingLatch
argument_list|()
decl_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|DeleteTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|latch
argument_list|)
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postDeleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"DeleteTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|truncateTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|boolean
name|preserveSplits
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preTruncateTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" truncate "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|TruncateTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|preserveSplits
argument_list|,
name|latch
argument_list|)
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postTruncateTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"TruncateTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|addColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|ColumnFamilyDescriptor
name|column
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|checkTableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
return|return
name|modifyTable
argument_list|(
name|tableName
argument_list|,
operator|new
name|TableDescriptorGetter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TableDescriptor
name|get
parameter_list|()
throws|throws
name|IOException
block|{
name|TableDescriptor
name|old
init|=
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|.
name|hasColumnFamily
argument_list|(
name|column
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidFamilyOperationException
argument_list|(
literal|"Column family '"
operator|+
name|column
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"' in table '"
operator|+
name|tableName
operator|+
literal|"' already exists so cannot be added"
argument_list|)
throw|;
block|}
return|return
name|TableDescriptorBuilder
operator|.
name|newBuilder
argument_list|(
name|old
argument_list|)
operator|.
name|setColumnFamily
argument_list|(
name|column
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Implement to return TableDescriptor after pre-checks    */
specifier|protected
interface|interface
name|TableDescriptorGetter
block|{
name|TableDescriptor
name|get
parameter_list|()
throws|throws
name|IOException
function_decl|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|modifyColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|ColumnFamilyDescriptor
name|descriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|checkTableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
return|return
name|modifyTable
argument_list|(
name|tableName
argument_list|,
operator|new
name|TableDescriptorGetter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TableDescriptor
name|get
parameter_list|()
throws|throws
name|IOException
block|{
name|TableDescriptor
name|old
init|=
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|old
operator|.
name|hasColumnFamily
argument_list|(
name|descriptor
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidFamilyOperationException
argument_list|(
literal|"Family '"
operator|+
name|descriptor
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"' does not exist, so it cannot be modified"
argument_list|)
throw|;
block|}
return|return
name|TableDescriptorBuilder
operator|.
name|newBuilder
argument_list|(
name|old
argument_list|)
operator|.
name|modifyColumnFamily
argument_list|(
name|descriptor
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|deleteColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnName
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|checkTableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
return|return
name|modifyTable
argument_list|(
name|tableName
argument_list|,
operator|new
name|TableDescriptorGetter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TableDescriptor
name|get
parameter_list|()
throws|throws
name|IOException
block|{
name|TableDescriptor
name|old
init|=
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|old
operator|.
name|hasColumnFamily
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidFamilyOperationException
argument_list|(
literal|"Family '"
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|columnName
argument_list|)
operator|+
literal|"' does not exist, so it cannot be deleted"
argument_list|)
throw|;
block|}
if|if
condition|(
name|old
operator|.
name|getColumnFamilyCount
argument_list|()
operator|==
literal|1
condition|)
block|{
throw|throw
operator|new
name|InvalidFamilyOperationException
argument_list|(
literal|"Family '"
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|columnName
argument_list|)
operator|+
literal|"' is the only column family in the table, so it cannot be deleted"
argument_list|)
throw|;
block|}
return|return
name|TableDescriptorBuilder
operator|.
name|newBuilder
argument_list|(
name|old
argument_list|)
operator|.
name|removeColumnFamily
argument_list|(
name|columnName
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|enableTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preEnableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// Normally, it would make sense for this authorization check to exist inside
comment|// AccessController, but because the authorization check is done based on internal state
comment|// (rather than explicit permissions) we'll do the check here instead of in the
comment|// coprocessor.
name|MasterQuotaManager
name|quotaManager
init|=
name|getMasterQuotaManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|quotaManager
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|quotaManager
operator|.
name|isQuotaInitialized
argument_list|()
condition|)
block|{
name|SpaceQuotaSnapshot
name|currSnapshotOfTable
init|=
name|QuotaTableUtil
operator|.
name|getCurrentSnapshotFromQuotaTable
argument_list|(
name|getConnection
argument_list|()
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|currSnapshotOfTable
operator|!=
literal|null
condition|)
block|{
name|SpaceQuotaStatus
name|quotaStatus
init|=
name|currSnapshotOfTable
operator|.
name|getQuotaStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|quotaStatus
operator|.
name|isInViolation
argument_list|()
operator|&&
name|SpaceViolationPolicy
operator|.
name|DISABLE
operator|==
name|quotaStatus
operator|.
name|getPolicy
argument_list|()
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"Enabling the table '"
operator|+
name|tableName
operator|+
literal|"' is disallowed due to a violated space quota."
argument_list|)
throw|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Unable to check for space quotas as the MasterQuotaManager is not enabled"
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" enable "
operator|+
name|tableName
argument_list|)
expr_stmt|;
comment|// Execute the operation asynchronously - client will check the progress of the operation
comment|// In case the request is from a<1.1 client before returning,
comment|// we want to make sure that the table is prepared to be
comment|// enabled (the table is locked and the table state is set).
comment|// Note: if the procedure throws exception, we will catch it and rethrow.
specifier|final
name|ProcedurePrepareLatch
name|prepareLatch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|()
decl_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|EnableTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|prepareLatch
argument_list|)
argument_list|)
expr_stmt|;
name|prepareLatch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postEnableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"EnableTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|disableTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preDisableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" disable "
operator|+
name|tableName
argument_list|)
expr_stmt|;
comment|// Execute the operation asynchronously - client will check the progress of the operation
comment|// In case the request is from a<1.1 client before returning,
comment|// we want to make sure that the table is prepared to be
comment|// enabled (the table is locked and the table state is set).
comment|// Note: if the procedure throws exception, we will catch it and rethrow.
comment|//
comment|// We need to wait for the procedure to potentially fail due to "prepare" sanity
comment|// checks. This will block only the beginning of the procedure. See HBASE-19953.
specifier|final
name|ProcedurePrepareLatch
name|prepareLatch
init|=
name|ProcedurePrepareLatch
operator|.
name|createBlockingLatch
argument_list|()
decl_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|DisableTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|,
name|prepareLatch
argument_list|)
argument_list|)
expr_stmt|;
name|prepareLatch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postDisableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"DisableTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|private
name|long
name|modifyTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|TableDescriptorGetter
name|newDescriptorGetter
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|,
specifier|final
name|boolean
name|shouldCheckDescriptor
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|TableDescriptor
name|oldDescriptor
init|=
name|getMaster
argument_list|()
operator|.
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|TableDescriptor
name|newDescriptor
init|=
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preModifyTable
argument_list|(
name|tableName
argument_list|,
name|oldDescriptor
argument_list|,
name|newDescriptorGetter
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|TableDescriptorChecker
operator|.
name|sanityCheck
argument_list|(
name|conf
argument_list|,
name|newDescriptor
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} modify table {} from {} to {}"
argument_list|,
name|getClientIdAuditPrefix
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|oldDescriptor
argument_list|,
name|newDescriptor
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation completes before
comment|// continuing.
comment|//
comment|// We need to wait for the procedure to potentially fail due to "prepare" sanity
comment|// checks. This will block only the beginning of the procedure. See HBASE-19953.
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createBlockingLatch
argument_list|()
decl_stmt|;
name|submitProcedure
argument_list|(
operator|new
name|ModifyTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|newDescriptor
argument_list|,
name|latch
argument_list|,
name|oldDescriptor
argument_list|,
name|shouldCheckDescriptor
argument_list|)
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postModifyTable
argument_list|(
name|tableName
argument_list|,
name|oldDescriptor
argument_list|,
name|newDescriptor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"ModifyTableProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|modifyTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|TableDescriptor
name|newDescriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|modifyTable
argument_list|(
name|tableName
argument_list|,
operator|new
name|TableDescriptorGetter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TableDescriptor
name|get
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|newDescriptor
return|;
block|}
block|}
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|long
name|restoreSnapshot
parameter_list|(
specifier|final
name|SnapshotDescription
name|snapshotDesc
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|,
specifier|final
name|boolean
name|restoreAcl
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|getSnapshotManager
argument_list|()
operator|.
name|checkSnapshotSupport
argument_list|()
expr_stmt|;
comment|// Ensure namespace exists. Will throw exception if non-known NS.
specifier|final
name|TableName
name|dstTable
init|=
name|TableName
operator|.
name|valueOf
argument_list|(
name|snapshotDesc
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
name|getClusterSchema
argument_list|()
operator|.
name|getNamespace
argument_list|(
name|dstTable
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|setProcId
argument_list|(
name|getSnapshotManager
argument_list|()
operator|.
name|restoreOrCloneSnapshot
argument_list|(
name|snapshotDesc
argument_list|,
name|getNonceKey
argument_list|()
argument_list|,
name|restoreAcl
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"RestoreSnapshotProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|private
name|void
name|checkTableExists
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|TableNotFoundException
block|{
if|if
condition|(
operator|!
name|MetaTableAccessor
operator|.
name|tableExists
argument_list|(
name|getConnection
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkTableModifiable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|TableNotFoundException
throws|,
name|TableNotDisabledException
block|{
if|if
condition|(
name|isCatalogTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't modify catalog tables"
argument_list|)
throw|;
block|}
name|checkTableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|TableState
name|ts
init|=
name|getTableStateManager
argument_list|()
operator|.
name|getTableState
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ts
operator|.
name|isDisabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|TableNotDisabledException
argument_list|(
literal|"Not DISABLED; "
operator|+
name|ts
argument_list|)
throw|;
block|}
block|}
specifier|public
name|ClusterMetrics
name|getClusterMetricsWithoutCoprocessor
parameter_list|()
throws|throws
name|InterruptedIOException
block|{
return|return
name|getClusterMetricsWithoutCoprocessor
argument_list|(
name|EnumSet
operator|.
name|allOf
argument_list|(
name|Option
operator|.
name|class
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|ClusterMetrics
name|getClusterMetricsWithoutCoprocessor
parameter_list|(
name|EnumSet
argument_list|<
name|Option
argument_list|>
name|options
parameter_list|)
throws|throws
name|InterruptedIOException
block|{
name|ClusterMetricsBuilder
name|builder
init|=
name|ClusterMetricsBuilder
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
comment|// given that hbase1 can't submit the request with Option,
comment|// we return all information to client if the list of Option is empty.
if|if
condition|(
name|options
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|options
operator|=
name|EnumSet
operator|.
name|allOf
argument_list|(
name|Option
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Option
name|opt
range|:
name|options
control|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|HBASE_VERSION
case|:
name|builder
operator|.
name|setHBaseVersion
argument_list|(
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLUSTER_ID
case|:
name|builder
operator|.
name|setClusterId
argument_list|(
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|MASTER
case|:
name|builder
operator|.
name|setMasterName
argument_list|(
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKUP_MASTERS
case|:
name|builder
operator|.
name|setBackerMasterNames
argument_list|(
name|getBackupMasters
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIVE_SERVERS
case|:
block|{
if|if
condition|(
name|serverManager
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setLiveServerMetrics
argument_list|(
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toMap
argument_list|(
name|e
lambda|->
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
lambda|->
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DEAD_SERVERS
case|:
block|{
if|if
condition|(
name|serverManager
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setDeadServerNames
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|serverManager
operator|.
name|getDeadServers
argument_list|()
operator|.
name|copyServerNames
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MASTER_COPROCESSORS
case|:
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setMasterCoprocessorNames
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|getMasterCoprocessors
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|REGIONS_IN_TRANSITION
case|:
block|{
if|if
condition|(
name|assignmentManager
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setRegionsInTransition
argument_list|(
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionsStateInTransition
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|BALANCER_ON
case|:
block|{
if|if
condition|(
name|loadBalancerTracker
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setBalancerOn
argument_list|(
name|loadBalancerTracker
operator|.
name|isBalancerOn
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MASTER_INFO_PORT
case|:
block|{
if|if
condition|(
name|infoServer
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setMasterInfoPort
argument_list|(
name|infoServer
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SERVERS_NAME
case|:
block|{
if|if
condition|(
name|serverManager
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setServerNames
argument_list|(
name|serverManager
operator|.
name|getOnlineServersList
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TABLE_TO_REGIONS_COUNT
case|:
block|{
if|if
condition|(
name|isActiveMaster
argument_list|()
operator|&&
name|isInitialized
argument_list|()
operator|&&
name|assignmentManager
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|Map
argument_list|<
name|TableName
argument_list|,
name|RegionStatesCount
argument_list|>
name|tableRegionStatesCountMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|TableDescriptor
argument_list|>
name|tableDescriptorMap
init|=
name|getTableDescriptors
argument_list|()
operator|.
name|getAll
argument_list|()
decl_stmt|;
for|for
control|(
name|TableDescriptor
name|tableDescriptor
range|:
name|tableDescriptorMap
operator|.
name|values
argument_list|()
control|)
block|{
name|TableName
name|tableName
init|=
name|tableDescriptor
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|RegionStatesCount
name|regionStatesCount
init|=
name|assignmentManager
operator|.
name|getRegionStatesCount
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|tableRegionStatesCountMap
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|regionStatesCount
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|setTableRegionStatesCount
argument_list|(
name|tableRegionStatesCountMap
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while populating TABLE_TO_REGIONS_COUNT for Cluster Metrics.."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * @return cluster status    */
specifier|public
name|ClusterMetrics
name|getClusterMetrics
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getClusterMetrics
argument_list|(
name|EnumSet
operator|.
name|allOf
argument_list|(
name|Option
operator|.
name|class
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|ClusterMetrics
name|getClusterMetrics
parameter_list|(
name|EnumSet
argument_list|<
name|Option
argument_list|>
name|options
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetClusterMetrics
argument_list|()
expr_stmt|;
block|}
name|ClusterMetrics
name|status
init|=
name|getClusterMetricsWithoutCoprocessor
argument_list|(
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetClusterMetrics
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
specifier|private
name|List
argument_list|<
name|ServerName
argument_list|>
name|getBackupMasters
parameter_list|()
throws|throws
name|InterruptedIOException
block|{
comment|// Build Set of backup masters from ZK nodes
name|List
argument_list|<
name|String
argument_list|>
name|backupMasterStrings
decl_stmt|;
try|try
block|{
name|backupMasterStrings
operator|=
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
operator|.
name|zooKeeper
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|backupMasterAddressesZNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|prefix
argument_list|(
literal|"Unable to list backup servers"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|backupMasterStrings
operator|=
literal|null
expr_stmt|;
block|}
name|List
argument_list|<
name|ServerName
argument_list|>
name|backupMasters
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
if|if
condition|(
name|backupMasterStrings
operator|!=
literal|null
operator|&&
operator|!
name|backupMasterStrings
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|backupMasters
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|backupMasterStrings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|backupMasterStrings
control|)
block|{
try|try
block|{
name|byte
index|[]
name|bytes
decl_stmt|;
try|try
block|{
name|bytes
operator|=
name|ZKUtil
operator|.
name|getData
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|backupMasterAddressesZNode
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
block|}
if|if
condition|(
name|bytes
operator|!=
literal|null
condition|)
block|{
name|ServerName
name|sn
decl_stmt|;
try|try
block|{
name|sn
operator|=
name|ProtobufUtil
operator|.
name|parseServerNameFrom
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed parse, skipping registering backup server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|backupMasters
operator|.
name|add
argument_list|(
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|prefix
argument_list|(
literal|"Unable to get information about "
operator|+
literal|"backup servers"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|backupMasters
argument_list|,
operator|new
name|Comparator
argument_list|<
name|ServerName
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|ServerName
name|s1
parameter_list|,
name|ServerName
name|s2
parameter_list|)
block|{
return|return
name|s1
operator|.
name|getServerName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|s2
operator|.
name|getServerName
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|backupMasters
return|;
block|}
comment|/**    * The set of loaded coprocessors is stored in a static set. Since it's    * statically allocated, it does not require that HMaster's cpHost be    * initialized prior to accessing it.    * @return a String representation of the set of names of the loaded coprocessors.    */
specifier|public
specifier|static
name|String
name|getLoadedCoprocessors
parameter_list|()
block|{
return|return
name|CoprocessorHost
operator|.
name|getLoadedCoprocessors
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @return timestamp in millis when HMaster was started.    */
specifier|public
name|long
name|getMasterStartTime
parameter_list|()
block|{
return|return
name|startcode
return|;
block|}
comment|/**    * @return timestamp in millis when HMaster became the active master.    */
specifier|public
name|long
name|getMasterActiveTime
parameter_list|()
block|{
return|return
name|masterActiveTime
return|;
block|}
comment|/**    * @return timestamp in millis when HMaster finished becoming the active master    */
specifier|public
name|long
name|getMasterFinishedInitializationTime
parameter_list|()
block|{
return|return
name|masterFinishedInitializationTime
return|;
block|}
specifier|public
name|int
name|getNumWALFiles
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|public
name|ProcedureStore
name|getProcedureStore
parameter_list|()
block|{
return|return
name|procedureStore
return|;
block|}
specifier|public
name|int
name|getRegionServerInfoPort
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
name|int
name|port
init|=
name|this
operator|.
name|serverManager
operator|.
name|getInfoPort
argument_list|(
name|sn
argument_list|)
decl_stmt|;
return|return
name|port
operator|==
literal|0
condition|?
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|REGIONSERVER_INFO_PORT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_REGIONSERVER_INFOPORT
argument_list|)
else|:
name|port
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getRegionServerVersion
parameter_list|(
name|ServerName
name|sn
parameter_list|)
block|{
comment|// Will return "0.0.0" if the server is not online to prevent move system region to unknown
comment|// version RS.
return|return
name|this
operator|.
name|serverManager
operator|.
name|getVersion
argument_list|(
name|sn
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkIfShouldMoveSystemRegionAsync
parameter_list|()
block|{
name|assignmentManager
operator|.
name|checkIfShouldMoveSystemRegionAsync
argument_list|()
expr_stmt|;
block|}
comment|/**    * @return array of coprocessor SimpleNames.    */
specifier|public
name|String
index|[]
name|getMasterCoprocessors
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|masterCoprocessors
init|=
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|getCoprocessors
argument_list|()
decl_stmt|;
return|return
name|masterCoprocessors
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|masterCoprocessors
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|reason
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
if|if
condition|(
name|isAborted
argument_list|()
operator|||
name|isStopped
argument_list|()
condition|)
block|{
return|return;
block|}
name|setAbortRequested
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
comment|// HBASE-4014: dump a list of loaded coprocessors.
name|LOG
operator|.
name|error
argument_list|(
name|HBaseMarkers
operator|.
name|FATAL
argument_list|,
literal|"Master server abort: loaded coprocessors are: "
operator|+
name|getLoadedCoprocessors
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|msg
init|=
literal|"***** ABORTING master "
operator|+
name|this
operator|+
literal|": "
operator|+
name|reason
operator|+
literal|" *****"
decl_stmt|;
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|HBaseMarkers
operator|.
name|FATAL
argument_list|,
name|msg
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
name|HBaseMarkers
operator|.
name|FATAL
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|stopMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception occurred while stopping master"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ZKWatcher
name|getZooKeeper
parameter_list|()
block|{
return|return
name|zooKeeper
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterCoprocessorHost
name|getMasterCoprocessorHost
parameter_list|()
block|{
return|return
name|cpHost
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterQuotaManager
name|getMasterQuotaManager
parameter_list|()
block|{
return|return
name|quotaManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|ProcedureExecutor
argument_list|<
name|MasterProcedureEnv
argument_list|>
name|getMasterProcedureExecutor
parameter_list|()
block|{
return|return
name|procedureExecutor
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerName
name|getServerName
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverName
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssignmentManager
name|getAssignmentManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|assignmentManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|CatalogJanitor
name|getCatalogJanitor
parameter_list|()
block|{
return|return
name|this
operator|.
name|catalogJanitorChore
return|;
block|}
specifier|public
name|MemoryBoundedLogMessageBuffer
name|getRegionServerFatalLogBuffer
parameter_list|()
block|{
return|return
name|rsFatals
return|;
block|}
comment|/**    * Shutdown the cluster.    * Master runs a coordinated stop of all RegionServers and then itself.    */
specifier|public
name|void
name|shutdown
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preShutdown
argument_list|()
expr_stmt|;
block|}
comment|// Tell the servermanager cluster shutdown has been called. This makes it so when Master is
comment|// last running server, it'll stop itself. Next, we broadcast the cluster shutdown by setting
comment|// the cluster status as down. RegionServers will notice this change in state and will start
comment|// shutting themselves down. When last has exited, Master can go down.
if|if
condition|(
name|this
operator|.
name|serverManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|serverManager
operator|.
name|shutdownCluster
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|clusterStatusTracker
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterDown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ZooKeeper exception trying to set cluster as down in ZK"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Stop the procedure executor. Will stop any ongoing assign, unassign, server crash etc.,
comment|// processing so we can go down.
if|if
condition|(
name|this
operator|.
name|procedureExecutor
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|procedureExecutor
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
comment|// Shutdown our cluster connection. This will kill any hosted RPCs that might be going on;
comment|// this is what we want especially if the Master is in startup phase doing call outs to
comment|// hbase:meta, etc. when cluster is down. Without ths connection close, we'd have to wait on
comment|// the rpc to timeout.
if|if
condition|(
name|this
operator|.
name|asyncClusterConnection
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|asyncClusterConnection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|stopMaster
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preStopMaster
argument_list|()
expr_stmt|;
block|}
name|stop
argument_list|(
literal|"Stopped by "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isStopped
argument_list|()
condition|)
block|{
name|super
operator|.
name|stop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|activeMasterManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|activeMasterManager
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|checkServiceStarted
parameter_list|()
throws|throws
name|ServerNotRunningYetException
block|{
if|if
condition|(
operator|!
name|serviceStarted
condition|)
block|{
throw|throw
operator|new
name|ServerNotRunningYetException
argument_list|(
literal|"Server is not running yet"
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
class|class
name|MasterStoppedException
extends|extends
name|DoNotRetryIOException
block|{
name|MasterStoppedException
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|checkInitialized
parameter_list|()
throws|throws
name|PleaseHoldException
throws|,
name|ServerNotRunningYetException
throws|,
name|MasterNotRunningException
throws|,
name|MasterStoppedException
block|{
name|checkServiceStarted
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PleaseHoldException
argument_list|(
literal|"Master is initializing"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isStopped
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MasterStoppedException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Report whether this master is currently the active master or not.    * If not active master, we are parked on ZK waiting to become active.    *    * This method is used for testing.    *    * @return true if active master, false if not.    */
annotation|@
name|Override
specifier|public
name|boolean
name|isActiveMaster
parameter_list|()
block|{
return|return
name|activeMaster
return|;
block|}
comment|/**    * Report whether this master has completed with its initialization and is    * ready.  If ready, the master is also the active master.  A standby master    * is never ready.    *    * This method is used for testing.    *    * @return true if master is ready to go, false if not.    */
annotation|@
name|Override
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
return|return
name|initialized
operator|.
name|isReady
argument_list|()
return|;
block|}
comment|/**    * Report whether this master is in maintenance mode.    *    * @return true if master is in maintenanceMode    */
annotation|@
name|Override
specifier|public
name|boolean
name|isInMaintenanceMode
parameter_list|()
block|{
return|return
name|maintenanceMode
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|setInitialized
parameter_list|(
name|boolean
name|isInitialized
parameter_list|)
block|{
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
operator|.
name|setEventReady
argument_list|(
name|initialized
argument_list|,
name|isInitialized
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|getInitializedEvent
parameter_list|()
block|{
return|return
name|initialized
return|;
block|}
comment|/**    * Compute the average load across all region servers.    * Currently, this uses a very naive computation - just uses the number of    * regions being served, ignoring stats about number of requests.    * @return the average load    */
specifier|public
name|double
name|getAverageLoad
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|RegionStates
name|regionStates
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionStates
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|regionStates
operator|.
name|getAverageLoad
argument_list|()
return|;
block|}
comment|/*    * @return the count of region split plans executed    */
specifier|public
name|long
name|getSplitPlanCount
parameter_list|()
block|{
return|return
name|splitPlanCount
return|;
block|}
comment|/*    * @return the count of region merge plans executed    */
specifier|public
name|long
name|getMergePlanCount
parameter_list|()
block|{
return|return
name|mergePlanCount
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|registerService
parameter_list|(
name|Service
name|instance
parameter_list|)
block|{
comment|/*      * No stacking of instances is allowed for a single service name      */
name|Descriptors
operator|.
name|ServiceDescriptor
name|serviceDesc
init|=
name|instance
operator|.
name|getDescriptorForType
argument_list|()
decl_stmt|;
name|String
name|serviceName
init|=
name|CoprocessorRpcUtils
operator|.
name|getServiceName
argument_list|(
name|serviceDesc
argument_list|)
decl_stmt|;
if|if
condition|(
name|coprocessorServiceHandlers
operator|.
name|containsKey
argument_list|(
name|serviceName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor service "
operator|+
name|serviceName
operator|+
literal|" already registered, rejecting request from "
operator|+
name|instance
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|coprocessorServiceHandlers
operator|.
name|put
argument_list|(
name|serviceName
argument_list|,
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Registered master coprocessor service: service="
operator|+
name|serviceName
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Utility for constructing an instance of the passed HMaster class.    * @param masterClass    * @return HMaster instance.    */
specifier|public
specifier|static
name|HMaster
name|constructMaster
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|masterClass
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|c
init|=
name|masterClass
operator|.
name|getConstructor
argument_list|(
name|Configuration
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|c
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Throwable
name|error
init|=
name|e
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|InvocationTargetException
operator|&&
operator|(
operator|(
name|InvocationTargetException
operator|)
name|e
operator|)
operator|.
name|getTargetException
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|error
operator|=
operator|(
operator|(
name|InvocationTargetException
operator|)
name|e
operator|)
operator|.
name|getTargetException
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of Master: "
operator|+
name|masterClass
operator|.
name|toString
argument_list|()
operator|+
literal|". "
argument_list|,
name|error
argument_list|)
throw|;
block|}
block|}
comment|/**    * @see org.apache.hadoop.hbase.master.HMasterCommandLine    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"STARTING service "
operator|+
name|HMaster
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|VersionInfo
operator|.
name|logVersion
argument_list|()
expr_stmt|;
operator|new
name|HMasterCommandLine
argument_list|(
name|HMaster
operator|.
name|class
argument_list|)
operator|.
name|doMain
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
specifier|public
name|HFileCleaner
name|getHFileCleaner
parameter_list|()
block|{
return|return
name|this
operator|.
name|hfileCleaner
return|;
block|}
specifier|public
name|LogCleaner
name|getLogCleaner
parameter_list|()
block|{
return|return
name|this
operator|.
name|logCleaner
return|;
block|}
comment|/**    * @return the underlying snapshot manager    */
annotation|@
name|Override
specifier|public
name|SnapshotManager
name|getSnapshotManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotManager
return|;
block|}
comment|/**    * @return the underlying MasterProcedureManagerHost    */
annotation|@
name|Override
specifier|public
name|MasterProcedureManagerHost
name|getMasterProcedureManagerHost
parameter_list|()
block|{
return|return
name|mpmHost
return|;
block|}
annotation|@
name|Override
specifier|public
name|ClusterSchema
name|getClusterSchema
parameter_list|()
block|{
return|return
name|this
operator|.
name|clusterSchemaService
return|;
block|}
comment|/**    * Create a new Namespace.    * @param namespaceDescriptor descriptor for new Namespace    * @param nonceGroup Identifier for the source of the request, a client or process.    * @param nonce A unique identifier for this operation from the client or process identified by    *<code>nonceGroup</code> (the source must ensure each operation gets a unique id).    * @return procedure id    */
name|long
name|createNamespace
parameter_list|(
specifier|final
name|NamespaceDescriptor
name|namespaceDescriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|TableName
operator|.
name|isLegalNamespaceName
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|namespaceDescriptor
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preCreateNamespace
argument_list|(
name|namespaceDescriptor
argument_list|)
expr_stmt|;
comment|// We need to wait for the procedure to potentially fail due to "prepare" sanity
comment|// checks. This will block only the beginning of the procedure. See HBASE-19953.
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createBlockingLatch
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" creating "
operator|+
name|namespaceDescriptor
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation to complete before
comment|// continuing.
name|setProcId
argument_list|(
name|getClusterSchema
argument_list|()
operator|.
name|createNamespace
argument_list|(
name|namespaceDescriptor
argument_list|,
name|getNonceKey
argument_list|()
argument_list|,
name|latch
argument_list|)
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postCreateNamespace
argument_list|(
name|namespaceDescriptor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"CreateNamespaceProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Modify an existing Namespace.    * @param nonceGroup Identifier for the source of the request, a client or process.    * @param nonce A unique identifier for this operation from the client or process identified by    *<code>nonceGroup</code> (the source must ensure each operation gets a unique id).    * @return procedure id    */
name|long
name|modifyNamespace
parameter_list|(
specifier|final
name|NamespaceDescriptor
name|newNsDescriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|TableName
operator|.
name|isLegalNamespaceName
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|newNsDescriptor
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|NamespaceDescriptor
name|oldNsDescriptor
init|=
name|getNamespace
argument_list|(
name|newNsDescriptor
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preModifyNamespace
argument_list|(
name|oldNsDescriptor
argument_list|,
name|newNsDescriptor
argument_list|)
expr_stmt|;
comment|// We need to wait for the procedure to potentially fail due to "prepare" sanity
comment|// checks. This will block only the beginning of the procedure. See HBASE-19953.
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createBlockingLatch
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" modify "
operator|+
name|newNsDescriptor
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation to complete before
comment|// continuing.
name|setProcId
argument_list|(
name|getClusterSchema
argument_list|()
operator|.
name|modifyNamespace
argument_list|(
name|newNsDescriptor
argument_list|,
name|getNonceKey
argument_list|()
argument_list|,
name|latch
argument_list|)
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postModifyNamespace
argument_list|(
name|oldNsDescriptor
argument_list|,
name|newNsDescriptor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"ModifyNamespaceProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Delete an existing Namespace. Only empty Namespaces (no tables) can be removed.    * @param nonceGroup Identifier for the source of the request, a client or process.    * @param nonce A unique identifier for this operation from the client or process identified by    *<code>nonceGroup</code> (the source must ensure each operation gets a unique id).    * @return procedure id    */
name|long
name|deleteNamespace
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|preDeleteNamespace
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" delete "
operator|+
name|name
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation to complete before
comment|// continuing.
comment|//
comment|// We need to wait for the procedure to potentially fail due to "prepare" sanity
comment|// checks. This will block only the beginning of the procedure. See HBASE-19953.
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createBlockingLatch
argument_list|()
decl_stmt|;
name|setProcId
argument_list|(
name|submitProcedure
argument_list|(
operator|new
name|DeleteNamespaceProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|name
argument_list|,
name|latch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
comment|// Will not be invoked in the face of Exception thrown by the Procedure's execution
name|getMaster
argument_list|()
operator|.
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|postDeleteNamespace
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"DeleteNamespaceProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Get a Namespace    * @param name Name of the Namespace    * @return Namespace descriptor for<code>name</code>    */
name|NamespaceDescriptor
name|getNamespace
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|cpHost
operator|.
name|preGetNamespaceDescriptor
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|NamespaceDescriptor
name|nsd
init|=
name|this
operator|.
name|clusterSchemaService
operator|.
name|getNamespace
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|cpHost
operator|.
name|postGetNamespaceDescriptor
argument_list|(
name|nsd
argument_list|)
expr_stmt|;
return|return
name|nsd
return|;
block|}
comment|/**    * Get all Namespaces    * @return All Namespace descriptors    */
name|List
argument_list|<
name|NamespaceDescriptor
argument_list|>
name|getNamespaces
parameter_list|()
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|NamespaceDescriptor
argument_list|>
name|nsds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preListNamespaceDescriptors
argument_list|(
name|nsds
argument_list|)
expr_stmt|;
block|}
name|nsds
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|clusterSchemaService
operator|.
name|getNamespaces
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cpHost
operator|.
name|postListNamespaceDescriptors
argument_list|(
name|nsds
argument_list|)
expr_stmt|;
block|}
return|return
name|nsds
return|;
block|}
comment|/**    * List namespace names    * @return All namespace names    */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|listNamespaces
parameter_list|()
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|namespaces
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preListNamespaces
argument_list|(
name|namespaces
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|NamespaceDescriptor
name|namespace
range|:
name|clusterSchemaService
operator|.
name|getNamespaces
argument_list|()
control|)
block|{
name|namespaces
operator|.
name|add
argument_list|(
name|namespace
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postListNamespaces
argument_list|(
name|namespaces
argument_list|)
expr_stmt|;
block|}
return|return
name|namespaces
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|TableName
argument_list|>
name|listTableNamesByNamespace
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|listTableNames
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|TableDescriptor
argument_list|>
name|listTableDescriptorsByNamespace
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|listTableDescriptors
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|abortProcedure
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|,
specifier|final
name|boolean
name|mayInterruptIfRunning
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preAbortProcedure
argument_list|(
name|this
operator|.
name|procedureExecutor
argument_list|,
name|procId
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|result
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|abort
argument_list|(
name|procId
argument_list|,
name|mayInterruptIfRunning
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postAbortProcedure
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Procedure
argument_list|<
name|?
argument_list|>
argument_list|>
name|getProcedures
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetProcedures
argument_list|()
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
name|List
argument_list|<
name|Procedure
argument_list|<
name|?
argument_list|>
argument_list|>
name|procList
init|=
operator|(
name|List
operator|)
name|this
operator|.
name|procedureExecutor
operator|.
name|getProcedures
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetProcedures
argument_list|(
name|procList
argument_list|)
expr_stmt|;
block|}
return|return
name|procList
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|LockedResource
argument_list|>
name|getLocks
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetLocks
argument_list|()
expr_stmt|;
block|}
name|MasterProcedureScheduler
name|procedureScheduler
init|=
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getProcedureScheduler
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|LockedResource
argument_list|>
name|lockedResources
init|=
name|procedureScheduler
operator|.
name|getLocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetLocks
argument_list|(
name|lockedResources
argument_list|)
expr_stmt|;
block|}
return|return
name|lockedResources
return|;
block|}
comment|/**    * Returns the list of table descriptors that match the specified request    * @param namespace the namespace to query, or null if querying for all    * @param regex The regular expression to match against, or null if querying for all    * @param tableNameList the list of table names, or null if querying for all    * @param includeSysTables False to match only against userspace tables    * @return the list of table descriptors    */
specifier|public
name|List
argument_list|<
name|TableDescriptor
argument_list|>
name|listTableDescriptors
parameter_list|(
specifier|final
name|String
name|namespace
parameter_list|,
specifier|final
name|String
name|regex
parameter_list|,
specifier|final
name|List
argument_list|<
name|TableName
argument_list|>
name|tableNameList
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|TableDescriptor
argument_list|>
name|htds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetTableDescriptors
argument_list|(
name|tableNameList
argument_list|,
name|htds
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
name|htds
operator|=
name|getTableDescriptors
argument_list|(
name|htds
argument_list|,
name|namespace
argument_list|,
name|regex
argument_list|,
name|tableNameList
argument_list|,
name|includeSysTables
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetTableDescriptors
argument_list|(
name|tableNameList
argument_list|,
name|htds
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
return|return
name|htds
return|;
block|}
comment|/**    * Returns the list of table names that match the specified request    * @param regex The regular expression to match against, or null if querying for all    * @param namespace the namespace to query, or null if querying for all    * @param includeSysTables False to match only against userspace tables    * @return the list of table names    */
specifier|public
name|List
argument_list|<
name|TableName
argument_list|>
name|listTableNames
parameter_list|(
specifier|final
name|String
name|namespace
parameter_list|,
specifier|final
name|String
name|regex
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|TableDescriptor
argument_list|>
name|htds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetTableNames
argument_list|(
name|htds
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
name|htds
operator|=
name|getTableDescriptors
argument_list|(
name|htds
argument_list|,
name|namespace
argument_list|,
name|regex
argument_list|,
literal|null
argument_list|,
name|includeSysTables
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetTableNames
argument_list|(
name|htds
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|TableName
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|htds
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|TableDescriptor
name|htd
range|:
name|htds
control|)
name|result
operator|.
name|add
argument_list|(
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * @return list of table table descriptors after filtering by regex and whether to include system    *    tables, etc.    * @throws IOException    */
specifier|private
name|List
argument_list|<
name|TableDescriptor
argument_list|>
name|getTableDescriptors
parameter_list|(
specifier|final
name|List
argument_list|<
name|TableDescriptor
argument_list|>
name|htds
parameter_list|,
specifier|final
name|String
name|namespace
parameter_list|,
specifier|final
name|String
name|regex
parameter_list|,
specifier|final
name|List
argument_list|<
name|TableName
argument_list|>
name|tableNameList
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableNameList
operator|==
literal|null
operator|||
name|tableNameList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// request for all TableDescriptors
name|Collection
argument_list|<
name|TableDescriptor
argument_list|>
name|allHtds
decl_stmt|;
if|if
condition|(
name|namespace
operator|!=
literal|null
operator|&&
name|namespace
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Do a check on the namespace existence. Will fail if does not exist.
name|this
operator|.
name|clusterSchemaService
operator|.
name|getNamespace
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
name|allHtds
operator|=
name|tableDescriptors
operator|.
name|getByNamespace
argument_list|(
name|namespace
argument_list|)
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|allHtds
operator|=
name|tableDescriptors
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|TableDescriptor
name|desc
range|:
name|allHtds
control|)
block|{
if|if
condition|(
name|tableStateManager
operator|.
name|isTablePresent
argument_list|(
name|desc
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|&&
operator|(
name|includeSysTables
operator|||
operator|!
name|desc
operator|.
name|getTableName
argument_list|()
operator|.
name|isSystemTable
argument_list|()
operator|)
condition|)
block|{
name|htds
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|TableName
name|s
range|:
name|tableNameList
control|)
block|{
if|if
condition|(
name|tableStateManager
operator|.
name|isTablePresent
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|TableDescriptor
name|desc
init|=
name|tableDescriptors
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
name|htds
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Retains only those matched by regular expression.
if|if
condition|(
name|regex
operator|!=
literal|null
condition|)
name|filterTablesByRegex
argument_list|(
name|htds
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|htds
return|;
block|}
comment|/**    * Removes the table descriptors that don't match the pattern.    * @param descriptors list of table descriptors to filter    * @param pattern the regex to use    */
specifier|private
specifier|static
name|void
name|filterTablesByRegex
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|TableDescriptor
argument_list|>
name|descriptors
parameter_list|,
specifier|final
name|Pattern
name|pattern
parameter_list|)
block|{
specifier|final
name|String
name|defaultNS
init|=
name|NamespaceDescriptor
operator|.
name|DEFAULT_NAMESPACE_NAME_STR
decl_stmt|;
name|Iterator
argument_list|<
name|TableDescriptor
argument_list|>
name|itr
init|=
name|descriptors
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|TableDescriptor
name|htd
init|=
name|itr
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|tableName
init|=
name|htd
operator|.
name|getTableName
argument_list|()
operator|.
name|getNameAsString
argument_list|()
decl_stmt|;
name|boolean
name|matched
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|tableName
argument_list|)
operator|.
name|matches
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|matched
operator|&&
name|htd
operator|.
name|getTableName
argument_list|()
operator|.
name|getNamespaceAsString
argument_list|()
operator|.
name|equals
argument_list|(
name|defaultNS
argument_list|)
condition|)
block|{
name|matched
operator|=
name|pattern
operator|.
name|matcher
argument_list|(
name|defaultNS
operator|+
name|TableName
operator|.
name|NAMESPACE_DELIM
operator|+
name|tableName
argument_list|)
operator|.
name|matches
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|itr
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLastMajorCompactionTimestamp
parameter_list|(
name|TableName
name|table
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getClusterMetrics
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|Option
operator|.
name|LIVE_SERVERS
argument_list|)
argument_list|)
operator|.
name|getLastMajorCompactionTimestamp
argument_list|(
name|table
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLastMajorCompactionTimestampForRegion
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getClusterMetrics
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|Option
operator|.
name|LIVE_SERVERS
argument_list|)
argument_list|)
operator|.
name|getLastMajorCompactionTimestamp
argument_list|(
name|regionName
argument_list|)
return|;
block|}
comment|/**    * Gets the mob file compaction state for a specific table.    * Whether all the mob files are selected is known during the compaction execution, but    * the statistic is done just before compaction starts, it is hard to know the compaction    * type at that time, so the rough statistics are chosen for the mob file compaction. Only two    * compaction states are available, CompactionState.MAJOR_AND_MINOR and CompactionState.NONE.    * @param tableName The current table name.    * @return If a given table is in mob file compaction now.    */
specifier|public
name|CompactionState
name|getMobCompactionState
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
name|AtomicInteger
name|compactionsCount
init|=
name|mobCompactionStates
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|compactionsCount
operator|!=
literal|null
operator|&&
name|compactionsCount
operator|.
name|get
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|CompactionState
operator|.
name|MAJOR_AND_MINOR
return|;
block|}
return|return
name|CompactionState
operator|.
name|NONE
return|;
block|}
specifier|public
name|void
name|reportMobCompactionStart
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|IdLock
operator|.
name|Entry
name|lockEntry
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockEntry
operator|=
name|mobCompactionLock
operator|.
name|getLockEntry
argument_list|(
name|tableName
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|AtomicInteger
name|compactionsCount
init|=
name|mobCompactionStates
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|compactionsCount
operator|==
literal|null
condition|)
block|{
name|compactionsCount
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mobCompactionStates
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|compactionsCount
argument_list|)
expr_stmt|;
block|}
name|compactionsCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|lockEntry
operator|!=
literal|null
condition|)
block|{
name|mobCompactionLock
operator|.
name|releaseLockEntry
argument_list|(
name|lockEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|reportMobCompactionEnd
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|IdLock
operator|.
name|Entry
name|lockEntry
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockEntry
operator|=
name|mobCompactionLock
operator|.
name|getLockEntry
argument_list|(
name|tableName
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|AtomicInteger
name|compactionsCount
init|=
name|mobCompactionStates
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|compactionsCount
operator|!=
literal|null
condition|)
block|{
name|int
name|count
init|=
name|compactionsCount
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
comment|// remove the entry if the count is 0.
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|mobCompactionStates
operator|.
name|remove
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|lockEntry
operator|!=
literal|null
condition|)
block|{
name|mobCompactionLock
operator|.
name|releaseLockEntry
argument_list|(
name|lockEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Requests mob compaction.    * @param tableName The table the compact.    * @param columns The compacted columns.    * @param allFiles Whether add all mob files into the compaction.    */
specifier|public
name|void
name|requestMobCompaction
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|List
argument_list|<
name|ColumnFamilyDescriptor
argument_list|>
name|columns
parameter_list|,
name|boolean
name|allFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|mobCompactThread
operator|.
name|requestMobCompaction
argument_list|(
name|conf
argument_list|,
name|getFileSystem
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|columns
argument_list|,
name|allFiles
argument_list|)
expr_stmt|;
block|}
comment|/**    * Queries the state of the {@link LoadBalancerTracker}. If the balancer is not initialized,    * false is returned.    *    * @return The state of the load balancer, or false if the load balancer isn't defined.    */
specifier|public
name|boolean
name|isBalancerOn
parameter_list|()
block|{
return|return
operator|!
name|isInMaintenanceMode
argument_list|()
operator|&&
name|loadBalancerTracker
operator|!=
literal|null
operator|&&
name|loadBalancerTracker
operator|.
name|isBalancerOn
argument_list|()
return|;
block|}
comment|/**    * Queries the state of the {@link RegionNormalizerTracker}. If it's not initialized,    * false is returned.    */
specifier|public
name|boolean
name|isNormalizerOn
parameter_list|()
block|{
return|return
operator|!
name|isInMaintenanceMode
argument_list|()
operator|&&
name|regionNormalizerTracker
operator|!=
literal|null
operator|&&
name|regionNormalizerTracker
operator|.
name|isNormalizerOn
argument_list|()
return|;
block|}
comment|/**    * Queries the state of the {@link SplitOrMergeTracker}. If it is not initialized,    * false is returned. If switchType is illegal, false will return.    * @param switchType see {@link org.apache.hadoop.hbase.client.MasterSwitchType}    * @return The state of the switch    */
annotation|@
name|Override
specifier|public
name|boolean
name|isSplitOrMergeEnabled
parameter_list|(
name|MasterSwitchType
name|switchType
parameter_list|)
block|{
return|return
operator|!
name|isInMaintenanceMode
argument_list|()
operator|&&
name|splitOrMergeTracker
operator|!=
literal|null
operator|&&
name|splitOrMergeTracker
operator|.
name|isSplitOrMergeEnabled
argument_list|(
name|switchType
argument_list|)
return|;
block|}
comment|/**    * Fetch the configured {@link LoadBalancer} class name. If none is set, a default is returned.    *    * @return The name of the {@link LoadBalancer} in use.    */
specifier|public
name|String
name|getLoadBalancerClassName
parameter_list|()
block|{
return|return
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_MASTER_LOADBALANCER_CLASS
argument_list|,
name|LoadBalancerFactory
operator|.
name|getDefaultLoadBalancerClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return RegionNormalizerTracker instance    */
specifier|public
name|RegionNormalizerTracker
name|getRegionNormalizerTracker
parameter_list|()
block|{
return|return
name|regionNormalizerTracker
return|;
block|}
specifier|public
name|SplitOrMergeTracker
name|getSplitOrMergeTracker
parameter_list|()
block|{
return|return
name|splitOrMergeTracker
return|;
block|}
annotation|@
name|Override
specifier|public
name|LoadBalancer
name|getLoadBalancer
parameter_list|()
block|{
return|return
name|balancer
return|;
block|}
annotation|@
name|Override
specifier|public
name|FavoredNodesManager
name|getFavoredNodesManager
parameter_list|()
block|{
return|return
name|favoredNodesManager
return|;
block|}
specifier|private
name|long
name|executePeerProcedure
parameter_list|(
name|AbstractPeerProcedure
argument_list|<
name|?
argument_list|>
name|procedure
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|procId
init|=
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
name|procedure
argument_list|)
decl_stmt|;
name|procedure
operator|.
name|getLatch
argument_list|()
operator|.
name|await
argument_list|()
expr_stmt|;
return|return
name|procId
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|addReplicationPeer
parameter_list|(
name|String
name|peerId
parameter_list|,
name|ReplicationPeerConfig
name|peerConfig
parameter_list|,
name|boolean
name|enabled
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" creating replication peer, id="
operator|+
name|peerId
operator|+
literal|", config="
operator|+
name|peerConfig
operator|+
literal|", state="
operator|+
operator|(
name|enabled
condition|?
literal|"ENABLED"
else|:
literal|"DISABLED"
operator|)
argument_list|)
expr_stmt|;
return|return
name|executePeerProcedure
argument_list|(
operator|new
name|AddPeerProcedure
argument_list|(
name|peerId
argument_list|,
name|peerConfig
argument_list|,
name|enabled
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|removeReplicationPeer
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" removing replication peer, id="
operator|+
name|peerId
argument_list|)
expr_stmt|;
return|return
name|executePeerProcedure
argument_list|(
operator|new
name|RemovePeerProcedure
argument_list|(
name|peerId
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|enableReplicationPeer
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" enable replication peer, id="
operator|+
name|peerId
argument_list|)
expr_stmt|;
return|return
name|executePeerProcedure
argument_list|(
operator|new
name|EnablePeerProcedure
argument_list|(
name|peerId
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|disableReplicationPeer
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" disable replication peer, id="
operator|+
name|peerId
argument_list|)
expr_stmt|;
return|return
name|executePeerProcedure
argument_list|(
operator|new
name|DisablePeerProcedure
argument_list|(
name|peerId
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReplicationPeerConfig
name|getReplicationPeerConfig
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preGetReplicationPeerConfig
argument_list|(
name|peerId
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" get replication peer config, id="
operator|+
name|peerId
argument_list|)
expr_stmt|;
name|ReplicationPeerConfig
name|peerConfig
init|=
name|this
operator|.
name|replicationPeerManager
operator|.
name|getPeerConfig
argument_list|(
name|peerId
argument_list|)
operator|.
name|orElseThrow
argument_list|(
parameter_list|()
lambda|->
operator|new
name|ReplicationPeerNotFoundException
argument_list|(
name|peerId
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetReplicationPeerConfig
argument_list|(
name|peerId
argument_list|)
expr_stmt|;
block|}
return|return
name|peerConfig
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|updateReplicationPeerConfig
parameter_list|(
name|String
name|peerId
parameter_list|,
name|ReplicationPeerConfig
name|peerConfig
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" update replication peer config, id="
operator|+
name|peerId
operator|+
literal|", config="
operator|+
name|peerConfig
argument_list|)
expr_stmt|;
return|return
name|executePeerProcedure
argument_list|(
operator|new
name|UpdatePeerConfigProcedure
argument_list|(
name|peerId
argument_list|,
name|peerConfig
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ReplicationPeerDescription
argument_list|>
name|listReplicationPeers
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preListReplicationPeers
argument_list|(
name|regex
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} list replication peers, regex={}"
argument_list|,
name|getClientIdAuditPrefix
argument_list|()
argument_list|,
name|regex
argument_list|)
expr_stmt|;
name|Pattern
name|pattern
init|=
name|regex
operator|==
literal|null
condition|?
literal|null
else|:
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ReplicationPeerDescription
argument_list|>
name|peers
init|=
name|this
operator|.
name|replicationPeerManager
operator|.
name|listPeers
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postListReplicationPeers
argument_list|(
name|regex
argument_list|)
expr_stmt|;
block|}
return|return
name|peers
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|transitReplicationPeerSyncReplicationState
parameter_list|(
name|String
name|peerId
parameter_list|,
name|SyncReplicationState
name|state
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" transit current cluster state to {} in a synchronous replication peer id={}"
argument_list|,
name|state
argument_list|,
name|peerId
argument_list|)
expr_stmt|;
return|return
name|executePeerProcedure
argument_list|(
operator|new
name|TransitPeerSyncReplicationStateProcedure
argument_list|(
name|peerId
argument_list|,
name|state
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Mark region server(s) as decommissioned (previously called 'draining') to prevent additional    * regions from getting assigned to them. Also unload the regions on the servers asynchronously.0    * @param servers Region servers to decommission.    */
specifier|public
name|void
name|decommissionRegionServers
parameter_list|(
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|,
specifier|final
name|boolean
name|offload
parameter_list|)
throws|throws
name|HBaseIOException
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|serversAdded
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|servers
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Place the decommission marker first.
name|String
name|parentZnode
init|=
name|getZooKeeper
argument_list|()
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|drainingZNode
decl_stmt|;
for|for
control|(
name|ServerName
name|server
range|:
name|servers
control|)
block|{
try|try
block|{
name|String
name|node
init|=
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|parentZnode
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
argument_list|)
decl_stmt|;
name|ZKUtil
operator|.
name|createAndFailSilent
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|prefix
argument_list|(
literal|"Unable to decommission '"
operator|+
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|"'."
argument_list|)
argument_list|,
name|ke
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|.
name|addServerToDrainList
argument_list|(
name|server
argument_list|)
condition|)
block|{
name|serversAdded
operator|.
name|add
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Move the regions off the decommissioned servers.
if|if
condition|(
name|offload
condition|)
block|{
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|destServers
init|=
name|this
operator|.
name|serverManager
operator|.
name|createDestinationServersList
argument_list|()
decl_stmt|;
for|for
control|(
name|ServerName
name|server
range|:
name|serversAdded
control|)
block|{
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|regionsOnServer
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionsOnServer
argument_list|(
name|server
argument_list|)
decl_stmt|;
for|for
control|(
name|RegionInfo
name|hri
range|:
name|regionsOnServer
control|)
block|{
name|ServerName
name|dest
init|=
name|balancer
operator|.
name|randomAssignment
argument_list|(
name|hri
argument_list|,
name|destServers
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
literal|"Unable to determine a plan to move "
operator|+
name|hri
argument_list|)
throw|;
block|}
name|RegionPlan
name|rp
init|=
operator|new
name|RegionPlan
argument_list|(
name|hri
argument_list|,
name|server
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|moveAsync
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * List region servers marked as decommissioned (previously called 'draining') to not get regions    * assigned to them.    * @return List of decommissioned servers.    */
specifier|public
name|List
argument_list|<
name|ServerName
argument_list|>
name|listDecommissionedRegionServers
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverManager
operator|.
name|getDrainingServersList
argument_list|()
return|;
block|}
comment|/**    * Remove decommission marker (previously called 'draining') from a region server to allow regions    * assignments. Load regions onto the server asynchronously if a list of regions is given    * @param server Region server to remove decommission marker from.    */
specifier|public
name|void
name|recommissionRegionServer
parameter_list|(
specifier|final
name|ServerName
name|server
parameter_list|,
specifier|final
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|encodedRegionNames
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Remove the server from decommissioned (draining) server list.
name|String
name|parentZnode
init|=
name|getZooKeeper
argument_list|()
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|drainingZNode
decl_stmt|;
name|String
name|node
init|=
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|parentZnode
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|ZKUtil
operator|.
name|deleteNodeFailSilent
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|prefix
argument_list|(
literal|"Unable to recommission '"
operator|+
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|"'."
argument_list|)
argument_list|,
name|ke
argument_list|)
throw|;
block|}
name|this
operator|.
name|serverManager
operator|.
name|removeServerFromDrainList
argument_list|(
name|server
argument_list|)
expr_stmt|;
comment|// Load the regions onto the server if we are given a list of regions.
if|if
condition|(
name|encodedRegionNames
operator|==
literal|null
operator|||
name|encodedRegionNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|server
argument_list|)
condition|)
block|{
return|return;
block|}
for|for
control|(
name|byte
index|[]
name|encodedRegionName
range|:
name|encodedRegionNames
control|)
block|{
name|RegionState
name|regionState
init|=
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionState
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionState
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown region "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RegionInfo
name|hri
init|=
name|regionState
operator|.
name|getRegion
argument_list|()
decl_stmt|;
if|if
condition|(
name|server
operator|.
name|equals
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping move of region "
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" because region already assigned to the same server "
operator|+
name|server
operator|+
literal|"."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RegionPlan
name|rp
init|=
operator|new
name|RegionPlan
argument_list|(
name|hri
argument_list|,
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|,
name|server
argument_list|)
decl_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|moveAsync
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|LockManager
name|getLockManager
parameter_list|()
block|{
return|return
name|lockManager
return|;
block|}
specifier|public
name|QuotaObserverChore
name|getQuotaObserverChore
parameter_list|()
block|{
return|return
name|this
operator|.
name|quotaObserverChore
return|;
block|}
specifier|public
name|SpaceQuotaSnapshotNotifier
name|getSpaceQuotaSnapshotNotifier
parameter_list|()
block|{
return|return
name|this
operator|.
name|spaceQuotaSnapshotNotifier
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|RemoteProcedure
argument_list|<
name|MasterProcedureEnv
argument_list|,
name|?
argument_list|>
name|getRemoteProcedure
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
init|=
name|procedureExecutor
operator|.
name|getProcedure
argument_list|(
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|procedure
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
assert|assert
name|procedure
operator|instanceof
name|RemoteProcedure
assert|;
return|return
operator|(
name|RemoteProcedure
argument_list|<
name|MasterProcedureEnv
argument_list|,
name|?
argument_list|>
operator|)
name|procedure
return|;
block|}
specifier|public
name|void
name|remoteProcedureCompleted
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Remote procedure done, pid={}"
argument_list|,
name|procId
argument_list|)
expr_stmt|;
name|RemoteProcedure
argument_list|<
name|MasterProcedureEnv
argument_list|,
name|?
argument_list|>
name|procedure
init|=
name|getRemoteProcedure
argument_list|(
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|procedure
operator|!=
literal|null
condition|)
block|{
name|procedure
operator|.
name|remoteOperationCompleted
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|remoteProcedureFailed
parameter_list|(
name|long
name|procId
parameter_list|,
name|RemoteProcedureException
name|error
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Remote procedure failed, pid={}"
argument_list|,
name|procId
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|RemoteProcedure
argument_list|<
name|MasterProcedureEnv
argument_list|,
name|?
argument_list|>
name|procedure
init|=
name|getRemoteProcedure
argument_list|(
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|procedure
operator|!=
literal|null
condition|)
block|{
name|procedure
operator|.
name|remoteOperationFailed
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Reopen regions provided in the argument    *    * @param tableName The current table name    * @param regionNames The region names of the regions to reopen    * @param nonceGroup Identifier for the source of the request, a client or process    * @param nonce A unique identifier for this operation from the client or process identified by    *<code>nonceGroup</code> (the source must ensure each operation gets a unique id).    * @return procedure Id    * @throws IOException if reopening region fails while running procedure    */
name|long
name|reopenRegions
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|regionNames
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|MasterProcedureUtil
operator|.
name|submitProcedure
argument_list|(
operator|new
name|MasterProcedureUtil
operator|.
name|NonceProcedureRunnable
argument_list|(
name|this
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|submitProcedure
argument_list|(
operator|new
name|ReopenTableRegionsProcedure
argument_list|(
name|tableName
argument_list|,
name|regionNames
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getDescription
parameter_list|()
block|{
return|return
literal|"ReopenTableRegionsProcedure"
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReplicationPeerManager
name|getReplicationPeerManager
parameter_list|()
block|{
return|return
name|replicationPeerManager
return|;
block|}
specifier|public
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|ServerName
argument_list|,
name|ReplicationLoadSource
argument_list|>
argument_list|>
argument_list|>
name|getReplicationLoad
parameter_list|(
name|ServerName
index|[]
name|serverNames
parameter_list|)
block|{
name|List
argument_list|<
name|ReplicationPeerDescription
argument_list|>
name|peerList
init|=
name|this
operator|.
name|getReplicationPeerManager
argument_list|()
operator|.
name|listPeers
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|peerList
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|ServerName
argument_list|,
name|ReplicationLoadSource
argument_list|>
argument_list|>
argument_list|>
name|replicationLoadSourceMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|peerList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|peerList
operator|.
name|stream
argument_list|()
operator|.
name|forEach
argument_list|(
name|peer
lambda|->
name|replicationLoadSourceMap
operator|.
name|put
argument_list|(
name|peer
operator|.
name|getPeerId
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ServerName
name|serverName
range|:
name|serverNames
control|)
block|{
name|List
argument_list|<
name|ReplicationLoadSource
argument_list|>
name|replicationLoadSources
init|=
name|getServerManager
argument_list|()
operator|.
name|getLoad
argument_list|(
name|serverName
argument_list|)
operator|.
name|getReplicationLoadSourceList
argument_list|()
decl_stmt|;
for|for
control|(
name|ReplicationLoadSource
name|replicationLoadSource
range|:
name|replicationLoadSources
control|)
block|{
name|replicationLoadSourceMap
operator|.
name|get
argument_list|(
name|replicationLoadSource
operator|.
name|getPeerID
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<>
argument_list|(
name|serverName
argument_list|,
name|replicationLoadSource
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|List
argument_list|<
name|Pair
argument_list|<
name|ServerName
argument_list|,
name|ReplicationLoadSource
argument_list|>
argument_list|>
name|loads
range|:
name|replicationLoadSourceMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|loads
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|loads
operator|.
name|sort
argument_list|(
name|Comparator
operator|.
name|comparingLong
argument_list|(
name|load
lambda|->
operator|(
operator|-
literal|1
operator|)
operator|*
name|load
operator|.
name|getSecond
argument_list|()
operator|.
name|getReplicationLag
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|replicationLoadSourceMap
return|;
block|}
comment|/**    * This method modifies the master's configuration in order to inject replication-related features    */
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
name|void
name|decorateMasterConfiguration
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|plugins
init|=
name|conf
operator|.
name|get
argument_list|(
name|HBASE_MASTER_LOGCLEANER_PLUGINS
argument_list|)
decl_stmt|;
name|String
name|cleanerClass
init|=
name|ReplicationLogCleaner
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|plugins
operator|.
name|contains
argument_list|(
name|cleanerClass
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|HBASE_MASTER_LOGCLEANER_PLUGINS
argument_list|,
name|plugins
operator|+
literal|","
operator|+
name|cleanerClass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ReplicationUtils
operator|.
name|isReplicationForBulkLoadDataEnabled
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|plugins
operator|=
name|conf
operator|.
name|get
argument_list|(
name|HFileCleaner
operator|.
name|MASTER_HFILE_CLEANER_PLUGINS
argument_list|)
expr_stmt|;
name|cleanerClass
operator|=
name|ReplicationHFileCleaner
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|plugins
operator|.
name|contains
argument_list|(
name|cleanerClass
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|HFileCleaner
operator|.
name|MASTER_HFILE_CLEANER_PLUGINS
argument_list|,
name|plugins
operator|+
literal|","
operator|+
name|cleanerClass
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|SnapshotQuotaObserverChore
name|getSnapshotQuotaObserverChore
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotQuotaChore
return|;
block|}
annotation|@
name|Override
specifier|public
name|SyncReplicationReplayWALManager
name|getSyncReplicationReplayWALManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|syncReplicationReplayWALManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|ReplicationStatus
argument_list|>
name|getWalGroupsReplicationStatus
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|isOnline
argument_list|()
operator|||
operator|!
name|LoadBalancer
operator|.
name|isMasterCanHostUserRegions
argument_list|(
name|conf
argument_list|)
condition|)
block|{
return|return
operator|new
name|HashMap
argument_list|<>
argument_list|()
return|;
block|}
return|return
name|super
operator|.
name|getWalGroupsReplicationStatus
argument_list|()
return|;
block|}
specifier|public
name|HbckChore
name|getHbckChore
parameter_list|()
block|{
return|return
name|this
operator|.
name|hbckChore
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getClusterId
parameter_list|()
block|{
if|if
condition|(
name|activeMaster
condition|)
block|{
return|return
name|super
operator|.
name|getClusterId
argument_list|()
return|;
block|}
return|return
name|cachedClusterId
operator|.
name|getFromCacheOrFetch
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|runReplicationBarrierCleaner
parameter_list|()
block|{
name|ReplicationBarrierCleaner
name|rbc
init|=
name|this
operator|.
name|replicationBarrierCleaner
decl_stmt|;
if|if
condition|(
name|rbc
operator|!=
literal|null
condition|)
block|{
name|rbc
operator|.
name|chore
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

