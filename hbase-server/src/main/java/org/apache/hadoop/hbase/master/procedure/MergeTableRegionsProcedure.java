begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaMutationAnnotation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Mutation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|MergeRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|CacheConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|AssignmentManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|CatalogJanitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterCoprocessorHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionStates
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|ServerManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegionFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreFileInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProcedureProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionStateTransition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionStateTransition
operator|.
name|TransitionCode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_comment
comment|/**  * The procedure to Merge a region in a table.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|MergeTableRegionsProcedure
extends|extends
name|AbstractStateMachineTableProcedure
argument_list|<
name|MergeTableRegionsState
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|MergeTableRegionsProcedure
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|Boolean
name|traceEnabled
decl_stmt|;
specifier|private
name|AssignmentManager
name|assignmentManager
decl_stmt|;
specifier|private
name|int
name|timeout
decl_stmt|;
specifier|private
name|ServerName
name|regionLocation
decl_stmt|;
specifier|private
name|String
name|regionsToMergeListFullName
decl_stmt|;
specifier|private
name|String
name|regionsToMergeListEncodedName
decl_stmt|;
specifier|private
name|HRegionInfo
index|[]
name|regionsToMerge
decl_stmt|;
specifier|private
name|HRegionInfo
name|mergedRegionInfo
decl_stmt|;
specifier|private
name|boolean
name|forcible
decl_stmt|;
specifier|public
name|MergeTableRegionsProcedure
parameter_list|()
block|{
name|this
operator|.
name|traceEnabled
operator|=
name|isTraceEnabled
argument_list|()
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|regionLocation
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|regionsToMergeListFullName
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|regionsToMergeListEncodedName
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|MergeTableRegionsProcedure
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|HRegionInfo
index|[]
name|regionsToMerge
parameter_list|,
specifier|final
name|boolean
name|forcible
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|this
operator|.
name|traceEnabled
operator|=
name|isTraceEnabled
argument_list|()
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|=
name|getAssignmentManager
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|// For now, we only merge 2 regions.  It could be extended to more than 2 regions in
comment|// the future.
assert|assert
operator|(
name|regionsToMerge
operator|.
name|length
operator|==
literal|2
operator|)
assert|;
assert|assert
operator|(
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getTable
argument_list|()
operator|==
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getTable
argument_list|()
operator|)
assert|;
name|this
operator|.
name|regionsToMerge
operator|=
name|regionsToMerge
expr_stmt|;
name|this
operator|.
name|forcible
operator|=
name|forcible
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|regionsToMergeListFullName
operator|=
name|getRegionsToMergeListFullNameString
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionsToMergeListEncodedName
operator|=
name|getRegionsToMergeListEncodedNameString
argument_list|()
expr_stmt|;
comment|// Check daughter regions and make sure that we have valid daughter regions before
comment|// doing the real work.
name|checkDaughterRegions
argument_list|()
expr_stmt|;
comment|// WARN: make sure there is no parent region of the two merging regions in
comment|// hbase:meta If exists, fixing up daughters would cause daughter regions(we
comment|// have merged one) online again when we restart master, so we should clear
comment|// the parent region to prevent the above case
comment|// Since HBASE-7721, we don't need fix up daughters any more. so here do
comment|// nothing
name|setupMergedRegionInfo
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|Flow
name|executeFromState
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|MergeTableRegionsState
name|state
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|this
operator|+
literal|" execute state="
operator|+
name|state
argument_list|)
expr_stmt|;
block|}
try|try
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MERGE_TABLE_REGIONS_PREPARE
case|:
name|prepareMergeRegion
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_MOVE_REGION_TO_SAME_RS
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_MOVE_REGION_TO_SAME_RS
case|:
if|if
condition|(
name|MoveRegionsToSameRS
argument_list|(
name|env
argument_list|)
condition|)
block|{
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_PRE_MERGE_OPERATION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cancel merging regions "
operator|+
name|getRegionsToMergeListFullNameString
argument_list|()
operator|+
literal|", because can't move them to the same RS"
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_POST_OPERATION
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MERGE_TABLE_REGIONS_PRE_MERGE_OPERATION
case|:
name|preMergeRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_SET_MERGING_TABLE_STATE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_SET_MERGING_TABLE_STATE
case|:
name|setRegionStateToMerging
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_CLOSE_REGIONS
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_CLOSE_REGIONS
case|:
name|closeRegionsForMerge
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_CREATE_MERGED_REGION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_CREATE_MERGED_REGION
case|:
name|createMergedRegion
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_PRE_MERGE_COMMIT_OPERATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_PRE_MERGE_COMMIT_OPERATION
case|:
name|preMergeRegionsCommit
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_UPDATE_META
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_UPDATE_META
case|:
name|updateMetaForMergedRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_POST_MERGE_COMMIT_OPERATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_POST_MERGE_COMMIT_OPERATION
case|:
name|postMergeRegionsCommit
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_OPEN_MERGED_REGION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_OPEN_MERGED_REGION
case|:
name|openMergedRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_POST_OPERATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_POST_OPERATION
case|:
name|postCompletedMergeRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|NO_MORE_STATE
return|;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|this
operator|+
literal|" unhandled state="
operator|+
name|state
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error trying to merge regions "
operator|+
name|getRegionsToMergeListFullNameString
argument_list|()
operator|+
literal|" in the table "
operator|+
name|getTableName
argument_list|()
operator|+
literal|" (in state="
operator|+
name|state
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setFailure
argument_list|(
literal|"master-merge-regions"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|Flow
operator|.
name|HAS_MORE_STATE
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|rollbackState
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|MergeTableRegionsState
name|state
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|this
operator|+
literal|" rollback state="
operator|+
name|state
argument_list|)
expr_stmt|;
block|}
try|try
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MERGE_TABLE_REGIONS_POST_OPERATION
case|:
case|case
name|MERGE_TABLE_REGIONS_OPEN_MERGED_REGION
case|:
case|case
name|MERGE_TABLE_REGIONS_POST_MERGE_COMMIT_OPERATION
case|:
case|case
name|MERGE_TABLE_REGIONS_UPDATE_META
case|:
name|String
name|msg
init|=
name|this
operator|+
literal|" We are in the "
operator|+
name|state
operator|+
literal|" state."
operator|+
literal|" It is complicated to rollback the merge operation that region server is working on."
operator|+
literal|" Rollback is not supported and we should let the merge operation to complete"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|// PONR
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|this
operator|+
literal|" unhandled state="
operator|+
name|state
argument_list|)
throw|;
case|case
name|MERGE_TABLE_REGIONS_PRE_MERGE_COMMIT_OPERATION
case|:
break|break;
case|case
name|MERGE_TABLE_REGIONS_CREATE_MERGED_REGION
case|:
name|cleanupMergedRegion
argument_list|(
name|env
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_CLOSE_REGIONS
case|:
name|rollbackCloseRegionsForMerge
argument_list|(
name|env
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_SET_MERGING_TABLE_STATE
case|:
name|setRegionStateToRevertMerging
argument_list|(
name|env
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_PRE_MERGE_OPERATION
case|:
name|postRollBackMergeRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_MOVE_REGION_TO_SAME_RS
case|:
break|break;
comment|// nothing to rollback
case|case
name|MERGE_TABLE_REGIONS_PREPARE
case|:
break|break;
comment|// nothing to rollback
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|this
operator|+
literal|" unhandled state="
operator|+
name|state
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// This will be retried. Unless there is a bug in the code,
comment|// this should be just a "temporary error" (e.g. network down)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed rollback attempt step "
operator|+
name|state
operator|+
literal|" for merging the regions "
operator|+
name|getRegionsToMergeListFullNameString
argument_list|()
operator|+
literal|" in table "
operator|+
name|getTableName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/*    * Check whether we are in the state that can be rollback    */
annotation|@
name|Override
specifier|protected
name|boolean
name|isRollbackSupported
parameter_list|(
specifier|final
name|MergeTableRegionsState
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MERGE_TABLE_REGIONS_POST_OPERATION
case|:
case|case
name|MERGE_TABLE_REGIONS_OPEN_MERGED_REGION
case|:
case|case
name|MERGE_TABLE_REGIONS_POST_MERGE_COMMIT_OPERATION
case|:
case|case
name|MERGE_TABLE_REGIONS_UPDATE_META
case|:
comment|// It is not safe to rollback if we reach to these states.
return|return
literal|false
return|;
default|default:
break|break;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|MergeTableRegionsState
name|getState
parameter_list|(
specifier|final
name|int
name|stateId
parameter_list|)
block|{
return|return
name|MergeTableRegionsState
operator|.
name|valueOf
argument_list|(
name|stateId
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|getStateId
parameter_list|(
specifier|final
name|MergeTableRegionsState
name|state
parameter_list|)
block|{
return|return
name|state
operator|.
name|getNumber
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|MergeTableRegionsState
name|getInitialState
parameter_list|()
block|{
return|return
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_PREPARE
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|serializeStateData
parameter_list|(
specifier|final
name|OutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|serializeStateData
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsStateData
operator|.
name|Builder
name|mergeTableRegionsMsg
init|=
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsStateData
operator|.
name|newBuilder
argument_list|()
operator|.
name|setUserInfo
argument_list|(
name|MasterProcedureUtil
operator|.
name|toProtoUserInfo
argument_list|(
name|getUser
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setMergedRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|mergedRegionInfo
argument_list|)
argument_list|)
operator|.
name|setForcible
argument_list|(
name|forcible
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|regionsToMerge
control|)
block|{
name|mergeTableRegionsMsg
operator|.
name|addRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|hri
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mergeTableRegionsMsg
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|deserializeStateData
parameter_list|(
specifier|final
name|InputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|deserializeStateData
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsStateData
name|mergeTableRegionsMsg
init|=
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsStateData
operator|.
name|parseDelimitedFrom
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|setUser
argument_list|(
name|MasterProcedureUtil
operator|.
name|toUserInfo
argument_list|(
name|mergeTableRegionsMsg
operator|.
name|getUserInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|mergeTableRegionsMsg
operator|.
name|getRegionInfoCount
argument_list|()
operator|==
literal|2
operator|)
assert|;
name|regionsToMerge
operator|=
operator|new
name|HRegionInfo
index|[
name|mergeTableRegionsMsg
operator|.
name|getRegionInfoCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionsToMerge
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|regionsToMerge
index|[
name|i
index|]
operator|=
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|mergeTableRegionsMsg
operator|.
name|getRegionInfo
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mergedRegionInfo
operator|=
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|mergeTableRegionsMsg
operator|.
name|getMergedRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|toStringClassDetails
parameter_list|(
name|StringBuilder
name|sb
parameter_list|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" (table="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" regions="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getRegionsToMergeListFullNameString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" forcible="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|forcible
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|LockState
name|acquireLock
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
if|if
condition|(
name|env
operator|.
name|waitInitialized
argument_list|(
name|this
argument_list|)
condition|)
block|{
return|return
name|LockState
operator|.
name|LOCK_EVENT_WAIT
return|;
block|}
return|return
name|env
operator|.
name|getProcedureScheduler
argument_list|()
operator|.
name|waitRegions
argument_list|(
name|this
argument_list|,
name|getTableName
argument_list|()
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
condition|?
name|LockState
operator|.
name|LOCK_EVENT_WAIT
else|:
name|LockState
operator|.
name|LOCK_ACQUIRED
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|releaseLock
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
name|env
operator|.
name|getProcedureScheduler
argument_list|()
operator|.
name|wakeRegions
argument_list|(
name|this
argument_list|,
name|getTableName
argument_list|()
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
name|getTableName
parameter_list|()
block|{
return|return
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getTable
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableOperationType
name|getTableOperationType
parameter_list|()
block|{
return|return
name|TableOperationType
operator|.
name|MERGE
return|;
block|}
comment|/**    * check daughter regions    * @throws IOException    */
specifier|private
name|void
name|checkDaughterRegions
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Note: the following logic assumes that we only have 2 regions to merge.  In the future,
comment|// if we want to extend to more than 2 regions, the code needs to modify a little bit.
comment|//
if|if
condition|(
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getReplicaId
argument_list|()
operator|!=
name|HRegionInfo
operator|.
name|DEFAULT_REPLICA_ID
operator|||
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getReplicaId
argument_list|()
operator|!=
name|HRegionInfo
operator|.
name|DEFAULT_REPLICA_ID
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Can't merge non-default replicas"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|HRegionInfo
operator|.
name|areAdjacent
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Trying to merge non-adjacent regions "
operator|+
name|getRegionsToMergeListFullNameString
argument_list|()
operator|+
literal|" where forcible = "
operator|+
name|forcible
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|forcible
condition|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Prepare merge and do some check    * @param env MasterProcedureEnv    * @throws IOException    */
specifier|private
name|void
name|prepareMergeRegion
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Note: the following logic assumes that we only have 2 regions to merge.  In the future,
comment|// if we want to extend to more than 2 regions, the code needs to modify a little bit.
comment|//
name|CatalogJanitor
name|catalogJanitor
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getCatalogJanitor
argument_list|()
decl_stmt|;
name|boolean
name|regionAHasMergeQualifier
init|=
operator|!
name|catalogJanitor
operator|.
name|cleanMergeQualifier
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionAHasMergeQualifier
operator|||
operator|!
name|catalogJanitor
operator|.
name|cleanMergeQualifier
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Skip merging regions "
operator|+
name|getRegionsToMergeListFullNameString
argument_list|()
operator|+
literal|", because region "
operator|+
operator|(
name|regionAHasMergeQualifier
condition|?
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getEncodedName
argument_list|()
else|:
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getEncodedName
argument_list|()
operator|)
operator|+
literal|" has merge qualifier"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MergeRegionException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|RegionStates
name|regionStates
init|=
name|getAssignmentManager
argument_list|(
name|env
argument_list|)
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
name|RegionState
name|regionStateA
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|RegionState
name|regionStateB
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionStateA
operator|==
literal|null
operator|||
name|regionStateB
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|regionStateA
operator|==
literal|null
condition|?
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getEncodedName
argument_list|()
else|:
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|regionStateA
operator|.
name|isOpened
argument_list|()
operator|||
operator|!
name|regionStateB
operator|.
name|isOpened
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Unable to merge regions not online "
operator|+
name|regionStateA
operator|+
literal|", "
operator|+
name|regionStateB
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create merged region info through the specified two regions    */
specifier|private
name|void
name|setupMergedRegionInfo
parameter_list|()
block|{
name|long
name|rid
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
comment|// Regionid is timestamp. Merged region's id can't be less than that of
comment|// merging regions else will insert at wrong location in hbase:meta
if|if
condition|(
name|rid
operator|<
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getRegionId
argument_list|()
operator|||
name|rid
operator|<
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getRegionId
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Clock skew; merging regions id are "
operator|+
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getRegionId
argument_list|()
operator|+
literal|" and "
operator|+
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getRegionId
argument_list|()
operator|+
literal|", but current time here is "
operator|+
name|rid
argument_list|)
expr_stmt|;
name|rid
operator|=
name|Math
operator|.
name|max
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getRegionId
argument_list|()
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getRegionId
argument_list|()
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|byte
index|[]
name|startKey
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|endKey
init|=
literal|null
decl_stmt|;
comment|// Choose the smaller as start key
if|if
condition|(
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|compareTo
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|startKey
operator|=
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getStartKey
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|startKey
operator|=
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getStartKey
argument_list|()
expr_stmt|;
block|}
comment|// Choose the bigger as end key
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
operator|||
operator|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
operator|&&
name|Bytes
operator|.
name|compareTo
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getEndKey
argument_list|()
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|endKey
operator|=
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|endKey
operator|=
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
block|}
comment|// Merged region is sorted between two merging regions in META
name|mergedRegionInfo
operator|=
operator|new
name|HRegionInfo
argument_list|(
name|getTableName
argument_list|()
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
literal|false
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
comment|/**    * Move all regions to the same region server    * @param env MasterProcedureEnv    * @return whether target regions hosted by the same RS    * @throws IOException    */
specifier|private
name|boolean
name|MoveRegionsToSameRS
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Make sure regions are on the same regionserver before send merge
comment|// regions request to region server.
comment|//
name|boolean
name|onSameRS
init|=
name|isRegionsOnTheSameServer
argument_list|(
name|env
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|onSameRS
condition|)
block|{
comment|// Note: the following logic assumes that we only have 2 regions to merge.  In the future,
comment|// if we want to extend to more than 2 regions, the code needs to modify a little bit.
comment|//
name|RegionStates
name|regionStates
init|=
name|getAssignmentManager
argument_list|(
name|env
argument_list|)
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
name|ServerName
name|regionLocation2
init|=
name|regionStates
operator|.
name|getRegionServerOfRegion
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|RegionLoad
name|loadOfRegionA
init|=
name|getRegionLoad
argument_list|(
name|env
argument_list|,
name|regionLocation
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|RegionLoad
name|loadOfRegionB
init|=
name|getRegionLoad
argument_list|(
name|env
argument_list|,
name|regionLocation2
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|loadOfRegionA
operator|!=
literal|null
operator|&&
name|loadOfRegionB
operator|!=
literal|null
operator|&&
name|loadOfRegionA
operator|.
name|getRequestsCount
argument_list|()
operator|<
name|loadOfRegionB
operator|.
name|getRequestsCount
argument_list|()
condition|)
block|{
comment|// switch regionsToMerge[0] and regionsToMerge[1]
name|HRegionInfo
name|tmpRegion
init|=
name|this
operator|.
name|regionsToMerge
index|[
literal|0
index|]
decl_stmt|;
name|this
operator|.
name|regionsToMerge
index|[
literal|0
index|]
operator|=
name|this
operator|.
name|regionsToMerge
index|[
literal|1
index|]
expr_stmt|;
name|this
operator|.
name|regionsToMerge
index|[
literal|1
index|]
operator|=
name|tmpRegion
expr_stmt|;
name|ServerName
name|tmpLocation
init|=
name|regionLocation
decl_stmt|;
name|regionLocation
operator|=
name|regionLocation2
expr_stmt|;
name|regionLocation2
operator|=
name|tmpLocation
expr_stmt|;
block|}
name|long
name|startTime
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
name|RegionPlan
name|regionPlan
init|=
operator|new
name|RegionPlan
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
argument_list|,
name|regionLocation2
argument_list|,
name|regionLocation
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Moving regions to same server for merge: "
operator|+
name|regionPlan
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|getAssignmentManager
argument_list|(
name|env
argument_list|)
operator|.
name|balance
argument_list|(
name|regionPlan
argument_list|)
expr_stmt|;
do|do
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|// Make sure check RIT first, then get region location, otherwise
comment|// we would make a wrong result if region is online between getting
comment|// region location and checking RIT
name|boolean
name|isRIT
init|=
name|regionStates
operator|.
name|isRegionInTransition
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|regionLocation2
operator|=
name|regionStates
operator|.
name|getRegionServerOfRegion
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|onSameRS
operator|=
name|regionLocation
operator|.
name|equals
argument_list|(
name|regionLocation2
argument_list|)
expr_stmt|;
if|if
condition|(
name|onSameRS
operator|||
operator|!
name|isRIT
condition|)
block|{
comment|// Regions are on the same RS, or regionsToMerge[1] is not in
comment|// RegionInTransition any more
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|InterruptedIOException
name|iioe
init|=
operator|new
name|InterruptedIOException
argument_list|()
decl_stmt|;
name|iioe
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|iioe
throw|;
block|}
block|}
do|while
condition|(
operator|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|startTime
operator|)
operator|<=
name|getTimeout
argument_list|(
name|env
argument_list|)
condition|)
do|;
block|}
return|return
name|onSameRS
return|;
block|}
comment|/**    * Pre merge region action    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|preMergeRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|boolean
name|ret
init|=
name|cpHost
operator|.
name|preMergeRegionsAction
argument_list|(
name|regionsToMerge
argument_list|,
name|getUser
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Coprocessor bypassing regions "
operator|+
name|getRegionsToMergeListFullNameString
argument_list|()
operator|+
literal|" merge."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Action after rollback a merge table regions action.    * @param env MasterProcedureEnv    * @throws IOException    */
specifier|private
name|void
name|postRollBackMergeRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postRollBackMergeRegionsAction
argument_list|(
name|regionsToMerge
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the region states to MERGING state    * @param env MasterProcedureEnv    * @throws IOException    */
specifier|public
name|void
name|setRegionStateToMerging
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionStateTransition
operator|.
name|Builder
name|transition
init|=
name|RegionStateTransition
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|transition
operator|.
name|setTransitionCode
argument_list|(
name|TransitionCode
operator|.
name|READY_TO_MERGE
argument_list|)
expr_stmt|;
name|transition
operator|.
name|addRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|mergedRegionInfo
argument_list|)
argument_list|)
expr_stmt|;
name|transition
operator|.
name|addRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|transition
operator|.
name|addRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|onRegionTransition
argument_list|(
name|getServerName
argument_list|(
name|env
argument_list|)
argument_list|,
name|transition
operator|.
name|build
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to update region state to MERGING for "
operator|+
name|getRegionsToMergeListFullNameString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Rollback the region state change    * @param env MasterProcedureEnv    * @throws IOException    */
specifier|private
name|void
name|setRegionStateToRevertMerging
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionStateTransition
operator|.
name|Builder
name|transition
init|=
name|RegionStateTransition
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|transition
operator|.
name|setTransitionCode
argument_list|(
name|TransitionCode
operator|.
name|MERGE_REVERTED
argument_list|)
expr_stmt|;
name|transition
operator|.
name|addRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|mergedRegionInfo
argument_list|)
argument_list|)
expr_stmt|;
name|transition
operator|.
name|addRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|transition
operator|.
name|addRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|msg
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|onRegionTransition
argument_list|(
name|getServerName
argument_list|(
name|env
argument_list|)
argument_list|,
name|transition
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|null
condition|)
block|{
comment|// If daughter regions are online, the msg is coming from RPC retry.  Ignore it.
name|RegionStates
name|regionStates
init|=
name|getAssignmentManager
argument_list|(
name|env
argument_list|)
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|regionStates
operator|.
name|isRegionOnline
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|regionStates
operator|.
name|isRegionOnline
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to update region state for "
operator|+
name|getRegionsToMergeListFullNameString
argument_list|()
operator|+
literal|" as part of operation for reverting merge.  Error message: "
operator|+
name|msg
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Create merged region    * @param env MasterProcedureEnv    * @throws IOException    */
specifier|private
name|void
name|createMergedRegion
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterFileSystem
name|mfs
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getMasterFileSystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|tabledir
init|=
name|FSUtils
operator|.
name|getTableDir
argument_list|(
name|mfs
operator|.
name|getRootDir
argument_list|()
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|FileSystem
name|fs
init|=
name|mfs
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|HRegionFileSystem
name|regionFs
init|=
name|HRegionFileSystem
operator|.
name|openRegionFromFileSystem
argument_list|(
name|env
operator|.
name|getMasterConfiguration
argument_list|()
argument_list|,
name|fs
argument_list|,
name|tabledir
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|regionFs
operator|.
name|createMergesDir
argument_list|()
expr_stmt|;
name|mergeStoreFiles
argument_list|(
name|env
argument_list|,
name|regionFs
argument_list|,
name|regionFs
operator|.
name|getMergesDir
argument_list|()
argument_list|)
expr_stmt|;
name|HRegionFileSystem
name|regionFs2
init|=
name|HRegionFileSystem
operator|.
name|openRegionFromFileSystem
argument_list|(
name|env
operator|.
name|getMasterConfiguration
argument_list|()
argument_list|,
name|fs
argument_list|,
name|tabledir
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mergeStoreFiles
argument_list|(
name|env
argument_list|,
name|regionFs2
argument_list|,
name|regionFs
operator|.
name|getMergesDir
argument_list|()
argument_list|)
expr_stmt|;
name|regionFs
operator|.
name|commitMergedRegion
argument_list|(
name|mergedRegionInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create reference file(s) of merging regions under the merges directory    * @param env MasterProcedureEnv    * @param regionFs region file system    * @param mergedDir the temp directory of merged region    * @throws IOException    */
specifier|private
name|void
name|mergeStoreFiles
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|HRegionFileSystem
name|regionFs
parameter_list|,
specifier|final
name|Path
name|mergedDir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterFileSystem
name|mfs
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getMasterFileSystem
argument_list|()
decl_stmt|;
specifier|final
name|Configuration
name|conf
init|=
name|env
operator|.
name|getMasterConfiguration
argument_list|()
decl_stmt|;
specifier|final
name|HTableDescriptor
name|htd
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|family
range|:
name|regionFs
operator|.
name|getFamilies
argument_list|()
control|)
block|{
specifier|final
name|HColumnDescriptor
name|hcd
init|=
name|htd
operator|.
name|getFamily
argument_list|(
name|family
operator|.
name|getBytes
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|StoreFileInfo
argument_list|>
name|storeFiles
init|=
name|regionFs
operator|.
name|getStoreFiles
argument_list|(
name|family
argument_list|)
decl_stmt|;
if|if
condition|(
name|storeFiles
operator|!=
literal|null
operator|&&
name|storeFiles
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|CacheConfig
name|cacheConf
init|=
operator|new
name|CacheConfig
argument_list|(
name|conf
argument_list|,
name|hcd
argument_list|)
decl_stmt|;
for|for
control|(
name|StoreFileInfo
name|storeFileInfo
range|:
name|storeFiles
control|)
block|{
comment|// Create reference file(s) of the region in mergedDir
name|regionFs
operator|.
name|mergeStoreFile
argument_list|(
name|mergedRegionInfo
argument_list|,
name|family
argument_list|,
operator|new
name|StoreFile
argument_list|(
name|mfs
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|storeFileInfo
argument_list|,
name|conf
argument_list|,
name|cacheConf
argument_list|,
name|hcd
operator|.
name|getBloomFilterType
argument_list|()
argument_list|)
argument_list|,
name|mergedDir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Clean up merged region    * @param env MasterProcedureEnv    * @throws IOException    */
specifier|private
name|void
name|cleanupMergedRegion
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterFileSystem
name|mfs
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getMasterFileSystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|tabledir
init|=
name|FSUtils
operator|.
name|getTableDir
argument_list|(
name|mfs
operator|.
name|getRootDir
argument_list|()
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|FileSystem
name|fs
init|=
name|mfs
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|HRegionFileSystem
name|regionFs
init|=
name|HRegionFileSystem
operator|.
name|openRegionFromFileSystem
argument_list|(
name|env
operator|.
name|getMasterConfiguration
argument_list|()
argument_list|,
name|fs
argument_list|,
name|tabledir
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|regionFs
operator|.
name|cleanupMergedRegion
argument_list|(
name|mergedRegionInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * RPC to region server that host the regions to merge, ask for close these regions    * @param env MasterProcedureEnv    * @throws IOException    */
specifier|private
name|void
name|closeRegionsForMerge
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getServerManager
argument_list|()
operator|.
name|sendRegionCloseForSplitOrMerge
argument_list|(
name|getServerName
argument_list|(
name|env
argument_list|)
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Close regions "
operator|+
name|getRegionsToMergeListFullNameString
argument_list|()
operator|+
literal|" for merging failed. Check region server log for more details."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Rollback close regions    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|rollbackCloseRegionsForMerge
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Check whether the region is closed; if so, open it in the same server
name|RegionStates
name|regionStates
init|=
name|getAssignmentManager
argument_list|(
name|env
argument_list|)
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|regionsToMerge
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RegionState
name|state
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|regionsToMerge
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
operator|&&
operator|(
name|state
operator|.
name|isClosing
argument_list|()
operator|||
name|state
operator|.
name|isClosed
argument_list|()
operator|)
condition|)
block|{
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getServerManager
argument_list|()
operator|.
name|sendRegionOpen
argument_list|(
name|getServerName
argument_list|(
name|env
argument_list|)
argument_list|,
name|regionsToMerge
index|[
name|i
index|]
argument_list|,
name|ServerName
operator|.
name|EMPTY_SERVER_LIST
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Post merge region action    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|preMergeRegionsCommit
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
annotation|@
name|MetaMutationAnnotation
specifier|final
name|List
argument_list|<
name|Mutation
argument_list|>
name|metaEntries
init|=
operator|new
name|ArrayList
argument_list|<
name|Mutation
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|ret
init|=
name|cpHost
operator|.
name|preMergeRegionsCommit
argument_list|(
name|regionsToMerge
argument_list|,
name|metaEntries
argument_list|,
name|getUser
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Coprocessor bypassing regions "
operator|+
name|getRegionsToMergeListFullNameString
argument_list|()
operator|+
literal|" merge."
argument_list|)
throw|;
block|}
try|try
block|{
for|for
control|(
name|Mutation
name|p
range|:
name|metaEntries
control|)
block|{
name|HRegionInfo
operator|.
name|parseRegionName
argument_list|(
name|p
operator|.
name|getRow
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Row key of mutation from coprocessor is not parsable as region name."
operator|+
literal|"Mutations from coprocessor should only be for hbase:meta table."
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * Add merged region to META and delete original regions.    * @param env MasterProcedureEnv    * @throws IOException    */
specifier|private
name|void
name|updateMetaForMergedRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionStateTransition
operator|.
name|Builder
name|transition
init|=
name|RegionStateTransition
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|transition
operator|.
name|setTransitionCode
argument_list|(
name|TransitionCode
operator|.
name|MERGE_PONR
argument_list|)
expr_stmt|;
name|transition
operator|.
name|addRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|mergedRegionInfo
argument_list|)
argument_list|)
expr_stmt|;
name|transition
operator|.
name|addRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|transition
operator|.
name|addRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add merged region and delete original regions
comment|// as an atomic update. See HBASE-7721. This update to hbase:meta makes the region
comment|// will determine whether the region is merged or not in case of failures.
if|if
condition|(
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|onRegionTransition
argument_list|(
name|getServerName
argument_list|(
name|env
argument_list|)
argument_list|,
name|transition
operator|.
name|build
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to update meta to add merged region that merges "
operator|+
name|getRegionsToMergeListFullNameString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Post merge region action    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|postMergeRegionsCommit
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postMergeRegionsCommit
argument_list|(
name|regionsToMerge
argument_list|,
name|mergedRegionInfo
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Assign merged region    * @param env MasterProcedureEnv    * @throws IOException    * @throws InterruptedException    **/
specifier|private
name|void
name|openMergedRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// Check whether the merged region is already opened; if so,
comment|// this is retry and we should just ignore.
name|RegionState
name|regionState
init|=
name|getAssignmentManager
argument_list|(
name|env
argument_list|)
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionState
argument_list|(
name|mergedRegionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
operator|&&
name|regionState
operator|.
name|isOpened
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip opening merged region "
operator|+
name|mergedRegionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" as it is already opened."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// TODO: The new AM should provide an API to force assign the merged region to the same RS
comment|// as daughter regions; if the RS is unavailable, then assign to a different RS.
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|assignMergedRegion
argument_list|(
name|mergedRegionInfo
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Post merge region action    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|postCompletedMergeRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postCompletedMergeRegionsAction
argument_list|(
name|regionsToMerge
argument_list|,
name|mergedRegionInfo
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|RegionLoad
name|getRegionLoad
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|ServerManager
name|serverManager
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getServerManager
argument_list|()
decl_stmt|;
name|ServerLoad
name|load
init|=
name|serverManager
operator|.
name|getLoad
argument_list|(
name|sn
argument_list|)
decl_stmt|;
if|if
condition|(
name|load
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLoad
argument_list|>
name|regionsLoad
init|=
name|load
operator|.
name|getRegionsLoad
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionsLoad
operator|!=
literal|null
condition|)
block|{
return|return
name|regionsLoad
operator|.
name|get
argument_list|(
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * The procedure could be restarted from a different machine. If the variable is null, we need to    * retrieve it.    * @param env MasterProcedureEnv    * @return whether target regions hosted by the same RS    */
specifier|private
name|boolean
name|isRegionsOnTheSameServer
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|Boolean
name|onSameRS
init|=
literal|true
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|RegionStates
name|regionStates
init|=
name|getAssignmentManager
argument_list|(
name|env
argument_list|)
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
name|regionLocation
operator|=
name|regionStates
operator|.
name|getRegionServerOfRegion
argument_list|(
name|regionsToMerge
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionLocation
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|regionsToMerge
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ServerName
name|regionLocation2
init|=
name|regionStates
operator|.
name|getRegionServerOfRegion
argument_list|(
name|regionsToMerge
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionLocation2
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|onSameRS
condition|)
block|{
name|onSameRS
operator|=
name|regionLocation
operator|.
name|equals
argument_list|(
name|regionLocation2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// At least one region is not online, merge will fail, no need to continue.
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|regionsToMerge
operator|.
name|length
condition|)
block|{
comment|// Finish checking all regions, return the result;
return|return
name|onSameRS
return|;
block|}
block|}
comment|// If reaching here, at least one region is not online.
name|String
name|msg
init|=
literal|"Skip merging regions "
operator|+
name|getRegionsToMergeListFullNameString
argument_list|()
operator|+
literal|", because region "
operator|+
name|regionsToMerge
index|[
name|i
index|]
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" is not online now."
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|/**    * The procedure could be restarted from a different machine. If the variable is null, we need to    * retrieve it.    * @param env MasterProcedureEnv    * @return assignmentManager    */
specifier|private
name|AssignmentManager
name|getAssignmentManager
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
if|if
condition|(
name|assignmentManager
operator|==
literal|null
condition|)
block|{
name|assignmentManager
operator|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getAssignmentManager
argument_list|()
expr_stmt|;
block|}
return|return
name|assignmentManager
return|;
block|}
comment|/**    * The procedure could be restarted from a different machine. If the variable is null, we need to    * retrieve it.    * @param env MasterProcedureEnv    * @return timeout value    */
specifier|private
name|int
name|getTimeout
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
if|if
condition|(
name|timeout
operator|==
operator|-
literal|1
condition|)
block|{
name|timeout
operator|=
name|env
operator|.
name|getMasterConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.master.regionmerge.timeout"
argument_list|,
name|regionsToMerge
operator|.
name|length
operator|*
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
name|timeout
return|;
block|}
comment|/**    * The procedure could be restarted from a different machine. If the variable is null, we need to    * retrieve it.    * @param env MasterProcedureEnv    * @return serverName    */
specifier|private
name|ServerName
name|getServerName
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
if|if
condition|(
name|regionLocation
operator|==
literal|null
condition|)
block|{
name|regionLocation
operator|=
name|getAssignmentManager
argument_list|(
name|env
argument_list|)
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionServerOfRegion
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|regionLocation
return|;
block|}
comment|/**    * The procedure could be restarted from a different machine. If the variable is null, we need to    * retrieve it.    * @param fullName whether return only encoded name    * @return region names in a list    */
specifier|private
name|String
name|getRegionsToMergeListFullNameString
parameter_list|()
block|{
if|if
condition|(
name|regionsToMergeListFullName
operator|==
literal|null
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"["
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|regionsToMerge
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|regionsToMerge
index|[
name|i
index|]
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", "
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|regionsToMerge
index|[
name|i
index|]
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" ]"
argument_list|)
expr_stmt|;
name|regionsToMergeListFullName
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|regionsToMergeListFullName
return|;
block|}
comment|/**    * The procedure could be restarted from a different machine. If the variable is null, we need to    * retrieve it.    * @return encoded region names    */
specifier|private
name|String
name|getRegionsToMergeListEncodedNameString
parameter_list|()
block|{
if|if
condition|(
name|regionsToMergeListEncodedName
operator|==
literal|null
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"["
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|regionsToMerge
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|regionsToMerge
index|[
name|i
index|]
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|", "
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|regionsToMerge
index|[
name|i
index|]
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" ]"
argument_list|)
expr_stmt|;
name|regionsToMergeListEncodedName
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|regionsToMergeListEncodedName
return|;
block|}
comment|/**    * The procedure could be restarted from a different machine. If the variable is null, we need to    * retrieve it.    * @return traceEnabled    */
specifier|private
name|Boolean
name|isTraceEnabled
parameter_list|()
block|{
if|if
condition|(
name|traceEnabled
operator|==
literal|null
condition|)
block|{
name|traceEnabled
operator|=
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
expr_stmt|;
block|}
return|return
name|traceEnabled
return|;
block|}
block|}
end_class

end_unit

