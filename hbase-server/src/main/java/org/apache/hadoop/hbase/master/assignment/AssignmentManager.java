begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|PleaseHoldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionStateListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|YouAreDeadException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfoBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionReplicaUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|UnexpectedStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesPromoter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|AssignmentListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|LoadBalancer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterServices
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MetricsAssignmentManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|NoSuchProcedureException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|ServerListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|TableStateManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|RegionStates
operator|.
name|RegionStateNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|RegionStates
operator|.
name|ServerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|RegionStates
operator|.
name|ServerStateNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|FavoredStochasticBalancer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|RegionNormalizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureEnv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ProcedureSyncWait
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ServerCrashException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ServerCrashProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|Procedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureInMemoryChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProcedureProtos
operator|.
name|RegionTransitionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionStateTransition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionStateTransition
operator|.
name|TransitionCode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|ReportRegionStateTransitionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|ReportRegionStateTransitionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_comment
comment|/**  * The AssignmentManager is the coordinator for region assign/unassign operations.  *<ul>  *<li>In-memory states of regions and servers are stored in {@link RegionStates}.</li>  *<li>hbase:meta state updates are handled by {@link RegionStateStore}.</li>  *</ul>  * Regions are created by CreateTable, Split, Merge.  * Regions are deleted by DeleteTable, Split, Merge.  * Assigns are triggered by CreateTable, EnableTable, Split, Merge, ServerCrash.  * Unassigns are triggered by DisableTable, Split, Merge  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|AssignmentManager
implements|implements
name|ServerListener
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AssignmentManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// TODO: AMv2
comment|//  - handle region migration from hbase1 to hbase2.
comment|//  - handle sys table assignment first (e.g. acl, namespace)
comment|//  - handle table priorities
comment|//  - If ServerBusyException trying to update hbase:meta, we abort the Master
comment|//   See updateRegionLocation in RegionStateStore.
comment|//
comment|// See also
comment|// https://docs.google.com/document/d/1eVKa7FHdeoJ1-9o8yZcOTAQbv0u0bblBlCCzVSIn69g/edit#heading=h.ystjyrkbtoq5
comment|// for other TODOs.
specifier|public
specifier|static
specifier|final
name|String
name|BOOTSTRAP_THREAD_POOL_SIZE_CONF_KEY
init|=
literal|"hbase.assignment.bootstrap.thread.pool.size"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASSIGN_DISPATCH_WAIT_MSEC_CONF_KEY
init|=
literal|"hbase.assignment.dispatch.wait.msec"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_ASSIGN_DISPATCH_WAIT_MSEC
init|=
literal|150
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASSIGN_DISPATCH_WAITQ_MAX_CONF_KEY
init|=
literal|"hbase.assignment.dispatch.wait.queue.max.size"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_ASSIGN_DISPATCH_WAITQ_MAX
init|=
literal|100
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|RIT_CHORE_INTERVAL_MSEC_CONF_KEY
init|=
literal|"hbase.assignment.rit.chore.interval.msec"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_RIT_CHORE_INTERVAL_MSEC
init|=
literal|5
operator|*
literal|1000
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASSIGN_MAX_ATTEMPTS
init|=
literal|"hbase.assignment.maximum.attempts"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_ASSIGN_MAX_ATTEMPTS
init|=
literal|10
decl_stmt|;
comment|/** Region in Transition metrics threshold time */
specifier|public
specifier|static
specifier|final
name|String
name|METRICS_RIT_STUCK_WARNING_THRESHOLD
init|=
literal|"hbase.metrics.rit.stuck.warning.threshold"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_RIT_STUCK_WARNING_THRESHOLD
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
specifier|private
specifier|final
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|metaInitializedEvent
init|=
operator|new
name|ProcedureEvent
argument_list|<>
argument_list|(
literal|"meta initialized"
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|metaLoadEvent
init|=
operator|new
name|ProcedureEvent
argument_list|<>
argument_list|(
literal|"meta load"
argument_list|)
decl_stmt|;
comment|/**    * Indicator that AssignmentManager has recovered the region states so    * that ServerCrashProcedure can be fully enabled and re-assign regions    * of dead servers. So that when re-assignment happens, AssignmentManager    * has proper region states.    */
specifier|private
specifier|final
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|failoverCleanupDone
init|=
operator|new
name|ProcedureEvent
argument_list|<>
argument_list|(
literal|"failover cleanup"
argument_list|)
decl_stmt|;
comment|/** Listeners that are called on assignment events. */
specifier|private
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|AssignmentListener
argument_list|>
name|listeners
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|AssignmentListener
argument_list|>
argument_list|()
decl_stmt|;
comment|// TODO: why is this different from the listeners (carried over from the old AM)
specifier|private
name|RegionStateListener
name|regionStateListener
decl_stmt|;
specifier|private
name|RegionNormalizer
name|regionNormalizer
decl_stmt|;
specifier|private
specifier|final
name|MetricsAssignmentManager
name|metrics
decl_stmt|;
specifier|private
specifier|final
name|RegionInTransitionChore
name|ritChore
decl_stmt|;
specifier|private
specifier|final
name|MasterServices
name|master
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|running
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|RegionStates
name|regionStates
init|=
operator|new
name|RegionStates
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|RegionStateStore
name|regionStateStore
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|shouldAssignRegionsWithFavoredNodes
decl_stmt|;
specifier|private
specifier|final
name|int
name|assignDispatchWaitQueueMaxSize
decl_stmt|;
specifier|private
specifier|final
name|int
name|assignDispatchWaitMillis
decl_stmt|;
specifier|private
specifier|final
name|int
name|assignMaxAttempts
decl_stmt|;
specifier|private
specifier|final
name|Object
name|checkIfShouldMoveSystemRegionLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|Thread
name|assignThread
decl_stmt|;
specifier|public
name|AssignmentManager
parameter_list|(
specifier|final
name|MasterServices
name|master
parameter_list|)
block|{
name|this
argument_list|(
name|master
argument_list|,
operator|new
name|RegionStateStore
argument_list|(
name|master
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|AssignmentManager
parameter_list|(
specifier|final
name|MasterServices
name|master
parameter_list|,
specifier|final
name|RegionStateStore
name|stateStore
parameter_list|)
block|{
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|this
operator|.
name|regionStateStore
operator|=
name|stateStore
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
operator|new
name|MetricsAssignmentManager
argument_list|()
expr_stmt|;
specifier|final
name|Configuration
name|conf
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
comment|// Only read favored nodes if using the favored nodes load balancer.
name|this
operator|.
name|shouldAssignRegionsWithFavoredNodes
operator|=
name|FavoredStochasticBalancer
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|HConstants
operator|.
name|HBASE_MASTER_LOADBALANCER_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignDispatchWaitMillis
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|ASSIGN_DISPATCH_WAIT_MSEC_CONF_KEY
argument_list|,
name|DEFAULT_ASSIGN_DISPATCH_WAIT_MSEC
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignDispatchWaitQueueMaxSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|ASSIGN_DISPATCH_WAITQ_MAX_CONF_KEY
argument_list|,
name|DEFAULT_ASSIGN_DISPATCH_WAITQ_MAX
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignMaxAttempts
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|ASSIGN_MAX_ATTEMPTS
argument_list|,
name|DEFAULT_ASSIGN_MAX_ATTEMPTS
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|ritChoreInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|RIT_CHORE_INTERVAL_MSEC_CONF_KEY
argument_list|,
name|DEFAULT_RIT_CHORE_INTERVAL_MSEC
argument_list|)
decl_stmt|;
name|this
operator|.
name|ritChore
operator|=
operator|new
name|RegionInTransitionChore
argument_list|(
name|ritChoreInterval
argument_list|)
expr_stmt|;
comment|// Used for region related procedure.
name|setRegionNormalizer
argument_list|(
name|master
operator|.
name|getRegionNormalizer
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|running
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting assignment manager"
argument_list|)
expr_stmt|;
comment|// Register Server Listener
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|registerListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Start the RegionStateStore
name|regionStateStore
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Start the Assignment Thread
name|startAssignmentThread
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|stop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|running
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping assignment manager"
argument_list|)
expr_stmt|;
comment|// The AM is started before the procedure executor,
comment|// but the actual work will be loaded/submitted only once we have the executor
specifier|final
name|boolean
name|hasProcExecutor
init|=
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|!=
literal|null
decl_stmt|;
comment|// Remove the RIT chore
if|if
condition|(
name|hasProcExecutor
condition|)
block|{
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|removeChore
argument_list|(
name|this
operator|.
name|ritChore
argument_list|)
expr_stmt|;
block|}
comment|// Stop the Assignment Thread
name|stopAssignmentThread
argument_list|()
expr_stmt|;
comment|// Stop the RegionStateStore
name|regionStates
operator|.
name|clear
argument_list|()
expr_stmt|;
name|regionStateStore
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// Unregister Server Listener
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|unregisterListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Update meta events (for testing)
if|if
condition|(
name|hasProcExecutor
condition|)
block|{
name|metaLoadEvent
operator|.
name|suspend
argument_list|()
expr_stmt|;
name|setFailoverCleanupDone
argument_list|(
literal|false
argument_list|)
expr_stmt|;
for|for
control|(
name|RegionInfo
name|hri
range|:
name|getMetaRegionSet
argument_list|()
control|)
block|{
name|setMetaInitialized
argument_list|(
name|hri
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|running
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|master
operator|.
name|getConfiguration
argument_list|()
return|;
block|}
specifier|public
name|MetricsAssignmentManager
name|getAssignmentManagerMetrics
parameter_list|()
block|{
return|return
name|metrics
return|;
block|}
specifier|private
name|LoadBalancer
name|getBalancer
parameter_list|()
block|{
return|return
name|master
operator|.
name|getLoadBalancer
argument_list|()
return|;
block|}
specifier|private
name|MasterProcedureEnv
name|getProcedureEnvironment
parameter_list|()
block|{
return|return
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|getEnvironment
argument_list|()
return|;
block|}
specifier|private
name|MasterProcedureScheduler
name|getProcedureScheduler
parameter_list|()
block|{
return|return
name|getProcedureEnvironment
argument_list|()
operator|.
name|getProcedureScheduler
argument_list|()
return|;
block|}
specifier|protected
name|int
name|getAssignMaxAttempts
parameter_list|()
block|{
return|return
name|assignMaxAttempts
return|;
block|}
comment|/**    * Add the listener to the notification list.    * @param listener The AssignmentListener to register    */
specifier|public
name|void
name|registerListener
parameter_list|(
specifier|final
name|AssignmentListener
name|listener
parameter_list|)
block|{
name|this
operator|.
name|listeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove the listener from the notification list.    * @param listener The AssignmentListener to unregister    */
specifier|public
name|boolean
name|unregisterListener
parameter_list|(
specifier|final
name|AssignmentListener
name|listener
parameter_list|)
block|{
return|return
name|this
operator|.
name|listeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
return|;
block|}
specifier|public
name|void
name|setRegionStateListener
parameter_list|(
specifier|final
name|RegionStateListener
name|listener
parameter_list|)
block|{
name|this
operator|.
name|regionStateListener
operator|=
name|listener
expr_stmt|;
block|}
specifier|public
name|void
name|setRegionNormalizer
parameter_list|(
specifier|final
name|RegionNormalizer
name|normalizer
parameter_list|)
block|{
name|this
operator|.
name|regionNormalizer
operator|=
name|normalizer
expr_stmt|;
block|}
specifier|public
name|RegionNormalizer
name|getRegionNormalizer
parameter_list|()
block|{
return|return
name|regionNormalizer
return|;
block|}
specifier|public
name|RegionStates
name|getRegionStates
parameter_list|()
block|{
return|return
name|regionStates
return|;
block|}
specifier|public
name|RegionStateStore
name|getRegionStateStore
parameter_list|()
block|{
return|return
name|regionStateStore
return|;
block|}
specifier|public
name|List
argument_list|<
name|ServerName
argument_list|>
name|getFavoredNodes
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
return|return
name|this
operator|.
name|shouldAssignRegionsWithFavoredNodes
condition|?
operator|(
operator|(
name|FavoredStochasticBalancer
operator|)
name|getBalancer
argument_list|()
operator|)
operator|.
name|getFavoredNodes
argument_list|(
name|regionInfo
argument_list|)
else|:
name|ServerName
operator|.
name|EMPTY_SERVER_LIST
return|;
block|}
comment|// ============================================================================================
comment|//  Table State Manager helpers
comment|// ============================================================================================
name|TableStateManager
name|getTableStateManager
parameter_list|()
block|{
return|return
name|master
operator|.
name|getTableStateManager
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|tableName
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|ENABLED
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|tableName
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
return|;
block|}
comment|// ============================================================================================
comment|//  META Helpers
comment|// ============================================================================================
specifier|private
name|boolean
name|isMetaRegion
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
return|return
name|regionInfo
operator|.
name|isMetaRegion
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isMetaRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
return|return
name|getMetaRegionFromName
argument_list|(
name|regionName
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|public
name|RegionInfo
name|getMetaRegionFromName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
for|for
control|(
name|RegionInfo
name|hri
range|:
name|getMetaRegionSet
argument_list|()
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|regionName
argument_list|)
condition|)
block|{
return|return
name|hri
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|boolean
name|isCarryingMeta
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
for|for
control|(
name|RegionInfo
name|hri
range|:
name|getMetaRegionSet
argument_list|()
control|)
block|{
if|if
condition|(
name|isCarryingRegion
argument_list|(
name|serverName
argument_list|,
name|hri
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|isCarryingRegion
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
comment|// TODO: check for state?
specifier|final
name|RegionStateNode
name|node
init|=
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
return|return
operator|(
name|node
operator|!=
literal|null
operator|&&
name|serverName
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getRegionLocation
argument_list|()
argument_list|)
operator|)
return|;
block|}
specifier|private
name|RegionInfo
name|getMetaForRegion
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
comment|//if (regionInfo.isMetaRegion()) return regionInfo;
comment|// TODO: handle multiple meta. if the region provided is not meta lookup
comment|// which meta the region belongs to.
return|return
name|RegionInfoBuilder
operator|.
name|FIRST_META_REGIONINFO
return|;
block|}
comment|// TODO: handle multiple meta.
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|RegionInfo
argument_list|>
name|META_REGION_SET
init|=
name|Collections
operator|.
name|singleton
argument_list|(
name|RegionInfoBuilder
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
decl_stmt|;
specifier|public
name|Set
argument_list|<
name|RegionInfo
argument_list|>
name|getMetaRegionSet
parameter_list|()
block|{
return|return
name|META_REGION_SET
return|;
block|}
comment|// ============================================================================================
comment|//  META Event(s) helpers
comment|// ============================================================================================
specifier|public
name|boolean
name|isMetaInitialized
parameter_list|()
block|{
return|return
name|metaInitializedEvent
operator|.
name|isReady
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isMetaRegionInTransition
parameter_list|()
block|{
return|return
operator|!
name|isMetaInitialized
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|waitMetaInitialized
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
comment|// TODO: handle multiple meta. should this wait on all meta?
comment|// this is used by the ServerCrashProcedure...
return|return
name|waitMetaInitialized
argument_list|(
name|proc
argument_list|,
name|RegionInfoBuilder
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|waitMetaInitialized
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|,
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
return|return
name|getMetaInitializedEvent
argument_list|(
name|getMetaForRegion
argument_list|(
name|regionInfo
argument_list|)
argument_list|)
operator|.
name|suspendIfNotReady
argument_list|(
name|proc
argument_list|)
return|;
block|}
specifier|private
name|void
name|setMetaInitialized
parameter_list|(
specifier|final
name|RegionInfo
name|metaRegionInfo
parameter_list|,
specifier|final
name|boolean
name|isInitialized
parameter_list|)
block|{
assert|assert
name|isMetaRegion
argument_list|(
name|metaRegionInfo
argument_list|)
operator|:
literal|"unexpected non-meta region "
operator|+
name|metaRegionInfo
assert|;
specifier|final
name|ProcedureEvent
name|metaInitEvent
init|=
name|getMetaInitializedEvent
argument_list|(
name|metaRegionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|isInitialized
condition|)
block|{
name|metaInitEvent
operator|.
name|wake
argument_list|(
name|getProcedureScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metaInitEvent
operator|.
name|suspend
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|ProcedureEvent
name|getMetaInitializedEvent
parameter_list|(
specifier|final
name|RegionInfo
name|metaRegionInfo
parameter_list|)
block|{
assert|assert
name|isMetaRegion
argument_list|(
name|metaRegionInfo
argument_list|)
operator|:
literal|"unexpected non-meta region "
operator|+
name|metaRegionInfo
assert|;
comment|// TODO: handle multiple meta.
return|return
name|metaInitializedEvent
return|;
block|}
specifier|public
name|boolean
name|waitMetaLoaded
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
return|return
name|metaLoadEvent
operator|.
name|suspendIfNotReady
argument_list|(
name|proc
argument_list|)
return|;
block|}
specifier|protected
name|void
name|wakeMetaLoadedEvent
parameter_list|()
block|{
name|metaLoadEvent
operator|.
name|wake
argument_list|(
name|getProcedureScheduler
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
name|isMetaLoaded
argument_list|()
operator|:
literal|"expected meta to be loaded"
assert|;
block|}
specifier|public
name|boolean
name|isMetaLoaded
parameter_list|()
block|{
return|return
name|metaLoadEvent
operator|.
name|isReady
argument_list|()
return|;
block|}
comment|// ============================================================================================
comment|//  TODO: Sync helpers
comment|// ============================================================================================
specifier|public
name|void
name|assignMeta
parameter_list|(
specifier|final
name|RegionInfo
name|metaRegionInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|assignMeta
argument_list|(
name|metaRegionInfo
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|assignMeta
parameter_list|(
specifier|final
name|RegionInfo
name|metaRegionInfo
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|isMetaRegion
argument_list|(
name|metaRegionInfo
argument_list|)
operator|:
literal|"unexpected non-meta region "
operator|+
name|metaRegionInfo
assert|;
name|AssignProcedure
name|proc
decl_stmt|;
if|if
condition|(
name|serverName
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Try assigning Meta "
operator|+
name|metaRegionInfo
operator|+
literal|" to "
operator|+
name|serverName
argument_list|)
expr_stmt|;
name|proc
operator|=
name|createAssignProcedure
argument_list|(
name|metaRegionInfo
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Assigning "
operator|+
name|metaRegionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|proc
operator|=
name|createAssignProcedure
argument_list|(
name|metaRegionInfo
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|ProcedureSyncWait
operator|.
name|submitAndWaitProcedure
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
argument_list|,
name|proc
argument_list|)
expr_stmt|;
block|}
comment|/**    * Start a new thread to check if there are region servers whose versions are higher than others.    * If so, move all system table regions to RS with the highest version to keep compatibility.    * The reason is, RS in new version may not be able to access RS in old version when there are    * some incompatible changes.    */
specifier|public
name|void
name|checkIfShouldMoveSystemRegionAsync
parameter_list|()
block|{
operator|new
name|Thread
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
synchronized|synchronized
init|(
name|checkIfShouldMoveSystemRegionLock
init|)
block|{
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|plans
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ServerName
name|server
range|:
name|getExcludedServersForSystemTable
argument_list|()
control|)
block|{
if|if
condition|(
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|isServerDead
argument_list|(
name|server
argument_list|)
condition|)
block|{
comment|// TODO: See HBASE-18494 and HBASE-18495. Though getExcludedServersForSystemTable()
comment|// considers only online servers, the server could be queued for dead server
comment|// processing. As region assignments for crashed server is handled by
comment|// ServerCrashProcedure, do NOT handle them here. The goal is to handle this through
comment|// regular flow of LoadBalancer as a favored node and not to have this special
comment|// handling.
continue|continue;
block|}
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|regionsShouldMove
init|=
name|getCarryingSystemTables
argument_list|(
name|server
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|regionsShouldMove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|RegionInfo
name|regionInfo
range|:
name|regionsShouldMove
control|)
block|{
comment|// null value for dest forces destination server to be selected by balancer
name|RegionPlan
name|plan
init|=
operator|new
name|RegionPlan
argument_list|(
name|regionInfo
argument_list|,
name|server
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionInfo
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
comment|// Must move meta region first.
name|moveAsync
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|plans
operator|.
name|add
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|RegionPlan
name|plan
range|:
name|plans
control|)
block|{
name|moveAsync
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
specifier|private
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|getCarryingSystemTables
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
name|Set
argument_list|<
name|RegionStateNode
argument_list|>
name|regions
init|=
name|this
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getServerNode
argument_list|(
name|serverName
argument_list|)
operator|.
name|getRegions
argument_list|()
decl_stmt|;
if|if
condition|(
name|regions
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|()
return|;
block|}
return|return
name|regions
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|RegionStateNode
operator|::
name|getRegionInfo
argument_list|)
operator|.
name|filter
argument_list|(
name|r
lambda|->
name|r
operator|.
name|getTable
argument_list|()
operator|.
name|isSystemTable
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|assign
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|assign
argument_list|(
name|regionInfo
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|assign
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
throws|throws
name|IOException
block|{
name|AssignProcedure
name|proc
init|=
name|createAssignProcedure
argument_list|(
name|regionInfo
argument_list|,
name|forceNewPlan
argument_list|)
decl_stmt|;
name|ProcedureSyncWait
operator|.
name|submitAndWaitProcedure
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
argument_list|,
name|proc
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|unassign
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|unassign
argument_list|(
name|regionInfo
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|unassign
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: rename this reassign
name|RegionStateNode
name|node
init|=
name|this
operator|.
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
name|ServerName
name|destinationServer
init|=
name|node
operator|.
name|getRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|destinationServer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
literal|"DestinationServer is null; Assigned? "
operator|+
name|node
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
assert|assert
name|destinationServer
operator|!=
literal|null
assert|;
name|node
operator|.
name|toString
argument_list|()
expr_stmt|;
name|UnassignProcedure
name|proc
init|=
name|createUnassignProcedure
argument_list|(
name|regionInfo
argument_list|,
name|destinationServer
argument_list|,
name|forceNewPlan
argument_list|)
decl_stmt|;
name|ProcedureSyncWait
operator|.
name|submitAndWaitProcedure
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
argument_list|,
name|proc
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|move
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionStateNode
name|node
init|=
name|this
operator|.
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
name|ServerName
name|sourceServer
init|=
name|node
operator|.
name|getRegionLocation
argument_list|()
decl_stmt|;
name|RegionPlan
name|plan
init|=
operator|new
name|RegionPlan
argument_list|(
name|regionInfo
argument_list|,
name|sourceServer
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|MoveRegionProcedure
name|proc
init|=
name|createMoveRegionProcedure
argument_list|(
name|plan
argument_list|)
decl_stmt|;
name|ProcedureSyncWait
operator|.
name|submitAndWaitProcedure
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
argument_list|,
name|proc
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
name|moveAsync
parameter_list|(
specifier|final
name|RegionPlan
name|regionPlan
parameter_list|)
block|{
name|MoveRegionProcedure
name|proc
init|=
name|createMoveRegionProcedure
argument_list|(
name|regionPlan
argument_list|)
decl_stmt|;
return|return
name|ProcedureSyncWait
operator|.
name|submitProcedure
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
argument_list|,
name|proc
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|boolean
name|waitForAssignment
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|waitForAssignment
argument_list|(
name|regionInfo
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
comment|// TODO: Remove this?
specifier|public
name|boolean
name|waitForAssignment
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|long
name|timeout
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionStateNode
name|node
init|=
literal|null
decl_stmt|;
comment|// This method can be called before the regionInfo has made it into the regionStateMap
comment|// so wait around here a while.
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// Something badly wrong if takes ten seconds to register a region.
name|long
name|endTime
init|=
name|startTime
operator|+
literal|10000
decl_stmt|;
while|while
condition|(
operator|(
name|node
operator|=
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
operator|)
operator|==
literal|null
operator|&&
name|isRunning
argument_list|()
operator|&&
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|<
name|endTime
condition|)
block|{
comment|// Presume it not yet added but will be added soon. Let it spew a lot so we can tell if
comment|// we are waiting here alot.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting on "
operator|+
name|regionInfo
operator|+
literal|" to be added to regionStateMap"
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
return|return
literal|false
return|;
throw|throw
operator|new
name|RegionException
argument_list|(
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" never registered with Assigment."
argument_list|)
throw|;
block|}
name|RegionTransitionProcedure
name|proc
init|=
name|node
operator|.
name|getProcedure
argument_list|()
decl_stmt|;
if|if
condition|(
name|proc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchProcedureException
argument_list|(
name|node
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|ProcedureSyncWait
operator|.
name|waitForProcedureToCompleteIOE
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
argument_list|,
name|proc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// ============================================================================================
comment|//  RegionTransition procedures helpers
comment|// ============================================================================================
specifier|public
name|AssignProcedure
index|[]
name|createAssignProcedures
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|RegionInfo
argument_list|>
name|regionInfo
parameter_list|)
block|{
return|return
name|createAssignProcedures
argument_list|(
name|regionInfo
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|AssignProcedure
index|[]
name|createAssignProcedures
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|RegionInfo
argument_list|>
name|regionInfo
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
block|{
if|if
condition|(
name|regionInfo
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
specifier|final
name|AssignProcedure
index|[]
name|procs
init|=
operator|new
name|AssignProcedure
index|[
name|regionInfo
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RegionInfo
name|hri
range|:
name|regionInfo
control|)
block|{
name|procs
index|[
name|index
operator|++
index|]
operator|=
name|createAssignProcedure
argument_list|(
name|hri
argument_list|,
name|forceNewPlan
argument_list|)
expr_stmt|;
block|}
return|return
name|procs
return|;
block|}
comment|// Needed for the following method so it can type the created Array we return
specifier|private
specifier|static
specifier|final
name|UnassignProcedure
index|[]
name|UNASSIGNED_PROCEDURE_FOR_TYPE_INFO
init|=
operator|new
name|UnassignProcedure
index|[
literal|0
index|]
decl_stmt|;
name|UnassignProcedure
index|[]
name|createUnassignProcedures
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|RegionStateNode
argument_list|>
name|nodes
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
specifier|final
name|List
argument_list|<
name|UnassignProcedure
argument_list|>
name|procs
init|=
operator|new
name|ArrayList
argument_list|<
name|UnassignProcedure
argument_list|>
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RegionStateNode
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|regionStates
operator|.
name|include
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
condition|)
continue|continue;
comment|// Look for regions that are offline/closed; i.e. already unassigned.
if|if
condition|(
name|this
operator|.
name|regionStates
operator|.
name|isRegionOffline
argument_list|(
name|node
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
condition|)
continue|continue;
assert|assert
name|node
operator|.
name|getRegionLocation
argument_list|()
operator|!=
literal|null
operator|:
name|node
operator|.
name|toString
argument_list|()
assert|;
name|procs
operator|.
name|add
argument_list|(
name|createUnassignProcedure
argument_list|(
name|node
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|node
operator|.
name|getRegionLocation
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|procs
operator|.
name|toArray
argument_list|(
name|UNASSIGNED_PROCEDURE_FOR_TYPE_INFO
argument_list|)
return|;
block|}
specifier|public
name|MoveRegionProcedure
index|[]
name|createReopenProcedures
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|RegionInfo
argument_list|>
name|regionInfo
parameter_list|)
block|{
specifier|final
name|MoveRegionProcedure
index|[]
name|procs
init|=
operator|new
name|MoveRegionProcedure
index|[
name|regionInfo
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RegionInfo
name|hri
range|:
name|regionInfo
control|)
block|{
specifier|final
name|ServerName
name|serverName
init|=
name|regionStates
operator|.
name|getRegionServerOfRegion
argument_list|(
name|hri
argument_list|)
decl_stmt|;
specifier|final
name|RegionPlan
name|plan
init|=
operator|new
name|RegionPlan
argument_list|(
name|hri
argument_list|,
name|serverName
argument_list|,
name|serverName
argument_list|)
decl_stmt|;
name|procs
index|[
name|index
operator|++
index|]
operator|=
name|createMoveRegionProcedure
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
return|return
name|procs
return|;
block|}
comment|/**    * Called by things like EnableTableProcedure to get a list of AssignProcedure    * to assign the regions of the table.    */
specifier|public
name|AssignProcedure
index|[]
name|createAssignProcedures
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|createAssignProcedures
argument_list|(
name|regionStates
operator|.
name|getRegionsOfTable
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Called by things like DisableTableProcedure to get a list of UnassignProcedure    * to unassign the regions of the table.    */
specifier|public
name|UnassignProcedure
index|[]
name|createUnassignProcedures
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|createUnassignProcedures
argument_list|(
name|regionStates
operator|.
name|getTableRegionStateNodes
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Called by things like ModifyColumnFamilyProcedure to get a list of MoveRegionProcedure    * to reopen the regions of the table.    */
specifier|public
name|MoveRegionProcedure
index|[]
name|createReopenProcedures
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|createReopenProcedures
argument_list|(
name|regionStates
operator|.
name|getRegionsOfTable
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|AssignProcedure
name|createAssignProcedure
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
block|{
name|AssignProcedure
name|proc
init|=
operator|new
name|AssignProcedure
argument_list|(
name|regionInfo
argument_list|,
name|forceNewPlan
argument_list|)
decl_stmt|;
name|proc
operator|.
name|setOwner
argument_list|(
name|getProcedureEnvironment
argument_list|()
operator|.
name|getRequestUser
argument_list|()
operator|.
name|getShortName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|proc
return|;
block|}
specifier|public
name|AssignProcedure
name|createAssignProcedure
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|ServerName
name|targetServer
parameter_list|)
block|{
name|AssignProcedure
name|proc
init|=
operator|new
name|AssignProcedure
argument_list|(
name|regionInfo
argument_list|,
name|targetServer
argument_list|)
decl_stmt|;
name|proc
operator|.
name|setOwner
argument_list|(
name|getProcedureEnvironment
argument_list|()
operator|.
name|getRequestUser
argument_list|()
operator|.
name|getShortName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|proc
return|;
block|}
specifier|public
name|UnassignProcedure
name|createUnassignProcedure
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|ServerName
name|destinationServer
parameter_list|,
specifier|final
name|boolean
name|force
parameter_list|)
block|{
comment|// If destinationServer is null, figure it.
name|ServerName
name|sn
init|=
name|destinationServer
operator|!=
literal|null
condition|?
name|destinationServer
else|:
name|getRegionStates
argument_list|()
operator|.
name|getRegionState
argument_list|(
name|regionInfo
argument_list|)
operator|.
name|getServerName
argument_list|()
decl_stmt|;
assert|assert
name|sn
operator|!=
literal|null
assert|;
name|UnassignProcedure
name|proc
init|=
operator|new
name|UnassignProcedure
argument_list|(
name|regionInfo
argument_list|,
name|sn
argument_list|,
name|force
argument_list|)
decl_stmt|;
name|proc
operator|.
name|setOwner
argument_list|(
name|getProcedureEnvironment
argument_list|()
operator|.
name|getRequestUser
argument_list|()
operator|.
name|getShortName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|proc
return|;
block|}
specifier|public
name|MoveRegionProcedure
name|createMoveRegionProcedure
parameter_list|(
specifier|final
name|RegionPlan
name|plan
parameter_list|)
block|{
if|if
condition|(
name|plan
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getTable
argument_list|()
operator|.
name|isSystemTable
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|exclude
init|=
name|getExcludedServersForSystemTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|plan
operator|.
name|getDestination
argument_list|()
operator|!=
literal|null
operator|&&
name|exclude
operator|.
name|contains
argument_list|(
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|)
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Can not move "
operator|+
name|plan
operator|.
name|getRegionInfo
argument_list|()
operator|+
literal|" to "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
operator|+
literal|" because the server is not with highest version"
argument_list|)
expr_stmt|;
name|plan
operator|.
name|setDestination
argument_list|(
name|getBalancer
argument_list|()
operator|.
name|randomAssignment
argument_list|(
name|plan
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|this
operator|.
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|createDestinationServersList
argument_list|(
name|exclude
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|new
name|MoveRegionProcedure
argument_list|(
name|getProcedureEnvironment
argument_list|()
argument_list|,
name|plan
argument_list|)
return|;
block|}
specifier|public
name|SplitTableRegionProcedure
name|createSplitProcedure
parameter_list|(
specifier|final
name|RegionInfo
name|regionToSplit
parameter_list|,
specifier|final
name|byte
index|[]
name|splitKey
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|SplitTableRegionProcedure
argument_list|(
name|getProcedureEnvironment
argument_list|()
argument_list|,
name|regionToSplit
argument_list|,
name|splitKey
argument_list|)
return|;
block|}
specifier|public
name|MergeTableRegionsProcedure
name|createMergeProcedure
parameter_list|(
specifier|final
name|RegionInfo
name|regionToMergeA
parameter_list|,
specifier|final
name|RegionInfo
name|regionToMergeB
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|MergeTableRegionsProcedure
argument_list|(
name|getProcedureEnvironment
argument_list|()
argument_list|,
name|regionToMergeA
argument_list|,
name|regionToMergeB
argument_list|)
return|;
block|}
comment|/**    * Delete the region states. This is called by "DeleteTable"    */
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ArrayList
argument_list|<
name|RegionInfo
argument_list|>
name|regions
init|=
name|regionStates
operator|.
name|getTableRegionsInfo
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|regionStateStore
operator|.
name|deleteRegions
argument_list|(
name|regions
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|RegionInfo
name|regionInfo
init|=
name|regions
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// we expect the region to be offline
name|regionStates
operator|.
name|removeFromOfflineRegions
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|deleteRegion
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ============================================================================================
comment|//  RS Region Transition Report helpers
comment|// ============================================================================================
comment|// TODO: Move this code in MasterRpcServices and call on specific event?
specifier|public
name|ReportRegionStateTransitionResponse
name|reportRegionStateTransition
parameter_list|(
specifier|final
name|ReportRegionStateTransitionRequest
name|req
parameter_list|)
throws|throws
name|PleaseHoldException
block|{
specifier|final
name|ReportRegionStateTransitionResponse
operator|.
name|Builder
name|builder
init|=
name|ReportRegionStateTransitionResponse
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
specifier|final
name|ServerName
name|serverName
init|=
name|ProtobufUtil
operator|.
name|toServerName
argument_list|(
name|req
operator|.
name|getServer
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|RegionStateTransition
name|transition
range|:
name|req
operator|.
name|getTransitionList
argument_list|()
control|)
block|{
switch|switch
condition|(
name|transition
operator|.
name|getTransitionCode
argument_list|()
condition|)
block|{
case|case
name|OPENED
case|:
case|case
name|FAILED_OPEN
case|:
case|case
name|CLOSED
case|:
assert|assert
name|transition
operator|.
name|getRegionInfoCount
argument_list|()
operator|==
literal|1
operator|:
name|transition
assert|;
specifier|final
name|RegionInfo
name|hri
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|updateRegionTransition
argument_list|(
name|serverName
argument_list|,
name|transition
operator|.
name|getTransitionCode
argument_list|()
argument_list|,
name|hri
argument_list|,
name|transition
operator|.
name|hasOpenSeqNum
argument_list|()
condition|?
name|transition
operator|.
name|getOpenSeqNum
argument_list|()
else|:
name|HConstants
operator|.
name|NO_SEQNUM
argument_list|)
expr_stmt|;
break|break;
case|case
name|READY_TO_SPLIT
case|:
case|case
name|SPLIT
case|:
case|case
name|SPLIT_REVERTED
case|:
assert|assert
name|transition
operator|.
name|getRegionInfoCount
argument_list|()
operator|==
literal|3
operator|:
name|transition
assert|;
specifier|final
name|RegionInfo
name|parent
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RegionInfo
name|splitA
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RegionInfo
name|splitB
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|updateRegionSplitTransition
argument_list|(
name|serverName
argument_list|,
name|transition
operator|.
name|getTransitionCode
argument_list|()
argument_list|,
name|parent
argument_list|,
name|splitA
argument_list|,
name|splitB
argument_list|)
expr_stmt|;
break|break;
case|case
name|READY_TO_MERGE
case|:
case|case
name|MERGED
case|:
case|case
name|MERGE_REVERTED
case|:
assert|assert
name|transition
operator|.
name|getRegionInfoCount
argument_list|()
operator|==
literal|3
operator|:
name|transition
assert|;
specifier|final
name|RegionInfo
name|merged
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RegionInfo
name|mergeA
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RegionInfo
name|mergeB
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|updateRegionMergeTransition
argument_list|(
name|serverName
argument_list|,
name|transition
operator|.
name|getTransitionCode
argument_list|()
argument_list|,
name|merged
argument_list|,
name|mergeA
argument_list|,
name|mergeB
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|PleaseHoldException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"Failed transition "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
decl||
name|IOException
name|e
parameter_list|)
block|{
comment|// TODO: at the moment we have a single error message and the RS will abort
comment|// if the master says that one of the region transitions failed.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed transition"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setErrorMessage
argument_list|(
literal|"Failed transition "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
name|void
name|updateRegionTransition
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|TransitionCode
name|state
parameter_list|,
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|long
name|seqId
parameter_list|)
throws|throws
name|PleaseHoldException
throws|,
name|UnexpectedStateException
block|{
name|checkFailoverCleanupCompleted
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
specifier|final
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionNode
operator|==
literal|null
condition|)
block|{
comment|// the table/region is gone. maybe a delete, split, merge
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Server %s was trying to transition region %s to %s. but the region was removed."
argument_list|,
name|serverName
argument_list|,
name|regionInfo
argument_list|,
name|state
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Update region transition serverName=%s region=%s regionState=%s"
argument_list|,
name|serverName
argument_list|,
name|regionNode
argument_list|,
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ServerStateNode
name|serverNode
init|=
name|regionStates
operator|.
name|getOrCreateServer
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reportTransition
argument_list|(
name|regionNode
argument_list|,
name|serverNode
argument_list|,
name|state
argument_list|,
name|seqId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No procedure for %s. server=%s to transition to %s"
argument_list|,
name|regionNode
argument_list|,
name|serverName
argument_list|,
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// FYI: regionNode is sometimes synchronized by the caller but not always.
specifier|private
name|boolean
name|reportTransition
parameter_list|(
specifier|final
name|RegionStateNode
name|regionNode
parameter_list|,
specifier|final
name|ServerStateNode
name|serverNode
parameter_list|,
specifier|final
name|TransitionCode
name|state
parameter_list|,
specifier|final
name|long
name|seqId
parameter_list|)
throws|throws
name|UnexpectedStateException
block|{
specifier|final
name|ServerName
name|serverName
init|=
name|serverNode
operator|.
name|getServerName
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|regionNode
init|)
block|{
specifier|final
name|RegionTransitionProcedure
name|proc
init|=
name|regionNode
operator|.
name|getProcedure
argument_list|()
decl_stmt|;
if|if
condition|(
name|proc
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// serverNode.getReportEvent().removeProcedure(proc);
name|proc
operator|.
name|reportTransition
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|serverName
argument_list|,
name|state
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|updateRegionSplitTransition
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|TransitionCode
name|state
parameter_list|,
specifier|final
name|RegionInfo
name|parent
parameter_list|,
specifier|final
name|RegionInfo
name|hriA
parameter_list|,
specifier|final
name|RegionInfo
name|hriB
parameter_list|)
throws|throws
name|IOException
block|{
name|checkFailoverCleanupCompleted
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|TransitionCode
operator|.
name|READY_TO_SPLIT
condition|)
block|{
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
literal|"unsupported split regionState="
operator|+
name|state
operator|+
literal|" for parent region "
operator|+
name|parent
operator|+
literal|" maybe an old RS (< 2.0) had the operation in progress"
argument_list|)
throw|;
block|}
comment|// sanity check on the request
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|hriA
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|hriB
operator|.
name|getStartKey
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"unsupported split request with bad keys: parent="
operator|+
name|parent
operator|+
literal|" hriA="
operator|+
name|hriA
operator|+
literal|" hriB="
operator|+
name|hriB
argument_list|)
throw|;
block|}
comment|// Submit the Split procedure
specifier|final
name|byte
index|[]
name|splitKey
init|=
name|hriB
operator|.
name|getStartKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Split request from "
operator|+
name|serverName
operator|+
literal|", parent="
operator|+
name|parent
operator|+
literal|" splitKey="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|splitKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|submitProcedure
argument_list|(
name|createSplitProcedure
argument_list|(
name|parent
argument_list|,
name|splitKey
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the RS is< 2.0 throw an exception to abort the operation, we are handling the split
if|if
condition|(
name|regionStates
operator|.
name|getOrCreateServer
argument_list|(
name|serverName
argument_list|)
operator|.
name|getVersionNumber
argument_list|()
operator|<
literal|0x0200000
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Split handled by the master: parent=%s hriA=%s hriB=%s"
argument_list|,
name|parent
operator|.
name|getShortNameToLog
argument_list|()
argument_list|,
name|hriA
argument_list|,
name|hriB
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|updateRegionMergeTransition
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|TransitionCode
name|state
parameter_list|,
specifier|final
name|RegionInfo
name|merged
parameter_list|,
specifier|final
name|RegionInfo
name|hriA
parameter_list|,
specifier|final
name|RegionInfo
name|hriB
parameter_list|)
throws|throws
name|IOException
block|{
name|checkFailoverCleanupCompleted
argument_list|(
name|merged
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|TransitionCode
operator|.
name|READY_TO_MERGE
condition|)
block|{
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
literal|"Unsupported merge regionState="
operator|+
name|state
operator|+
literal|" for regionA="
operator|+
name|hriA
operator|+
literal|" regionB="
operator|+
name|hriB
operator|+
literal|" merged="
operator|+
name|merged
operator|+
literal|" maybe an old RS (< 2.0) had the operation in progress"
argument_list|)
throw|;
block|}
comment|// Submit the Merge procedure
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling merge request from RS="
operator|+
name|merged
operator|+
literal|", merged="
operator|+
name|merged
argument_list|)
expr_stmt|;
block|}
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|submitProcedure
argument_list|(
name|createMergeProcedure
argument_list|(
name|hriA
argument_list|,
name|hriB
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the RS is< 2.0 throw an exception to abort the operation, we are handling the merge
if|if
condition|(
name|regionStates
operator|.
name|getOrCreateServer
argument_list|(
name|serverName
argument_list|)
operator|.
name|getVersionNumber
argument_list|()
operator|<
literal|0x0200000
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Merge not handled yet: regionState=%s merged=%s hriA=%s hriB=%s"
argument_list|,
name|state
argument_list|,
name|merged
argument_list|,
name|hriA
argument_list|,
name|hriB
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// ============================================================================================
comment|//  RS Status update (report online regions) helpers
comment|// ============================================================================================
comment|/**    * the master will call this method when the RS send the regionServerReport().    * the report will contains the "hbase version" and the "online regions".    * this method will check the the online regions against the in-memory state of the AM,    * if there is a mismatch we will try to fence out the RS with the assumption    * that something went wrong on the RS side.    */
specifier|public
name|void
name|reportOnlineRegions
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|int
name|versionNumber
parameter_list|,
specifier|final
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|regionNames
parameter_list|)
throws|throws
name|YouAreDeadException
block|{
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
return|return;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"ReportOnlineRegions "
operator|+
name|serverName
operator|+
literal|" regionCount="
operator|+
name|regionNames
operator|.
name|size
argument_list|()
operator|+
literal|", metaLoaded="
operator|+
name|isMetaLoaded
argument_list|()
operator|+
literal|" "
operator|+
name|regionNames
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|element
lambda|->
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|element
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ServerStateNode
name|serverNode
init|=
name|regionStates
operator|.
name|getOrCreateServer
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
comment|// update the server version number. This will be used for live upgrades.
synchronized|synchronized
init|(
name|serverNode
init|)
block|{
name|serverNode
operator|.
name|setVersionNumber
argument_list|(
name|versionNumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|serverNode
operator|.
name|isInState
argument_list|(
name|ServerState
operator|.
name|SPLITTING
argument_list|,
name|ServerState
operator|.
name|OFFLINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Got a report from a server result in state "
operator|+
name|serverNode
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|regionNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// nothing to do if we don't have regions
name|LOG
operator|.
name|trace
argument_list|(
literal|"no online region found on "
operator|+
name|serverName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isMetaLoaded
argument_list|()
condition|)
block|{
comment|// if we are still on startup, discard the report unless is from someone holding meta
name|checkOnlineRegionsReportForMeta
argument_list|(
name|serverNode
argument_list|,
name|regionNames
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The Heartbeat updates us of what regions are only. check and verify the state.
name|checkOnlineRegionsReport
argument_list|(
name|serverNode
argument_list|,
name|regionNames
argument_list|)
expr_stmt|;
block|}
comment|// wake report event
name|wakeServerReportEvent
argument_list|(
name|serverNode
argument_list|)
expr_stmt|;
block|}
name|void
name|checkOnlineRegionsReportForMeta
parameter_list|(
specifier|final
name|ServerStateNode
name|serverNode
parameter_list|,
specifier|final
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|regionNames
parameter_list|)
block|{
try|try
block|{
for|for
control|(
name|byte
index|[]
name|regionName
range|:
name|regionNames
control|)
block|{
specifier|final
name|RegionInfo
name|hri
init|=
name|getMetaRegionFromName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|hri
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skip online report for region="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
operator|+
literal|" while meta is loading"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
specifier|final
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|hri
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"META REPORTED: "
operator|+
name|regionNode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reportTransition
argument_list|(
name|regionNode
argument_list|,
name|serverNode
argument_list|,
name|TransitionCode
operator|.
name|OPENED
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"META REPORTED but no procedure found (complete?)"
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
name|serverNode
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"META REPORTED: "
operator|+
name|regionNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|UnexpectedStateException
name|e
parameter_list|)
block|{
specifier|final
name|ServerName
name|serverName
init|=
name|serverNode
operator|.
name|getServerName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"KILLING "
operator|+
name|serverName
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|killRegionServer
argument_list|(
name|serverNode
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|checkOnlineRegionsReport
parameter_list|(
specifier|final
name|ServerStateNode
name|serverNode
parameter_list|,
specifier|final
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|regionNames
parameter_list|)
throws|throws
name|YouAreDeadException
block|{
specifier|final
name|ServerName
name|serverName
init|=
name|serverNode
operator|.
name|getServerName
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|byte
index|[]
name|regionName
range|:
name|regionNames
control|)
block|{
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
return|return;
specifier|final
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getRegionStateNodeFromName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
literal|"Not online: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
synchronized|synchronized
init|(
name|regionNode
init|)
block|{
if|if
condition|(
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|OPENING
argument_list|,
name|State
operator|.
name|OPEN
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
name|regionNode
operator|.
name|toString
argument_list|()
operator|+
literal|"reported OPEN on server="
operator|+
name|serverName
operator|+
literal|" but state has otherwise."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|OPENING
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|reportTransition
argument_list|(
name|regionNode
argument_list|,
name|serverNode
argument_list|,
name|TransitionCode
operator|.
name|OPENED
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|regionNode
operator|.
name|toString
argument_list|()
operator|+
literal|" reported OPEN on server="
operator|+
name|serverName
operator|+
literal|" but state has otherwise AND NO procedure is running"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|UnexpectedStateException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|regionNode
operator|.
name|toString
argument_list|()
operator|+
literal|" reported unexpteced OPEN: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|CLOSING
argument_list|,
name|State
operator|.
name|SPLITTING
argument_list|)
condition|)
block|{
name|long
name|diff
init|=
name|regionNode
operator|.
name|getLastUpdate
argument_list|()
operator|-
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|diff
operator|>
literal|1000
comment|/*One Second... make configurable if an issue*/
condition|)
block|{
comment|// So, we can get report that a region is CLOSED or SPLIT because a heartbeat
comment|// came in at about same time as a region transition. Make sure there is some
comment|// elapsed time between killing remote server.
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
name|regionNode
operator|.
name|toString
argument_list|()
operator|+
literal|" reported an unexpected OPEN; time since last update="
operator|+
name|diff
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|UnexpectedStateException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Killing "
operator|+
name|serverName
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|killRegionServer
argument_list|(
name|serverNode
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|YouAreDeadException
operator|)
operator|new
name|YouAreDeadException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|boolean
name|waitServerReportEvent
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
specifier|final
name|ServerStateNode
name|serverNode
init|=
name|regionStates
operator|.
name|getOrCreateServer
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
return|return
name|serverNode
operator|.
name|getReportEvent
argument_list|()
operator|.
name|suspendIfNotReady
argument_list|(
name|proc
argument_list|)
return|;
block|}
specifier|protected
name|void
name|wakeServerReportEvent
parameter_list|(
specifier|final
name|ServerStateNode
name|serverNode
parameter_list|)
block|{
name|serverNode
operator|.
name|getReportEvent
argument_list|()
operator|.
name|wake
argument_list|(
name|getProcedureScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// ============================================================================================
comment|//  RIT chore
comment|// ============================================================================================
specifier|private
specifier|static
class|class
name|RegionInTransitionChore
extends|extends
name|ProcedureInMemoryChore
argument_list|<
name|MasterProcedureEnv
argument_list|>
block|{
specifier|public
name|RegionInTransitionChore
parameter_list|(
specifier|final
name|int
name|timeoutMsec
parameter_list|)
block|{
name|super
argument_list|(
name|timeoutMsec
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|periodicExecute
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
specifier|final
name|AssignmentManager
name|am
init|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
decl_stmt|;
specifier|final
name|RegionInTransitionStat
name|ritStat
init|=
name|am
operator|.
name|computeRegionInTransitionStat
argument_list|()
decl_stmt|;
if|if
condition|(
name|ritStat
operator|.
name|hasRegionsOverThreshold
argument_list|()
condition|)
block|{
for|for
control|(
name|RegionState
name|hri
range|:
name|ritStat
operator|.
name|getRegionOverThreshold
argument_list|()
control|)
block|{
name|am
operator|.
name|handleRegionOverStuckWarningThreshold
argument_list|(
name|hri
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update metrics
name|am
operator|.
name|updateRegionsInTransitionMetrics
argument_list|(
name|ritStat
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|RegionInTransitionStat
name|computeRegionInTransitionStat
parameter_list|()
block|{
specifier|final
name|RegionInTransitionStat
name|rit
init|=
operator|new
name|RegionInTransitionStat
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|rit
operator|.
name|update
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|rit
return|;
block|}
specifier|public
specifier|static
class|class
name|RegionInTransitionStat
block|{
specifier|private
specifier|final
name|int
name|ritThreshold
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|ritsOverThreshold
init|=
literal|null
decl_stmt|;
specifier|private
name|long
name|statTimestamp
decl_stmt|;
specifier|private
name|long
name|oldestRITTime
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|totalRITsTwiceThreshold
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|totalRITs
init|=
literal|0
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|public
name|RegionInTransitionStat
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|ritThreshold
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|METRICS_RIT_STUCK_WARNING_THRESHOLD
argument_list|,
name|DEFAULT_RIT_STUCK_WARNING_THRESHOLD
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|getRITThreshold
parameter_list|()
block|{
return|return
name|ritThreshold
return|;
block|}
specifier|public
name|long
name|getTimestamp
parameter_list|()
block|{
return|return
name|statTimestamp
return|;
block|}
specifier|public
name|int
name|getTotalRITs
parameter_list|()
block|{
return|return
name|totalRITs
return|;
block|}
specifier|public
name|long
name|getOldestRITTime
parameter_list|()
block|{
return|return
name|oldestRITTime
return|;
block|}
specifier|public
name|int
name|getTotalRITsOverThreshold
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|m
init|=
name|this
operator|.
name|ritsOverThreshold
decl_stmt|;
return|return
name|m
operator|!=
literal|null
condition|?
name|m
operator|.
name|size
argument_list|()
else|:
literal|0
return|;
block|}
specifier|public
name|boolean
name|hasRegionsTwiceOverThreshold
parameter_list|()
block|{
return|return
name|totalRITsTwiceThreshold
operator|>
literal|0
return|;
block|}
specifier|public
name|boolean
name|hasRegionsOverThreshold
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|m
init|=
name|this
operator|.
name|ritsOverThreshold
decl_stmt|;
return|return
name|m
operator|!=
literal|null
operator|&&
operator|!
name|m
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|public
name|Collection
argument_list|<
name|RegionState
argument_list|>
name|getRegionOverThreshold
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|m
init|=
name|this
operator|.
name|ritsOverThreshold
decl_stmt|;
return|return
name|m
operator|!=
literal|null
condition|?
name|m
operator|.
name|values
argument_list|()
else|:
name|Collections
operator|.
name|EMPTY_SET
return|;
block|}
specifier|public
name|boolean
name|isRegionOverThreshold
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|m
init|=
name|this
operator|.
name|ritsOverThreshold
decl_stmt|;
return|return
name|m
operator|!=
literal|null
operator|&&
name|m
operator|.
name|containsKey
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isRegionTwiceOverThreshold
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|m
init|=
name|this
operator|.
name|ritsOverThreshold
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
return|return
literal|false
return|;
specifier|final
name|RegionState
name|state
init|=
name|m
operator|.
name|get
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
operator|(
name|statTimestamp
operator|-
name|state
operator|.
name|getStamp
argument_list|()
operator|)
operator|>
operator|(
name|ritThreshold
operator|*
literal|2
operator|)
return|;
block|}
specifier|protected
name|void
name|update
parameter_list|(
specifier|final
name|AssignmentManager
name|am
parameter_list|)
block|{
specifier|final
name|RegionStates
name|regionStates
init|=
name|am
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
name|this
operator|.
name|statTimestamp
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
expr_stmt|;
name|update
argument_list|(
name|regionStates
operator|.
name|getRegionsStateInTransition
argument_list|()
argument_list|,
name|statTimestamp
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|regionStates
operator|.
name|getRegionFailedOpen
argument_list|()
argument_list|,
name|statTimestamp
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|update
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|RegionState
argument_list|>
name|regions
parameter_list|,
specifier|final
name|long
name|currentTime
parameter_list|)
block|{
for|for
control|(
name|RegionState
name|state
range|:
name|regions
control|)
block|{
name|totalRITs
operator|++
expr_stmt|;
specifier|final
name|long
name|ritTime
init|=
name|currentTime
operator|-
name|state
operator|.
name|getStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|ritTime
operator|>
name|ritThreshold
condition|)
block|{
if|if
condition|(
name|ritsOverThreshold
operator|==
literal|null
condition|)
block|{
name|ritsOverThreshold
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|ritsOverThreshold
operator|.
name|put
argument_list|(
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|totalRITsTwiceThreshold
operator|+=
operator|(
name|ritTime
operator|>
operator|(
name|ritThreshold
operator|*
literal|2
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|oldestRITTime
operator|<
name|ritTime
condition|)
block|{
name|oldestRITTime
operator|=
name|ritTime
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|updateRegionsInTransitionMetrics
parameter_list|(
specifier|final
name|RegionInTransitionStat
name|ritStat
parameter_list|)
block|{
name|metrics
operator|.
name|updateRITOldestAge
argument_list|(
name|ritStat
operator|.
name|getOldestRITTime
argument_list|()
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|updateRITCount
argument_list|(
name|ritStat
operator|.
name|getTotalRITs
argument_list|()
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|updateRITCountOverThreshold
argument_list|(
name|ritStat
operator|.
name|getTotalRITsOverThreshold
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|handleRegionOverStuckWarningThreshold
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
specifier|final
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
comment|//if (regionNode.isStuck()) {
name|LOG
operator|.
name|warn
argument_list|(
literal|"TODO Handle stuck in transition: "
operator|+
name|regionNode
argument_list|)
expr_stmt|;
block|}
comment|// ============================================================================================
comment|//  TODO: Master load/bootstrap
comment|// ============================================================================================
specifier|public
name|void
name|joinCluster
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Joining the cluster..."
argument_list|)
expr_stmt|;
comment|// Scan hbase:meta to build list of existing regions, servers, and assignment
name|loadMeta
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|countOfRegionServers
argument_list|()
operator|<
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"waiting for RS to join"
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|sleep
argument_list|(
literal|250
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"RS joined. Num RS = "
operator|+
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|countOfRegionServers
argument_list|()
argument_list|)
expr_stmt|;
comment|// This method will assign all user regions if a clean server startup or
comment|// it will reconstruct master state and cleanup any leftovers from previous master process.
name|boolean
name|failover
init|=
name|processofflineServersWithOnlineRegions
argument_list|()
decl_stmt|;
comment|// Start the RIT chore
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|addChore
argument_list|(
name|this
operator|.
name|ritChore
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Joined the cluster in %s, failover=%s"
argument_list|,
name|StringUtils
operator|.
name|humanTimeDiff
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
argument_list|)
argument_list|,
name|failover
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|loadMeta
parameter_list|()
throws|throws
name|IOException
block|{
comment|// TODO: use a thread pool
name|regionStateStore
operator|.
name|visitMeta
argument_list|(
operator|new
name|RegionStateStore
operator|.
name|RegionStateVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|visitRegionState
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|State
name|state
parameter_list|,
specifier|final
name|ServerName
name|regionLocation
parameter_list|,
specifier|final
name|ServerName
name|lastHost
parameter_list|,
specifier|final
name|long
name|openSeqNum
parameter_list|)
block|{
specifier|final
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
name|State
name|localState
init|=
name|state
decl_stmt|;
if|if
condition|(
name|localState
operator|==
literal|null
condition|)
block|{
comment|// No region state column data in hbase:meta table! Are I doing a rolling upgrade from
comment|// hbase1 to hbase2? Am I restoring a SNAPSHOT or otherwise adding a region to hbase:meta?
comment|// In any of these cases, state is empty. For now, presume OFFLINE but there are probably
comment|// cases where we need to probe more to be sure this correct; TODO informed by experience.
name|LOG
operator|.
name|info
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" regionState=null; presuming "
operator|+
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
name|localState
operator|=
name|State
operator|.
name|OFFLINE
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|regionNode
init|)
block|{
if|if
condition|(
operator|!
name|regionNode
operator|.
name|isInTransition
argument_list|()
condition|)
block|{
name|regionNode
operator|.
name|setState
argument_list|(
name|localState
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setLastHost
argument_list|(
name|lastHost
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
name|regionLocation
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setOpenSeqNum
argument_list|(
name|openSeqNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|localState
operator|==
name|State
operator|.
name|OPEN
condition|)
block|{
assert|assert
name|regionLocation
operator|!=
literal|null
operator|:
literal|"found null region location for "
operator|+
name|regionNode
assert|;
name|regionStates
operator|.
name|addRegionToServer
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|localState
operator|==
name|State
operator|.
name|OFFLINE
operator|||
name|regionInfo
operator|.
name|isOffline
argument_list|()
condition|)
block|{
name|regionStates
operator|.
name|addToOfflineRegions
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// These regions should have a procedure in replay
name|regionStates
operator|.
name|addRegionInTransition
argument_list|(
name|regionNode
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// every assignment is blocked until meta is loaded.
name|wakeMetaLoadedEvent
argument_list|()
expr_stmt|;
block|}
comment|// TODO: the assumption here is that if RSs are crashing while we are executing this
comment|// they will be handled by the SSH that are put in the ServerManager "queue".
comment|// we can integrate this a bit better.
specifier|private
name|boolean
name|processofflineServersWithOnlineRegions
parameter_list|()
block|{
name|boolean
name|failover
init|=
operator|!
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|getDeadServers
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|ServerName
argument_list|>
name|offlineServersWithOnlineRegions
init|=
operator|new
name|HashSet
argument_list|<
name|ServerName
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|ArrayList
argument_list|<
name|RegionInfo
argument_list|>
name|regionsToAssign
init|=
operator|new
name|ArrayList
argument_list|<
name|RegionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|st
decl_stmt|,
name|et
decl_stmt|;
name|st
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
for|for
control|(
name|RegionStateNode
name|regionNode
range|:
name|regionStates
operator|.
name|getRegionStateNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|regionNode
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|OPEN
condition|)
block|{
specifier|final
name|ServerName
name|serverName
init|=
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|isServerOnline
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|offlineServersWithOnlineRegions
operator|.
name|add
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regionNode
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|OFFLINE
condition|)
block|{
if|if
condition|(
name|isTableEnabled
argument_list|(
name|regionNode
operator|.
name|getTable
argument_list|()
argument_list|)
condition|)
block|{
name|regionsToAssign
operator|.
name|add
argument_list|(
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|et
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"[STEP-1] "
operator|+
name|StringUtils
operator|.
name|humanTimeDiff
argument_list|(
name|et
operator|-
name|st
argument_list|)
argument_list|)
expr_stmt|;
comment|// kill servers with online regions
name|st
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
for|for
control|(
name|ServerName
name|serverName
range|:
name|offlineServersWithOnlineRegions
control|)
block|{
if|if
condition|(
operator|!
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|isServerOnline
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"KILL RS hosting regions but not online "
operator|+
name|serverName
operator|+
literal|" (master="
operator|+
name|master
operator|.
name|getServerName
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|killRegionServer
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
name|et
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"[STEP-2] "
operator|+
name|StringUtils
operator|.
name|humanTimeDiff
argument_list|(
name|et
operator|-
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|setFailoverCleanupDone
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// assign offline regions
name|st
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
for|for
control|(
name|RegionInfo
name|regionInfo
range|:
name|getOrderedRegions
argument_list|(
name|regionsToAssign
argument_list|)
control|)
block|{
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|submitProcedure
argument_list|(
name|createAssignProcedure
argument_list|(
name|regionInfo
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|et
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"[STEP-3] "
operator|+
name|StringUtils
operator|.
name|humanTimeDiff
argument_list|(
name|et
operator|-
name|st
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|failover
return|;
block|}
comment|/**    * Used by ServerCrashProcedure to make sure AssignmentManager has completed    * the failover cleanup before re-assigning regions of dead servers. So that    * when re-assignment happens, AssignmentManager has proper region states.    */
specifier|public
name|boolean
name|isFailoverCleanupDone
parameter_list|()
block|{
return|return
name|failoverCleanupDone
operator|.
name|isReady
argument_list|()
return|;
block|}
comment|/**    * Used by ServerCrashProcedure tests verify the ability to suspend the    * execution of the ServerCrashProcedure.    */
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|setFailoverCleanupDone
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
block|{
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|getEnvironment
argument_list|()
operator|.
name|setEventReady
argument_list|(
name|failoverCleanupDone
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ProcedureEvent
name|getFailoverCleanupEvent
parameter_list|()
block|{
return|return
name|failoverCleanupDone
return|;
block|}
comment|/**    * Used to check if the failover cleanup is done.    * if not we throw PleaseHoldException since we are rebuilding the RegionStates    * @param hri region to check if it is already rebuild    * @throws PleaseHoldException if the failover cleanup is not completed    */
specifier|private
name|void
name|checkFailoverCleanupCompleted
parameter_list|(
specifier|final
name|RegionInfo
name|hri
parameter_list|)
throws|throws
name|PleaseHoldException
block|{
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PleaseHoldException
argument_list|(
literal|"AssignmentManager not running"
argument_list|)
throw|;
block|}
comment|// TODO: can we avoid throwing an exception if hri is already loaded?
comment|//       at the moment we bypass only meta
name|boolean
name|meta
init|=
name|isMetaRegion
argument_list|(
name|hri
argument_list|)
decl_stmt|;
name|boolean
name|cleanup
init|=
name|isFailoverCleanupDone
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isMetaRegion
argument_list|(
name|hri
argument_list|)
operator|&&
operator|!
name|isFailoverCleanupDone
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"Master not fully online; hbase:meta="
operator|+
name|meta
operator|+
literal|", failoverCleanup="
operator|+
name|cleanup
decl_stmt|;
throw|throw
operator|new
name|PleaseHoldException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
comment|// ============================================================================================
comment|//  TODO: Metrics
comment|// ============================================================================================
specifier|public
name|int
name|getNumRegionsOpened
parameter_list|()
block|{
comment|// TODO: Used by TestRegionPlacement.java and assume monotonically increasing value
return|return
literal|0
return|;
block|}
specifier|public
name|void
name|submitServerCrash
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|boolean
name|shouldSplitWal
parameter_list|)
block|{
name|boolean
name|carryingMeta
init|=
name|isCarryingMeta
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
name|ProcedureExecutor
argument_list|<
name|MasterProcedureEnv
argument_list|>
name|procExec
init|=
name|this
operator|.
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
decl_stmt|;
name|procExec
operator|.
name|submitProcedure
argument_list|(
operator|new
name|ServerCrashProcedure
argument_list|(
name|procExec
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|serverName
argument_list|,
name|shouldSplitWal
argument_list|,
name|carryingMeta
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added="
operator|+
name|serverName
operator|+
literal|" to dead servers, submitted shutdown handler to be executed meta="
operator|+
name|carryingMeta
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|offlineRegion
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
comment|// TODO used by MasterRpcServices ServerCrashProcedure
specifier|final
name|RegionStateNode
name|node
init|=
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|node
operator|.
name|offline
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|onlineRegion
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
comment|// TODO used by TestSplitTransactionOnCluster.java
block|}
specifier|public
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|getSnapShotOfAssignment
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|RegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
return|return
name|regionStates
operator|.
name|getSnapShotOfAssignment
argument_list|(
name|regions
argument_list|)
return|;
block|}
comment|// ============================================================================================
comment|//  TODO: UTILS/HELPERS?
comment|// ============================================================================================
comment|/**    * Used by the client (via master) to identify if all regions have the schema updates    *    * @param tableName    * @return Pair indicating the status of the alter command (pending/total)    * @throws IOException    */
specifier|public
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|getReopenStatus
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
if|if
condition|(
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
condition|)
return|return
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
specifier|final
name|List
argument_list|<
name|RegionState
argument_list|>
name|states
init|=
name|regionStates
operator|.
name|getTableRegionStates
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|int
name|ritCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RegionState
name|regionState
range|:
name|states
control|)
block|{
if|if
condition|(
operator|!
name|regionState
operator|.
name|isOpened
argument_list|()
condition|)
name|ritCount
operator|++
expr_stmt|;
block|}
return|return
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|ritCount
argument_list|,
name|states
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Used when assign regions, this method will put system regions in    * front of user regions    * @param regions    * @return A list of regions with system regions at front    */
specifier|public
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|getOrderedRegions
parameter_list|(
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
if|if
condition|(
name|regions
operator|==
literal|null
condition|)
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|systemList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|userList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RegionInfo
name|hri
range|:
name|regions
control|)
block|{
if|if
condition|(
name|hri
operator|.
name|getTable
argument_list|()
operator|.
name|isSystemTable
argument_list|()
condition|)
name|systemList
operator|.
name|add
argument_list|(
name|hri
argument_list|)
expr_stmt|;
else|else
name|userList
operator|.
name|add
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
comment|// Append userList to systemList
name|systemList
operator|.
name|addAll
argument_list|(
name|userList
argument_list|)
expr_stmt|;
return|return
name|systemList
return|;
block|}
comment|// ============================================================================================
comment|//  TODO: Region State In Transition
comment|// ============================================================================================
specifier|protected
name|boolean
name|addRegionInTransition
parameter_list|(
specifier|final
name|RegionStateNode
name|regionNode
parameter_list|,
specifier|final
name|RegionTransitionProcedure
name|procedure
parameter_list|)
block|{
return|return
name|regionStates
operator|.
name|addRegionInTransition
argument_list|(
name|regionNode
argument_list|,
name|procedure
argument_list|)
return|;
block|}
specifier|protected
name|void
name|removeRegionInTransition
parameter_list|(
specifier|final
name|RegionStateNode
name|regionNode
parameter_list|,
specifier|final
name|RegionTransitionProcedure
name|procedure
parameter_list|)
block|{
name|regionStates
operator|.
name|removeRegionInTransition
argument_list|(
name|regionNode
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasRegionsInTransition
parameter_list|()
block|{
return|return
name|regionStates
operator|.
name|hasRegionsInTransition
argument_list|()
return|;
block|}
specifier|public
name|List
argument_list|<
name|RegionStateNode
argument_list|>
name|getRegionsInTransition
parameter_list|()
block|{
return|return
name|regionStates
operator|.
name|getRegionsInTransition
argument_list|()
return|;
block|}
specifier|public
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|getAssignedRegions
parameter_list|()
block|{
return|return
name|regionStates
operator|.
name|getAssignedRegions
argument_list|()
return|;
block|}
specifier|public
name|RegionInfo
name|getRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
specifier|final
name|RegionStateNode
name|regionState
init|=
name|regionStates
operator|.
name|getRegionStateNodeFromName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
return|return
name|regionState
operator|!=
literal|null
condition|?
name|regionState
operator|.
name|getRegionInfo
argument_list|()
else|:
literal|null
return|;
block|}
comment|// ============================================================================================
comment|//  TODO: Region Status update
comment|// ============================================================================================
specifier|private
name|void
name|sendRegionOpenedNotification
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
name|getBalancer
argument_list|()
operator|.
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|AssignmentListener
name|listener
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|listener
operator|.
name|regionOpened
argument_list|(
name|regionInfo
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|sendRegionClosedNotification
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
name|getBalancer
argument_list|()
operator|.
name|regionOffline
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|AssignmentListener
name|listener
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|listener
operator|.
name|regionClosed
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|markRegionAsOpening
parameter_list|(
specifier|final
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|regionNode
init|)
block|{
name|regionNode
operator|.
name|transitionState
argument_list|(
name|State
operator|.
name|OPENING
argument_list|,
name|RegionStates
operator|.
name|STATES_EXPECTED_ON_OPEN
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|addRegionToServer
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
name|regionStateStore
operator|.
name|updateRegionLocation
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
block|}
comment|// update the operation count metrics
name|metrics
operator|.
name|incrementOperationCounter
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|undoRegionAsOpening
parameter_list|(
specifier|final
name|RegionStateNode
name|regionNode
parameter_list|)
block|{
name|boolean
name|opening
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|regionNode
init|)
block|{
if|if
condition|(
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|OPENING
argument_list|)
condition|)
block|{
name|opening
operator|=
literal|true
expr_stmt|;
name|regionStates
operator|.
name|removeRegionFromServer
argument_list|(
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
block|}
comment|// Should we update hbase:meta?
block|}
if|if
condition|(
name|opening
condition|)
block|{
comment|// TODO: Metrics. Do opposite of metrics.incrementOperationCounter();
block|}
block|}
specifier|public
name|void
name|markRegionAsOpened
parameter_list|(
specifier|final
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|RegionInfo
name|hri
init|=
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|regionNode
init|)
block|{
name|regionNode
operator|.
name|transitionState
argument_list|(
name|State
operator|.
name|OPEN
argument_list|,
name|RegionStates
operator|.
name|STATES_EXPECTED_ON_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|isMetaRegion
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|master
operator|.
name|getTableStateManager
argument_list|()
operator|.
name|setTableState
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|ENABLED
argument_list|)
expr_stmt|;
name|setMetaInitialized
argument_list|(
name|hri
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|regionStates
operator|.
name|addRegionToServer
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
comment|// TODO: OPENING Updates hbase:meta too... we need to do both here and there?
comment|// That is a lot of hbase:meta writing.
name|regionStateStore
operator|.
name|updateRegionLocation
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
name|sendRegionOpenedNotification
argument_list|(
name|hri
argument_list|,
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|markRegionAsClosing
parameter_list|(
specifier|final
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|RegionInfo
name|hri
init|=
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|regionNode
init|)
block|{
name|regionNode
operator|.
name|transitionState
argument_list|(
name|State
operator|.
name|CLOSING
argument_list|,
name|RegionStates
operator|.
name|STATES_EXPECTED_ON_CLOSE
argument_list|)
expr_stmt|;
comment|// Set meta has not initialized early. so people trying to create/edit tables will wait
if|if
condition|(
name|isMetaRegion
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|setMetaInitialized
argument_list|(
name|hri
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|regionStates
operator|.
name|addRegionToServer
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
name|regionStateStore
operator|.
name|updateRegionLocation
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
block|}
comment|// update the operation count metrics
name|metrics
operator|.
name|incrementOperationCounter
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|undoRegionAsClosing
parameter_list|(
specifier|final
name|RegionStateNode
name|regionNode
parameter_list|)
block|{
comment|// TODO: Metrics. Do opposite of metrics.incrementOperationCounter();
comment|// There is nothing to undo?
block|}
specifier|public
name|void
name|markRegionAsClosed
parameter_list|(
specifier|final
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|RegionInfo
name|hri
init|=
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|regionNode
init|)
block|{
name|regionNode
operator|.
name|transitionState
argument_list|(
name|State
operator|.
name|CLOSED
argument_list|,
name|RegionStates
operator|.
name|STATES_EXPECTED_ON_CLOSE
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|removeRegionFromServer
argument_list|(
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setLastHost
argument_list|(
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|regionStateStore
operator|.
name|updateRegionLocation
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
name|sendRegionClosedNotification
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|markRegionAsSplit
parameter_list|(
specifier|final
name|RegionInfo
name|parent
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|RegionInfo
name|daughterA
parameter_list|,
specifier|final
name|RegionInfo
name|daughterB
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Update hbase:meta. Parent will be marked offline and split up in hbase:meta.
comment|// The parent stays in regionStates until cleared when removed by CatalogJanitor.
comment|// Update its state in regionStates to it shows as offline and split when read
comment|// later figuring what regions are in a table and what are not: see
comment|// regionStates#getRegionsOfTable
specifier|final
name|RegionStateNode
name|node
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|node
operator|.
name|setState
argument_list|(
name|State
operator|.
name|SPLIT
argument_list|)
expr_stmt|;
specifier|final
name|RegionStateNode
name|nodeA
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|daughterA
argument_list|)
decl_stmt|;
name|nodeA
operator|.
name|setState
argument_list|(
name|State
operator|.
name|SPLITTING_NEW
argument_list|)
expr_stmt|;
specifier|final
name|RegionStateNode
name|nodeB
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|daughterB
argument_list|)
decl_stmt|;
name|nodeB
operator|.
name|setState
argument_list|(
name|State
operator|.
name|SPLITTING_NEW
argument_list|)
expr_stmt|;
name|regionStateStore
operator|.
name|splitRegion
argument_list|(
name|parent
argument_list|,
name|daughterA
argument_list|,
name|daughterB
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldAssignFavoredNodes
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|onlineServers
init|=
name|this
operator|.
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|getOnlineServersList
argument_list|()
decl_stmt|;
operator|(
operator|(
name|FavoredNodesPromoter
operator|)
name|getBalancer
argument_list|()
operator|)
operator|.
name|generateFavoredNodesForDaughter
argument_list|(
name|onlineServers
argument_list|,
name|parent
argument_list|,
name|daughterA
argument_list|,
name|daughterB
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * When called here, the merge has happened. The two merged regions have been    * unassigned and the above markRegionClosed has been called on each so they have been    * disassociated from a hosting Server. The merged region will be open after this call. The    * merged regions are removed from hbase:meta below> Later they are deleted from the filesystem    * by the catalog janitor running against hbase:meta. It notices when the merged region no    * longer holds references to the old regions.    */
specifier|public
name|void
name|markRegionAsMerged
parameter_list|(
specifier|final
name|RegionInfo
name|child
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|RegionInfo
name|mother
parameter_list|,
specifier|final
name|RegionInfo
name|father
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|RegionStateNode
name|node
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|node
operator|.
name|setState
argument_list|(
name|State
operator|.
name|MERGED
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|deleteRegion
argument_list|(
name|mother
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|deleteRegion
argument_list|(
name|father
argument_list|)
expr_stmt|;
name|regionStateStore
operator|.
name|mergeRegions
argument_list|(
name|child
argument_list|,
name|mother
argument_list|,
name|father
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldAssignFavoredNodes
argument_list|(
name|child
argument_list|)
condition|)
block|{
operator|(
operator|(
name|FavoredNodesPromoter
operator|)
name|getBalancer
argument_list|()
operator|)
operator|.
name|generateFavoredNodesForMergedRegion
argument_list|(
name|child
argument_list|,
name|mother
argument_list|,
name|father
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Favored nodes should be applied only when FavoredNodes balancer is configured and the region    * belongs to a non-system table.    */
specifier|private
name|boolean
name|shouldAssignFavoredNodes
parameter_list|(
name|RegionInfo
name|region
parameter_list|)
block|{
return|return
name|this
operator|.
name|shouldAssignRegionsWithFavoredNodes
operator|&&
name|FavoredNodesManager
operator|.
name|isFavoredNodeApplicable
argument_list|(
name|region
argument_list|)
return|;
block|}
comment|// ============================================================================================
comment|//  Assign Queue (Assign/Balance)
comment|// ============================================================================================
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|RegionStateNode
argument_list|>
name|pendingAssignQueue
init|=
operator|new
name|ArrayList
argument_list|<
name|RegionStateNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ReentrantLock
name|assignQueueLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Condition
name|assignQueueFullCond
init|=
name|assignQueueLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
comment|/**    * Add the assign operation to the assignment queue.    * The pending assignment operation will be processed,    * and each region will be assigned by a server using the balancer.    */
specifier|protected
name|void
name|queueAssign
parameter_list|(
specifier|final
name|RegionStateNode
name|regionNode
parameter_list|)
block|{
name|regionNode
operator|.
name|getProcedureEvent
argument_list|()
operator|.
name|suspend
argument_list|()
expr_stmt|;
comment|// TODO: quick-start for meta and the other sys-tables?
name|assignQueueLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|pendingAssignQueue
operator|.
name|add
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionNode
operator|.
name|isSystemTable
argument_list|()
operator|||
name|pendingAssignQueue
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|||
name|pendingAssignQueue
operator|.
name|size
argument_list|()
operator|>=
name|assignDispatchWaitQueueMaxSize
condition|)
block|{
name|assignQueueFullCond
operator|.
name|signal
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|assignQueueLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|startAssignmentThread
parameter_list|()
block|{
name|assignThread
operator|=
operator|new
name|Thread
argument_list|(
literal|"AssignmentThread"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|isRunning
argument_list|()
condition|)
block|{
name|processAssignQueue
argument_list|()
expr_stmt|;
block|}
name|pendingAssignQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
expr_stmt|;
name|assignThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|stopAssignmentThread
parameter_list|()
block|{
name|assignQueueSignal
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
name|assignThread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|assignQueueSignal
argument_list|()
expr_stmt|;
name|assignThread
operator|.
name|join
argument_list|(
literal|250
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"join interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|assignQueueSignal
parameter_list|()
block|{
name|assignQueueLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|assignQueueFullCond
operator|.
name|signal
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|assignQueueLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
literal|"WA_AWAIT_NOT_IN_LOOP"
argument_list|)
specifier|private
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
name|waitOnAssignQueue
parameter_list|()
block|{
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
name|regions
init|=
literal|null
decl_stmt|;
name|assignQueueLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|pendingAssignQueue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|isRunning
argument_list|()
condition|)
block|{
name|assignQueueFullCond
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
return|return
literal|null
return|;
name|assignQueueFullCond
operator|.
name|await
argument_list|(
name|assignDispatchWaitMillis
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|regions
operator|=
operator|new
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
argument_list|(
name|pendingAssignQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|RegionStateNode
name|regionNode
range|:
name|pendingAssignQueue
control|)
block|{
name|regions
operator|.
name|put
argument_list|(
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
block|}
name|pendingAssignQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"got interrupted "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|assignQueueLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|regions
return|;
block|}
specifier|private
name|void
name|processAssignQueue
parameter_list|()
block|{
specifier|final
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
name|regions
init|=
name|waitOnAssignQueue
argument_list|()
decl_stmt|;
if|if
condition|(
name|regions
operator|==
literal|null
operator|||
name|regions
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
operator|!
name|isRunning
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"PROCESS ASSIGN QUEUE regionCount="
operator|+
name|regions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// TODO: Optimize balancer. pass a RegionPlan?
specifier|final
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
name|retainMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|userRRList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// regions for system tables requiring reassignment
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|sysRRList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RegionStateNode
name|regionNode
range|:
name|regions
operator|.
name|values
argument_list|()
control|)
block|{
name|boolean
name|sysTable
init|=
name|regionNode
operator|.
name|isSystemTable
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|rrList
init|=
name|sysTable
condition|?
name|sysRRList
else|:
name|userRRList
decl_stmt|;
if|if
condition|(
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|retainMap
operator|.
name|put
argument_list|(
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rrList
operator|.
name|add
argument_list|(
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: connect with the listener to invalidate the cache
comment|// TODO use events
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
init|=
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|createDestinationServersList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|servers
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"no server available, unable to find a location for "
operator|+
name|regions
operator|.
name|size
argument_list|()
operator|+
literal|" unassigned regions. waiting"
argument_list|)
expr_stmt|;
block|}
comment|// the was AM killed
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"aborting assignment-queue with "
operator|+
name|regions
operator|.
name|size
argument_list|()
operator|+
literal|" not assigned"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Threads
operator|.
name|sleep
argument_list|(
literal|250
argument_list|)
expr_stmt|;
name|servers
operator|=
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|createDestinationServersList
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sysRRList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// system table regions requiring reassignment are present, get region servers
comment|// not available for system table regions
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|excludeServers
init|=
name|getExcludedServersForSystemTable
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|serversForSysTables
init|=
name|servers
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|s
lambda|->
operator|!
name|excludeServers
operator|.
name|contains
argument_list|(
name|s
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|serversForSysTables
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No servers available for system table regions, considering all servers!"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing assignment plans for System tables sysServersCount="
operator|+
name|serversForSysTables
operator|.
name|size
argument_list|()
operator|+
literal|", allServersCount="
operator|+
name|servers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|processAssignmentPlans
argument_list|(
name|regions
argument_list|,
literal|null
argument_list|,
name|sysRRList
argument_list|,
name|serversForSysTables
operator|.
name|isEmpty
argument_list|()
condition|?
name|servers
else|:
name|serversForSysTables
argument_list|)
expr_stmt|;
block|}
name|processAssignmentPlans
argument_list|(
name|regions
argument_list|,
name|retainMap
argument_list|,
name|userRRList
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|processAssignmentPlans
parameter_list|(
specifier|final
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
name|regions
parameter_list|,
specifier|final
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
name|retainMap
parameter_list|,
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|rrList
parameter_list|,
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|)
block|{
name|boolean
name|isTraceEnabled
init|=
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
decl_stmt|;
if|if
condition|(
name|isTraceEnabled
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"available servers count="
operator|+
name|servers
operator|.
name|size
argument_list|()
operator|+
literal|": "
operator|+
name|servers
argument_list|)
expr_stmt|;
block|}
specifier|final
name|LoadBalancer
name|balancer
init|=
name|getBalancer
argument_list|()
decl_stmt|;
comment|// ask the balancer where to place regions
if|if
condition|(
name|retainMap
operator|!=
literal|null
operator|&&
operator|!
name|retainMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|isTraceEnabled
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"retain assign regions="
operator|+
name|retainMap
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|acceptPlan
argument_list|(
name|regions
argument_list|,
name|balancer
operator|.
name|retainAssignment
argument_list|(
name|retainMap
argument_list|,
name|servers
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"unable to retain assignment"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|addToPendingAssignment
argument_list|(
name|regions
argument_list|,
name|retainMap
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: Do we need to split retain and round-robin?
comment|// the retain seems to fallback to round-robin/random if the region is not in the map.
if|if
condition|(
operator|!
name|rrList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|rrList
argument_list|,
name|RegionInfo
operator|.
name|COMPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|isTraceEnabled
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"round robin regions="
operator|+
name|rrList
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|acceptPlan
argument_list|(
name|regions
argument_list|,
name|balancer
operator|.
name|roundRobinAssignment
argument_list|(
name|rrList
argument_list|,
name|servers
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"unable to round-robin assignment"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|addToPendingAssignment
argument_list|(
name|regions
argument_list|,
name|rrList
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|acceptPlan
parameter_list|(
specifier|final
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
name|regions
parameter_list|,
specifier|final
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|plan
parameter_list|)
throws|throws
name|HBaseIOException
block|{
specifier|final
name|ProcedureEvent
index|[]
name|events
init|=
operator|new
name|ProcedureEvent
index|[
name|regions
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|final
name|long
name|st
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
literal|"unable to compute plans for regions="
operator|+
name|regions
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|plan
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|int
name|evcount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|entry
range|:
name|plan
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|ServerName
name|server
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
for|for
control|(
name|RegionInfo
name|hri
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
specifier|final
name|RegionStateNode
name|regionNode
init|=
name|regions
operator|.
name|get
argument_list|(
name|hri
argument_list|)
decl_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|events
index|[
name|evcount
operator|++
index|]
operator|=
name|regionNode
operator|.
name|getProcedureEvent
argument_list|()
expr_stmt|;
block|}
block|}
name|ProcedureEvent
operator|.
name|wakeEvents
argument_list|(
name|getProcedureScheduler
argument_list|()
argument_list|,
name|events
argument_list|)
expr_stmt|;
specifier|final
name|long
name|et
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"ASSIGN ACCEPT "
operator|+
name|events
operator|.
name|length
operator|+
literal|" -> "
operator|+
name|StringUtils
operator|.
name|humanTimeDiff
argument_list|(
name|et
operator|-
name|st
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addToPendingAssignment
parameter_list|(
specifier|final
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
name|regions
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|RegionInfo
argument_list|>
name|pendingRegions
parameter_list|)
block|{
name|assignQueueLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|RegionInfo
name|hri
range|:
name|pendingRegions
control|)
block|{
name|pendingAssignQueue
operator|.
name|add
argument_list|(
name|regions
operator|.
name|get
argument_list|(
name|hri
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|assignQueueLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a list of servers that this region can not assign to.    * For system table, we must assign them to a server with highest version.    */
specifier|public
name|List
argument_list|<
name|ServerName
argument_list|>
name|getExcludedServersForSystemTable
parameter_list|()
block|{
name|List
argument_list|<
name|Pair
argument_list|<
name|ServerName
argument_list|,
name|String
argument_list|>
argument_list|>
name|serverList
init|=
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|getOnlineServersList
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
parameter_list|(
name|s
parameter_list|)
lambda|->
operator|new
name|Pair
argument_list|<>
argument_list|(
name|s
argument_list|,
name|master
operator|.
name|getRegionServerVersion
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|()
return|;
block|}
name|String
name|highestVersion
init|=
name|Collections
operator|.
name|max
argument_list|(
name|serverList
argument_list|,
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
name|VersionInfo
operator|.
name|compareVersion
argument_list|(
name|o1
operator|.
name|getSecond
argument_list|()
argument_list|,
name|o2
operator|.
name|getSecond
argument_list|()
argument_list|)
argument_list|)
operator|.
name|getSecond
argument_list|()
decl_stmt|;
return|return
name|serverList
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
parameter_list|(
name|p
parameter_list|)
lambda|->
operator|!
name|p
operator|.
name|getSecond
argument_list|()
operator|.
name|equals
argument_list|(
name|highestVersion
argument_list|)
argument_list|)
operator|.
name|map
argument_list|(
name|Pair
operator|::
name|getFirst
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
return|;
block|}
comment|// ============================================================================================
comment|//  Server Helpers
comment|// ============================================================================================
annotation|@
name|Override
specifier|public
name|void
name|serverAdded
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{   }
annotation|@
name|Override
specifier|public
name|void
name|serverRemoved
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
specifier|final
name|ServerStateNode
name|serverNode
init|=
name|regionStates
operator|.
name|getServerNode
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverNode
operator|==
literal|null
condition|)
return|return;
comment|// just in case, wake procedures waiting for this server report
name|wakeServerReportEvent
argument_list|(
name|serverNode
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|getServerVersion
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
specifier|final
name|ServerStateNode
name|node
init|=
name|regionStates
operator|.
name|getServerNode
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
return|return
name|node
operator|!=
literal|null
condition|?
name|node
operator|.
name|getVersionNumber
argument_list|()
else|:
literal|0
return|;
block|}
specifier|public
name|void
name|killRegionServer
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
specifier|final
name|ServerStateNode
name|serverNode
init|=
name|regionStates
operator|.
name|getServerNode
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
name|killRegionServer
argument_list|(
name|serverNode
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|killRegionServer
parameter_list|(
specifier|final
name|ServerStateNode
name|serverNode
parameter_list|)
block|{
comment|/** Don't do this. Messes up accounting. Let ServerCrashProcedure do this.     for (RegionStateNode regionNode: serverNode.getRegions()) {       regionNode.offline();     }*/
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|expireServer
argument_list|(
name|serverNode
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Handle RIT of meta region against crashed server.    * Only used when ServerCrashProcedure is not enabled.    * See handleRIT in ServerCrashProcedure for similar function.    *    * @param serverName Server that has already crashed    */
specifier|public
name|void
name|handleMetaRITOnCrashedServer
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
name|RegionInfo
name|hri
init|=
name|RegionReplicaUtil
operator|.
name|getRegionInfoForReplica
argument_list|(
name|RegionInfoBuilder
operator|.
name|FIRST_META_REGIONINFO
argument_list|,
name|RegionInfo
operator|.
name|DEFAULT_REPLICA_ID
argument_list|)
decl_stmt|;
name|RegionState
name|regionStateNode
init|=
name|getRegionStates
argument_list|()
operator|.
name|getRegionState
argument_list|(
name|hri
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|regionStateNode
operator|.
name|getServerName
argument_list|()
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// meta has been assigned to crashed server.
name|LOG
operator|.
name|info
argument_list|(
literal|"Meta assigned to crashed "
operator|+
name|serverName
operator|+
literal|"; reassigning..."
argument_list|)
expr_stmt|;
comment|// Handle failure and wake event
name|RegionTransitionProcedure
name|rtp
init|=
name|getRegionStates
argument_list|()
operator|.
name|getRegionTransitionProcedure
argument_list|(
name|hri
argument_list|)
decl_stmt|;
comment|// Do not need to consider for REGION_TRANSITION_QUEUE step
if|if
condition|(
name|rtp
operator|!=
literal|null
operator|&&
name|rtp
operator|.
name|isMeta
argument_list|()
operator|&&
name|rtp
operator|.
name|getTransitionState
argument_list|()
operator|==
name|RegionTransitionState
operator|.
name|REGION_TRANSITION_DISPATCH
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failing "
operator|+
name|rtp
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|rtp
operator|.
name|remoteCallFailed
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|serverName
argument_list|,
operator|new
name|ServerCrashException
argument_list|(
name|rtp
operator|.
name|getProcId
argument_list|()
argument_list|,
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

