begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|PleaseHoldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|DoNotRetryRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfoBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|UnexpectedStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesPromoter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|LoadBalancer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterServices
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MetricsAssignmentManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|ServerManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|TableStateManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|FavoredStochasticBalancer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureEnv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ProcedureSyncWait
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ServerCrashProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|Procedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureInMemoryChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|SequenceId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HasThread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MetaTableLocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionStateTransition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionStateTransition
operator|.
name|TransitionCode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|ReportRegionStateTransitionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|ReportRegionStateTransitionResponse
import|;
end_import

begin_comment
comment|/**  * The AssignmentManager is the coordinator for region assign/unassign operations.  *<ul>  *<li>In-memory states of regions and servers are stored in {@link RegionStates}.</li>  *<li>hbase:meta state updates are handled by {@link RegionStateStore}.</li>  *</ul>  * Regions are created by CreateTable, Split, Merge.  * Regions are deleted by DeleteTable, Split, Merge.  * Assigns are triggered by CreateTable, EnableTable, Split, Merge, ServerCrash.  * Unassigns are triggered by DisableTable, Split, Merge  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|AssignmentManager
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AssignmentManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// TODO: AMv2
comment|//  - handle region migration from hbase1 to hbase2.
comment|//  - handle sys table assignment first (e.g. acl, namespace)
comment|//  - handle table priorities
comment|//  - If ServerBusyException trying to update hbase:meta, we abort the Master
comment|//   See updateRegionLocation in RegionStateStore.
comment|//
comment|// See also
comment|// https://docs.google.com/document/d/1eVKa7FHdeoJ1-9o8yZcOTAQbv0u0bblBlCCzVSIn69g/edit#heading=h.ystjyrkbtoq5
comment|// for other TODOs.
specifier|public
specifier|static
specifier|final
name|String
name|BOOTSTRAP_THREAD_POOL_SIZE_CONF_KEY
init|=
literal|"hbase.assignment.bootstrap.thread.pool.size"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASSIGN_DISPATCH_WAIT_MSEC_CONF_KEY
init|=
literal|"hbase.assignment.dispatch.wait.msec"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_ASSIGN_DISPATCH_WAIT_MSEC
init|=
literal|150
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASSIGN_DISPATCH_WAITQ_MAX_CONF_KEY
init|=
literal|"hbase.assignment.dispatch.wait.queue.max.size"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_ASSIGN_DISPATCH_WAITQ_MAX
init|=
literal|100
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|RIT_CHORE_INTERVAL_MSEC_CONF_KEY
init|=
literal|"hbase.assignment.rit.chore.interval.msec"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_RIT_CHORE_INTERVAL_MSEC
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEAD_REGION_METRIC_CHORE_INTERVAL_MSEC_CONF_KEY
init|=
literal|"hbase.assignment.dead.region.metric.chore.interval.msec"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_DEAD_REGION_METRIC_CHORE_INTERVAL_MSEC
init|=
literal|120
operator|*
literal|1000
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASSIGN_MAX_ATTEMPTS
init|=
literal|"hbase.assignment.maximum.attempts"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_ASSIGN_MAX_ATTEMPTS
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASSIGN_RETRY_IMMEDIATELY_MAX_ATTEMPTS
init|=
literal|"hbase.assignment.retry.immediately.maximum.attempts"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_ASSIGN_RETRY_IMMEDIATELY_MAX_ATTEMPTS
init|=
literal|3
decl_stmt|;
comment|/** Region in Transition metrics threshold time */
specifier|public
specifier|static
specifier|final
name|String
name|METRICS_RIT_STUCK_WARNING_THRESHOLD
init|=
literal|"hbase.metrics.rit.stuck.warning.threshold"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_RIT_STUCK_WARNING_THRESHOLD
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
specifier|private
specifier|final
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|metaAssignEvent
init|=
operator|new
name|ProcedureEvent
argument_list|<>
argument_list|(
literal|"meta assign"
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|metaLoadEvent
init|=
operator|new
name|ProcedureEvent
argument_list|<>
argument_list|(
literal|"meta load"
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|MetricsAssignmentManager
name|metrics
decl_stmt|;
specifier|private
specifier|final
name|RegionInTransitionChore
name|ritChore
decl_stmt|;
specifier|private
specifier|final
name|DeadServerMetricRegionChore
name|deadMetricChore
decl_stmt|;
specifier|private
specifier|final
name|MasterServices
name|master
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|running
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|RegionStates
name|regionStates
init|=
operator|new
name|RegionStates
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|RegionStateStore
name|regionStateStore
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|shouldAssignRegionsWithFavoredNodes
decl_stmt|;
specifier|private
specifier|final
name|int
name|assignDispatchWaitQueueMaxSize
decl_stmt|;
specifier|private
specifier|final
name|int
name|assignDispatchWaitMillis
decl_stmt|;
specifier|private
specifier|final
name|int
name|assignMaxAttempts
decl_stmt|;
specifier|private
specifier|final
name|int
name|assignRetryImmediatelyMaxAttempts
decl_stmt|;
specifier|private
specifier|final
name|Object
name|checkIfShouldMoveSystemRegionLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|Thread
name|assignThread
decl_stmt|;
specifier|public
name|AssignmentManager
parameter_list|(
specifier|final
name|MasterServices
name|master
parameter_list|)
block|{
name|this
argument_list|(
name|master
argument_list|,
operator|new
name|RegionStateStore
argument_list|(
name|master
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
name|AssignmentManager
parameter_list|(
specifier|final
name|MasterServices
name|master
parameter_list|,
specifier|final
name|RegionStateStore
name|stateStore
parameter_list|)
block|{
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|this
operator|.
name|regionStateStore
operator|=
name|stateStore
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
operator|new
name|MetricsAssignmentManager
argument_list|()
expr_stmt|;
specifier|final
name|Configuration
name|conf
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
comment|// Only read favored nodes if using the favored nodes load balancer.
name|this
operator|.
name|shouldAssignRegionsWithFavoredNodes
operator|=
name|FavoredStochasticBalancer
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|HConstants
operator|.
name|HBASE_MASTER_LOADBALANCER_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignDispatchWaitMillis
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|ASSIGN_DISPATCH_WAIT_MSEC_CONF_KEY
argument_list|,
name|DEFAULT_ASSIGN_DISPATCH_WAIT_MSEC
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignDispatchWaitQueueMaxSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|ASSIGN_DISPATCH_WAITQ_MAX_CONF_KEY
argument_list|,
name|DEFAULT_ASSIGN_DISPATCH_WAITQ_MAX
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignMaxAttempts
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|ASSIGN_MAX_ATTEMPTS
argument_list|,
name|DEFAULT_ASSIGN_MAX_ATTEMPTS
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignRetryImmediatelyMaxAttempts
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|ASSIGN_RETRY_IMMEDIATELY_MAX_ATTEMPTS
argument_list|,
name|DEFAULT_ASSIGN_RETRY_IMMEDIATELY_MAX_ATTEMPTS
argument_list|)
expr_stmt|;
name|int
name|ritChoreInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|RIT_CHORE_INTERVAL_MSEC_CONF_KEY
argument_list|,
name|DEFAULT_RIT_CHORE_INTERVAL_MSEC
argument_list|)
decl_stmt|;
name|this
operator|.
name|ritChore
operator|=
operator|new
name|RegionInTransitionChore
argument_list|(
name|ritChoreInterval
argument_list|)
expr_stmt|;
name|int
name|deadRegionChoreInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DEAD_REGION_METRIC_CHORE_INTERVAL_MSEC_CONF_KEY
argument_list|,
name|DEFAULT_DEAD_REGION_METRIC_CHORE_INTERVAL_MSEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|deadRegionChoreInterval
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|deadMetricChore
operator|=
operator|new
name|DeadServerMetricRegionChore
argument_list|(
name|deadRegionChoreInterval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|deadMetricChore
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
if|if
condition|(
operator|!
name|running
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Starting assignment manager"
argument_list|)
expr_stmt|;
comment|// Start the Assignment Thread
name|startAssignmentThread
argument_list|()
expr_stmt|;
comment|// load meta region state
name|ZKWatcher
name|zkw
init|=
name|master
operator|.
name|getZooKeeper
argument_list|()
decl_stmt|;
comment|// it could be null in some tests
if|if
condition|(
name|zkw
operator|!=
literal|null
condition|)
block|{
name|RegionState
name|regionState
init|=
name|MetaTableLocator
operator|.
name|getMetaRegionState
argument_list|(
name|zkw
argument_list|)
decl_stmt|;
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|RegionInfoBuilder
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
decl_stmt|;
name|regionNode
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setState
argument_list|(
name|regionState
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionNode
operator|.
name|getProcedure
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|regionNode
operator|.
name|getProcedure
argument_list|()
operator|.
name|stateLoaded
argument_list|(
name|this
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
block|}
name|setMetaAssigned
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|,
name|regionState
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|OPEN
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|regionNode
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Create RegionStateNode based on the TRSP list, and attach the TRSP to the RegionStateNode.    *<p>    * This is used to restore the RIT region list, so we do not need to restore it in the loadingMeta    * method below. And it is also very important as now before submitting a TRSP, we need to attach    * it to the RegionStateNode, which acts like a guard, so we need to restore this information at    * the very beginning, before we start processing any procedures.    */
specifier|public
name|void
name|setupRIT
parameter_list|(
name|List
argument_list|<
name|TransitRegionStateProcedure
argument_list|>
name|procs
parameter_list|)
block|{
name|procs
operator|.
name|forEach
argument_list|(
name|proc
lambda|->
block|{
name|RegionInfo
name|regionInfo
init|=
name|proc
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
name|TransitRegionStateProcedure
name|existingProc
init|=
name|regionNode
operator|.
name|getProcedure
argument_list|()
decl_stmt|;
if|if
condition|(
name|existingProc
operator|!=
literal|null
condition|)
block|{
comment|// This is possible, as we will detach the procedure from the RSN before we
comment|// actually finish the procedure. This is because that, we will detach the TRSP from the RSN
comment|// during execution, at that time, the procedure has not been marked as done in the pv2
comment|// framework yet, so it is possible that we schedule a new TRSP immediately and when
comment|// arriving here, we will find out that there are multiple TRSPs for the region. But we can
comment|// make sure that, only the last one can take the charge, the previous ones should have all
comment|// been finished already. So here we will compare the proc id, the greater one will win.
if|if
condition|(
name|existingProc
operator|.
name|getProcId
argument_list|()
operator|<
name|proc
operator|.
name|getProcId
argument_list|()
condition|)
block|{
comment|// the new one wins, unset and set it to the new one below
name|regionNode
operator|.
name|unsetProcedure
argument_list|(
name|existingProc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the old one wins, skip
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Attach {} to {} to restore RIT"
argument_list|,
name|proc
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setProcedure
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|stop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|running
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping assignment manager"
argument_list|)
expr_stmt|;
comment|// The AM is started before the procedure executor,
comment|// but the actual work will be loaded/submitted only once we have the executor
specifier|final
name|boolean
name|hasProcExecutor
init|=
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|!=
literal|null
decl_stmt|;
comment|// Remove the RIT chore
if|if
condition|(
name|hasProcExecutor
condition|)
block|{
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|removeChore
argument_list|(
name|this
operator|.
name|ritChore
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|deadMetricChore
operator|!=
literal|null
condition|)
block|{
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|removeChore
argument_list|(
name|this
operator|.
name|deadMetricChore
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Stop the Assignment Thread
name|stopAssignmentThread
argument_list|()
expr_stmt|;
comment|// Stop the RegionStateStore
name|regionStates
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Update meta events (for testing)
if|if
condition|(
name|hasProcExecutor
condition|)
block|{
name|metaLoadEvent
operator|.
name|suspend
argument_list|()
expr_stmt|;
for|for
control|(
name|RegionInfo
name|hri
range|:
name|getMetaRegionSet
argument_list|()
control|)
block|{
name|setMetaAssigned
argument_list|(
name|hri
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|running
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|master
operator|.
name|getConfiguration
argument_list|()
return|;
block|}
specifier|public
name|MetricsAssignmentManager
name|getAssignmentManagerMetrics
parameter_list|()
block|{
return|return
name|metrics
return|;
block|}
specifier|private
name|LoadBalancer
name|getBalancer
parameter_list|()
block|{
return|return
name|master
operator|.
name|getLoadBalancer
argument_list|()
return|;
block|}
specifier|private
name|MasterProcedureEnv
name|getProcedureEnvironment
parameter_list|()
block|{
return|return
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|getEnvironment
argument_list|()
return|;
block|}
specifier|private
name|MasterProcedureScheduler
name|getProcedureScheduler
parameter_list|()
block|{
return|return
name|getProcedureEnvironment
argument_list|()
operator|.
name|getProcedureScheduler
argument_list|()
return|;
block|}
name|int
name|getAssignMaxAttempts
parameter_list|()
block|{
return|return
name|assignMaxAttempts
return|;
block|}
name|int
name|getAssignRetryImmediatelyMaxAttempts
parameter_list|()
block|{
return|return
name|assignRetryImmediatelyMaxAttempts
return|;
block|}
specifier|public
name|RegionStates
name|getRegionStates
parameter_list|()
block|{
return|return
name|regionStates
return|;
block|}
comment|/**    * Returns the regions hosted by the specified server.    *<p/>    * Notice that, for SCP, after we submit the SCP, no one can change the region list for the    * ServerStateNode so we do not need any locks here. And for other usage, this can only give you a    * snapshot of the current region list for this server, which means, right after you get the    * region list, new regions may be moved to this server or some regions may be moved out from this    * server, so you should not use it critically if you need strong consistency.    */
specifier|public
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|getRegionsOnServer
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
name|ServerStateNode
name|serverInfo
init|=
name|regionStates
operator|.
name|getServerNode
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverInfo
operator|==
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
return|return
name|serverInfo
operator|.
name|getRegionInfoList
argument_list|()
return|;
block|}
specifier|public
name|RegionStateStore
name|getRegionStateStore
parameter_list|()
block|{
return|return
name|regionStateStore
return|;
block|}
specifier|public
name|List
argument_list|<
name|ServerName
argument_list|>
name|getFavoredNodes
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
return|return
name|this
operator|.
name|shouldAssignRegionsWithFavoredNodes
condition|?
operator|(
operator|(
name|FavoredStochasticBalancer
operator|)
name|getBalancer
argument_list|()
operator|)
operator|.
name|getFavoredNodes
argument_list|(
name|regionInfo
argument_list|)
else|:
name|ServerName
operator|.
name|EMPTY_SERVER_LIST
return|;
block|}
comment|// ============================================================================================
comment|//  Table State Manager helpers
comment|// ============================================================================================
name|TableStateManager
name|getTableStateManager
parameter_list|()
block|{
return|return
name|master
operator|.
name|getTableStateManager
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|tableName
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|ENABLED
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|tableName
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
return|;
block|}
comment|// ============================================================================================
comment|//  META Helpers
comment|// ============================================================================================
specifier|private
name|boolean
name|isMetaRegion
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
return|return
name|regionInfo
operator|.
name|isMetaRegion
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isMetaRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
return|return
name|getMetaRegionFromName
argument_list|(
name|regionName
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|public
name|RegionInfo
name|getMetaRegionFromName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
for|for
control|(
name|RegionInfo
name|hri
range|:
name|getMetaRegionSet
argument_list|()
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|regionName
argument_list|)
condition|)
block|{
return|return
name|hri
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|boolean
name|isCarryingMeta
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
comment|// TODO: handle multiple meta
return|return
name|isCarryingRegion
argument_list|(
name|serverName
argument_list|,
name|RegionInfoBuilder
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isCarryingRegion
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
comment|// TODO: check for state?
specifier|final
name|RegionStateNode
name|node
init|=
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
return|return
operator|(
name|node
operator|!=
literal|null
operator|&&
name|serverName
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getRegionLocation
argument_list|()
argument_list|)
operator|)
return|;
block|}
specifier|private
name|RegionInfo
name|getMetaForRegion
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
comment|//if (regionInfo.isMetaRegion()) return regionInfo;
comment|// TODO: handle multiple meta. if the region provided is not meta lookup
comment|// which meta the region belongs to.
return|return
name|RegionInfoBuilder
operator|.
name|FIRST_META_REGIONINFO
return|;
block|}
comment|// TODO: handle multiple meta.
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|RegionInfo
argument_list|>
name|META_REGION_SET
init|=
name|Collections
operator|.
name|singleton
argument_list|(
name|RegionInfoBuilder
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
decl_stmt|;
specifier|public
name|Set
argument_list|<
name|RegionInfo
argument_list|>
name|getMetaRegionSet
parameter_list|()
block|{
return|return
name|META_REGION_SET
return|;
block|}
comment|// ============================================================================================
comment|//  META Event(s) helpers
comment|// ============================================================================================
comment|/**    * Notice that, this only means the meta region is available on a RS, but the AM may still be    * loading the region states from meta, so usually you need to check {@link #isMetaLoaded()} first    * before checking this method, unless you can make sure that your piece of code can only be    * executed after AM builds the region states.    * @see #isMetaLoaded()    */
specifier|public
name|boolean
name|isMetaAssigned
parameter_list|()
block|{
return|return
name|metaAssignEvent
operator|.
name|isReady
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isMetaRegionInTransition
parameter_list|()
block|{
return|return
operator|!
name|isMetaAssigned
argument_list|()
return|;
block|}
comment|/**    * Notice that this event does not mean the AM has already finished region state rebuilding. See    * the comment of {@link #isMetaAssigned()} for more details.    * @see #isMetaAssigned()    */
specifier|public
name|boolean
name|waitMetaAssigned
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|proc
parameter_list|,
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
return|return
name|getMetaAssignEvent
argument_list|(
name|getMetaForRegion
argument_list|(
name|regionInfo
argument_list|)
argument_list|)
operator|.
name|suspendIfNotReady
argument_list|(
name|proc
argument_list|)
return|;
block|}
specifier|private
name|void
name|setMetaAssigned
parameter_list|(
name|RegionInfo
name|metaRegionInfo
parameter_list|,
name|boolean
name|assigned
parameter_list|)
block|{
assert|assert
name|isMetaRegion
argument_list|(
name|metaRegionInfo
argument_list|)
operator|:
literal|"unexpected non-meta region "
operator|+
name|metaRegionInfo
assert|;
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|metaAssignEvent
init|=
name|getMetaAssignEvent
argument_list|(
name|metaRegionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|assigned
condition|)
block|{
name|metaAssignEvent
operator|.
name|wake
argument_list|(
name|getProcedureScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metaAssignEvent
operator|.
name|suspend
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
name|getMetaAssignEvent
parameter_list|(
name|RegionInfo
name|metaRegionInfo
parameter_list|)
block|{
assert|assert
name|isMetaRegion
argument_list|(
name|metaRegionInfo
argument_list|)
operator|:
literal|"unexpected non-meta region "
operator|+
name|metaRegionInfo
assert|;
comment|// TODO: handle multiple meta.
return|return
name|metaAssignEvent
return|;
block|}
comment|/**    * Wait until AM finishes the meta loading, i.e, the region states rebuilding.    * @see #isMetaLoaded()    * @see #waitMetaAssigned(Procedure, RegionInfo)    */
specifier|public
name|boolean
name|waitMetaLoaded
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|proc
parameter_list|)
block|{
return|return
name|metaLoadEvent
operator|.
name|suspendIfNotReady
argument_list|(
name|proc
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
name|void
name|wakeMetaLoadedEvent
parameter_list|()
block|{
name|metaLoadEvent
operator|.
name|wake
argument_list|(
name|getProcedureScheduler
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
name|isMetaLoaded
argument_list|()
operator|:
literal|"expected meta to be loaded"
assert|;
block|}
comment|/**    * Return whether AM finishes the meta loading, i.e, the region states rebuilding.    * @see #isMetaAssigned()    * @see #waitMetaLoaded(Procedure)    */
specifier|public
name|boolean
name|isMetaLoaded
parameter_list|()
block|{
return|return
name|metaLoadEvent
operator|.
name|isReady
argument_list|()
return|;
block|}
comment|/**    * Start a new thread to check if there are region servers whose versions are higher than others.    * If so, move all system table regions to RS with the highest version to keep compatibility.    * The reason is, RS in new version may not be able to access RS in old version when there are    * some incompatible changes.    *<p>This method is called when a new RegionServer is added to cluster only.</p>    */
specifier|public
name|void
name|checkIfShouldMoveSystemRegionAsync
parameter_list|()
block|{
comment|// TODO: Fix this thread. If a server is killed and a new one started, this thread thinks that
comment|// it should 'move' the system tables from the old server to the new server but
comment|// ServerCrashProcedure is on it; and it will take care of the assign without dataloss.
if|if
condition|(
name|this
operator|.
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|countOfRegionServers
argument_list|()
operator|<=
literal|1
condition|)
block|{
return|return;
block|}
comment|// This thread used to run whenever there was a change in the cluster. The ZooKeeper
comment|// childrenChanged notification came in before the nodeDeleted message and so this method
comment|// cold run before a ServerCrashProcedure could run. That meant that this thread could see
comment|// a Crashed Server before ServerCrashProcedure and it could find system regions on the
comment|// crashed server and go move them before ServerCrashProcedure had a chance; could be
comment|// dataloss too if WALs were not recovered.
operator|new
name|Thread
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
synchronized|synchronized
init|(
name|checkIfShouldMoveSystemRegionLock
init|)
block|{
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|plans
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// TODO: I don't think this code does a good job if all servers in cluster have same
comment|// version. It looks like it will schedule unnecessary moves.
for|for
control|(
name|ServerName
name|server
range|:
name|getExcludedServersForSystemTable
argument_list|()
control|)
block|{
if|if
condition|(
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|isServerDead
argument_list|(
name|server
argument_list|)
condition|)
block|{
comment|// TODO: See HBASE-18494 and HBASE-18495. Though getExcludedServersForSystemTable()
comment|// considers only online servers, the server could be queued for dead server
comment|// processing. As region assignments for crashed server is handled by
comment|// ServerCrashProcedure, do NOT handle them here. The goal is to handle this through
comment|// regular flow of LoadBalancer as a favored node and not to have this special
comment|// handling.
continue|continue;
block|}
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|regionsShouldMove
init|=
name|getSystemTables
argument_list|(
name|server
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|regionsShouldMove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|RegionInfo
name|regionInfo
range|:
name|regionsShouldMove
control|)
block|{
comment|// null value for dest forces destination server to be selected by balancer
name|RegionPlan
name|plan
init|=
operator|new
name|RegionPlan
argument_list|(
name|regionInfo
argument_list|,
name|server
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionInfo
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
comment|// Must move meta region first.
name|LOG
operator|.
name|info
argument_list|(
literal|"Async MOVE of {} to newer Server={}"
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|moveAsync
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|plans
operator|.
name|add
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|RegionPlan
name|plan
range|:
name|plans
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Async MOVE of {} to newer Server={}"
argument_list|,
name|plan
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|moveAsync
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
specifier|private
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|getSystemTables
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
name|ServerStateNode
name|serverNode
init|=
name|regionStates
operator|.
name|getServerNode
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverNode
operator|==
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
return|return
name|serverNode
operator|.
name|getSystemRegionInfoList
argument_list|()
return|;
block|}
specifier|private
name|void
name|preTransitCheck
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|,
name|RegionState
operator|.
name|State
index|[]
name|expectedStates
parameter_list|)
throws|throws
name|HBaseIOException
block|{
if|if
condition|(
name|regionNode
operator|.
name|getProcedure
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
name|regionNode
operator|+
literal|" is currently in transition"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|regionNode
operator|.
name|isInState
argument_list|(
name|expectedStates
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DoNotRetryRegionException
argument_list|(
literal|"Unexpected state for "
operator|+
name|regionNode
argument_list|)
throw|;
block|}
if|if
condition|(
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|regionNode
operator|.
name|getTable
argument_list|()
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|DISABLING
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|DISABLED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
name|regionNode
operator|.
name|getTable
argument_list|()
operator|+
literal|" is disabled for "
operator|+
name|regionNode
argument_list|)
throw|;
block|}
block|}
comment|// TODO: Need an async version of this for hbck2.
specifier|public
name|long
name|assign
parameter_list|(
name|RegionInfo
name|regionInfo
parameter_list|,
name|ServerName
name|sn
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: should we use getRegionStateNode?
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
name|TransitRegionStateProcedure
name|proc
decl_stmt|;
name|regionNode
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preTransitCheck
argument_list|(
name|regionNode
argument_list|,
name|STATES_EXPECTED_ON_ASSIGN
argument_list|)
expr_stmt|;
name|proc
operator|=
name|TransitRegionStateProcedure
operator|.
name|assign
argument_list|(
name|getProcedureEnvironment
argument_list|()
argument_list|,
name|regionInfo
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setProcedure
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|regionNode
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|ProcedureSyncWait
operator|.
name|submitAndWaitProcedure
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
argument_list|,
name|proc
argument_list|)
expr_stmt|;
return|return
name|proc
operator|.
name|getProcId
argument_list|()
return|;
block|}
specifier|public
name|long
name|assign
parameter_list|(
name|RegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|assign
argument_list|(
name|regionInfo
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
name|long
name|unassign
parameter_list|(
name|RegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
literal|"No RegionState found for "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
throw|;
block|}
name|TransitRegionStateProcedure
name|proc
decl_stmt|;
name|regionNode
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preTransitCheck
argument_list|(
name|regionNode
argument_list|,
name|STATES_EXPECTED_ON_UNASSIGN_OR_MOVE
argument_list|)
expr_stmt|;
name|proc
operator|=
name|TransitRegionStateProcedure
operator|.
name|unassign
argument_list|(
name|getProcedureEnvironment
argument_list|()
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setProcedure
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|regionNode
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|ProcedureSyncWait
operator|.
name|submitAndWaitProcedure
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
argument_list|,
name|proc
argument_list|)
expr_stmt|;
return|return
name|proc
operator|.
name|getProcId
argument_list|()
return|;
block|}
specifier|public
name|TransitRegionStateProcedure
name|createMoveRegionProcedure
parameter_list|(
name|RegionInfo
name|regionInfo
parameter_list|,
name|ServerName
name|targetServer
parameter_list|)
throws|throws
name|HBaseIOException
block|{
name|RegionStateNode
name|regionNode
init|=
name|this
operator|.
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
literal|"No RegionState found for "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
throw|;
block|}
name|TransitRegionStateProcedure
name|proc
decl_stmt|;
name|regionNode
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|preTransitCheck
argument_list|(
name|regionNode
argument_list|,
name|STATES_EXPECTED_ON_UNASSIGN_OR_MOVE
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|checkOnline
argument_list|()
expr_stmt|;
name|proc
operator|=
name|TransitRegionStateProcedure
operator|.
name|move
argument_list|(
name|getProcedureEnvironment
argument_list|()
argument_list|,
name|regionInfo
argument_list|,
name|targetServer
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setProcedure
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|regionNode
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|proc
return|;
block|}
specifier|public
name|void
name|move
parameter_list|(
name|RegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|TransitRegionStateProcedure
name|proc
init|=
name|createMoveRegionProcedure
argument_list|(
name|regionInfo
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ProcedureSyncWait
operator|.
name|submitAndWaitProcedure
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
argument_list|,
name|proc
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Future
argument_list|<
name|byte
index|[]
argument_list|>
name|moveAsync
parameter_list|(
name|RegionPlan
name|regionPlan
parameter_list|)
throws|throws
name|HBaseIOException
block|{
name|TransitRegionStateProcedure
name|proc
init|=
name|createMoveRegionProcedure
argument_list|(
name|regionPlan
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|regionPlan
operator|.
name|getDestination
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|ProcedureSyncWait
operator|.
name|submitProcedure
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
argument_list|,
name|proc
argument_list|)
return|;
block|}
comment|// ============================================================================================
comment|//  RegionTransition procedures helpers
comment|// ============================================================================================
comment|/**    * Create round-robin assigns. Use on table creation to distribute out regions across cluster.    * @return AssignProcedures made out of the passed in<code>hris</code> and a call to the balancer    *         to populate the assigns with targets chosen using round-robin (default balancer    *         scheme). If at assign-time, the target chosen is no longer up, thats fine, the    *         AssignProcedure will ask the balancer for a new target, and so on.    */
specifier|public
name|TransitRegionStateProcedure
index|[]
name|createRoundRobinAssignProcedures
parameter_list|(
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|hris
parameter_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
name|serversToExclude
parameter_list|)
block|{
if|if
condition|(
name|hris
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|new
name|TransitRegionStateProcedure
index|[
literal|0
index|]
return|;
block|}
if|if
condition|(
name|serversToExclude
operator|!=
literal|null
operator|&&
name|this
operator|.
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|getOnlineServersList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Only one region server found and hence going ahead with the assignment"
argument_list|)
expr_stmt|;
name|serversToExclude
operator|=
literal|null
expr_stmt|;
block|}
try|try
block|{
comment|// Ask the balancer to assign our regions. Pass the regions en masse. The balancer can do
comment|// a better job if it has all the assignments in the one lump.
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|assignments
init|=
name|getBalancer
argument_list|()
operator|.
name|roundRobinAssignment
argument_list|(
name|hris
argument_list|,
name|this
operator|.
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|createDestinationServersList
argument_list|(
name|serversToExclude
argument_list|)
argument_list|)
decl_stmt|;
comment|// Return mid-method!
return|return
name|createAssignProcedures
argument_list|(
name|assignments
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|hioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed roundRobinAssignment"
argument_list|,
name|hioe
argument_list|)
expr_stmt|;
block|}
comment|// If an error above, fall-through to this simpler assign. Last resort.
return|return
name|createAssignProcedures
argument_list|(
name|hris
argument_list|)
return|;
block|}
comment|/**    * Create round-robin assigns. Use on table creation to distribute out regions across cluster.    * @return AssignProcedures made out of the passed in<code>hris</code> and a call to the balancer    *         to populate the assigns with targets chosen using round-robin (default balancer    *         scheme). If at assign-time, the target chosen is no longer up, thats fine, the    *         AssignProcedure will ask the balancer for a new target, and so on.    */
specifier|public
name|TransitRegionStateProcedure
index|[]
name|createRoundRobinAssignProcedures
parameter_list|(
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|hris
parameter_list|)
block|{
return|return
name|createRoundRobinAssignProcedures
argument_list|(
name|hris
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|compare
parameter_list|(
name|TransitRegionStateProcedure
name|left
parameter_list|,
name|TransitRegionStateProcedure
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|.
name|getRegion
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
if|if
condition|(
name|right
operator|.
name|getRegion
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
return|return
name|RegionInfo
operator|.
name|COMPARATOR
operator|.
name|compare
argument_list|(
name|left
operator|.
name|getRegion
argument_list|()
argument_list|,
name|right
operator|.
name|getRegion
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|.
name|getRegion
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
return|return
operator|+
literal|1
return|;
block|}
if|if
condition|(
name|left
operator|.
name|getRegion
argument_list|()
operator|.
name|getTable
argument_list|()
operator|.
name|isSystemTable
argument_list|()
condition|)
block|{
if|if
condition|(
name|right
operator|.
name|getRegion
argument_list|()
operator|.
name|getTable
argument_list|()
operator|.
name|isSystemTable
argument_list|()
condition|)
block|{
return|return
name|RegionInfo
operator|.
name|COMPARATOR
operator|.
name|compare
argument_list|(
name|left
operator|.
name|getRegion
argument_list|()
argument_list|,
name|right
operator|.
name|getRegion
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|.
name|getRegion
argument_list|()
operator|.
name|getTable
argument_list|()
operator|.
name|isSystemTable
argument_list|()
condition|)
block|{
return|return
operator|+
literal|1
return|;
block|}
return|return
name|RegionInfo
operator|.
name|COMPARATOR
operator|.
name|compare
argument_list|(
name|left
operator|.
name|getRegion
argument_list|()
argument_list|,
name|right
operator|.
name|getRegion
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|TransitRegionStateProcedure
name|createAssignProcedure
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|,
name|ServerName
name|targetServer
parameter_list|,
name|boolean
name|override
parameter_list|)
block|{
name|TransitRegionStateProcedure
name|proc
decl_stmt|;
name|regionNode
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|override
operator|&&
name|regionNode
operator|.
name|getProcedure
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|regionNode
operator|.
name|unsetProcedure
argument_list|(
name|regionNode
operator|.
name|getProcedure
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|regionNode
operator|.
name|getProcedure
argument_list|()
operator|==
literal|null
assert|;
name|proc
operator|=
name|TransitRegionStateProcedure
operator|.
name|assign
argument_list|(
name|getProcedureEnvironment
argument_list|()
argument_list|,
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|targetServer
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setProcedure
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|regionNode
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|proc
return|;
block|}
specifier|private
name|TransitRegionStateProcedure
name|createUnassignProcedure
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|,
name|boolean
name|override
parameter_list|)
block|{
name|TransitRegionStateProcedure
name|proc
decl_stmt|;
name|regionNode
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|override
operator|&&
name|regionNode
operator|.
name|getProcedure
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|regionNode
operator|.
name|unsetProcedure
argument_list|(
name|regionNode
operator|.
name|getProcedure
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|regionNode
operator|.
name|getProcedure
argument_list|()
operator|==
literal|null
assert|;
name|proc
operator|=
name|TransitRegionStateProcedure
operator|.
name|unassign
argument_list|(
name|getProcedureEnvironment
argument_list|()
argument_list|,
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setProcedure
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|regionNode
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|proc
return|;
block|}
comment|/**    * Create one TransitRegionStateProcedure to assign a region w/o specifying a target server.    * This method is specified for HBCK2    */
specifier|public
name|TransitRegionStateProcedure
name|createOneAssignProcedure
parameter_list|(
name|RegionInfo
name|hri
parameter_list|,
name|boolean
name|override
parameter_list|)
block|{
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|hri
argument_list|)
decl_stmt|;
return|return
name|createAssignProcedure
argument_list|(
name|regionNode
argument_list|,
literal|null
argument_list|,
name|override
argument_list|)
return|;
block|}
comment|/**    * Create one TransitRegionStateProcedure to unassign a region.    * This method is specified for HBCK2    */
specifier|public
name|TransitRegionStateProcedure
name|createOneUnassignProcedure
parameter_list|(
name|RegionInfo
name|hri
parameter_list|,
name|boolean
name|override
parameter_list|)
block|{
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|hri
argument_list|)
decl_stmt|;
return|return
name|createUnassignProcedure
argument_list|(
name|regionNode
argument_list|,
name|override
argument_list|)
return|;
block|}
comment|/**    * Create an array of TransitRegionStateProcedure w/o specifying a target server.    *<p/>    * If no target server, at assign time, we will try to use the former location of the region if    * one exists. This is how we 'retain' the old location across a server restart.    *<p/>    * Should only be called when you can make sure that no one can touch these regions other than    * you. For example, when you are creating table.    */
specifier|public
name|TransitRegionStateProcedure
index|[]
name|createAssignProcedures
parameter_list|(
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|hris
parameter_list|)
block|{
return|return
name|hris
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|hri
lambda|->
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|hri
argument_list|)
argument_list|)
operator|.
name|map
argument_list|(
name|regionNode
lambda|->
name|createAssignProcedure
argument_list|(
name|regionNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|sorted
argument_list|(
name|AssignmentManager
operator|::
name|compare
argument_list|)
operator|.
name|toArray
argument_list|(
name|TransitRegionStateProcedure
index|[]
operator|::
operator|new
argument_list|)
return|;
block|}
comment|/**    * @param assignments Map of assignments from which we produce an array of AssignProcedures.    * @return Assignments made from the passed in<code>assignments</code>    */
specifier|private
name|TransitRegionStateProcedure
index|[]
name|createAssignProcedures
parameter_list|(
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|assignments
parameter_list|)
block|{
return|return
name|assignments
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|flatMap
argument_list|(
name|e
lambda|->
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|hri
lambda|->
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|hri
argument_list|)
argument_list|)
operator|.
name|map
argument_list|(
name|regionNode
lambda|->
name|createAssignProcedure
argument_list|(
name|regionNode
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
operator|.
name|sorted
argument_list|(
name|AssignmentManager
operator|::
name|compare
argument_list|)
operator|.
name|toArray
argument_list|(
name|TransitRegionStateProcedure
index|[]
operator|::
operator|new
argument_list|)
return|;
block|}
comment|/**    * Called by DisableTableProcedure to unassign all the regions for a table.    */
specifier|public
name|TransitRegionStateProcedure
index|[]
name|createUnassignProceduresForDisabling
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|regionStates
operator|.
name|getTableRegionStateNodes
argument_list|(
name|tableName
argument_list|)
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|regionNode
lambda|->
block|{
name|regionNode
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|regionStates
operator|.
name|include
argument_list|(
name|regionNode
argument_list|,
literal|false
argument_list|)
operator|||
name|regionStates
operator|.
name|isRegionOffline
argument_list|(
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// As in DisableTableProcedure, we will hold the xlock for table, so we can make sure that
comment|// this procedure has not been executed yet, as TRSP will hold the shared lock for table all
comment|// the time. So here we will unset it and when it is actually executed, it will find that
comment|// the attach procedure is not itself and quit immediately.
if|if
condition|(
name|regionNode
operator|.
name|getProcedure
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|regionNode
operator|.
name|unsetProcedure
argument_list|(
name|regionNode
operator|.
name|getProcedure
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|TransitRegionStateProcedure
name|proc
init|=
name|TransitRegionStateProcedure
operator|.
name|unassign
argument_list|(
name|getProcedureEnvironment
argument_list|()
argument_list|,
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
decl_stmt|;
name|regionNode
operator|.
name|setProcedure
argument_list|(
name|proc
argument_list|)
expr_stmt|;
return|return
name|proc
return|;
block|}
finally|finally
block|{
name|regionNode
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
operator|.
name|filter
argument_list|(
name|p
lambda|->
name|p
operator|!=
literal|null
argument_list|)
operator|.
name|toArray
argument_list|(
name|TransitRegionStateProcedure
index|[]
operator|::
operator|new
argument_list|)
return|;
block|}
specifier|public
name|SplitTableRegionProcedure
name|createSplitProcedure
parameter_list|(
specifier|final
name|RegionInfo
name|regionToSplit
parameter_list|,
specifier|final
name|byte
index|[]
name|splitKey
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|SplitTableRegionProcedure
argument_list|(
name|getProcedureEnvironment
argument_list|()
argument_list|,
name|regionToSplit
argument_list|,
name|splitKey
argument_list|)
return|;
block|}
specifier|public
name|MergeTableRegionsProcedure
name|createMergeProcedure
parameter_list|(
specifier|final
name|RegionInfo
name|regionToMergeA
parameter_list|,
specifier|final
name|RegionInfo
name|regionToMergeB
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|MergeTableRegionsProcedure
argument_list|(
name|getProcedureEnvironment
argument_list|()
argument_list|,
name|regionToMergeA
argument_list|,
name|regionToMergeB
argument_list|)
return|;
block|}
comment|/**    * Delete the region states. This is called by "DeleteTable"    */
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ArrayList
argument_list|<
name|RegionInfo
argument_list|>
name|regions
init|=
name|regionStates
operator|.
name|getTableRegionsInfo
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|regionStateStore
operator|.
name|deleteRegions
argument_list|(
name|regions
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|RegionInfo
name|regionInfo
init|=
name|regions
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// we expect the region to be offline
name|regionStates
operator|.
name|removeFromOfflineRegions
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|deleteRegion
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ============================================================================================
comment|//  RS Region Transition Report helpers
comment|// ============================================================================================
specifier|private
name|void
name|reportRegionStateTransition
parameter_list|(
name|ReportRegionStateTransitionResponse
operator|.
name|Builder
name|builder
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
name|List
argument_list|<
name|RegionStateTransition
argument_list|>
name|transitionList
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|RegionStateTransition
name|transition
range|:
name|transitionList
control|)
block|{
switch|switch
condition|(
name|transition
operator|.
name|getTransitionCode
argument_list|()
condition|)
block|{
case|case
name|OPENED
case|:
case|case
name|FAILED_OPEN
case|:
case|case
name|CLOSED
case|:
assert|assert
name|transition
operator|.
name|getRegionInfoCount
argument_list|()
operator|==
literal|1
operator|:
name|transition
assert|;
specifier|final
name|RegionInfo
name|hri
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|procId
init|=
name|transition
operator|.
name|getProcIdCount
argument_list|()
operator|>
literal|0
condition|?
name|transition
operator|.
name|getProcId
argument_list|(
literal|0
argument_list|)
else|:
name|Procedure
operator|.
name|NO_PROC_ID
decl_stmt|;
name|updateRegionTransition
argument_list|(
name|serverName
argument_list|,
name|transition
operator|.
name|getTransitionCode
argument_list|()
argument_list|,
name|hri
argument_list|,
name|transition
operator|.
name|hasOpenSeqNum
argument_list|()
condition|?
name|transition
operator|.
name|getOpenSeqNum
argument_list|()
else|:
name|HConstants
operator|.
name|NO_SEQNUM
argument_list|,
name|procId
argument_list|)
expr_stmt|;
break|break;
case|case
name|READY_TO_SPLIT
case|:
case|case
name|SPLIT
case|:
case|case
name|SPLIT_REVERTED
case|:
assert|assert
name|transition
operator|.
name|getRegionInfoCount
argument_list|()
operator|==
literal|3
operator|:
name|transition
assert|;
specifier|final
name|RegionInfo
name|parent
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RegionInfo
name|splitA
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RegionInfo
name|splitB
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|updateRegionSplitTransition
argument_list|(
name|serverName
argument_list|,
name|transition
operator|.
name|getTransitionCode
argument_list|()
argument_list|,
name|parent
argument_list|,
name|splitA
argument_list|,
name|splitB
argument_list|)
expr_stmt|;
break|break;
case|case
name|READY_TO_MERGE
case|:
case|case
name|MERGED
case|:
case|case
name|MERGE_REVERTED
case|:
assert|assert
name|transition
operator|.
name|getRegionInfoCount
argument_list|()
operator|==
literal|3
operator|:
name|transition
assert|;
specifier|final
name|RegionInfo
name|merged
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RegionInfo
name|mergeA
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RegionInfo
name|mergeB
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|updateRegionMergeTransition
argument_list|(
name|serverName
argument_list|,
name|transition
operator|.
name|getTransitionCode
argument_list|()
argument_list|,
name|merged
argument_list|,
name|mergeA
argument_list|,
name|mergeB
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
specifier|public
name|ReportRegionStateTransitionResponse
name|reportRegionStateTransition
parameter_list|(
specifier|final
name|ReportRegionStateTransitionRequest
name|req
parameter_list|)
throws|throws
name|PleaseHoldException
block|{
name|ReportRegionStateTransitionResponse
operator|.
name|Builder
name|builder
init|=
name|ReportRegionStateTransitionResponse
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ServerName
name|serverName
init|=
name|ProtobufUtil
operator|.
name|toServerName
argument_list|(
name|req
operator|.
name|getServer
argument_list|()
argument_list|)
decl_stmt|;
name|ServerStateNode
name|serverNode
init|=
name|regionStates
operator|.
name|getOrCreateServer
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
comment|// here we have to acquire a read lock instead of a simple exclusive lock. This is because that
comment|// we should not block other reportRegionStateTransition call from the same region server. This
comment|// is not only about performance, but also to prevent dead lock. Think of the meta region is
comment|// also on the same region server and you hold the lock which blocks the
comment|// reportRegionStateTransition for meta, and since meta is not online, you will block inside the
comment|// lock protection to wait for meta online...
name|serverNode
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// we only accept reportRegionStateTransition if the region server is online, see the comment
comment|// above in submitServerCrash method and HBASE-21508 for more details.
if|if
condition|(
name|serverNode
operator|.
name|isInState
argument_list|(
name|ServerState
operator|.
name|ONLINE
argument_list|)
condition|)
block|{
try|try
block|{
name|reportRegionStateTransition
argument_list|(
name|builder
argument_list|,
name|serverName
argument_list|,
name|req
operator|.
name|getTransitionList
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PleaseHoldException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Failed transition "
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
decl||
name|IOException
name|e
parameter_list|)
block|{
comment|// TODO: at the moment we have a single error message and the RS will abort
comment|// if the master says that one of the region transitions failed.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed transition"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setErrorMessage
argument_list|(
literal|"Failed transition "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The region server {} is already dead, skip reportRegionStateTransition call"
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setErrorMessage
argument_list|(
literal|"You are dead"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|serverNode
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
name|void
name|updateRegionTransition
parameter_list|(
name|ServerName
name|serverName
parameter_list|,
name|TransitionCode
name|state
parameter_list|,
name|RegionInfo
name|regionInfo
parameter_list|,
name|long
name|seqId
parameter_list|,
name|long
name|procId
parameter_list|)
throws|throws
name|IOException
block|{
name|checkMetaLoaded
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionNode
operator|==
literal|null
condition|)
block|{
comment|// the table/region is gone. maybe a delete, split, merge
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Server %s was trying to transition region %s to %s. but the region was removed."
argument_list|,
name|serverName
argument_list|,
name|regionInfo
argument_list|,
name|state
argument_list|)
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Update region transition serverName={} region={} regionState={}"
argument_list|,
name|serverName
argument_list|,
name|regionNode
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ServerStateNode
name|serverNode
init|=
name|regionStates
operator|.
name|getOrCreateServer
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
name|regionNode
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|reportTransition
argument_list|(
name|regionNode
argument_list|,
name|serverNode
argument_list|,
name|state
argument_list|,
name|seqId
argument_list|,
name|procId
argument_list|)
condition|)
block|{
comment|// Don't log WARN if shutting down cluster; during shutdown. Avoid the below messages:
comment|// 2018-08-13 10:45:10,551 WARN ...AssignmentManager: No matching procedure found for
comment|// rit=OPEN, location=ve0538.halxg.cloudera.com,16020,1533493000958,
comment|// table=IntegrationTestBigLinkedList, region=65ab289e2fc1530df65f6c3d7cde7aa5 transition
comment|// to CLOSED
comment|// These happen because on cluster shutdown, we currently let the RegionServers close
comment|// regions. This is the only time that region close is not run by the Master (so cluster
comment|// goes down fast). Consider changing it so Master runs all shutdowns.
if|if
condition|(
name|this
operator|.
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|isClusterShutdown
argument_list|()
operator|&&
name|state
operator|.
name|equals
argument_list|(
name|TransitionCode
operator|.
name|CLOSED
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"RegionServer {} {}"
argument_list|,
name|state
argument_list|,
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No matching procedure found for {} transition to {}"
argument_list|,
name|regionNode
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|regionNode
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|reportTransition
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|,
name|ServerStateNode
name|serverNode
parameter_list|,
name|TransitionCode
name|state
parameter_list|,
name|long
name|seqId
parameter_list|,
name|long
name|procId
parameter_list|)
throws|throws
name|IOException
block|{
name|ServerName
name|serverName
init|=
name|serverNode
operator|.
name|getServerName
argument_list|()
decl_stmt|;
name|TransitRegionStateProcedure
name|proc
init|=
name|regionNode
operator|.
name|getProcedure
argument_list|()
decl_stmt|;
if|if
condition|(
name|proc
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|proc
operator|.
name|reportTransition
argument_list|(
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|regionNode
argument_list|,
name|serverName
argument_list|,
name|state
argument_list|,
name|seqId
argument_list|,
name|procId
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|updateRegionSplitTransition
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|TransitionCode
name|state
parameter_list|,
specifier|final
name|RegionInfo
name|parent
parameter_list|,
specifier|final
name|RegionInfo
name|hriA
parameter_list|,
specifier|final
name|RegionInfo
name|hriB
parameter_list|)
throws|throws
name|IOException
block|{
name|checkMetaLoaded
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|TransitionCode
operator|.
name|READY_TO_SPLIT
condition|)
block|{
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
literal|"unsupported split regionState="
operator|+
name|state
operator|+
literal|" for parent region "
operator|+
name|parent
operator|+
literal|" maybe an old RS (< 2.0) had the operation in progress"
argument_list|)
throw|;
block|}
comment|// sanity check on the request
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|hriA
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|hriB
operator|.
name|getStartKey
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"unsupported split request with bad keys: parent="
operator|+
name|parent
operator|+
literal|" hriA="
operator|+
name|hriA
operator|+
literal|" hriB="
operator|+
name|hriB
argument_list|)
throw|;
block|}
comment|// Submit the Split procedure
specifier|final
name|byte
index|[]
name|splitKey
init|=
name|hriB
operator|.
name|getStartKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Split request from "
operator|+
name|serverName
operator|+
literal|", parent="
operator|+
name|parent
operator|+
literal|" splitKey="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|splitKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|submitProcedure
argument_list|(
name|createSplitProcedure
argument_list|(
name|parent
argument_list|,
name|splitKey
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the RS is< 2.0 throw an exception to abort the operation, we are handling the split
if|if
condition|(
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|getVersionNumber
argument_list|(
name|serverName
argument_list|)
operator|<
literal|0x0200000
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Split handled by the master: parent=%s hriA=%s hriB=%s"
argument_list|,
name|parent
operator|.
name|getShortNameToLog
argument_list|()
argument_list|,
name|hriA
argument_list|,
name|hriB
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|updateRegionMergeTransition
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|TransitionCode
name|state
parameter_list|,
specifier|final
name|RegionInfo
name|merged
parameter_list|,
specifier|final
name|RegionInfo
name|hriA
parameter_list|,
specifier|final
name|RegionInfo
name|hriB
parameter_list|)
throws|throws
name|IOException
block|{
name|checkMetaLoaded
argument_list|(
name|merged
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|TransitionCode
operator|.
name|READY_TO_MERGE
condition|)
block|{
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
literal|"Unsupported merge regionState="
operator|+
name|state
operator|+
literal|" for regionA="
operator|+
name|hriA
operator|+
literal|" regionB="
operator|+
name|hriB
operator|+
literal|" merged="
operator|+
name|merged
operator|+
literal|" maybe an old RS (< 2.0) had the operation in progress"
argument_list|)
throw|;
block|}
comment|// Submit the Merge procedure
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling merge request from RS="
operator|+
name|merged
operator|+
literal|", merged="
operator|+
name|merged
argument_list|)
expr_stmt|;
block|}
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|submitProcedure
argument_list|(
name|createMergeProcedure
argument_list|(
name|hriA
argument_list|,
name|hriB
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the RS is< 2.0 throw an exception to abort the operation, we are handling the merge
if|if
condition|(
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|getVersionNumber
argument_list|(
name|serverName
argument_list|)
operator|<
literal|0x0200000
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Merge not handled yet: regionState=%s merged=%s hriA=%s hriB=%s"
argument_list|,
name|state
argument_list|,
name|merged
argument_list|,
name|hriA
argument_list|,
name|hriB
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// ============================================================================================
comment|//  RS Status update (report online regions) helpers
comment|// ============================================================================================
comment|/**    * The master will call this method when the RS send the regionServerReport(). The report will    * contains the "online regions". This method will check the the online regions against the    * in-memory state of the AM, and we will log a warn message if there is a mismatch. This is    * because that there is no fencing between the reportRegionStateTransition method and    * regionServerReport method, so there could be race and introduce inconsistency here, but    * actually there is no problem.    *<p/>    * Please see HBASE-21421 and HBASE-21463 for more details.    */
specifier|public
name|void
name|reportOnlineRegions
parameter_list|(
name|ServerName
name|serverName
parameter_list|,
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|regionNames
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"ReportOnlineRegions {} regionCount={}, metaLoaded={} {}"
argument_list|,
name|serverName
argument_list|,
name|regionNames
operator|.
name|size
argument_list|()
argument_list|,
name|isMetaLoaded
argument_list|()
argument_list|,
name|regionNames
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|Bytes
operator|::
name|toStringBinary
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ServerStateNode
name|serverNode
init|=
name|regionStates
operator|.
name|getOrCreateServer
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|serverNode
init|)
block|{
if|if
condition|(
operator|!
name|serverNode
operator|.
name|isInState
argument_list|(
name|ServerState
operator|.
name|ONLINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Got a report from a server result in state "
operator|+
name|serverNode
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|regionNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// nothing to do if we don't have regions
name|LOG
operator|.
name|trace
argument_list|(
literal|"no online region found on {}"
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|isMetaLoaded
argument_list|()
condition|)
block|{
comment|// we are still on startup, skip checking
return|return;
block|}
comment|// The Heartbeat tells us of what regions are on the region serve, check the state.
name|checkOnlineRegionsReport
argument_list|(
name|serverNode
argument_list|,
name|regionNames
argument_list|)
expr_stmt|;
block|}
comment|// just check and output possible inconsistency, without actually doing anything
specifier|private
name|void
name|checkOnlineRegionsReport
parameter_list|(
name|ServerStateNode
name|serverNode
parameter_list|,
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|regionNames
parameter_list|)
block|{
name|ServerName
name|serverName
init|=
name|serverNode
operator|.
name|getServerName
argument_list|()
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|regionName
range|:
name|regionNames
control|)
block|{
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
block|{
return|return;
block|}
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getRegionStateNodeFromName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionNode
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No region state node for {}, it should already be on {}"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|regionNode
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|diff
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|regionNode
operator|.
name|getLastUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|OPENING
argument_list|,
name|State
operator|.
name|OPEN
argument_list|)
condition|)
block|{
comment|// This is possible as a region server has just closed a region but the region server
comment|// report is generated before the closing, but arrive after the closing. Make sure there
comment|// is some elapsed time so less false alarms.
if|if
condition|(
operator|!
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
operator|&&
name|diff
operator|>
literal|1000
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"{} reported OPEN on server={} but state has otherwise"
argument_list|,
name|regionNode
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|CLOSING
argument_list|,
name|State
operator|.
name|SPLITTING
argument_list|)
condition|)
block|{
comment|// So, we can get report that a region is CLOSED or SPLIT because a heartbeat
comment|// came in at about same time as a region transition. Make sure there is some
comment|// elapsed time so less false alarms.
if|if
condition|(
name|diff
operator|>
literal|1000
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"{} reported an unexpected OPEN on {}; time since last update={}ms"
argument_list|,
name|regionNode
argument_list|,
name|serverName
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|regionNode
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// ============================================================================================
comment|//  RIT chore
comment|// ============================================================================================
specifier|private
specifier|static
class|class
name|RegionInTransitionChore
extends|extends
name|ProcedureInMemoryChore
argument_list|<
name|MasterProcedureEnv
argument_list|>
block|{
specifier|public
name|RegionInTransitionChore
parameter_list|(
specifier|final
name|int
name|timeoutMsec
parameter_list|)
block|{
name|super
argument_list|(
name|timeoutMsec
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|periodicExecute
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
specifier|final
name|AssignmentManager
name|am
init|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
decl_stmt|;
specifier|final
name|RegionInTransitionStat
name|ritStat
init|=
name|am
operator|.
name|computeRegionInTransitionStat
argument_list|()
decl_stmt|;
if|if
condition|(
name|ritStat
operator|.
name|hasRegionsOverThreshold
argument_list|()
condition|)
block|{
for|for
control|(
name|RegionState
name|hri
range|:
name|ritStat
operator|.
name|getRegionOverThreshold
argument_list|()
control|)
block|{
name|am
operator|.
name|handleRegionOverStuckWarningThreshold
argument_list|(
name|hri
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update metrics
name|am
operator|.
name|updateRegionsInTransitionMetrics
argument_list|(
name|ritStat
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|DeadServerMetricRegionChore
extends|extends
name|ProcedureInMemoryChore
argument_list|<
name|MasterProcedureEnv
argument_list|>
block|{
specifier|public
name|DeadServerMetricRegionChore
parameter_list|(
specifier|final
name|int
name|timeoutMsec
parameter_list|)
block|{
name|super
argument_list|(
name|timeoutMsec
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|periodicExecute
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
specifier|final
name|ServerManager
name|sm
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getServerManager
argument_list|()
decl_stmt|;
specifier|final
name|AssignmentManager
name|am
init|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
decl_stmt|;
comment|// To minimize inconsistencies we are not going to snapshot live servers in advance in case
comment|// new servers are added; OTOH we don't want to add heavy sync for a consistent view since
comment|// this is for metrics. Instead, we're going to check each regions as we go; to avoid making
comment|// too many checks, we maintain a local lists of server, limiting us to false negatives. If
comment|// we miss some recently-dead server, we'll just see it next time.
name|Set
argument_list|<
name|ServerName
argument_list|>
name|recentlyLiveServers
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|deadRegions
init|=
literal|0
decl_stmt|,
name|unknownRegions
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RegionStateNode
name|rsn
range|:
name|am
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionStateNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|rsn
operator|.
name|getState
argument_list|()
operator|!=
name|State
operator|.
name|OPEN
condition|)
block|{
continue|continue;
comment|// Opportunistic check, should quickly skip RITs, offline tables, etc.
block|}
name|ServerName
name|sn
decl_stmt|;
name|State
name|state
decl_stmt|;
name|rsn
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|sn
operator|=
name|rsn
operator|.
name|getRegionLocation
argument_list|()
expr_stmt|;
name|state
operator|=
name|rsn
operator|.
name|getState
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|rsn
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|OPEN
condition|)
block|{
continue|continue;
comment|// Mostly skipping RITs that are already being take care of.
block|}
if|if
condition|(
name|sn
operator|==
literal|null
condition|)
block|{
operator|++
name|unknownRegions
expr_stmt|;
comment|// Opened on null?
continue|continue;
block|}
if|if
condition|(
name|recentlyLiveServers
operator|.
name|contains
argument_list|(
name|sn
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|ServerManager
operator|.
name|ServerLiveState
name|sls
init|=
name|sm
operator|.
name|isServerKnownAndOnline
argument_list|(
name|sn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sls
condition|)
block|{
case|case
name|LIVE
case|:
name|recentlyLiveServers
operator|.
name|add
argument_list|(
name|sn
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEAD
case|:
operator|++
name|deadRegions
expr_stmt|;
break|break;
case|case
name|UNKNOWN
case|:
operator|++
name|unknownRegions
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected "
operator|+
name|sls
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|deadRegions
operator|>
literal|0
operator|||
name|unknownRegions
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found {} OPEN regions on dead servers and {} OPEN regions on unknown servers"
argument_list|,
name|deadRegions
argument_list|,
name|unknownRegions
argument_list|)
expr_stmt|;
block|}
name|am
operator|.
name|updateDeadServerRegionMetrics
argument_list|(
name|deadRegions
argument_list|,
name|unknownRegions
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|RegionInTransitionStat
name|computeRegionInTransitionStat
parameter_list|()
block|{
specifier|final
name|RegionInTransitionStat
name|rit
init|=
operator|new
name|RegionInTransitionStat
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|rit
operator|.
name|update
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|rit
return|;
block|}
specifier|public
specifier|static
class|class
name|RegionInTransitionStat
block|{
specifier|private
specifier|final
name|int
name|ritThreshold
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|ritsOverThreshold
init|=
literal|null
decl_stmt|;
specifier|private
name|long
name|statTimestamp
decl_stmt|;
specifier|private
name|long
name|oldestRITTime
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|totalRITsTwiceThreshold
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|totalRITs
init|=
literal|0
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|public
name|RegionInTransitionStat
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|ritThreshold
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|METRICS_RIT_STUCK_WARNING_THRESHOLD
argument_list|,
name|DEFAULT_RIT_STUCK_WARNING_THRESHOLD
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|getRITThreshold
parameter_list|()
block|{
return|return
name|ritThreshold
return|;
block|}
specifier|public
name|long
name|getTimestamp
parameter_list|()
block|{
return|return
name|statTimestamp
return|;
block|}
specifier|public
name|int
name|getTotalRITs
parameter_list|()
block|{
return|return
name|totalRITs
return|;
block|}
specifier|public
name|long
name|getOldestRITTime
parameter_list|()
block|{
return|return
name|oldestRITTime
return|;
block|}
specifier|public
name|int
name|getTotalRITsOverThreshold
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|m
init|=
name|this
operator|.
name|ritsOverThreshold
decl_stmt|;
return|return
name|m
operator|!=
literal|null
condition|?
name|m
operator|.
name|size
argument_list|()
else|:
literal|0
return|;
block|}
specifier|public
name|boolean
name|hasRegionsTwiceOverThreshold
parameter_list|()
block|{
return|return
name|totalRITsTwiceThreshold
operator|>
literal|0
return|;
block|}
specifier|public
name|boolean
name|hasRegionsOverThreshold
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|m
init|=
name|this
operator|.
name|ritsOverThreshold
decl_stmt|;
return|return
name|m
operator|!=
literal|null
operator|&&
operator|!
name|m
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|public
name|Collection
argument_list|<
name|RegionState
argument_list|>
name|getRegionOverThreshold
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|m
init|=
name|this
operator|.
name|ritsOverThreshold
decl_stmt|;
return|return
name|m
operator|!=
literal|null
condition|?
name|m
operator|.
name|values
argument_list|()
else|:
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isRegionOverThreshold
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|m
init|=
name|this
operator|.
name|ritsOverThreshold
decl_stmt|;
return|return
name|m
operator|!=
literal|null
operator|&&
name|m
operator|.
name|containsKey
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isRegionTwiceOverThreshold
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|m
init|=
name|this
operator|.
name|ritsOverThreshold
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
return|return
literal|false
return|;
specifier|final
name|RegionState
name|state
init|=
name|m
operator|.
name|get
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
operator|(
name|statTimestamp
operator|-
name|state
operator|.
name|getStamp
argument_list|()
operator|)
operator|>
operator|(
name|ritThreshold
operator|*
literal|2
operator|)
return|;
block|}
specifier|protected
name|void
name|update
parameter_list|(
specifier|final
name|AssignmentManager
name|am
parameter_list|)
block|{
specifier|final
name|RegionStates
name|regionStates
init|=
name|am
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
name|this
operator|.
name|statTimestamp
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
expr_stmt|;
name|update
argument_list|(
name|regionStates
operator|.
name|getRegionsStateInTransition
argument_list|()
argument_list|,
name|statTimestamp
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|regionStates
operator|.
name|getRegionFailedOpen
argument_list|()
argument_list|,
name|statTimestamp
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|update
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|RegionState
argument_list|>
name|regions
parameter_list|,
specifier|final
name|long
name|currentTime
parameter_list|)
block|{
for|for
control|(
name|RegionState
name|state
range|:
name|regions
control|)
block|{
name|totalRITs
operator|++
expr_stmt|;
specifier|final
name|long
name|ritStartedMs
init|=
name|state
operator|.
name|getStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|ritStartedMs
operator|==
literal|0
condition|)
block|{
comment|// Don't output bogus values to metrics if they accidentally make it here.
name|LOG
operator|.
name|warn
argument_list|(
literal|"The RIT {} has no start time"
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|final
name|long
name|ritTime
init|=
name|currentTime
operator|-
name|ritStartedMs
decl_stmt|;
if|if
condition|(
name|ritTime
operator|>
name|ritThreshold
condition|)
block|{
if|if
condition|(
name|ritsOverThreshold
operator|==
literal|null
condition|)
block|{
name|ritsOverThreshold
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|ritsOverThreshold
operator|.
name|put
argument_list|(
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|totalRITsTwiceThreshold
operator|+=
operator|(
name|ritTime
operator|>
operator|(
name|ritThreshold
operator|*
literal|2
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|oldestRITTime
operator|<
name|ritTime
condition|)
block|{
name|oldestRITTime
operator|=
name|ritTime
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|updateRegionsInTransitionMetrics
parameter_list|(
specifier|final
name|RegionInTransitionStat
name|ritStat
parameter_list|)
block|{
name|metrics
operator|.
name|updateRITOldestAge
argument_list|(
name|ritStat
operator|.
name|getOldestRITTime
argument_list|()
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|updateRITCount
argument_list|(
name|ritStat
operator|.
name|getTotalRITs
argument_list|()
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|updateRITCountOverThreshold
argument_list|(
name|ritStat
operator|.
name|getTotalRITsOverThreshold
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|updateDeadServerRegionMetrics
parameter_list|(
name|int
name|deadRegions
parameter_list|,
name|int
name|unknownRegions
parameter_list|)
block|{
name|metrics
operator|.
name|updateDeadServerOpenRegions
argument_list|(
name|deadRegions
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|updateUnknownServerOpenRegions
argument_list|(
name|unknownRegions
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|handleRegionOverStuckWarningThreshold
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
specifier|final
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
comment|//if (regionNode.isStuck()) {
name|LOG
operator|.
name|warn
argument_list|(
literal|"STUCK Region-In-Transition {}"
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
block|}
comment|// ============================================================================================
comment|//  TODO: Master load/bootstrap
comment|// ============================================================================================
specifier|public
name|void
name|joinCluster
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Joining cluster..."
argument_list|)
expr_stmt|;
comment|// Scan hbase:meta to build list of existing regions, servers, and assignment.
comment|// hbase:meta is online now or will be. Inside loadMeta, we keep trying. Can't make progress
comment|// w/o  meta.
name|loadMeta
argument_list|()
expr_stmt|;
while|while
condition|(
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|countOfRegionServers
argument_list|()
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for RegionServers to join; current count={}"
argument_list|,
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|countOfRegionServers
argument_list|()
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|sleep
argument_list|(
literal|250
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of RegionServers={}"
argument_list|,
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|countOfRegionServers
argument_list|()
argument_list|)
expr_stmt|;
comment|// Start the chores
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|addChore
argument_list|(
name|this
operator|.
name|ritChore
argument_list|)
expr_stmt|;
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|addChore
argument_list|(
name|this
operator|.
name|deadMetricChore
argument_list|)
expr_stmt|;
name|long
name|costMs
init|=
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Joined the cluster in {}"
argument_list|,
name|StringUtils
operator|.
name|humanTimeDiff
argument_list|(
name|costMs
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create assign procedure for offline regions.    * Just follow the old processofflineServersWithOnlineRegions method. Since now we do not need to    * deal with dead server any more, we only deal with the regions in OFFLINE state in this method.    * And this is a bit strange, that for new regions, we will add it in CLOSED state instead of    * OFFLINE state, and usually there will be a procedure to track them. The    * processofflineServersWithOnlineRegions is a legacy from long ago, as things are going really    * different now, maybe we do not need this method any more. Need to revisit later.    */
comment|// Public so can be run by the Master as part of the startup. Needs hbase:meta to be online.
comment|// Needs to be done after the table state manager has been started.
specifier|public
name|void
name|processOfflineRegions
parameter_list|()
block|{
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|offlineRegions
init|=
name|regionStates
operator|.
name|getRegionStates
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|RegionState
operator|::
name|isOffline
argument_list|)
operator|.
name|filter
argument_list|(
name|s
lambda|->
name|isTableEnabled
argument_list|(
name|s
operator|.
name|getRegion
argument_list|()
operator|.
name|getTable
argument_list|()
argument_list|)
argument_list|)
operator|.
name|map
argument_list|(
name|RegionState
operator|::
name|getRegion
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|offlineRegions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
operator|.
name|submitProcedures
argument_list|(
name|master
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|createRoundRobinAssignProcedures
argument_list|(
name|offlineRegions
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|loadMeta
parameter_list|()
throws|throws
name|IOException
block|{
comment|// TODO: use a thread pool
name|regionStateStore
operator|.
name|visitMeta
argument_list|(
operator|new
name|RegionStateStore
operator|.
name|RegionStateVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|visitRegionState
parameter_list|(
name|Result
name|result
parameter_list|,
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|State
name|state
parameter_list|,
specifier|final
name|ServerName
name|regionLocation
parameter_list|,
specifier|final
name|ServerName
name|lastHost
parameter_list|,
specifier|final
name|long
name|openSeqNum
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
literal|null
operator|&&
name|regionLocation
operator|==
literal|null
operator|&&
name|lastHost
operator|==
literal|null
operator|&&
name|openSeqNum
operator|==
name|SequenceId
operator|.
name|NO_SEQUENCE_ID
condition|)
block|{
comment|// This is a row with nothing in it.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Skipping empty row={}"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|State
name|localState
init|=
name|state
decl_stmt|;
if|if
condition|(
name|localState
operator|==
literal|null
condition|)
block|{
comment|// No region state column data in hbase:meta table! Are I doing a rolling upgrade from
comment|// hbase1 to hbase2? Am I restoring a SNAPSHOT or otherwise adding a region to hbase:meta?
comment|// In any of these cases, state is empty. For now, presume OFFLINE but there are probably
comment|// cases where we need to probe more to be sure this correct; TODO informed by experience.
name|LOG
operator|.
name|info
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" regionState=null; presuming "
operator|+
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
name|localState
operator|=
name|State
operator|.
name|OFFLINE
expr_stmt|;
block|}
name|RegionStateNode
name|regionNode
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
comment|// Do not need to lock on regionNode, as we can make sure that before we finish loading
comment|// meta, all the related procedures can not be executed. The only exception is for meta
comment|// region related operations, but here we do not load the informations for meta region.
name|regionNode
operator|.
name|setState
argument_list|(
name|localState
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setLastHost
argument_list|(
name|lastHost
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
name|regionLocation
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setOpenSeqNum
argument_list|(
name|openSeqNum
argument_list|)
expr_stmt|;
comment|// Note: keep consistent with other methods, see region(Opening|Opened|Closing)
comment|//       RIT/ServerCrash handling should take care of the transiting regions.
if|if
condition|(
name|localState
operator|.
name|matches
argument_list|(
name|State
operator|.
name|OPEN
argument_list|,
name|State
operator|.
name|OPENING
argument_list|,
name|State
operator|.
name|CLOSING
argument_list|,
name|State
operator|.
name|SPLITTING
argument_list|,
name|State
operator|.
name|MERGING
argument_list|)
condition|)
block|{
assert|assert
name|regionLocation
operator|!=
literal|null
operator|:
literal|"found null region location for "
operator|+
name|regionNode
assert|;
name|regionStates
operator|.
name|addRegionToServer
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|localState
operator|==
name|State
operator|.
name|OFFLINE
operator|||
name|regionInfo
operator|.
name|isOffline
argument_list|()
condition|)
block|{
name|regionStates
operator|.
name|addToOfflineRegions
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regionNode
operator|.
name|getProcedure
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|regionNode
operator|.
name|getProcedure
argument_list|()
operator|.
name|stateLoaded
argument_list|(
name|AssignmentManager
operator|.
name|this
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
comment|// every assignment is blocked until meta is loaded.
name|wakeMetaLoadedEvent
argument_list|()
expr_stmt|;
block|}
comment|/**    * Used to check if the meta loading is done.    *<p/>    * if not we throw PleaseHoldException since we are rebuilding the RegionStates    * @param hri region to check if it is already rebuild    * @throws PleaseHoldException if meta has not been loaded yet    */
specifier|private
name|void
name|checkMetaLoaded
parameter_list|(
name|RegionInfo
name|hri
parameter_list|)
throws|throws
name|PleaseHoldException
block|{
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PleaseHoldException
argument_list|(
literal|"AssignmentManager not running"
argument_list|)
throw|;
block|}
name|boolean
name|meta
init|=
name|isMetaRegion
argument_list|(
name|hri
argument_list|)
decl_stmt|;
name|boolean
name|metaLoaded
init|=
name|isMetaLoaded
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|meta
operator|&&
operator|!
name|metaLoaded
condition|)
block|{
throw|throw
operator|new
name|PleaseHoldException
argument_list|(
literal|"Master not fully online; hbase:meta="
operator|+
name|meta
operator|+
literal|", metaLoaded="
operator|+
name|metaLoaded
argument_list|)
throw|;
block|}
block|}
comment|// ============================================================================================
comment|//  TODO: Metrics
comment|// ============================================================================================
specifier|public
name|int
name|getNumRegionsOpened
parameter_list|()
block|{
comment|// TODO: Used by TestRegionPlacement.java and assume monotonically increasing value
return|return
literal|0
return|;
block|}
specifier|public
name|long
name|submitServerCrash
parameter_list|(
name|ServerName
name|serverName
parameter_list|,
name|boolean
name|shouldSplitWal
parameter_list|)
block|{
name|boolean
name|carryingMeta
decl_stmt|;
name|long
name|pid
decl_stmt|;
name|ServerStateNode
name|serverNode
init|=
name|regionStates
operator|.
name|getServerNode
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverNode
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip to add SCP for {} since this server should be OFFLINE already"
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|// we hold the write lock here for fencing on reportRegionStateTransition. Once we set the
comment|// server state to CRASHED, we will no longer accept the reportRegionStateTransition call from
comment|// this server. This is used to simplify the implementation for TRSP and SCP, where we can make
comment|// sure that, the region list fetched by SCP will not be changed any more.
name|serverNode
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|ProcedureExecutor
argument_list|<
name|MasterProcedureEnv
argument_list|>
name|procExec
init|=
name|this
operator|.
name|master
operator|.
name|getMasterProcedureExecutor
argument_list|()
decl_stmt|;
name|carryingMeta
operator|=
name|isCarryingMeta
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|serverNode
operator|.
name|isInState
argument_list|(
name|ServerState
operator|.
name|ONLINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip to add SCP for {} with meta= {}, "
operator|+
literal|"since there should be a SCP is processing or already done for this server node"
argument_list|,
name|serverName
argument_list|,
name|carryingMeta
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|serverNode
operator|.
name|setState
argument_list|(
name|ServerState
operator|.
name|CRASHED
argument_list|)
expr_stmt|;
name|pid
operator|=
name|procExec
operator|.
name|submitProcedure
argument_list|(
operator|new
name|ServerCrashProcedure
argument_list|(
name|procExec
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|serverName
argument_list|,
name|shouldSplitWal
argument_list|,
name|carryingMeta
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added {} to dead servers which carryingMeta={}, submitted ServerCrashProcedure pid={}"
argument_list|,
name|serverName
argument_list|,
name|carryingMeta
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|serverNode
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|pid
return|;
block|}
specifier|public
name|void
name|offlineRegion
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
comment|// TODO used by MasterRpcServices
name|RegionStateNode
name|node
init|=
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|offline
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|onlineRegion
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
comment|// TODO used by TestSplitTransactionOnCluster.java
block|}
specifier|public
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|getSnapShotOfAssignment
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|RegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
return|return
name|regionStates
operator|.
name|getSnapShotOfAssignment
argument_list|(
name|regions
argument_list|)
return|;
block|}
comment|// ============================================================================================
comment|//  TODO: UTILS/HELPERS?
comment|// ============================================================================================
comment|/**    * Used by the client (via master) to identify if all regions have the schema updates    *    * @param tableName    * @return Pair indicating the status of the alter command (pending/total)    * @throws IOException    */
specifier|public
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|getReopenStatus
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
if|if
condition|(
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
condition|)
return|return
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
specifier|final
name|List
argument_list|<
name|RegionState
argument_list|>
name|states
init|=
name|regionStates
operator|.
name|getTableRegionStates
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|int
name|ritCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RegionState
name|regionState
range|:
name|states
control|)
block|{
if|if
condition|(
operator|!
name|regionState
operator|.
name|isOpened
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isSplit
argument_list|()
condition|)
block|{
name|ritCount
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|ritCount
argument_list|,
name|states
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|// ============================================================================================
comment|//  TODO: Region State In Transition
comment|// ============================================================================================
specifier|public
name|boolean
name|hasRegionsInTransition
parameter_list|()
block|{
return|return
name|regionStates
operator|.
name|hasRegionsInTransition
argument_list|()
return|;
block|}
specifier|public
name|List
argument_list|<
name|RegionStateNode
argument_list|>
name|getRegionsInTransition
parameter_list|()
block|{
return|return
name|regionStates
operator|.
name|getRegionsInTransition
argument_list|()
return|;
block|}
specifier|public
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|getAssignedRegions
parameter_list|()
block|{
return|return
name|regionStates
operator|.
name|getAssignedRegions
argument_list|()
return|;
block|}
specifier|public
name|RegionInfo
name|getRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
specifier|final
name|RegionStateNode
name|regionState
init|=
name|regionStates
operator|.
name|getRegionStateNodeFromName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
return|return
name|regionState
operator|!=
literal|null
condition|?
name|regionState
operator|.
name|getRegionInfo
argument_list|()
else|:
literal|null
return|;
block|}
comment|// ============================================================================================
comment|//  Expected states on region state transition.
comment|//  Notice that there is expected states for transiting to OPENING state, this is because SCP.
comment|//  See the comments in regionOpening method for more details.
comment|// ============================================================================================
specifier|private
specifier|static
specifier|final
name|State
index|[]
name|STATES_EXPECTED_ON_OPEN
init|=
block|{
name|State
operator|.
name|OPENING
block|,
comment|// Normal case
name|State
operator|.
name|OPEN
comment|// Retrying
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|State
index|[]
name|STATES_EXPECTED_ON_CLOSING
init|=
block|{
name|State
operator|.
name|OPEN
block|,
comment|// Normal case
name|State
operator|.
name|CLOSING
block|,
comment|// Retrying
name|State
operator|.
name|SPLITTING
block|,
comment|// Offline the split parent
name|State
operator|.
name|MERGING
comment|// Offline the merge parents
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|State
index|[]
name|STATES_EXPECTED_ON_CLOSED
init|=
block|{
name|State
operator|.
name|CLOSING
block|,
comment|// Normal case
name|State
operator|.
name|CLOSED
comment|// Retrying
block|}
decl_stmt|;
comment|// This is for manually scheduled region assign, can add other states later if we find out other
comment|// usages
specifier|private
specifier|static
specifier|final
name|State
index|[]
name|STATES_EXPECTED_ON_ASSIGN
init|=
block|{
name|State
operator|.
name|CLOSED
block|,
name|State
operator|.
name|OFFLINE
block|}
decl_stmt|;
comment|// We only allow unassign or move a region which is in OPEN state.
specifier|private
specifier|static
specifier|final
name|State
index|[]
name|STATES_EXPECTED_ON_UNASSIGN_OR_MOVE
init|=
block|{
name|State
operator|.
name|OPEN
block|}
decl_stmt|;
comment|// ============================================================================================
comment|// Region Status update
comment|// Should only be called in TransitRegionStateProcedure(and related procedures), as the locking
comment|// and pre-assumptions are very tricky.
comment|// ============================================================================================
specifier|private
name|void
name|transitStateAndUpdate
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|,
name|RegionState
operator|.
name|State
name|newState
parameter_list|,
name|RegionState
operator|.
name|State
modifier|...
name|expectedStates
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionState
operator|.
name|State
name|state
init|=
name|regionNode
operator|.
name|getState
argument_list|()
decl_stmt|;
name|regionNode
operator|.
name|transitionState
argument_list|(
name|newState
argument_list|,
name|expectedStates
argument_list|)
expr_stmt|;
name|boolean
name|succ
init|=
literal|false
decl_stmt|;
try|try
block|{
name|regionStateStore
operator|.
name|updateRegionLocation
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
name|succ
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|succ
condition|)
block|{
comment|// revert
name|regionNode
operator|.
name|setState
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// should be called within the synchronized block of RegionStateNode
name|void
name|regionOpening
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
comment|// As in SCP, for performance reason, there is no TRSP attached with this region, we will not
comment|// update the region state, which means that the region could be in any state when we want to
comment|// assign it after a RS crash. So here we do not pass the expectedStates parameter.
name|transitStateAndUpdate
argument_list|(
name|regionNode
argument_list|,
name|State
operator|.
name|OPENING
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|addRegionToServer
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
comment|// update the operation count metrics
name|metrics
operator|.
name|incrementOperationCounter
argument_list|()
expr_stmt|;
block|}
comment|// should be called under the RegionStateNode lock
comment|// The parameter 'giveUp' means whether we will try to open the region again, if it is true, then
comment|// we will persist the FAILED_OPEN state into hbase:meta.
name|void
name|regionFailedOpen
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|,
name|boolean
name|giveUp
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionState
operator|.
name|State
name|state
init|=
name|regionNode
operator|.
name|getState
argument_list|()
decl_stmt|;
name|ServerName
name|regionLocation
init|=
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|giveUp
condition|)
block|{
name|regionNode
operator|.
name|setState
argument_list|(
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|boolean
name|succ
init|=
literal|false
decl_stmt|;
try|try
block|{
name|regionStateStore
operator|.
name|updateRegionLocation
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
name|succ
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|succ
condition|)
block|{
comment|// revert
name|regionNode
operator|.
name|setState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
name|regionLocation
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|regionLocation
operator|!=
literal|null
condition|)
block|{
name|regionStates
operator|.
name|removeRegionFromServer
argument_list|(
name|regionLocation
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|// should be called under the RegionStateNode lock
name|void
name|regionClosing
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
name|transitStateAndUpdate
argument_list|(
name|regionNode
argument_list|,
name|State
operator|.
name|CLOSING
argument_list|,
name|STATES_EXPECTED_ON_CLOSING
argument_list|)
expr_stmt|;
name|RegionInfo
name|hri
init|=
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
comment|// Set meta has not initialized early. so people trying to create/edit tables will wait
if|if
condition|(
name|isMetaRegion
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|setMetaAssigned
argument_list|(
name|hri
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|regionStates
operator|.
name|addRegionToServer
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
comment|// update the operation count metrics
name|metrics
operator|.
name|incrementOperationCounter
argument_list|()
expr_stmt|;
block|}
comment|// for open and close, they will first be persist to the procedure store in
comment|// RegionRemoteProcedureBase. So here we will first change the in memory state as it is considered
comment|// as succeeded if the persistence to procedure store is succeeded, and then when the
comment|// RegionRemoteProcedureBase is woken up, we will persist the RegionStateNode to hbase:meta.
comment|// should be called under the RegionStateNode lock
name|void
name|regionOpenedWithoutPersistingToMeta
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
name|regionNode
operator|.
name|transitionState
argument_list|(
name|State
operator|.
name|OPEN
argument_list|,
name|STATES_EXPECTED_ON_OPEN
argument_list|)
expr_stmt|;
name|RegionInfo
name|regionInfo
init|=
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|regionStates
operator|.
name|addRegionToServer
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|removeFromFailedOpen
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|// should be called under the RegionStateNode lock
name|void
name|regionClosedWithoutPersistingToMeta
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
name|ServerName
name|regionLocation
init|=
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
decl_stmt|;
name|regionNode
operator|.
name|transitionState
argument_list|(
name|State
operator|.
name|CLOSED
argument_list|,
name|STATES_EXPECTED_ON_CLOSED
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionLocation
operator|!=
literal|null
condition|)
block|{
name|regionNode
operator|.
name|setLastHost
argument_list|(
name|regionLocation
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|removeRegionFromServer
argument_list|(
name|regionLocation
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|// should be called under the RegionStateNode lock
comment|// for SCP
name|void
name|regionClosedAbnormally
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionState
operator|.
name|State
name|state
init|=
name|regionNode
operator|.
name|getState
argument_list|()
decl_stmt|;
name|ServerName
name|regionLocation
init|=
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
decl_stmt|;
name|regionNode
operator|.
name|transitionState
argument_list|(
name|State
operator|.
name|ABNORMALLY_CLOSED
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|boolean
name|succ
init|=
literal|false
decl_stmt|;
try|try
block|{
name|regionStateStore
operator|.
name|updateRegionLocation
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
name|succ
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|succ
condition|)
block|{
comment|// revert
name|regionNode
operator|.
name|setState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
name|regionLocation
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|regionLocation
operator|!=
literal|null
condition|)
block|{
name|regionNode
operator|.
name|setLastHost
argument_list|(
name|regionLocation
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|removeRegionFromServer
argument_list|(
name|regionLocation
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|persistToMeta
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
name|regionStateStore
operator|.
name|updateRegionLocation
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
name|RegionInfo
name|regionInfo
init|=
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|isMetaRegion
argument_list|(
name|regionInfo
argument_list|)
operator|&&
name|regionNode
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|OPEN
condition|)
block|{
comment|// Usually we'd set a table ENABLED at this stage but hbase:meta is ALWAYs enabled, it
comment|// can't be disabled -- so skip the RPC (besides... enabled is managed by TableStateManager
comment|// which is backed by hbase:meta... Avoid setting ENABLED to avoid having to update state
comment|// on table that contains state.
name|setMetaAssigned
argument_list|(
name|regionInfo
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ============================================================================================
comment|// The above methods can only be called in TransitRegionStateProcedure(and related procedures)
comment|// ============================================================================================
specifier|public
name|void
name|markRegionAsSplit
parameter_list|(
specifier|final
name|RegionInfo
name|parent
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|RegionInfo
name|daughterA
parameter_list|,
specifier|final
name|RegionInfo
name|daughterB
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Update hbase:meta. Parent will be marked offline and split up in hbase:meta.
comment|// The parent stays in regionStates until cleared when removed by CatalogJanitor.
comment|// Update its state in regionStates to it shows as offline and split when read
comment|// later figuring what regions are in a table and what are not: see
comment|// regionStates#getRegionsOfTable
specifier|final
name|RegionStateNode
name|node
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|node
operator|.
name|setState
argument_list|(
name|State
operator|.
name|SPLIT
argument_list|)
expr_stmt|;
specifier|final
name|RegionStateNode
name|nodeA
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|daughterA
argument_list|)
decl_stmt|;
name|nodeA
operator|.
name|setState
argument_list|(
name|State
operator|.
name|SPLITTING_NEW
argument_list|)
expr_stmt|;
specifier|final
name|RegionStateNode
name|nodeB
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|daughterB
argument_list|)
decl_stmt|;
name|nodeB
operator|.
name|setState
argument_list|(
name|State
operator|.
name|SPLITTING_NEW
argument_list|)
expr_stmt|;
name|regionStateStore
operator|.
name|splitRegion
argument_list|(
name|parent
argument_list|,
name|daughterA
argument_list|,
name|daughterB
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldAssignFavoredNodes
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|onlineServers
init|=
name|this
operator|.
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|getOnlineServersList
argument_list|()
decl_stmt|;
operator|(
operator|(
name|FavoredNodesPromoter
operator|)
name|getBalancer
argument_list|()
operator|)
operator|.
name|generateFavoredNodesForDaughter
argument_list|(
name|onlineServers
argument_list|,
name|parent
argument_list|,
name|daughterA
argument_list|,
name|daughterB
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * When called here, the merge has happened. The two merged regions have been    * unassigned and the above markRegionClosed has been called on each so they have been    * disassociated from a hosting Server. The merged region will be open after this call. The    * merged regions are removed from hbase:meta below> Later they are deleted from the filesystem    * by the catalog janitor running against hbase:meta. It notices when the merged region no    * longer holds references to the old regions.    */
specifier|public
name|void
name|markRegionAsMerged
parameter_list|(
specifier|final
name|RegionInfo
name|child
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|RegionInfo
name|mother
parameter_list|,
specifier|final
name|RegionInfo
name|father
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|RegionStateNode
name|node
init|=
name|regionStates
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|node
operator|.
name|setState
argument_list|(
name|State
operator|.
name|MERGED
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|deleteRegion
argument_list|(
name|mother
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|deleteRegion
argument_list|(
name|father
argument_list|)
expr_stmt|;
name|regionStateStore
operator|.
name|mergeRegions
argument_list|(
name|child
argument_list|,
name|mother
argument_list|,
name|father
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldAssignFavoredNodes
argument_list|(
name|child
argument_list|)
condition|)
block|{
operator|(
operator|(
name|FavoredNodesPromoter
operator|)
name|getBalancer
argument_list|()
operator|)
operator|.
name|generateFavoredNodesForMergedRegion
argument_list|(
name|child
argument_list|,
name|mother
argument_list|,
name|father
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Favored nodes should be applied only when FavoredNodes balancer is configured and the region    * belongs to a non-system table.    */
specifier|private
name|boolean
name|shouldAssignFavoredNodes
parameter_list|(
name|RegionInfo
name|region
parameter_list|)
block|{
return|return
name|this
operator|.
name|shouldAssignRegionsWithFavoredNodes
operator|&&
name|FavoredNodesManager
operator|.
name|isFavoredNodeApplicable
argument_list|(
name|region
argument_list|)
return|;
block|}
comment|// ============================================================================================
comment|//  Assign Queue (Assign/Balance)
comment|// ============================================================================================
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|RegionStateNode
argument_list|>
name|pendingAssignQueue
init|=
operator|new
name|ArrayList
argument_list|<
name|RegionStateNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ReentrantLock
name|assignQueueLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Condition
name|assignQueueFullCond
init|=
name|assignQueueLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
comment|/**    * Add the assign operation to the assignment queue.    * The pending assignment operation will be processed,    * and each region will be assigned by a server using the balancer.    */
specifier|protected
name|void
name|queueAssign
parameter_list|(
specifier|final
name|RegionStateNode
name|regionNode
parameter_list|)
block|{
name|regionNode
operator|.
name|getProcedureEvent
argument_list|()
operator|.
name|suspend
argument_list|()
expr_stmt|;
comment|// TODO: quick-start for meta and the other sys-tables?
name|assignQueueLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|pendingAssignQueue
operator|.
name|add
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionNode
operator|.
name|isSystemTable
argument_list|()
operator|||
name|pendingAssignQueue
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|||
name|pendingAssignQueue
operator|.
name|size
argument_list|()
operator|>=
name|assignDispatchWaitQueueMaxSize
condition|)
block|{
name|assignQueueFullCond
operator|.
name|signal
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|assignQueueLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|startAssignmentThread
parameter_list|()
block|{
comment|// Get Server Thread name. Sometimes the Server is mocked so may not implement HasThread.
comment|// For example, in tests.
name|String
name|name
init|=
name|master
operator|instanceof
name|HasThread
condition|?
operator|(
operator|(
name|HasThread
operator|)
name|master
operator|)
operator|.
name|getName
argument_list|()
else|:
name|master
operator|.
name|getServerName
argument_list|()
operator|.
name|toShortString
argument_list|()
decl_stmt|;
name|assignThread
operator|=
operator|new
name|Thread
argument_list|(
name|name
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|isRunning
argument_list|()
condition|)
block|{
name|processAssignQueue
argument_list|()
expr_stmt|;
block|}
name|pendingAssignQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
expr_stmt|;
name|assignThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assignThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|stopAssignmentThread
parameter_list|()
block|{
name|assignQueueSignal
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
name|assignThread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|assignQueueSignal
argument_list|()
expr_stmt|;
name|assignThread
operator|.
name|join
argument_list|(
literal|250
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"join interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|assignQueueSignal
parameter_list|()
block|{
name|assignQueueLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|assignQueueFullCond
operator|.
name|signal
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|assignQueueLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
literal|"WA_AWAIT_NOT_IN_LOOP"
argument_list|)
specifier|private
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
name|waitOnAssignQueue
parameter_list|()
block|{
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
name|regions
init|=
literal|null
decl_stmt|;
name|assignQueueLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|pendingAssignQueue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|isRunning
argument_list|()
condition|)
block|{
name|assignQueueFullCond
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
return|return
literal|null
return|;
name|assignQueueFullCond
operator|.
name|await
argument_list|(
name|assignDispatchWaitMillis
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|regions
operator|=
operator|new
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
argument_list|(
name|pendingAssignQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|RegionStateNode
name|regionNode
range|:
name|pendingAssignQueue
control|)
block|{
name|regions
operator|.
name|put
argument_list|(
name|regionNode
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
block|}
name|pendingAssignQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"got interrupted "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|assignQueueLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|regions
return|;
block|}
specifier|private
name|void
name|processAssignQueue
parameter_list|()
block|{
specifier|final
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
name|regions
init|=
name|waitOnAssignQueue
argument_list|()
decl_stmt|;
if|if
condition|(
name|regions
operator|==
literal|null
operator|||
name|regions
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
operator|!
name|isRunning
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"PROCESS ASSIGN QUEUE regionCount="
operator|+
name|regions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// TODO: Optimize balancer. pass a RegionPlan?
specifier|final
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
name|retainMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|userHRIs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|regions
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Regions for system tables requiring reassignment
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|systemHRIs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RegionStateNode
name|regionStateNode
range|:
name|regions
operator|.
name|values
argument_list|()
control|)
block|{
name|boolean
name|sysTable
init|=
name|regionStateNode
operator|.
name|isSystemTable
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|hris
init|=
name|sysTable
condition|?
name|systemHRIs
else|:
name|userHRIs
decl_stmt|;
if|if
condition|(
name|regionStateNode
operator|.
name|getRegionLocation
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|retainMap
operator|.
name|put
argument_list|(
name|regionStateNode
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|regionStateNode
operator|.
name|getRegionLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hris
operator|.
name|add
argument_list|(
name|regionStateNode
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: connect with the listener to invalidate the cache
comment|// TODO use events
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
init|=
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|createDestinationServersList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|servers
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|;
operator|++
name|i
control|)
block|{
comment|// Report every fourth time around this loop; try not to flood log.
if|if
condition|(
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No servers available; cannot place "
operator|+
name|regions
operator|.
name|size
argument_list|()
operator|+
literal|" unassigned regions."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopped! Dropping assign of "
operator|+
name|regions
operator|.
name|size
argument_list|()
operator|+
literal|" queued regions."
argument_list|)
expr_stmt|;
return|return;
block|}
name|Threads
operator|.
name|sleep
argument_list|(
literal|250
argument_list|)
expr_stmt|;
name|servers
operator|=
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|createDestinationServersList
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|systemHRIs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// System table regions requiring reassignment are present, get region servers
comment|// not available for system table regions
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|excludeServers
init|=
name|getExcludedServersForSystemTable
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|serversForSysTables
init|=
name|servers
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|s
lambda|->
operator|!
name|excludeServers
operator|.
name|contains
argument_list|(
name|s
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|serversForSysTables
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Filtering old server versions and the excluded produced an empty set; "
operator|+
literal|"instead considering all candidate servers!"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing assignQueue; systemServersCount="
operator|+
name|serversForSysTables
operator|.
name|size
argument_list|()
operator|+
literal|", allServersCount="
operator|+
name|servers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|processAssignmentPlans
argument_list|(
name|regions
argument_list|,
literal|null
argument_list|,
name|systemHRIs
argument_list|,
name|serversForSysTables
operator|.
name|isEmpty
argument_list|()
condition|?
name|servers
else|:
name|serversForSysTables
argument_list|)
expr_stmt|;
block|}
name|processAssignmentPlans
argument_list|(
name|regions
argument_list|,
name|retainMap
argument_list|,
name|userHRIs
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|processAssignmentPlans
parameter_list|(
specifier|final
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
name|regions
parameter_list|,
specifier|final
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
name|retainMap
parameter_list|,
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|hris
parameter_list|,
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|)
block|{
name|boolean
name|isTraceEnabled
init|=
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
decl_stmt|;
if|if
condition|(
name|isTraceEnabled
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Available servers count="
operator|+
name|servers
operator|.
name|size
argument_list|()
operator|+
literal|": "
operator|+
name|servers
argument_list|)
expr_stmt|;
block|}
specifier|final
name|LoadBalancer
name|balancer
init|=
name|getBalancer
argument_list|()
decl_stmt|;
comment|// ask the balancer where to place regions
if|if
condition|(
name|retainMap
operator|!=
literal|null
operator|&&
operator|!
name|retainMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|isTraceEnabled
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"retain assign regions="
operator|+
name|retainMap
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|acceptPlan
argument_list|(
name|regions
argument_list|,
name|balancer
operator|.
name|retainAssignment
argument_list|(
name|retainMap
argument_list|,
name|servers
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"unable to retain assignment"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|addToPendingAssignment
argument_list|(
name|regions
argument_list|,
name|retainMap
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: Do we need to split retain and round-robin?
comment|// the retain seems to fallback to round-robin/random if the region is not in the map.
if|if
condition|(
operator|!
name|hris
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|hris
argument_list|,
name|RegionInfo
operator|.
name|COMPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|isTraceEnabled
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"round robin regions="
operator|+
name|hris
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|acceptPlan
argument_list|(
name|regions
argument_list|,
name|balancer
operator|.
name|roundRobinAssignment
argument_list|(
name|hris
argument_list|,
name|servers
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"unable to round-robin assignment"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|addToPendingAssignment
argument_list|(
name|regions
argument_list|,
name|hris
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|acceptPlan
parameter_list|(
specifier|final
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
name|regions
parameter_list|,
specifier|final
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|plan
parameter_list|)
throws|throws
name|HBaseIOException
block|{
specifier|final
name|ProcedureEvent
argument_list|<
name|?
argument_list|>
index|[]
name|events
init|=
operator|new
name|ProcedureEvent
index|[
name|regions
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|final
name|long
name|st
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
literal|"unable to compute plans for regions="
operator|+
name|regions
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|plan
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|int
name|evcount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|entry
range|:
name|plan
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|ServerName
name|server
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
for|for
control|(
name|RegionInfo
name|hri
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
specifier|final
name|RegionStateNode
name|regionNode
init|=
name|regions
operator|.
name|get
argument_list|(
name|hri
argument_list|)
decl_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|events
index|[
name|evcount
operator|++
index|]
operator|=
name|regionNode
operator|.
name|getProcedureEvent
argument_list|()
expr_stmt|;
block|}
block|}
name|ProcedureEvent
operator|.
name|wakeEvents
argument_list|(
name|getProcedureScheduler
argument_list|()
argument_list|,
name|events
argument_list|)
expr_stmt|;
specifier|final
name|long
name|et
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"ASSIGN ACCEPT "
operator|+
name|events
operator|.
name|length
operator|+
literal|" -> "
operator|+
name|StringUtils
operator|.
name|humanTimeDiff
argument_list|(
name|et
operator|-
name|st
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addToPendingAssignment
parameter_list|(
specifier|final
name|HashMap
argument_list|<
name|RegionInfo
argument_list|,
name|RegionStateNode
argument_list|>
name|regions
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|RegionInfo
argument_list|>
name|pendingRegions
parameter_list|)
block|{
name|assignQueueLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|RegionInfo
name|hri
range|:
name|pendingRegions
control|)
block|{
name|pendingAssignQueue
operator|.
name|add
argument_list|(
name|regions
operator|.
name|get
argument_list|(
name|hri
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|assignQueueLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a list of servers that this region cannot be assigned to.    * For system tables, we must assign them to a server with highest version.    */
specifier|public
name|List
argument_list|<
name|ServerName
argument_list|>
name|getExcludedServersForSystemTable
parameter_list|()
block|{
comment|// TODO: This should be a cached list kept by the ServerManager rather than calculated on each
comment|// move or system region assign. The RegionServerTracker keeps list of online Servers with
comment|// RegionServerInfo that includes Version.
name|List
argument_list|<
name|Pair
argument_list|<
name|ServerName
argument_list|,
name|String
argument_list|>
argument_list|>
name|serverList
init|=
name|master
operator|.
name|getServerManager
argument_list|()
operator|.
name|getOnlineServersList
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
parameter_list|(
name|s
parameter_list|)
lambda|->
operator|new
name|Pair
argument_list|<>
argument_list|(
name|s
argument_list|,
name|master
operator|.
name|getRegionServerVersion
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|String
name|highestVersion
init|=
name|Collections
operator|.
name|max
argument_list|(
name|serverList
argument_list|,
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
name|VersionInfo
operator|.
name|compareVersion
argument_list|(
name|o1
operator|.
name|getSecond
argument_list|()
argument_list|,
name|o2
operator|.
name|getSecond
argument_list|()
argument_list|)
argument_list|)
operator|.
name|getSecond
argument_list|()
decl_stmt|;
return|return
name|serverList
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
parameter_list|(
name|p
parameter_list|)
lambda|->
operator|!
name|p
operator|.
name|getSecond
argument_list|()
operator|.
name|equals
argument_list|(
name|highestVersion
argument_list|)
argument_list|)
operator|.
name|map
argument_list|(
name|Pair
operator|::
name|getFirst
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
name|MasterServices
name|getMaster
parameter_list|()
block|{
return|return
name|master
return|;
block|}
block|}
end_class

end_unit

