begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|hbck
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HbckErrorReporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|CacheConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|CorruptHFileException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mob
operator|.
name|MobUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
operator|.
name|FamilyDirFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
operator|.
name|HFileFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
operator|.
name|RegionDirFilter
import|;
end_import

begin_comment
comment|/**  * This class marches through all of the region's hfiles and verifies that  * they are all valid files. One just needs to instantiate the class, use  * checkTables(List&lt;Path&gt;) and then retrieve the corrupted hfiles (and  * quarantined files if in quarantining mode)  *  * The implementation currently parallelizes at the regionDir level.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|HFileCorruptionChecker
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HFileCorruptionChecker
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|final
name|FileSystem
name|fs
decl_stmt|;
specifier|final
name|CacheConfig
name|cacheConf
decl_stmt|;
specifier|final
name|ExecutorService
name|executor
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|corrupted
init|=
operator|new
name|ConcurrentSkipListSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|failures
init|=
operator|new
name|ConcurrentSkipListSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|quarantined
init|=
operator|new
name|ConcurrentSkipListSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|missing
init|=
operator|new
name|ConcurrentSkipListSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|corruptedMobFiles
init|=
operator|new
name|ConcurrentSkipListSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|failureMobFiles
init|=
operator|new
name|ConcurrentSkipListSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|missedMobFiles
init|=
operator|new
name|ConcurrentSkipListSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|quarantinedMobFiles
init|=
operator|new
name|ConcurrentSkipListSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|inQuarantineMode
decl_stmt|;
specifier|final
name|AtomicInteger
name|hfilesChecked
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
specifier|final
name|AtomicInteger
name|mobFilesChecked
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
specifier|public
name|HFileCorruptionChecker
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ExecutorService
name|executor
parameter_list|,
name|boolean
name|quarantine
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|cacheConf
operator|=
name|CacheConfig
operator|.
name|DISABLED
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
name|this
operator|.
name|inQuarantineMode
operator|=
name|quarantine
expr_stmt|;
block|}
comment|/**    * Checks a path to see if it is a valid hfile.    *    * @param p    *          full Path to an HFile    * @throws IOException    *           This is a connectivity related exception    */
specifier|protected
name|void
name|checkHFile
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|HFile
operator|.
name|Reader
name|r
init|=
literal|null
decl_stmt|;
try|try
block|{
name|r
operator|=
name|HFile
operator|.
name|createReader
argument_list|(
name|fs
argument_list|,
name|p
argument_list|,
name|cacheConf
argument_list|,
literal|true
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CorruptHFileException
name|che
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Found corrupt HFile "
operator|+
name|p
argument_list|,
name|che
argument_list|)
expr_stmt|;
name|corrupted
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|inQuarantineMode
condition|)
block|{
name|Path
name|dest
init|=
name|createQuarantinePath
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Quarantining corrupt HFile "
operator|+
name|p
operator|+
literal|" into "
operator|+
name|dest
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
name|fs
operator|.
name|mkdirs
argument_list|(
name|dest
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
name|success
operator|=
name|success
condition|?
name|fs
operator|.
name|rename
argument_list|(
name|p
argument_list|,
name|dest
argument_list|)
else|:
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|failures
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|quarantined
operator|.
name|add
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"HFile "
operator|+
name|p
operator|+
literal|" was missing.  Likely removed due to compaction/split?"
argument_list|)
expr_stmt|;
name|missing
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|hfilesChecked
operator|.
name|addAndGet
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|r
operator|.
name|close
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Given a path, generates a new path to where we move a corrupted hfile (bad    * trailer, no trailer).    *    * @param hFile    *          Path to a corrupt hfile (assumes that it is HBASE_DIR/ table    *          /region/cf/file)    * @return path to where corrupted files are stored. This should be    *         HBASE_DIR/.corrupt/table/region/cf/file.    */
name|Path
name|createQuarantinePath
parameter_list|(
name|Path
name|hFile
parameter_list|)
throws|throws
name|IOException
block|{
comment|// extract the normal dirs structure
name|Path
name|cfDir
init|=
name|hFile
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|Path
name|regionDir
init|=
name|cfDir
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|Path
name|tableDir
init|=
name|regionDir
operator|.
name|getParent
argument_list|()
decl_stmt|;
comment|// build up the corrupted dirs structure
name|Path
name|corruptBaseDir
init|=
operator|new
name|Path
argument_list|(
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|conf
argument_list|)
argument_list|,
name|HConstants
operator|.
name|CORRUPT_DIR_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.hfile.quarantine.dir"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"hbase.hfile.quarantine.dir is deprecated. Default to "
operator|+
name|corruptBaseDir
argument_list|)
expr_stmt|;
block|}
name|Path
name|corruptTableDir
init|=
operator|new
name|Path
argument_list|(
name|corruptBaseDir
argument_list|,
name|tableDir
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|corruptRegionDir
init|=
operator|new
name|Path
argument_list|(
name|corruptTableDir
argument_list|,
name|regionDir
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|corruptFamilyDir
init|=
operator|new
name|Path
argument_list|(
name|corruptRegionDir
argument_list|,
name|cfDir
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|corruptHfile
init|=
operator|new
name|Path
argument_list|(
name|corruptFamilyDir
argument_list|,
name|hFile
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|corruptHfile
return|;
block|}
comment|/**    * Check all files in a column family dir.    *    * @param cfDir    *          column family directory    * @throws IOException    */
specifier|protected
name|void
name|checkColFamDir
parameter_list|(
name|Path
name|cfDir
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|statuses
init|=
literal|null
decl_stmt|;
try|try
block|{
name|statuses
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
name|cfDir
argument_list|)
expr_stmt|;
comment|// use same filter as scanner.
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
comment|// Hadoop 0.23+ listStatus semantics throws an exception if the path does not exist.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Colfam Directory "
operator|+
name|cfDir
operator|+
literal|" does not exist.  Likely due to concurrent split/compaction. Skipping."
argument_list|)
expr_stmt|;
name|missing
operator|.
name|add
argument_list|(
name|cfDir
argument_list|)
expr_stmt|;
return|return;
block|}
name|List
argument_list|<
name|FileStatus
argument_list|>
name|hfs
init|=
name|FSUtils
operator|.
name|filterFileStatuses
argument_list|(
name|statuses
argument_list|,
operator|new
name|HFileFilter
argument_list|(
name|fs
argument_list|)
argument_list|)
decl_stmt|;
comment|// Hadoop 1.0 listStatus does not throw an exception if the path does not exist.
if|if
condition|(
name|hfs
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|cfDir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Colfam Directory "
operator|+
name|cfDir
operator|+
literal|" does not exist.  Likely due to concurrent split/compaction. Skipping."
argument_list|)
expr_stmt|;
name|missing
operator|.
name|add
argument_list|(
name|cfDir
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|FileStatus
name|hfFs
range|:
name|hfs
control|)
block|{
name|Path
name|hf
init|=
name|hfFs
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|checkHFile
argument_list|(
name|hf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Check all files in a mob column family dir.    *    * @param cfDir    *          mob column family directory    * @throws IOException    */
specifier|protected
name|void
name|checkMobColFamDir
parameter_list|(
name|Path
name|cfDir
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|statuses
init|=
literal|null
decl_stmt|;
try|try
block|{
name|statuses
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
name|cfDir
argument_list|)
expr_stmt|;
comment|// use same filter as scanner.
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
comment|// Hadoop 0.23+ listStatus semantics throws an exception if the path does not exist.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Mob colfam Directory "
operator|+
name|cfDir
operator|+
literal|" does not exist.  Likely the table is deleted. Skipping."
argument_list|)
expr_stmt|;
name|missedMobFiles
operator|.
name|add
argument_list|(
name|cfDir
argument_list|)
expr_stmt|;
return|return;
block|}
name|List
argument_list|<
name|FileStatus
argument_list|>
name|hfs
init|=
name|FSUtils
operator|.
name|filterFileStatuses
argument_list|(
name|statuses
argument_list|,
operator|new
name|HFileFilter
argument_list|(
name|fs
argument_list|)
argument_list|)
decl_stmt|;
comment|// Hadoop 1.0 listStatus does not throw an exception if the path does not exist.
if|if
condition|(
name|hfs
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|cfDir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Mob colfam Directory "
operator|+
name|cfDir
operator|+
literal|" does not exist.  Likely the table is deleted. Skipping."
argument_list|)
expr_stmt|;
name|missedMobFiles
operator|.
name|add
argument_list|(
name|cfDir
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|FileStatus
name|hfFs
range|:
name|hfs
control|)
block|{
name|Path
name|hf
init|=
name|hfFs
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|checkMobFile
argument_list|(
name|hf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Checks a path to see if it is a valid mob file.    *    * @param p    *          full Path to a mob file.    * @throws IOException    *           This is a connectivity related exception    */
specifier|protected
name|void
name|checkMobFile
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|HFile
operator|.
name|Reader
name|r
init|=
literal|null
decl_stmt|;
try|try
block|{
name|r
operator|=
name|HFile
operator|.
name|createReader
argument_list|(
name|fs
argument_list|,
name|p
argument_list|,
name|cacheConf
argument_list|,
literal|true
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CorruptHFileException
name|che
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Found corrupt mob file "
operator|+
name|p
argument_list|,
name|che
argument_list|)
expr_stmt|;
name|corruptedMobFiles
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|inQuarantineMode
condition|)
block|{
name|Path
name|dest
init|=
name|createQuarantinePath
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Quarantining corrupt mob file "
operator|+
name|p
operator|+
literal|" into "
operator|+
name|dest
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
name|fs
operator|.
name|mkdirs
argument_list|(
name|dest
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
name|success
operator|=
name|success
condition|?
name|fs
operator|.
name|rename
argument_list|(
name|p
argument_list|,
name|dest
argument_list|)
else|:
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|failureMobFiles
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|quarantinedMobFiles
operator|.
name|add
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Mob file "
operator|+
name|p
operator|+
literal|" was missing.  Likely removed due to compaction?"
argument_list|)
expr_stmt|;
name|missedMobFiles
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|mobFilesChecked
operator|.
name|addAndGet
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|r
operator|.
name|close
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Checks all the mob files of a table.    * @param regionDir The mob region directory    * @throws IOException    */
specifier|private
name|void
name|checkMobRegionDir
parameter_list|(
name|Path
name|regionDir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|regionDir
argument_list|)
condition|)
block|{
return|return;
block|}
name|FileStatus
index|[]
name|hfs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|hfs
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
name|regionDir
argument_list|,
operator|new
name|FamilyDirFilter
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
comment|// Hadoop 0.23+ listStatus semantics throws an exception if the path does not exist.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Mob directory "
operator|+
name|regionDir
operator|+
literal|" does not exist.  Likely the table is deleted. Skipping."
argument_list|)
expr_stmt|;
name|missedMobFiles
operator|.
name|add
argument_list|(
name|regionDir
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Hadoop 1.0 listStatus does not throw an exception if the path does not exist.
if|if
condition|(
name|hfs
operator|.
name|length
operator|==
literal|0
operator|&&
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|regionDir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Mob directory "
operator|+
name|regionDir
operator|+
literal|" does not exist.  Likely the table is deleted. Skipping."
argument_list|)
expr_stmt|;
name|missedMobFiles
operator|.
name|add
argument_list|(
name|regionDir
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|FileStatus
name|hfFs
range|:
name|hfs
control|)
block|{
name|Path
name|hf
init|=
name|hfFs
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|checkMobColFamDir
argument_list|(
name|hf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Check all column families in a region dir.    *    * @param regionDir    *          region directory    * @throws IOException    */
specifier|protected
name|void
name|checkRegionDir
parameter_list|(
name|Path
name|regionDir
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|statuses
init|=
literal|null
decl_stmt|;
try|try
block|{
name|statuses
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
name|regionDir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
comment|// Hadoop 0.23+ listStatus semantics throws an exception if the path does not exist.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region Directory "
operator|+
name|regionDir
operator|+
literal|" does not exist.  Likely due to concurrent split/compaction. Skipping."
argument_list|)
expr_stmt|;
name|missing
operator|.
name|add
argument_list|(
name|regionDir
argument_list|)
expr_stmt|;
return|return;
block|}
name|List
argument_list|<
name|FileStatus
argument_list|>
name|cfs
init|=
name|FSUtils
operator|.
name|filterFileStatuses
argument_list|(
name|statuses
argument_list|,
operator|new
name|FamilyDirFilter
argument_list|(
name|fs
argument_list|)
argument_list|)
decl_stmt|;
comment|// Hadoop 1.0 listStatus does not throw an exception if the path does not exist.
if|if
condition|(
name|cfs
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|regionDir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region Directory "
operator|+
name|regionDir
operator|+
literal|" does not exist.  Likely due to concurrent split/compaction. Skipping."
argument_list|)
expr_stmt|;
name|missing
operator|.
name|add
argument_list|(
name|regionDir
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|FileStatus
name|cfFs
range|:
name|cfs
control|)
block|{
name|Path
name|cfDir
init|=
name|cfFs
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|checkColFamDir
argument_list|(
name|cfDir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Check all the regiondirs in the specified tableDir    *    * @param tableDir    *          path to a table    * @throws IOException    */
name|void
name|checkTableDir
parameter_list|(
name|Path
name|tableDir
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|rds
init|=
name|FSUtils
operator|.
name|listStatusWithStatusFilter
argument_list|(
name|fs
argument_list|,
name|tableDir
argument_list|,
operator|new
name|RegionDirFilter
argument_list|(
name|fs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rds
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|tableDir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Table Directory "
operator|+
name|tableDir
operator|+
literal|" does not exist.  Likely due to concurrent delete. Skipping."
argument_list|)
expr_stmt|;
name|missing
operator|.
name|add
argument_list|(
name|tableDir
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Parallelize check at the region dir level
name|List
argument_list|<
name|RegionDirChecker
argument_list|>
name|rdcs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|rds
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Future
argument_list|<
name|Void
argument_list|>
argument_list|>
name|rdFutures
decl_stmt|;
for|for
control|(
name|FileStatus
name|rdFs
range|:
name|rds
control|)
block|{
name|Path
name|rdDir
init|=
name|rdFs
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|RegionDirChecker
name|work
init|=
operator|new
name|RegionDirChecker
argument_list|(
name|rdDir
argument_list|)
decl_stmt|;
name|rdcs
operator|.
name|add
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
comment|// add mob region
name|rdcs
operator|.
name|add
argument_list|(
name|createMobRegionDirChecker
argument_list|(
name|tableDir
argument_list|)
argument_list|)
expr_stmt|;
comment|// Submit and wait for completion
try|try
block|{
name|rdFutures
operator|=
name|executor
operator|.
name|invokeAll
argument_list|(
name|rdcs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region dirs checking interrupted!"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rdFutures
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Future
argument_list|<
name|Void
argument_list|>
name|f
init|=
name|rdFutures
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
name|f
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to quarantine an HFile in regiondir "
operator|+
name|rdcs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|regionDir
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
comment|// rethrow IOExceptions
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|e
operator|.
name|getCause
argument_list|()
throw|;
block|}
comment|// rethrow RuntimeExceptions
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|e
operator|.
name|getCause
argument_list|()
throw|;
block|}
comment|// this should never happen
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected exception encountered"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
comment|// bailing out.
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region dirs check interrupted!"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|// bailing out
return|return;
block|}
block|}
block|}
comment|/**    * An individual work item for parallelized regiondir processing. This is    * intentionally an inner class so it can use the shared error sets and fs.    */
specifier|private
class|class
name|RegionDirChecker
implements|implements
name|Callable
argument_list|<
name|Void
argument_list|>
block|{
specifier|final
name|Path
name|regionDir
decl_stmt|;
name|RegionDirChecker
parameter_list|(
name|Path
name|regionDir
parameter_list|)
block|{
name|this
operator|.
name|regionDir
operator|=
name|regionDir
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
name|checkRegionDir
argument_list|(
name|regionDir
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * An individual work item for parallelized mob dir processing. This is    * intentionally an inner class so it can use the shared error sets and fs.    */
specifier|private
class|class
name|MobRegionDirChecker
extends|extends
name|RegionDirChecker
block|{
name|MobRegionDirChecker
parameter_list|(
name|Path
name|regionDir
parameter_list|)
block|{
name|super
argument_list|(
name|regionDir
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
name|checkMobRegionDir
argument_list|(
name|regionDir
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Creates an instance of MobRegionDirChecker.    * @param tableDir The current table directory.    * @return An instance of MobRegionDirChecker.    */
specifier|private
name|MobRegionDirChecker
name|createMobRegionDirChecker
parameter_list|(
name|Path
name|tableDir
parameter_list|)
block|{
name|TableName
name|tableName
init|=
name|FSUtils
operator|.
name|getTableName
argument_list|(
name|tableDir
argument_list|)
decl_stmt|;
name|Path
name|mobDir
init|=
name|MobUtils
operator|.
name|getMobRegionPath
argument_list|(
name|conf
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
return|return
operator|new
name|MobRegionDirChecker
argument_list|(
name|mobDir
argument_list|)
return|;
block|}
comment|/**    * Check the specified table dirs for bad hfiles.    */
specifier|public
name|void
name|checkTables
parameter_list|(
name|Collection
argument_list|<
name|Path
argument_list|>
name|tables
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|Path
name|t
range|:
name|tables
control|)
block|{
name|checkTableDir
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return the set of check failure file paths after checkTables is called.    */
specifier|public
name|Collection
argument_list|<
name|Path
argument_list|>
name|getFailures
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|failures
argument_list|)
return|;
block|}
comment|/**    * @return the set of corrupted file paths after checkTables is called.    */
specifier|public
name|Collection
argument_list|<
name|Path
argument_list|>
name|getCorrupted
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|corrupted
argument_list|)
return|;
block|}
comment|/**    * @return number of hfiles checked in the last HfileCorruptionChecker run    */
specifier|public
name|int
name|getHFilesChecked
parameter_list|()
block|{
return|return
name|hfilesChecked
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * @return the set of successfully quarantined paths after checkTables is called.    */
specifier|public
name|Collection
argument_list|<
name|Path
argument_list|>
name|getQuarantined
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|quarantined
argument_list|)
return|;
block|}
comment|/**    * @return the set of paths that were missing.  Likely due to deletion/moves from    *  compaction or flushes.    */
specifier|public
name|Collection
argument_list|<
name|Path
argument_list|>
name|getMissing
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|missing
argument_list|)
return|;
block|}
comment|/**    * @return the set of check failure mob file paths after checkTables is called.    */
specifier|public
name|Collection
argument_list|<
name|Path
argument_list|>
name|getFailureMobFiles
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|failureMobFiles
argument_list|)
return|;
block|}
comment|/**    * @return the set of corrupted mob file paths after checkTables is called.    */
specifier|public
name|Collection
argument_list|<
name|Path
argument_list|>
name|getCorruptedMobFiles
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|corruptedMobFiles
argument_list|)
return|;
block|}
comment|/**    * @return number of mob files checked in the last HfileCorruptionChecker run    */
specifier|public
name|int
name|getMobFilesChecked
parameter_list|()
block|{
return|return
name|mobFilesChecked
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * @return the set of successfully quarantined paths after checkTables is called.    */
specifier|public
name|Collection
argument_list|<
name|Path
argument_list|>
name|getQuarantinedMobFiles
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|quarantinedMobFiles
argument_list|)
return|;
block|}
comment|/**    * @return the set of paths that were missing.  Likely due to table deletion or    *  deletion/moves from compaction.    */
specifier|public
name|Collection
argument_list|<
name|Path
argument_list|>
name|getMissedMobFiles
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|missedMobFiles
argument_list|)
return|;
block|}
comment|/**    * Print a human readable summary of hfile quarantining operations.    * @param out    */
specifier|public
name|void
name|report
parameter_list|(
name|HbckErrorReporter
name|out
parameter_list|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"Checked "
operator|+
name|hfilesChecked
operator|.
name|get
argument_list|()
operator|+
literal|" hfile for corruption"
argument_list|)
expr_stmt|;
name|out
operator|.
name|print
argument_list|(
literal|"  HFiles corrupted:                  "
operator|+
name|corrupted
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|inQuarantineMode
condition|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"    HFiles successfully quarantined: "
operator|+
name|quarantined
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Path
name|sq
range|:
name|quarantined
control|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"      "
operator|+
name|sq
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|print
argument_list|(
literal|"    HFiles failed quarantine:        "
operator|+
name|failures
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Path
name|fq
range|:
name|failures
control|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"      "
operator|+
name|fq
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|print
argument_list|(
literal|"    HFiles moved while checking:     "
operator|+
name|missing
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Path
name|mq
range|:
name|missing
control|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"      "
operator|+
name|mq
argument_list|)
expr_stmt|;
block|}
name|String
name|initialState
init|=
operator|(
name|corrupted
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|"OK"
else|:
literal|"CORRUPTED"
decl_stmt|;
name|String
name|fixedState
init|=
operator|(
name|corrupted
operator|.
name|size
argument_list|()
operator|==
name|quarantined
operator|.
name|size
argument_list|()
operator|)
condition|?
literal|"OK"
else|:
literal|"CORRUPTED"
decl_stmt|;
comment|// print mob-related report
if|if
condition|(
name|inQuarantineMode
condition|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"    Mob files successfully quarantined: "
operator|+
name|quarantinedMobFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Path
name|sq
range|:
name|quarantinedMobFiles
control|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"      "
operator|+
name|sq
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|print
argument_list|(
literal|"    Mob files failed quarantine:        "
operator|+
name|failureMobFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Path
name|fq
range|:
name|failureMobFiles
control|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"      "
operator|+
name|fq
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|print
argument_list|(
literal|"    Mob files moved while checking:     "
operator|+
name|missedMobFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Path
name|mq
range|:
name|missedMobFiles
control|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"      "
operator|+
name|mq
argument_list|)
expr_stmt|;
block|}
name|String
name|initialMobState
init|=
operator|(
name|corruptedMobFiles
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|"OK"
else|:
literal|"CORRUPTED"
decl_stmt|;
name|String
name|fixedMobState
init|=
operator|(
name|corruptedMobFiles
operator|.
name|size
argument_list|()
operator|==
name|quarantinedMobFiles
operator|.
name|size
argument_list|()
operator|)
condition|?
literal|"OK"
else|:
literal|"CORRUPTED"
decl_stmt|;
if|if
condition|(
name|inQuarantineMode
condition|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"Summary: "
operator|+
name|initialState
operator|+
literal|" => "
operator|+
name|fixedState
argument_list|)
expr_stmt|;
name|out
operator|.
name|print
argument_list|(
literal|"Mob summary: "
operator|+
name|initialMobState
operator|+
literal|" => "
operator|+
name|fixedMobState
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|print
argument_list|(
literal|"Summary: "
operator|+
name|initialState
argument_list|)
expr_stmt|;
name|out
operator|.
name|print
argument_list|(
literal|"Mob summary: "
operator|+
name|initialMobState
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

