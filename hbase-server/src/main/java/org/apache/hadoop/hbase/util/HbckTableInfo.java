begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfoBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|tool
operator|.
name|BulkLoadHFilesTool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|hbck
operator|.
name|TableIntegrityErrorHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|hbck
operator|.
name|TableIntegrityErrorHandlerImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|TreeMultimap
import|;
end_import

begin_comment
comment|/**  * Maintain information about a particular table.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|HbckTableInfo
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HbckTableInfo
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|TO_BE_LOADED
init|=
literal|"to_be_loaded"
decl_stmt|;
name|TableName
name|tableName
decl_stmt|;
name|TreeSet
argument_list|<
name|ServerName
argument_list|>
name|deployedOn
decl_stmt|;
comment|// backwards regions
specifier|final
name|List
argument_list|<
name|HbckRegionInfo
argument_list|>
name|backwards
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// sidelined big overlapped regions
specifier|final
name|Map
argument_list|<
name|Path
argument_list|,
name|HbckRegionInfo
argument_list|>
name|sidelinedRegions
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// region split calculator
specifier|final
name|RegionSplitCalculator
argument_list|<
name|HbckRegionInfo
argument_list|>
name|sc
init|=
operator|new
name|RegionSplitCalculator
argument_list|<>
argument_list|(
name|HbckRegionInfo
operator|.
name|COMPARATOR
argument_list|)
decl_stmt|;
comment|// Histogram of different TableDescriptors found.  Ideally there is only one!
specifier|final
name|Set
argument_list|<
name|TableDescriptor
argument_list|>
name|htds
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// key = start split, values = set of splits in problem group
specifier|final
name|Multimap
argument_list|<
name|byte
index|[]
argument_list|,
name|HbckRegionInfo
argument_list|>
name|overlapGroups
init|=
name|TreeMultimap
operator|.
name|create
argument_list|(
name|RegionSplitCalculator
operator|.
name|BYTES_COMPARATOR
argument_list|,
name|HbckRegionInfo
operator|.
name|COMPARATOR
argument_list|)
decl_stmt|;
comment|// list of regions derived from meta entries.
specifier|private
name|ImmutableList
argument_list|<
name|RegionInfo
argument_list|>
name|regionsFromMeta
init|=
literal|null
decl_stmt|;
name|HBaseFsck
name|hbck
decl_stmt|;
name|HbckTableInfo
parameter_list|(
name|TableName
name|name
parameter_list|,
name|HBaseFsck
name|hbck
parameter_list|)
block|{
name|this
operator|.
name|tableName
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|hbck
operator|=
name|hbck
expr_stmt|;
name|deployedOn
operator|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**    * @return descriptor common to all regions.  null if are none or multiple!    */
name|TableDescriptor
name|getTableDescriptor
parameter_list|()
block|{
if|if
condition|(
name|htds
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|TableDescriptor
operator|)
name|htds
operator|.
name|toArray
argument_list|()
index|[
literal|0
index|]
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"None/Multiple table descriptors found for table '"
operator|+
name|tableName
operator|+
literal|"' regions: "
operator|+
name|htds
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|void
name|addRegionInfo
parameter_list|(
name|HbckRegionInfo
name|hir
parameter_list|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|hir
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
condition|)
block|{
comment|// end key is absolute end key, just add it.
comment|// ignore replicas other than primary for these checks
if|if
condition|(
name|hir
operator|.
name|getReplicaId
argument_list|()
operator|==
name|RegionInfo
operator|.
name|DEFAULT_REPLICA_ID
condition|)
block|{
name|sc
operator|.
name|add
argument_list|(
name|hir
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// if not the absolute end key, check for cycle
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|hir
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|hir
operator|.
name|getEndKey
argument_list|()
argument_list|)
operator|>
literal|0
condition|)
block|{
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|REGION_CYCLE
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"The endkey for this region comes before the "
operator|+
literal|"startkey, startkey=%s, endkey=%s"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|hir
operator|.
name|getStartKey
argument_list|()
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|hir
operator|.
name|getEndKey
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|hir
argument_list|)
expr_stmt|;
name|backwards
operator|.
name|add
argument_list|(
name|hir
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// main case, add to split calculator
comment|// ignore replicas other than primary for these checks
if|if
condition|(
name|hir
operator|.
name|getReplicaId
argument_list|()
operator|==
name|RegionInfo
operator|.
name|DEFAULT_REPLICA_ID
condition|)
block|{
name|sc
operator|.
name|add
argument_list|(
name|hir
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|addServer
parameter_list|(
name|ServerName
name|server
parameter_list|)
block|{
name|this
operator|.
name|deployedOn
operator|.
name|add
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TableName
name|getName
parameter_list|()
block|{
return|return
name|tableName
return|;
block|}
specifier|public
name|int
name|getNumRegions
parameter_list|()
block|{
return|return
name|sc
operator|.
name|getStarts
argument_list|()
operator|.
name|size
argument_list|()
operator|+
name|backwards
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
specifier|synchronized
name|ImmutableList
argument_list|<
name|RegionInfo
argument_list|>
name|getRegionsFromMeta
parameter_list|(
name|TreeMap
argument_list|<
name|String
argument_list|,
name|HbckRegionInfo
argument_list|>
name|regionInfoMap
parameter_list|)
block|{
comment|// lazy loaded, synchronized to ensure a single load
if|if
condition|(
name|regionsFromMeta
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|regions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|HbckRegionInfo
name|h
range|:
name|regionInfoMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|h
operator|.
name|getTableName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|h
operator|.
name|getMetaEntry
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|regions
operator|.
name|add
argument_list|(
name|h
operator|.
name|getMetaEntry
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|regionsFromMeta
operator|=
name|Ordering
operator|.
name|from
argument_list|(
name|RegionInfo
operator|.
name|COMPARATOR
argument_list|)
operator|.
name|immutableSortedCopy
argument_list|(
name|regions
argument_list|)
expr_stmt|;
block|}
return|return
name|regionsFromMeta
return|;
block|}
class|class
name|IntegrityFixSuggester
extends|extends
name|TableIntegrityErrorHandlerImpl
block|{
name|HbckErrorReporter
name|errors
decl_stmt|;
name|IntegrityFixSuggester
parameter_list|(
name|HbckTableInfo
name|ti
parameter_list|,
name|HbckErrorReporter
name|errors
parameter_list|)
block|{
name|this
operator|.
name|errors
operator|=
name|errors
expr_stmt|;
name|setTableInfo
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleRegionStartKeyNotEmpty
parameter_list|(
name|HbckRegionInfo
name|hi
parameter_list|)
throws|throws
name|IOException
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|FIRST_REGION_STARTKEY_NOT_EMPTY
argument_list|,
literal|"First region should start with an empty key.  You need to "
operator|+
literal|" create a new region and regioninfo in HDFS to plug the hole."
argument_list|,
name|getTableInfo
argument_list|()
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleRegionEndKeyNotEmpty
parameter_list|(
name|byte
index|[]
name|curEndKey
parameter_list|)
throws|throws
name|IOException
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|LAST_REGION_ENDKEY_NOT_EMPTY
argument_list|,
literal|"Last region should end with an empty key. You need to "
operator|+
literal|"create a new region and regioninfo in HDFS to plug the hole."
argument_list|,
name|getTableInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleDegenerateRegion
parameter_list|(
name|HbckRegionInfo
name|hi
parameter_list|)
throws|throws
name|IOException
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|DEGENERATE_REGION
argument_list|,
literal|"Region has the same start and end key."
argument_list|,
name|getTableInfo
argument_list|()
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleDuplicateStartKeys
parameter_list|(
name|HbckRegionInfo
name|r1
parameter_list|,
name|HbckRegionInfo
name|r2
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|r1
operator|.
name|getStartKey
argument_list|()
decl_stmt|;
comment|// dup start key
name|errors
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|DUPE_STARTKEYS
argument_list|,
literal|"Multiple regions have the same startkey: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|,
name|getTableInfo
argument_list|()
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|errors
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|DUPE_STARTKEYS
argument_list|,
literal|"Multiple regions have the same startkey: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|,
name|getTableInfo
argument_list|()
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleSplit
parameter_list|(
name|HbckRegionInfo
name|r1
parameter_list|,
name|HbckRegionInfo
name|r2
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|key
init|=
name|r1
operator|.
name|getStartKey
argument_list|()
decl_stmt|;
comment|// dup start key
name|errors
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|DUPE_ENDKEYS
argument_list|,
literal|"Multiple regions have the same regionID: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|,
name|getTableInfo
argument_list|()
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|errors
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|DUPE_ENDKEYS
argument_list|,
literal|"Multiple regions have the same regionID: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|,
name|getTableInfo
argument_list|()
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleOverlapInRegionChain
parameter_list|(
name|HbckRegionInfo
name|hi1
parameter_list|,
name|HbckRegionInfo
name|hi2
parameter_list|)
throws|throws
name|IOException
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|OVERLAP_IN_REGION_CHAIN
argument_list|,
literal|"There is an overlap in the region chain."
argument_list|,
name|getTableInfo
argument_list|()
argument_list|,
name|hi1
argument_list|,
name|hi2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleHoleInRegionChain
parameter_list|(
name|byte
index|[]
name|holeStart
parameter_list|,
name|byte
index|[]
name|holeStop
parameter_list|)
throws|throws
name|IOException
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|HOLE_IN_REGION_CHAIN
argument_list|,
literal|"There is a hole in the region chain between "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|holeStart
argument_list|)
operator|+
literal|" and "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|holeStop
argument_list|)
operator|+
literal|".  You need to create a new .regioninfo and region "
operator|+
literal|"dir in hdfs to plug the hole."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This handler fixes integrity errors from hdfs information.  There are    * basically three classes of integrity problems 1) holes, 2) overlaps, and    * 3) invalid regions.    *    * This class overrides methods that fix holes and the overlap group case.    * Individual cases of particular overlaps are handled by the general    * overlap group merge repair case.    *    * If hbase is online, this forces regions offline before doing merge    * operations.    */
class|class
name|HDFSIntegrityFixer
extends|extends
name|IntegrityFixSuggester
block|{
name|Configuration
name|conf
decl_stmt|;
name|boolean
name|fixOverlaps
init|=
literal|true
decl_stmt|;
name|HDFSIntegrityFixer
parameter_list|(
name|HbckTableInfo
name|ti
parameter_list|,
name|HbckErrorReporter
name|errors
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|boolean
name|fixHoles
parameter_list|,
name|boolean
name|fixOverlaps
parameter_list|)
block|{
name|super
argument_list|(
name|ti
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|fixOverlaps
operator|=
name|fixOverlaps
expr_stmt|;
comment|// TODO properly use fixHoles
block|}
comment|/**      * This is a special case hole -- when the first region of a table is      * missing from META, HBase doesn't acknowledge the existance of the      * table.      */
annotation|@
name|Override
specifier|public
name|void
name|handleRegionStartKeyNotEmpty
parameter_list|(
name|HbckRegionInfo
name|next
parameter_list|)
throws|throws
name|IOException
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|FIRST_REGION_STARTKEY_NOT_EMPTY
argument_list|,
literal|"First region should start with an empty key.  Creating a new "
operator|+
literal|"region and regioninfo in HDFS to plug the hole."
argument_list|,
name|getTableInfo
argument_list|()
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|TableDescriptor
name|htd
init|=
name|getTableInfo
argument_list|()
operator|.
name|getTableDescriptor
argument_list|()
decl_stmt|;
comment|// from special EMPTY_START_ROW to next region's startKey
name|RegionInfo
name|newRegion
init|=
name|RegionInfoBuilder
operator|.
name|newBuilder
argument_list|(
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|.
name|setStartKey
argument_list|(
name|HConstants
operator|.
name|EMPTY_START_ROW
argument_list|)
operator|.
name|setEndKey
argument_list|(
name|next
operator|.
name|getStartKey
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// TODO test
name|HRegion
name|region
init|=
name|HBaseFsckRepair
operator|.
name|createHDFSRegionDir
argument_list|(
name|conf
argument_list|,
name|newRegion
argument_list|,
name|htd
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Table region start key was not empty.  Created new empty region: "
operator|+
name|newRegion
operator|+
literal|" "
operator|+
name|region
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|fixes
operator|++
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleRegionEndKeyNotEmpty
parameter_list|(
name|byte
index|[]
name|curEndKey
parameter_list|)
throws|throws
name|IOException
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|LAST_REGION_ENDKEY_NOT_EMPTY
argument_list|,
literal|"Last region should end with an empty key.  Creating a new "
operator|+
literal|"region and regioninfo in HDFS to plug the hole."
argument_list|,
name|getTableInfo
argument_list|()
argument_list|)
expr_stmt|;
name|TableDescriptor
name|htd
init|=
name|getTableInfo
argument_list|()
operator|.
name|getTableDescriptor
argument_list|()
decl_stmt|;
comment|// from curEndKey to EMPTY_START_ROW
name|RegionInfo
name|newRegion
init|=
name|RegionInfoBuilder
operator|.
name|newBuilder
argument_list|(
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|.
name|setStartKey
argument_list|(
name|curEndKey
argument_list|)
operator|.
name|setEndKey
argument_list|(
name|HConstants
operator|.
name|EMPTY_START_ROW
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HRegion
name|region
init|=
name|HBaseFsckRepair
operator|.
name|createHDFSRegionDir
argument_list|(
name|conf
argument_list|,
name|newRegion
argument_list|,
name|htd
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Table region end key was not empty.  Created new empty region: "
operator|+
name|newRegion
operator|+
literal|" "
operator|+
name|region
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|fixes
operator|++
expr_stmt|;
block|}
comment|/**      * There is a hole in the hdfs regions that violates the table integrity      * rules.  Create a new empty region that patches the hole.      */
annotation|@
name|Override
specifier|public
name|void
name|handleHoleInRegionChain
parameter_list|(
name|byte
index|[]
name|holeStartKey
parameter_list|,
name|byte
index|[]
name|holeStopKey
parameter_list|)
throws|throws
name|IOException
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|HbckErrorReporter
operator|.
name|ERROR_CODE
operator|.
name|HOLE_IN_REGION_CHAIN
argument_list|,
literal|"There is a hole in the region chain between "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|holeStartKey
argument_list|)
operator|+
literal|" and "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|holeStopKey
argument_list|)
operator|+
literal|".  Creating a new regioninfo and region "
operator|+
literal|"dir in hdfs to plug the hole."
argument_list|)
expr_stmt|;
name|TableDescriptor
name|htd
init|=
name|getTableInfo
argument_list|()
operator|.
name|getTableDescriptor
argument_list|()
decl_stmt|;
name|RegionInfo
name|newRegion
init|=
name|RegionInfoBuilder
operator|.
name|newBuilder
argument_list|(
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|.
name|setStartKey
argument_list|(
name|holeStartKey
argument_list|)
operator|.
name|setEndKey
argument_list|(
name|holeStopKey
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HRegion
name|region
init|=
name|HBaseFsckRepair
operator|.
name|createHDFSRegionDir
argument_list|(
name|conf
argument_list|,
name|newRegion
argument_list|,
name|htd
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Plugged hole by creating new empty region: "
operator|+
name|newRegion
operator|+
literal|" "
operator|+
name|region
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|fixes
operator|++
expr_stmt|;
block|}
comment|/**      * This takes set of overlapping regions and merges them into a single      * region.  This covers cases like degenerate regions, shared start key,      * general overlaps, duplicate ranges, and partial overlapping regions.      *      * Cases:      * - Clean regions that overlap      * - Only .oldlogs regions (can't find start/stop range, or figure out)      *      * This is basically threadsafe, except for the fixer increment in mergeOverlaps.      */
annotation|@
name|Override
specifier|public
name|void
name|handleOverlapGroup
parameter_list|(
name|Collection
argument_list|<
name|HbckRegionInfo
argument_list|>
name|overlap
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|overlap
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|overlap
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|fixOverlaps
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not attempting to repair overlaps."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|overlap
operator|.
name|size
argument_list|()
operator|>
name|hbck
operator|.
name|getMaxMerge
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Overlap group has "
operator|+
name|overlap
operator|.
name|size
argument_list|()
operator|+
literal|" overlapping "
operator|+
literal|"regions which is greater than "
operator|+
name|hbck
operator|.
name|getMaxMerge
argument_list|()
operator|+
literal|", the max number of regions to merge"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hbck
operator|.
name|shouldSidelineBigOverlaps
argument_list|()
condition|)
block|{
comment|// we only sideline big overlapped groups that exceeds the max number of regions to merge
name|sidelineBigOverlaps
argument_list|(
name|overlap
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|hbck
operator|.
name|shouldRemoveParents
argument_list|()
condition|)
block|{
name|removeParentsAndFixSplits
argument_list|(
name|overlap
argument_list|)
expr_stmt|;
block|}
name|mergeOverlaps
argument_list|(
name|overlap
argument_list|)
expr_stmt|;
block|}
name|void
name|removeParentsAndFixSplits
parameter_list|(
name|Collection
argument_list|<
name|HbckRegionInfo
argument_list|>
name|overlap
parameter_list|)
throws|throws
name|IOException
block|{
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|range
init|=
literal|null
decl_stmt|;
name|HbckRegionInfo
name|parent
init|=
literal|null
decl_stmt|;
name|HbckRegionInfo
name|daughterA
init|=
literal|null
decl_stmt|;
name|HbckRegionInfo
name|daughterB
init|=
literal|null
decl_stmt|;
name|Collection
argument_list|<
name|HbckRegionInfo
argument_list|>
name|daughters
init|=
operator|new
name|ArrayList
argument_list|<
name|HbckRegionInfo
argument_list|>
argument_list|(
name|overlap
argument_list|)
decl_stmt|;
name|String
name|thread
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"== ["
operator|+
name|thread
operator|+
literal|"] Attempting fix splits in overlap state."
argument_list|)
expr_stmt|;
comment|// we only can handle a single split per group at the time
if|if
condition|(
name|overlap
operator|.
name|size
argument_list|()
operator|>
literal|3
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Too many overlaps were found on this group, falling back to regular merge."
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|HbckRegionInfo
name|hi
range|:
name|overlap
control|)
block|{
if|if
condition|(
name|range
operator|==
literal|null
condition|)
block|{
name|range
operator|=
operator|new
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|(
name|hi
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|hi
operator|.
name|getEndKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|RegionSplitCalculator
operator|.
name|BYTES_COMPARATOR
operator|.
name|compare
argument_list|(
name|hi
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|range
operator|.
name|getFirst
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
name|range
operator|.
name|setFirst
argument_list|(
name|hi
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RegionSplitCalculator
operator|.
name|BYTES_COMPARATOR
operator|.
name|compare
argument_list|(
name|hi
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|range
operator|.
name|getSecond
argument_list|()
argument_list|)
operator|>
literal|0
condition|)
block|{
name|range
operator|.
name|setSecond
argument_list|(
name|hi
operator|.
name|getEndKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"This group range is ["
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|range
operator|.
name|getFirst
argument_list|()
argument_list|)
operator|+
literal|", "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|range
operator|.
name|getSecond
argument_list|()
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
comment|// attempt to find a possible parent for the edge case of a split
for|for
control|(
name|HbckRegionInfo
name|hi
range|:
name|overlap
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|hi
operator|.
name|getHdfsHRI
argument_list|()
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|range
operator|.
name|getFirst
argument_list|()
argument_list|)
operator|==
literal|0
operator|&&
name|Bytes
operator|.
name|compareTo
argument_list|(
name|hi
operator|.
name|getHdfsHRI
argument_list|()
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|range
operator|.
name|getSecond
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"This is a parent for this group: "
operator|+
name|hi
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|parent
operator|=
name|hi
expr_stmt|;
block|}
block|}
comment|// Remove parent regions from daughters collection
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|daughters
operator|.
name|remove
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// Lets verify that daughters share the regionID at split time and they
comment|// were created after the parent
for|for
control|(
name|HbckRegionInfo
name|hi
range|:
name|daughters
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|hi
operator|.
name|getHdfsHRI
argument_list|()
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|range
operator|.
name|getFirst
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|parent
operator|.
name|getHdfsHRI
argument_list|()
operator|.
name|getRegionId
argument_list|()
operator|<
name|hi
operator|.
name|getHdfsHRI
argument_list|()
operator|.
name|getRegionId
argument_list|()
condition|)
block|{
name|daughterA
operator|=
name|hi
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|hi
operator|.
name|getHdfsHRI
argument_list|()
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|range
operator|.
name|getSecond
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|parent
operator|.
name|getHdfsHRI
argument_list|()
operator|.
name|getRegionId
argument_list|()
operator|<
name|hi
operator|.
name|getHdfsHRI
argument_list|()
operator|.
name|getRegionId
argument_list|()
condition|)
block|{
name|daughterB
operator|=
name|hi
expr_stmt|;
block|}
block|}
block|}
comment|// daughters must share the same regionID and we should have a parent too
if|if
condition|(
name|daughterA
operator|.
name|getHdfsHRI
argument_list|()
operator|.
name|getRegionId
argument_list|()
operator|!=
name|daughterB
operator|.
name|getHdfsHRI
argument_list|()
operator|.
name|getRegionId
argument_list|()
operator|||
name|parent
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Found parent: "
operator|+
name|parent
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Found potential daughter a: "
operator|+
name|daughterA
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Found potential daughter b: "
operator|+
name|daughterB
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to fix parent in overlap by removing the parent."
argument_list|)
expr_stmt|;
try|try
block|{
name|hbck
operator|.
name|closeRegion
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Parent region could not be closed, continuing with regular merge..."
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Parent region could not be closed, continuing with regular merge..."
argument_list|,
name|ie
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|hbck
operator|.
name|offline
argument_list|(
name|parent
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to offline parent region: "
operator|+
name|parent
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|".  Just continuing with regular merge... "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|HBaseFsckRepair
operator|.
name|removeParentInMeta
argument_list|(
name|conf
argument_list|,
name|parent
operator|.
name|getHdfsHRI
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to remove parent region in META: "
operator|+
name|parent
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|".  Just continuing with regular merge... "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return;
block|}
name|hbck
operator|.
name|sidelineRegionDir
argument_list|(
name|fs
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"["
operator|+
name|thread
operator|+
literal|"] Sidelined parent region dir "
operator|+
name|parent
operator|.
name|getHdfsRegionDir
argument_list|()
operator|+
literal|" into "
operator|+
name|hbck
operator|.
name|getSidelineDir
argument_list|()
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|debugLsr
argument_list|(
name|parent
operator|.
name|getHdfsRegionDir
argument_list|()
argument_list|)
expr_stmt|;
comment|// Make sure we don't have the parents and daughters around
name|overlap
operator|.
name|remove
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|overlap
operator|.
name|remove
argument_list|(
name|daughterA
argument_list|)
expr_stmt|;
name|overlap
operator|.
name|remove
argument_list|(
name|daughterB
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Done fixing split."
argument_list|)
expr_stmt|;
block|}
name|void
name|mergeOverlaps
parameter_list|(
name|Collection
argument_list|<
name|HbckRegionInfo
argument_list|>
name|overlap
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|thread
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"== ["
operator|+
name|thread
operator|+
literal|"] Merging regions into one region: "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|join
argument_list|(
name|overlap
argument_list|)
argument_list|)
expr_stmt|;
comment|// get the min / max range and close all concerned regions
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|range
init|=
literal|null
decl_stmt|;
for|for
control|(
name|HbckRegionInfo
name|hi
range|:
name|overlap
control|)
block|{
if|if
condition|(
name|range
operator|==
literal|null
condition|)
block|{
name|range
operator|=
operator|new
name|Pair
argument_list|<>
argument_list|(
name|hi
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|hi
operator|.
name|getEndKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|RegionSplitCalculator
operator|.
name|BYTES_COMPARATOR
operator|.
name|compare
argument_list|(
name|hi
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|range
operator|.
name|getFirst
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
name|range
operator|.
name|setFirst
argument_list|(
name|hi
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RegionSplitCalculator
operator|.
name|BYTES_COMPARATOR
operator|.
name|compare
argument_list|(
name|hi
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|range
operator|.
name|getSecond
argument_list|()
argument_list|)
operator|>
literal|0
condition|)
block|{
name|range
operator|.
name|setSecond
argument_list|(
name|hi
operator|.
name|getEndKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// need to close files so delete can happen.
name|LOG
operator|.
name|debug
argument_list|(
literal|"["
operator|+
name|thread
operator|+
literal|"] Closing region before moving data around: "
operator|+
name|hi
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"["
operator|+
name|thread
operator|+
literal|"] Contained region dir before close"
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|debugLsr
argument_list|(
name|hi
operator|.
name|getHdfsRegionDir
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"["
operator|+
name|thread
operator|+
literal|"] Closing region: "
operator|+
name|hi
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|closeRegion
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"["
operator|+
name|thread
operator|+
literal|"] Was unable to close region "
operator|+
name|hi
operator|+
literal|".  Just continuing... "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"["
operator|+
name|thread
operator|+
literal|"] Was unable to close region "
operator|+
name|hi
operator|+
literal|".  Just continuing... "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"["
operator|+
name|thread
operator|+
literal|"] Offlining region: "
operator|+
name|hi
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|offline
argument_list|(
name|hi
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"["
operator|+
name|thread
operator|+
literal|"] Unable to offline region from master: "
operator|+
name|hi
operator|+
literal|".  Just continuing... "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
comment|// create new empty container region.
name|TableDescriptor
name|htd
init|=
name|getTableInfo
argument_list|()
operator|.
name|getTableDescriptor
argument_list|()
decl_stmt|;
comment|// from start key to end Key
name|RegionInfo
name|newRegion
init|=
name|RegionInfoBuilder
operator|.
name|newBuilder
argument_list|(
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|.
name|setStartKey
argument_list|(
name|range
operator|.
name|getFirst
argument_list|()
argument_list|)
operator|.
name|setEndKey
argument_list|(
name|range
operator|.
name|getSecond
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HRegion
name|region
init|=
name|HBaseFsckRepair
operator|.
name|createHDFSRegionDir
argument_list|(
name|conf
argument_list|,
name|newRegion
argument_list|,
name|htd
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"["
operator|+
name|thread
operator|+
literal|"] Created new empty container region: "
operator|+
name|newRegion
operator|+
literal|" to contain regions: "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|join
argument_list|(
name|overlap
argument_list|)
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|debugLsr
argument_list|(
name|region
operator|.
name|getRegionFileSystem
argument_list|()
operator|.
name|getRegionDir
argument_list|()
argument_list|)
expr_stmt|;
comment|// all target regions are closed, should be able to safely cleanup.
name|boolean
name|didFix
init|=
literal|false
decl_stmt|;
name|Path
name|target
init|=
name|region
operator|.
name|getRegionFileSystem
argument_list|()
operator|.
name|getRegionDir
argument_list|()
decl_stmt|;
for|for
control|(
name|HbckRegionInfo
name|contained
range|:
name|overlap
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"["
operator|+
name|thread
operator|+
literal|"] Merging "
operator|+
name|contained
operator|+
literal|" into "
operator|+
name|target
argument_list|)
expr_stmt|;
name|int
name|merges
init|=
name|hbck
operator|.
name|mergeRegionDirs
argument_list|(
name|target
argument_list|,
name|contained
argument_list|)
decl_stmt|;
if|if
condition|(
name|merges
operator|>
literal|0
condition|)
block|{
name|didFix
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|didFix
condition|)
block|{
name|hbck
operator|.
name|fixes
operator|++
expr_stmt|;
block|}
block|}
comment|/**      * Sideline some regions in a big overlap group so that it      * will have fewer regions, and it is easier to merge them later on.      *      * @param bigOverlap the overlapped group with regions more than maxMerge      */
name|void
name|sidelineBigOverlaps
parameter_list|(
name|Collection
argument_list|<
name|HbckRegionInfo
argument_list|>
name|bigOverlap
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|overlapsToSideline
init|=
name|bigOverlap
operator|.
name|size
argument_list|()
operator|-
name|hbck
operator|.
name|getMaxMerge
argument_list|()
decl_stmt|;
if|if
condition|(
name|overlapsToSideline
operator|>
name|hbck
operator|.
name|getMaxOverlapsToSideline
argument_list|()
condition|)
block|{
name|overlapsToSideline
operator|=
name|hbck
operator|.
name|getMaxOverlapsToSideline
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|HbckRegionInfo
argument_list|>
name|regionsToSideline
init|=
name|RegionSplitCalculator
operator|.
name|findBigRanges
argument_list|(
name|bigOverlap
argument_list|,
name|overlapsToSideline
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|HbckRegionInfo
name|regionToSideline
range|:
name|regionsToSideline
control|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Closing region: "
operator|+
name|regionToSideline
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|closeRegion
argument_list|(
name|regionToSideline
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Was unable to close region "
operator|+
name|regionToSideline
operator|+
literal|".  Just continuing... "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Was unable to close region "
operator|+
name|regionToSideline
operator|+
literal|".  Just continuing... "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Offlining region: "
operator|+
name|regionToSideline
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|offline
argument_list|(
name|regionToSideline
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to offline region from master: "
operator|+
name|regionToSideline
operator|+
literal|".  Just continuing... "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Before sideline big overlapped region: "
operator|+
name|regionToSideline
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|sidelineRegionDir
init|=
name|hbck
operator|.
name|sidelineRegionDir
argument_list|(
name|fs
argument_list|,
name|TO_BE_LOADED
argument_list|,
name|regionToSideline
argument_list|)
decl_stmt|;
if|if
condition|(
name|sidelineRegionDir
operator|!=
literal|null
condition|)
block|{
name|sidelinedRegions
operator|.
name|put
argument_list|(
name|sidelineRegionDir
argument_list|,
name|regionToSideline
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"After sidelined big overlapped region: "
operator|+
name|regionToSideline
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|sidelineRegionDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|fixes
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Check the region chain (from META) of this table.  We are looking for    * holes, overlaps, and cycles.    * @return false if there are errors    */
specifier|public
name|boolean
name|checkRegionChain
parameter_list|(
name|TableIntegrityErrorHandler
name|handler
parameter_list|)
throws|throws
name|IOException
block|{
comment|// When table is disabled no need to check for the region chain. Some of the regions
comment|// accidently if deployed, this below code might report some issues like missing start
comment|// or end regions or region hole in chain and may try to fix which is unwanted.
if|if
condition|(
name|hbck
operator|.
name|isTableDisabled
argument_list|(
name|this
operator|.
name|tableName
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|int
name|originalErrorsCount
init|=
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|getErrorList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|Multimap
argument_list|<
name|byte
index|[]
argument_list|,
name|HbckRegionInfo
argument_list|>
name|regions
init|=
name|sc
operator|.
name|calcCoverage
argument_list|()
decl_stmt|;
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|splits
init|=
name|sc
operator|.
name|getSplits
argument_list|()
decl_stmt|;
name|byte
index|[]
name|prevKey
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|problemKey
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|splits
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// no region for this table
name|handler
operator|.
name|handleHoleInRegionChain
argument_list|(
name|HConstants
operator|.
name|EMPTY_START_ROW
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|byte
index|[]
name|key
range|:
name|splits
control|)
block|{
name|Collection
argument_list|<
name|HbckRegionInfo
argument_list|>
name|ranges
init|=
name|regions
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|prevKey
operator|==
literal|null
operator|&&
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|key
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
condition|)
block|{
for|for
control|(
name|HbckRegionInfo
name|rng
range|:
name|ranges
control|)
block|{
name|handler
operator|.
name|handleRegionStartKeyNotEmpty
argument_list|(
name|rng
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check for degenerate ranges
for|for
control|(
name|HbckRegionInfo
name|rng
range|:
name|ranges
control|)
block|{
comment|// special endkey case converts '' to null
name|byte
index|[]
name|endKey
init|=
name|rng
operator|.
name|getEndKey
argument_list|()
decl_stmt|;
name|endKey
operator|=
operator|(
name|endKey
operator|.
name|length
operator|==
literal|0
operator|)
condition|?
literal|null
else|:
name|endKey
expr_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|rng
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|endKey
argument_list|)
condition|)
block|{
name|handler
operator|.
name|handleDegenerateRegion
argument_list|(
name|rng
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ranges
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// this split key is ok -- no overlap, not a hole.
if|if
condition|(
name|problemKey
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"reached end of problem group: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|problemKey
operator|=
literal|null
expr_stmt|;
comment|// fell through, no more problem.
block|}
elseif|else
if|if
condition|(
name|ranges
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// set the new problem key group name, if already have problem key, just
comment|// keep using it.
if|if
condition|(
name|problemKey
operator|==
literal|null
condition|)
block|{
comment|// only for overlap regions.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Naming new problem group: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|problemKey
operator|=
name|key
expr_stmt|;
block|}
name|overlapGroups
operator|.
name|putAll
argument_list|(
name|problemKey
argument_list|,
name|ranges
argument_list|)
expr_stmt|;
comment|// record errors
name|ArrayList
argument_list|<
name|HbckRegionInfo
argument_list|>
name|subRange
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|ranges
argument_list|)
decl_stmt|;
comment|//  this dumb and n^2 but this shouldn't happen often
for|for
control|(
name|HbckRegionInfo
name|r1
range|:
name|ranges
control|)
block|{
if|if
condition|(
name|r1
operator|.
name|getReplicaId
argument_list|()
operator|!=
name|RegionInfo
operator|.
name|DEFAULT_REPLICA_ID
condition|)
block|{
continue|continue;
block|}
name|subRange
operator|.
name|remove
argument_list|(
name|r1
argument_list|)
expr_stmt|;
for|for
control|(
name|HbckRegionInfo
name|r2
range|:
name|subRange
control|)
block|{
if|if
condition|(
name|r2
operator|.
name|getReplicaId
argument_list|()
operator|!=
name|RegionInfo
operator|.
name|DEFAULT_REPLICA_ID
condition|)
block|{
continue|continue;
block|}
comment|// general case of same start key
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|r1
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|r2
operator|.
name|getStartKey
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|handler
operator|.
name|handleDuplicateStartKeys
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|r1
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|r2
operator|.
name|getStartKey
argument_list|()
argument_list|)
operator|==
literal|0
operator|&&
name|r1
operator|.
name|getHdfsHRI
argument_list|()
operator|.
name|getRegionId
argument_list|()
operator|==
name|r2
operator|.
name|getHdfsHRI
argument_list|()
operator|.
name|getRegionId
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"this is a split, log to splits"
argument_list|)
expr_stmt|;
name|handler
operator|.
name|handleSplit
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// overlap
name|handler
operator|.
name|handleOverlapInRegionChain
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ranges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|problemKey
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"reached end of problem group: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|problemKey
operator|=
literal|null
expr_stmt|;
name|byte
index|[]
name|holeStopKey
init|=
name|sc
operator|.
name|getSplits
argument_list|()
operator|.
name|higher
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// if higher key is null we reached the top.
if|if
condition|(
name|holeStopKey
operator|!=
literal|null
condition|)
block|{
comment|// hole
name|handler
operator|.
name|handleHoleInRegionChain
argument_list|(
name|key
argument_list|,
name|holeStopKey
argument_list|)
expr_stmt|;
block|}
block|}
name|prevKey
operator|=
name|key
expr_stmt|;
block|}
comment|// When the last region of a table is proper and having an empty end key, 'prevKey'
comment|// will be null.
if|if
condition|(
name|prevKey
operator|!=
literal|null
condition|)
block|{
name|handler
operator|.
name|handleRegionEndKeyNotEmpty
argument_list|(
name|prevKey
argument_list|)
expr_stmt|;
block|}
comment|// TODO fold this into the TableIntegrityHandler
if|if
condition|(
name|hbck
operator|.
name|getConf
argument_list|()
operator|.
name|getBoolean
argument_list|(
literal|"hbasefsck.overlap.merge.parallel"
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|boolean
name|ok
init|=
name|handleOverlapsParallel
argument_list|(
name|handler
argument_list|,
name|prevKey
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|Collection
argument_list|<
name|HbckRegionInfo
argument_list|>
name|overlap
range|:
name|overlapGroups
operator|.
name|asMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|handler
operator|.
name|handleOverlapGroup
argument_list|(
name|overlap
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hbck
operator|.
name|shouldDisplayFullReport
argument_list|()
condition|)
block|{
comment|// do full region split map dump
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|print
argument_list|(
literal|"---- Table '"
operator|+
name|this
operator|.
name|tableName
operator|+
literal|"': region split map"
argument_list|)
expr_stmt|;
name|dump
argument_list|(
name|splits
argument_list|,
name|regions
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|print
argument_list|(
literal|"---- Table '"
operator|+
name|this
operator|.
name|tableName
operator|+
literal|"': overlap groups"
argument_list|)
expr_stmt|;
name|dumpOverlapProblems
argument_list|(
name|overlapGroups
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|print
argument_list|(
literal|"There are "
operator|+
name|overlapGroups
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" overlap groups with "
operator|+
name|overlapGroups
operator|.
name|size
argument_list|()
operator|+
literal|" overlapping regions"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sidelinedRegions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Sidelined big overlapped regions, please bulk load them!"
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|print
argument_list|(
literal|"---- Table '"
operator|+
name|this
operator|.
name|tableName
operator|+
literal|"': sidelined big overlapped regions"
argument_list|)
expr_stmt|;
name|dumpSidelinedRegions
argument_list|(
name|sidelinedRegions
argument_list|)
expr_stmt|;
block|}
return|return
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|getErrorList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|originalErrorsCount
return|;
block|}
specifier|private
name|boolean
name|handleOverlapsParallel
parameter_list|(
name|TableIntegrityErrorHandler
name|handler
parameter_list|,
name|byte
index|[]
name|prevKey
parameter_list|)
throws|throws
name|IOException
block|{
comment|// we parallelize overlap handler for the case we have lots of groups to fix.  We can
comment|// safely assume each group is independent.
name|List
argument_list|<
name|HBaseFsck
operator|.
name|WorkItemOverlapMerge
argument_list|>
name|merges
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|overlapGroups
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Future
argument_list|<
name|Void
argument_list|>
argument_list|>
name|rets
decl_stmt|;
for|for
control|(
name|Collection
argument_list|<
name|HbckRegionInfo
argument_list|>
name|overlap
range|:
name|overlapGroups
operator|.
name|asMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
comment|//
name|merges
operator|.
name|add
argument_list|(
operator|new
name|HBaseFsck
operator|.
name|WorkItemOverlapMerge
argument_list|(
name|overlap
argument_list|,
name|handler
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|rets
operator|=
name|hbck
operator|.
name|executor
operator|.
name|invokeAll
argument_list|(
name|merges
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Overlap merges were interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|merges
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|HBaseFsck
operator|.
name|WorkItemOverlapMerge
name|work
init|=
name|merges
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|Void
argument_list|>
name|f
init|=
name|rets
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
name|f
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to merge overlap group"
operator|+
name|work
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Waiting for overlap merges was interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * This dumps data in a visually reasonable way for visual debugging    */
specifier|private
name|void
name|dump
parameter_list|(
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|splits
parameter_list|,
name|Multimap
argument_list|<
name|byte
index|[]
argument_list|,
name|HbckRegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
comment|// we display this way because the last end key should be displayed as well.
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|k
range|:
name|splits
control|)
block|{
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// clear out existing buffer, if any.
name|sb
operator|.
name|append
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|k
argument_list|)
operator|+
literal|":\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|HbckRegionInfo
name|r
range|:
name|regions
operator|.
name|get
argument_list|(
name|k
argument_list|)
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"[ "
operator|+
name|r
operator|.
name|toString
argument_list|()
operator|+
literal|", "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|r
operator|.
name|getEndKey
argument_list|()
argument_list|)
operator|+
literal|"]\t"
argument_list|)
expr_stmt|;
block|}
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|print
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|dumpOverlapProblems
parameter_list|(
name|Multimap
argument_list|<
name|byte
index|[]
argument_list|,
name|HbckRegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
comment|// we display this way because the last end key should be displayed as
comment|// well.
for|for
control|(
name|byte
index|[]
name|k
range|:
name|regions
operator|.
name|keySet
argument_list|()
control|)
block|{
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|print
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|k
argument_list|)
operator|+
literal|":"
argument_list|)
expr_stmt|;
for|for
control|(
name|HbckRegionInfo
name|r
range|:
name|regions
operator|.
name|get
argument_list|(
name|k
argument_list|)
control|)
block|{
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|print
argument_list|(
literal|"[ "
operator|+
name|r
operator|.
name|toString
argument_list|()
operator|+
literal|", "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|r
operator|.
name|getEndKey
argument_list|()
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|print
argument_list|(
literal|"----"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|dumpSidelinedRegions
parameter_list|(
name|Map
argument_list|<
name|Path
argument_list|,
name|HbckRegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|HbckRegionInfo
argument_list|>
name|entry
range|:
name|regions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TableName
name|tableName
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|Path
name|path
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|print
argument_list|(
literal|"This sidelined region dir should be bulk loaded: "
operator|+
name|path
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|hbck
operator|.
name|getErrors
argument_list|()
operator|.
name|print
argument_list|(
literal|"Bulk load command looks like: "
operator|+
name|BulkLoadHFilesTool
operator|.
name|NAME
operator|+
literal|" "
operator|+
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
literal|" "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

