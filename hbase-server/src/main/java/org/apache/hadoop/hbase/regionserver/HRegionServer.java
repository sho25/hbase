begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|Thread
operator|.
name|UncaughtExceptionHandler
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|MemoryType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|MemoryUsage
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|BindException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|MalformedObjectNameException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServlet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|SystemUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|math
operator|.
name|RandomUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ChoreService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClockOutOfSyncException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CoordinatedStateManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CoordinatedStateManagerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseInterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HealthCheckChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaTableAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ScheduledChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Stoppable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableDescriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|YouAreDeadException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ZNodeClearer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ClusterConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|NonceGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RpcRetryingCallerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|conf
operator|.
name|ConfigurationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|conf
operator|.
name|ConfigurationObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coordination
operator|.
name|BaseCoordinatedStateManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coordination
operator|.
name|SplitLogWorkerCoordination
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|CoprocessorHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|RegionMovedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|RegionOpeningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|UnknownProtocolException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|fs
operator|.
name|HFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|http
operator|.
name|InfoServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|CacheConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|util
operator|.
name|MemorySizeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|CoprocessorRpcUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcClientFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcControllerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcServerInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|ServerNotRunningYetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|ServerRpcController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|HMaster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|TableLockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|BaseLoadBalancer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mob
operator|.
name|MobCacheConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure
operator|.
name|RegionServerProcedureManagerHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|RegionServerQuotaManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|compactions
operator|.
name|CompactionConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|compactions
operator|.
name|CompactionProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|CloseMetaHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|CloseRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|RegionReplicaFlushHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|throttle
operator|.
name|FlushThroughputControllerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|throttle
operator|.
name|ThroughputController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|MetricsWAL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|WALActionsListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|regionserver
operator|.
name|ReplicationLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|Superusers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|UserProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|BlockingRpcChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ServiceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|UnsafeByteOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|RequestConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|CoprocessorServiceCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|CoprocessorServiceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|CoprocessorServiceResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClusterStatusProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClusterStatusProtos
operator|.
name|RegionLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClusterStatusProtos
operator|.
name|RegionStoreSequenceIds
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|Coprocessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|Coprocessor
operator|.
name|Builder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|NameStringPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|RegionServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|RegionSpecifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|RegionSpecifier
operator|.
name|RegionSpecifierType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetProcedureResultRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetProcedureResultResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|GetLastFlushedSequenceIdRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|GetLastFlushedSequenceIdResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionServerReportRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionServerStartupRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionServerStartupResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionServerStatusService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionStateTransition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionStateTransition
operator|.
name|TransitionCode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|ReportRSFatalErrorRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|ReportRegionStateTransitionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|ReportRegionStateTransitionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|SplitTableRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|SplitTableRegionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|trace
operator|.
name|SpanReceiverHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Addressing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CompressionTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSTableDescriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ForeignExceptionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HasThread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|JSONBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|JvmPauseMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ServerRegionReplicaUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Sleeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|AbstractFSWALProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WAL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ClusterStatusTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MasterAddressTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MetaTableLocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RecoveringRegionWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKClusterId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKSplitLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperNodeTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|NoNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|sun
operator|.
name|misc
operator|.
name|Signal
import|;
end_import

begin_import
import|import
name|sun
operator|.
name|misc
operator|.
name|SignalHandler
import|;
end_import

begin_comment
comment|/**  * HRegionServer makes a set of HRegions available to clients. It checks in with  * the HMaster. There are many HRegionServers in a single HBase deployment.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|TOOLS
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"deprecation"
block|,
literal|"restriction"
block|}
argument_list|)
specifier|public
class|class
name|HRegionServer
extends|extends
name|HasThread
implements|implements
name|RegionServerServices
implements|,
name|LastSequenceId
implements|,
name|ConfigurationObserver
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HRegionServer
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * For testing only!  Set to true to skip notifying region assignment to master .    */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"MS_SHOULD_BE_FINAL"
argument_list|)
specifier|public
specifier|static
name|boolean
name|TEST_SKIP_REPORTING_TRANSITION
init|=
literal|false
decl_stmt|;
comment|/*    * Strings to be used in forming the exception message for    * RegionsAlreadyInTransitionException.    */
specifier|protected
specifier|static
specifier|final
name|String
name|OPEN
init|=
literal|"OPEN"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|CLOSE
init|=
literal|"CLOSE"
decl_stmt|;
comment|//RegionName vs current action in progress
comment|//true - if open region action in progress
comment|//false - if close region action in progress
specifier|protected
specifier|final
name|ConcurrentMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Boolean
argument_list|>
name|regionsInTransitionInRS
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Boolean
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
comment|// Cache flushing
specifier|protected
name|MemStoreFlusher
name|cacheFlusher
decl_stmt|;
specifier|protected
name|HeapMemoryManager
name|hMemManager
decl_stmt|;
specifier|protected
name|CountDownLatch
name|initLatch
init|=
literal|null
decl_stmt|;
comment|/**    * Cluster connection to be shared by services.    * Initialized at server startup and closed when server shuts down.    * Clients must never close it explicitly.    */
specifier|protected
name|ClusterConnection
name|clusterConnection
decl_stmt|;
comment|/*    * Long-living meta table locator, which is created when the server is started and stopped    * when server shuts down. References to this locator shall be used to perform according    * operations in EventHandlers. Primary reason for this decision is to make it mockable    * for tests.    */
specifier|protected
name|MetaTableLocator
name|metaTableLocator
decl_stmt|;
comment|// Watch if a region is out of recovering state from ZooKeeper
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
name|RecoveringRegionWatcher
name|recoveringRegionWatcher
decl_stmt|;
comment|/**    * Go here to get table descriptors.    */
specifier|protected
name|TableDescriptors
name|tableDescriptors
decl_stmt|;
comment|// Replication services. If no replication, this handler will be null.
specifier|protected
name|ReplicationSourceService
name|replicationSourceHandler
decl_stmt|;
specifier|protected
name|ReplicationSinkService
name|replicationSinkHandler
decl_stmt|;
comment|// Compactions
specifier|public
name|CompactSplitThread
name|compactSplitThread
decl_stmt|;
comment|/**    * Map of regions currently being served by this region server. Key is the    * encoded region name.  All access should be synchronized.    */
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Region
argument_list|>
name|onlineRegions
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Region
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Map of encoded region names to the DataNode locations they should be hosted on    * We store the value as InetSocketAddress since this is used only in HDFS    * API (create() that takes favored nodes as hints for placing file blocks).    * We could have used ServerName here as the value class, but we'd need to    * convert it to InetSocketAddress at some point before the HDFS API call, and    * it seems a bit weird to store ServerName since ServerName refers to RegionServers    * and here we really mean DataNode locations.    */
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|InetSocketAddress
index|[]
argument_list|>
name|regionFavoredNodesMap
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|InetSocketAddress
index|[]
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Set of regions currently being in recovering state which means it can accept writes(edits from    * previous failed region server) but not reads. A recovering region is also an online region.    */
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Region
argument_list|>
name|recoveringRegions
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Region
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// Leases
specifier|protected
name|Leases
name|leases
decl_stmt|;
comment|// Instance of the hbase executor service.
specifier|protected
name|ExecutorService
name|service
decl_stmt|;
comment|// If false, the file system has become unavailable
specifier|protected
specifier|volatile
name|boolean
name|fsOk
decl_stmt|;
specifier|protected
name|HFileSystem
name|fs
decl_stmt|;
comment|// Set when a report to the master comes back with a message asking us to
comment|// shutdown. Also set by call to stop when debugging or running unit tests
comment|// of HRegionServer in isolation.
specifier|private
specifier|volatile
name|boolean
name|stopped
init|=
literal|false
decl_stmt|;
comment|// Go down hard. Used if file system becomes unavailable and also in
comment|// debugging and unit tests.
specifier|private
specifier|volatile
name|boolean
name|abortRequested
decl_stmt|;
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|rowlocks
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// A state before we go into stopped state.  At this stage we're closing user
comment|// space regions.
specifier|private
name|boolean
name|stopping
init|=
literal|false
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|killed
init|=
literal|false
decl_stmt|;
specifier|protected
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|Path
name|rootDir
decl_stmt|;
specifier|protected
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numRetries
decl_stmt|;
specifier|protected
specifier|final
name|int
name|threadWakeFrequency
decl_stmt|;
specifier|protected
specifier|final
name|int
name|msgInterval
decl_stmt|;
specifier|protected
specifier|final
name|int
name|numRegionsToReport
decl_stmt|;
comment|// Stub to do region server status calls against the master.
specifier|private
specifier|volatile
name|RegionServerStatusService
operator|.
name|BlockingInterface
name|rssStub
decl_stmt|;
comment|// RPC client. Used to make the stub above that does region server status checking.
name|RpcClient
name|rpcClient
decl_stmt|;
specifier|private
name|RpcRetryingCallerFactory
name|rpcRetryingCallerFactory
decl_stmt|;
specifier|private
name|RpcControllerFactory
name|rpcControllerFactory
decl_stmt|;
specifier|private
name|UncaughtExceptionHandler
name|uncaughtExceptionHandler
decl_stmt|;
comment|// Info server. Default access so can be used by unit tests. REGIONSERVER
comment|// is name of the webapp and the attribute name used stuffing this instance
comment|// into web context.
specifier|protected
name|InfoServer
name|infoServer
decl_stmt|;
specifier|private
name|JvmPauseMonitor
name|pauseMonitor
decl_stmt|;
comment|/** region server process name */
specifier|public
specifier|static
specifier|final
name|String
name|REGIONSERVER
init|=
literal|"regionserver"
decl_stmt|;
name|MetricsRegionServer
name|metricsRegionServer
decl_stmt|;
name|MetricsTable
name|metricsTable
decl_stmt|;
specifier|private
name|SpanReceiverHost
name|spanReceiverHost
decl_stmt|;
comment|/**    * ChoreService used to schedule tasks that we want to run periodically    */
specifier|private
specifier|final
name|ChoreService
name|choreService
decl_stmt|;
comment|/*    * Check for compactions requests.    */
name|ScheduledChore
name|compactionChecker
decl_stmt|;
comment|/*    * Check for flushes    */
name|ScheduledChore
name|periodicFlusher
decl_stmt|;
specifier|protected
specifier|volatile
name|WALFactory
name|walFactory
decl_stmt|;
comment|// WAL roller. log is protected rather than private to avoid
comment|// eclipse warning when accessed by inner classes
specifier|final
name|LogRoller
name|walRoller
decl_stmt|;
comment|// flag set after we're done setting up server threads
specifier|final
name|AtomicBoolean
name|online
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// zookeeper connection and watcher
specifier|protected
name|ZooKeeperWatcher
name|zooKeeper
decl_stmt|;
comment|// master address tracker
specifier|private
name|MasterAddressTracker
name|masterAddressTracker
decl_stmt|;
comment|// Cluster Status Tracker
specifier|protected
name|ClusterStatusTracker
name|clusterStatusTracker
decl_stmt|;
comment|// Log Splitting Worker
specifier|private
name|SplitLogWorker
name|splitLogWorker
decl_stmt|;
comment|// A sleeper that sleeps for msgInterval.
specifier|protected
specifier|final
name|Sleeper
name|sleeper
decl_stmt|;
specifier|private
specifier|final
name|int
name|operationTimeout
decl_stmt|;
specifier|private
specifier|final
name|int
name|shortOperationTimeout
decl_stmt|;
specifier|private
specifier|final
name|RegionServerAccounting
name|regionServerAccounting
decl_stmt|;
comment|// Cache configuration and block cache reference
specifier|protected
name|CacheConfig
name|cacheConfig
decl_stmt|;
comment|// Cache configuration for mob
specifier|final
name|MobCacheConfig
name|mobCacheConfig
decl_stmt|;
comment|/** The health check chore. */
specifier|private
name|HealthCheckChore
name|healthCheckChore
decl_stmt|;
comment|/** The nonce manager chore. */
specifier|private
name|ScheduledChore
name|nonceManagerChore
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Service
argument_list|>
name|coprocessorServiceHandlers
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
comment|/**    * The server name the Master sees us as.  Its made from the hostname the    * master passes us, port, and server startcode. Gets set after registration    * against  Master.    */
specifier|protected
name|ServerName
name|serverName
decl_stmt|;
comment|/*    * hostname specified by hostname config    */
specifier|protected
name|String
name|useThisHostnameInstead
decl_stmt|;
comment|// key to the config parameter of server hostname
comment|// the specification of server hostname is optional. The hostname should be resolvable from
comment|// both master and region server
specifier|final
specifier|static
name|String
name|RS_HOSTNAME_KEY
init|=
literal|"hbase.regionserver.hostname"
decl_stmt|;
specifier|final
specifier|static
name|String
name|MASTER_HOSTNAME_KEY
init|=
literal|"hbase.master.hostname"
decl_stmt|;
comment|/**    * This servers startcode.    */
specifier|protected
specifier|final
name|long
name|startcode
decl_stmt|;
comment|/**    * Unique identifier for the cluster we are a part of.    */
specifier|private
name|String
name|clusterId
decl_stmt|;
comment|/**    * MX Bean for RegionServerInfo    */
specifier|private
name|ObjectName
name|mxBean
init|=
literal|null
decl_stmt|;
comment|/**    * Chore to clean periodically the moved region list    */
specifier|private
name|MovedRegionsCleaner
name|movedRegionsCleaner
decl_stmt|;
comment|// chore for refreshing store files for secondary regions
specifier|private
name|StorefileRefresherChore
name|storefileRefresher
decl_stmt|;
specifier|private
name|RegionServerCoprocessorHost
name|rsHost
decl_stmt|;
specifier|private
name|RegionServerProcedureManagerHost
name|rspmHost
decl_stmt|;
specifier|private
name|RegionServerQuotaManager
name|rsQuotaManager
decl_stmt|;
comment|// Table level lock manager for locking for region operations
specifier|protected
name|TableLockManager
name|tableLockManager
decl_stmt|;
comment|/**    * Nonce manager. Nonces are used to make operations like increment and append idempotent    * in the case where client doesn't receive the response from a successful operation and    * retries. We track the successful ops for some time via a nonce sent by client and handle    * duplicate operations (currently, by failing them; in future we might use MVCC to return    * result). Nonces are also recovered from WAL during, recovery; however, the caveats (from    * HBASE-3787) are:    * - WAL recovery is optimized, and under high load we won't read nearly nonce-timeout worth    *   of past records. If we don't read the records, we don't read and recover the nonces.    *   Some WALs within nonce-timeout at recovery may not even be present due to rolling/cleanup.    * - There's no WAL recovery during normal region move, so nonces will not be transfered.    * We can have separate additional "Nonce WAL". It will just contain bunch of numbers and    * won't be flushed on main path - because WAL itself also contains nonces, if we only flush    * it before memstore flush, for a given nonce we will either see it in the WAL (if it was    * never flushed to disk, it will be part of recovery), or we'll see it as part of the nonce    * log (or both occasionally, which doesn't matter). Nonce log file can be deleted after the    * latest nonce in it expired. It can also be recovered during move.    */
specifier|final
name|ServerNonceManager
name|nonceManager
decl_stmt|;
specifier|private
name|UserProvider
name|userProvider
decl_stmt|;
specifier|protected
specifier|final
name|RSRpcServices
name|rpcServices
decl_stmt|;
specifier|protected
name|BaseCoordinatedStateManager
name|csm
decl_stmt|;
comment|/**    * Configuration manager is used to register/deregister and notify the configuration observers    * when the regionserver is notified that there was a change in the on disk configs.    */
specifier|protected
specifier|final
name|ConfigurationManager
name|configurationManager
decl_stmt|;
specifier|private
name|CompactedHFilesDischarger
name|compactedFileDischarger
decl_stmt|;
specifier|private
specifier|volatile
name|ThroughputController
name|flushThroughputController
decl_stmt|;
specifier|protected
specifier|final
name|SecureBulkLoadManager
name|secureBulkLoadManager
decl_stmt|;
comment|/**    * Starts a HRegionServer at the default location.    */
specifier|public
name|HRegionServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|CoordinatedStateManagerFactory
operator|.
name|getCoordinatedStateManager
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Starts a HRegionServer at the default location    * @param csm implementation of CoordinatedStateManager to be used    */
specifier|public
name|HRegionServer
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|CoordinatedStateManager
name|csm
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
literal|"RegionServer"
argument_list|)
expr_stmt|;
comment|// thread name
name|this
operator|.
name|fsOk
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|MemorySizeUtil
operator|.
name|checkForClusterFreeHeapMemoryLimit
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|HFile
operator|.
name|checkHFileVersion
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|checkCodecs
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|userProvider
operator|=
name|UserProvider
operator|.
name|instantiate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|FSUtils
operator|.
name|setupShortCircuitRead
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// Disable usage of meta replicas in the regionserver
name|this
operator|.
name|conf
operator|.
name|setBoolean
argument_list|(
name|HConstants
operator|.
name|USE_META_REPLICAS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Config'ed params
name|this
operator|.
name|numRetries
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_RETRIES_NUMBER
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadWakeFrequency
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|THREAD_WAKE_FREQUENCY
argument_list|,
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|msgInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.msginterval"
argument_list|,
literal|3
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|sleeper
operator|=
operator|new
name|Sleeper
argument_list|(
name|this
operator|.
name|msgInterval
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|boolean
name|isNoncesEnabled
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|HBASE_RS_NONCES_ENABLED
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|this
operator|.
name|nonceManager
operator|=
name|isNoncesEnabled
condition|?
operator|new
name|ServerNonceManager
argument_list|(
name|this
operator|.
name|conf
argument_list|)
else|:
literal|null
expr_stmt|;
name|this
operator|.
name|numRegionsToReport
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.numregionstoreport"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|operationTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_OPERATION_TIMEOUT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_OPERATION_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|shortOperationTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_RPC_SHORTOPERATION_TIMEOUT_KEY
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_RPC_SHORTOPERATION_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|abortRequested
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|stopped
operator|=
literal|false
expr_stmt|;
name|rpcServices
operator|=
name|createRpcServices
argument_list|()
expr_stmt|;
name|this
operator|.
name|startcode
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|instanceof
name|HMaster
condition|)
block|{
name|useThisHostnameInstead
operator|=
name|conf
operator|.
name|get
argument_list|(
name|MASTER_HOSTNAME_KEY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|useThisHostnameInstead
operator|=
name|conf
operator|.
name|get
argument_list|(
name|RS_HOSTNAME_KEY
argument_list|)
expr_stmt|;
block|}
name|String
name|hostName
init|=
name|shouldUseThisHostnameInstead
argument_list|()
condition|?
name|useThisHostnameInstead
else|:
name|rpcServices
operator|.
name|isa
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|serverName
operator|=
name|ServerName
operator|.
name|valueOf
argument_list|(
name|hostName
argument_list|,
name|rpcServices
operator|.
name|isa
operator|.
name|getPort
argument_list|()
argument_list|,
name|startcode
argument_list|)
expr_stmt|;
name|rpcControllerFactory
operator|=
name|RpcControllerFactory
operator|.
name|instantiate
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|rpcRetryingCallerFactory
operator|=
name|RpcRetryingCallerFactory
operator|.
name|instantiate
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// login the zookeeper client principal (if using security)
name|ZKUtil
operator|.
name|loginClient
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|HConstants
operator|.
name|ZK_CLIENT_KEYTAB_FILE
argument_list|,
name|HConstants
operator|.
name|ZK_CLIENT_KERBEROS_PRINCIPAL
argument_list|,
name|hostName
argument_list|)
expr_stmt|;
comment|// login the server principal (if using secure Hadoop)
name|login
argument_list|(
name|userProvider
argument_list|,
name|hostName
argument_list|)
expr_stmt|;
comment|// init superusers and add the server principal (if using security)
comment|// or process owner as default super user.
name|Superusers
operator|.
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|regionServerAccounting
operator|=
operator|new
name|RegionServerAccounting
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|cacheConfig
operator|=
operator|new
name|CacheConfig
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|mobCacheConfig
operator|=
operator|new
name|MobCacheConfig
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|uncaughtExceptionHandler
operator|=
operator|new
name|UncaughtExceptionHandler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|uncaughtException
parameter_list|(
name|Thread
name|t
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
name|abort
argument_list|(
literal|"Uncaught exception in service thread "
operator|+
name|t
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
expr_stmt|;
name|initializeFileSystem
argument_list|()
expr_stmt|;
name|service
operator|=
operator|new
name|ExecutorService
argument_list|(
name|getServerName
argument_list|()
operator|.
name|toShortString
argument_list|()
argument_list|)
expr_stmt|;
name|spanReceiverHost
operator|=
name|SpanReceiverHost
operator|.
name|getInstance
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
comment|// Some unit tests don't need a cluster, so no zookeeper at all
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.testing.nocluster"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// Open connection to zookeeper and set primary watcher
name|zooKeeper
operator|=
operator|new
name|ZooKeeperWatcher
argument_list|(
name|conf
argument_list|,
name|getProcessName
argument_list|()
operator|+
literal|":"
operator|+
name|rpcServices
operator|.
name|isa
operator|.
name|getPort
argument_list|()
argument_list|,
name|this
argument_list|,
name|canCreateBaseZNode
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|csm
operator|=
operator|(
name|BaseCoordinatedStateManager
operator|)
name|csm
expr_stmt|;
name|this
operator|.
name|csm
operator|.
name|initialize
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|csm
operator|.
name|start
argument_list|()
expr_stmt|;
name|tableLockManager
operator|=
name|TableLockManager
operator|.
name|createTableLockManager
argument_list|(
name|conf
argument_list|,
name|zooKeeper
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
name|masterAddressTracker
operator|=
operator|new
name|MasterAddressTracker
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|masterAddressTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|clusterStatusTracker
operator|=
operator|new
name|ClusterStatusTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|clusterStatusTracker
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|configurationManager
operator|=
operator|new
name|ConfigurationManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|secureBulkLoadManager
operator|=
operator|new
name|SecureBulkLoadManager
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|secureBulkLoadManager
operator|.
name|start
argument_list|()
expr_stmt|;
name|rpcServices
operator|.
name|start
argument_list|()
expr_stmt|;
name|putUpWebUI
argument_list|()
expr_stmt|;
name|this
operator|.
name|walRoller
operator|=
operator|new
name|LogRoller
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|choreService
operator|=
operator|new
name|ChoreService
argument_list|(
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|flushThroughputController
operator|=
name|FlushThroughputControllerFactory
operator|.
name|create
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SystemUtils
operator|.
name|IS_OS_WINDOWS
condition|)
block|{
name|Signal
operator|.
name|handle
argument_list|(
operator|new
name|Signal
argument_list|(
literal|"HUP"
argument_list|)
argument_list|,
operator|new
name|SignalHandler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|handle
parameter_list|(
name|Signal
name|signal
parameter_list|)
block|{
name|getConfiguration
argument_list|()
operator|.
name|reloadConfiguration
argument_list|()
expr_stmt|;
name|configurationManager
operator|.
name|notifyAllObservers
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// Create the CompactedFileDischarger chore service. This chore helps to
comment|// remove the compacted files
comment|// that will no longer be used in reads.
comment|// Default is 2 mins. The default value for TTLCleaner is 5 mins so we set this to
comment|// 2 mins so that compacted files can be archived before the TTLCleaner runs
name|int
name|cleanerInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.hfile.compaction.discharger.interval"
argument_list|,
literal|2
operator|*
literal|60
operator|*
literal|1000
argument_list|)
decl_stmt|;
name|this
operator|.
name|compactedFileDischarger
operator|=
operator|new
name|CompactedHFilesDischarger
argument_list|(
name|cleanerInterval
argument_list|,
operator|(
name|Stoppable
operator|)
name|this
argument_list|,
operator|(
name|RegionServerServices
operator|)
name|this
argument_list|)
expr_stmt|;
name|choreService
operator|.
name|scheduleChore
argument_list|(
name|compactedFileDischarger
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|initializeFileSystem
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Set 'fs.defaultFS' to match the filesystem on hbase.rootdir else
comment|// underlying hadoop hdfs accessors will be going against wrong filesystem
comment|// (unless all is set to defaults).
name|FSUtils
operator|.
name|setFsDefault
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|this
operator|.
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// Get fs instance used by this RS.  Do we use checksum verification in the hbase? If hbase
comment|// checksum verification enabled, then automatically switch off hdfs checksum verification.
name|boolean
name|useHBaseChecksum
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|HBASE_CHECKSUM_VERIFICATION
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|this
operator|.
name|fs
operator|=
operator|new
name|HFileSystem
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|useHBaseChecksum
argument_list|)
expr_stmt|;
name|this
operator|.
name|rootDir
operator|=
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableDescriptors
operator|=
name|getFsTableDescriptors
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|TableDescriptors
name|getFsTableDescriptors
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|FSTableDescriptors
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|fs
argument_list|,
name|this
operator|.
name|rootDir
argument_list|,
operator|!
name|canUpdateTableDescriptor
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|protected
name|void
name|setInitLatch
parameter_list|(
name|CountDownLatch
name|latch
parameter_list|)
block|{
name|this
operator|.
name|initLatch
operator|=
name|latch
expr_stmt|;
block|}
comment|/*    * Returns true if configured hostname should be used    */
specifier|protected
name|boolean
name|shouldUseThisHostnameInstead
parameter_list|()
block|{
return|return
name|useThisHostnameInstead
operator|!=
literal|null
operator|&&
operator|!
name|useThisHostnameInstead
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|protected
name|void
name|login
parameter_list|(
name|UserProvider
name|user
parameter_list|,
name|String
name|host
parameter_list|)
throws|throws
name|IOException
block|{
name|user
operator|.
name|login
argument_list|(
literal|"hbase.regionserver.keytab.file"
argument_list|,
literal|"hbase.regionserver.kerberos.principal"
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|waitForMasterActive
parameter_list|()
block|{   }
specifier|protected
name|String
name|getProcessName
parameter_list|()
block|{
return|return
name|REGIONSERVER
return|;
block|}
specifier|protected
name|boolean
name|canCreateBaseZNode
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|protected
name|boolean
name|canUpdateTableDescriptor
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|protected
name|RSRpcServices
name|createRpcServices
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|RSRpcServices
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|protected
name|void
name|configureInfoServer
parameter_list|()
block|{
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|"rs-status"
argument_list|,
literal|"/rs-status"
argument_list|,
name|RSStatusServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
name|REGIONSERVER
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|Class
argument_list|<
name|?
extends|extends
name|HttpServlet
argument_list|>
name|getDumpServlet
parameter_list|()
block|{
return|return
name|RSDumpServlet
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|registerService
parameter_list|(
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Service
name|instance
parameter_list|)
block|{
comment|/*      * No stacking of instances is allowed for a single service name      */
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|ServiceDescriptor
name|serviceDesc
init|=
name|instance
operator|.
name|getDescriptorForType
argument_list|()
decl_stmt|;
name|String
name|serviceName
init|=
name|CoprocessorRpcUtils
operator|.
name|getServiceName
argument_list|(
name|serviceDesc
argument_list|)
decl_stmt|;
if|if
condition|(
name|coprocessorServiceHandlers
operator|.
name|containsKey
argument_list|(
name|serviceName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor service "
operator|+
name|serviceName
operator|+
literal|" already registered, rejecting request from "
operator|+
name|instance
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|coprocessorServiceHandlers
operator|.
name|put
argument_list|(
name|serviceName
argument_list|,
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Registered regionserver coprocessor service: service="
operator|+
name|serviceName
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Create a 'smarter' Connection, one that is capable of by-passing RPC if the request is to    * the local server. Safe to use going to local or remote server.    * Create this instance in a method can be intercepted and mocked in tests.    * @throws IOException    */
annotation|@
name|VisibleForTesting
specifier|protected
name|ClusterConnection
name|createClusterConnection
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Create a cluster connection that when appropriate, can short-circuit and go directly to the
comment|// local server if the request is to the local server bypassing RPC. Can be used for both local
comment|// and remote invocations.
return|return
name|ConnectionUtils
operator|.
name|createShortCircuitConnection
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|,
name|userProvider
operator|.
name|getCurrent
argument_list|()
argument_list|,
name|serverName
argument_list|,
name|rpcServices
argument_list|,
name|rpcServices
argument_list|)
return|;
block|}
comment|/**    * Run test on configured codecs to make sure supporting libs are in place.    * @param c    * @throws IOException    */
specifier|private
specifier|static
name|void
name|checkCodecs
parameter_list|(
specifier|final
name|Configuration
name|c
parameter_list|)
throws|throws
name|IOException
block|{
comment|// check to see if the codec list is available:
name|String
index|[]
name|codecs
init|=
name|c
operator|.
name|getStrings
argument_list|(
literal|"hbase.regionserver.codecs"
argument_list|,
operator|(
name|String
index|[]
operator|)
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|codecs
operator|==
literal|null
condition|)
return|return;
for|for
control|(
name|String
name|codec
range|:
name|codecs
control|)
block|{
if|if
condition|(
operator|!
name|CompressionTest
operator|.
name|testCompression
argument_list|(
name|codec
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Compression codec "
operator|+
name|codec
operator|+
literal|" not supported, aborting RS construction"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
name|String
name|getClusterId
parameter_list|()
block|{
return|return
name|this
operator|.
name|clusterId
return|;
block|}
comment|/**    * Setup our cluster connection if not already initialized.    * @throws IOException    */
specifier|protected
specifier|synchronized
name|void
name|setupClusterConnection
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|clusterConnection
operator|==
literal|null
condition|)
block|{
name|clusterConnection
operator|=
name|createClusterConnection
argument_list|()
expr_stmt|;
name|metaTableLocator
operator|=
operator|new
name|MetaTableLocator
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * All initialization needed before we go register with Master.    *    * @throws IOException    * @throws InterruptedException    */
specifier|private
name|void
name|preRegistrationInitialization
parameter_list|()
block|{
try|try
block|{
name|setupClusterConnection
argument_list|()
expr_stmt|;
comment|// Health checker thread.
if|if
condition|(
name|isHealthCheckerConfigured
argument_list|()
condition|)
block|{
name|int
name|sleepTime
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HEALTH_CHORE_WAKE_FREQ
argument_list|,
name|HConstants
operator|.
name|DEFAULT_THREAD_WAKE_FREQUENCY
argument_list|)
decl_stmt|;
name|healthCheckChore
operator|=
operator|new
name|HealthCheckChore
argument_list|(
name|sleepTime
argument_list|,
name|this
argument_list|,
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|initializeZooKeeper
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isStopped
argument_list|()
operator|&&
operator|!
name|isAborted
argument_list|()
condition|)
block|{
name|initializeThreads
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Call stop if error or process will stick around for ever since server
comment|// puts up non-daemon threads.
name|this
operator|.
name|rpcServices
operator|.
name|stop
argument_list|()
expr_stmt|;
name|abort
argument_list|(
literal|"Initialization of RS failed.  Hence aborting RS."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Bring up connection to zk ensemble and then wait until a master for this    * cluster and then after that, wait until cluster 'up' flag has been set.    * This is the order in which master does things.    * Finally open long-living server short-circuit connection.    * @throws IOException    * @throws InterruptedException    */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE"
argument_list|,
name|justification
operator|=
literal|"cluster Id znode read would give us correct response"
argument_list|)
specifier|private
name|void
name|initializeZooKeeper
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// Create the master address tracker, register with zk, and start it.  Then
comment|// block until a master is available.  No point in starting up if no master
comment|// running.
name|blockAndCheckIfStopped
argument_list|(
name|this
operator|.
name|masterAddressTracker
argument_list|)
expr_stmt|;
comment|// Wait on cluster being up.  Master will set this flag up in zookeeper
comment|// when ready.
name|blockAndCheckIfStopped
argument_list|(
name|this
operator|.
name|clusterStatusTracker
argument_list|)
expr_stmt|;
name|doLatch
argument_list|(
name|this
operator|.
name|initLatch
argument_list|)
expr_stmt|;
comment|// Retrieve clusterId
comment|// Since cluster status is now up
comment|// ID should have already been set by HMaster
try|try
block|{
name|clusterId
operator|=
name|ZKClusterId
operator|.
name|readClusterIdZNode
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|)
expr_stmt|;
if|if
condition|(
name|clusterId
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|abort
argument_list|(
literal|"Cluster ID has not been set"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"ClusterId : "
operator|+
name|clusterId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|this
operator|.
name|abort
argument_list|(
literal|"Failed to retrieve Cluster ID"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// In case colocated master, wait here till it's active.
comment|// So backup masters won't start as regionservers.
comment|// This is to avoid showing backup masters as regionservers
comment|// in master web UI, or assigning any region to them.
name|waitForMasterActive
argument_list|()
expr_stmt|;
if|if
condition|(
name|isStopped
argument_list|()
operator|||
name|isAborted
argument_list|()
condition|)
block|{
return|return;
comment|// No need for further initialization
block|}
comment|// watch for snapshots and other procedures
try|try
block|{
name|rspmHost
operator|=
operator|new
name|RegionServerProcedureManagerHost
argument_list|()
expr_stmt|;
name|rspmHost
operator|.
name|loadProcedures
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|rspmHost
operator|.
name|initialize
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|this
operator|.
name|abort
argument_list|(
literal|"Failed to reach zk cluster when creating procedure handler."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// register watcher for recovering regions
name|this
operator|.
name|recoveringRegionWatcher
operator|=
operator|new
name|RecoveringRegionWatcher
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"RV_RETURN_VALUE_IGNORED"
argument_list|,
name|justification
operator|=
literal|"We don't care about the return"
argument_list|)
specifier|private
name|void
name|doLatch
parameter_list|(
specifier|final
name|CountDownLatch
name|latch
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|latch
operator|!=
literal|null
condition|)
block|{
comment|// Result is ignored intentionally but if I remove the below, findbugs complains (the
comment|// above justification on this method doesn't seem to suppress it).
name|boolean
name|result
init|=
name|latch
operator|.
name|await
argument_list|(
literal|20
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
block|}
block|}
comment|/**    * Utilty method to wait indefinitely on a znode availability while checking    * if the region server is shut down    * @param tracker znode tracker to use    * @throws IOException any IO exception, plus if the RS is stopped    * @throws InterruptedException    */
specifier|private
name|void
name|blockAndCheckIfStopped
parameter_list|(
name|ZooKeeperNodeTracker
name|tracker
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
while|while
condition|(
name|tracker
operator|.
name|blockUntilAvailable
argument_list|(
name|this
operator|.
name|msgInterval
argument_list|,
literal|false
argument_list|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|stopped
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Received the shutdown message while waiting."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * @return False if cluster shutdown in progress    */
specifier|private
name|boolean
name|isClusterUp
parameter_list|()
block|{
return|return
name|clusterStatusTracker
operator|!=
literal|null
operator|&&
name|clusterStatusTracker
operator|.
name|isClusterUp
argument_list|()
return|;
block|}
specifier|private
name|void
name|initializeThreads
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Cache flushing thread.
name|this
operator|.
name|cacheFlusher
operator|=
operator|new
name|MemStoreFlusher
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Compaction thread
name|this
operator|.
name|compactSplitThread
operator|=
operator|new
name|CompactSplitThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Background thread to check for compactions; needed if region has not gotten updates
comment|// in a while. It will take care of not checking too frequently on store-by-store basis.
name|this
operator|.
name|compactionChecker
operator|=
operator|new
name|CompactionChecker
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|threadWakeFrequency
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|periodicFlusher
operator|=
operator|new
name|PeriodicMemstoreFlusher
argument_list|(
name|this
operator|.
name|threadWakeFrequency
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|=
operator|new
name|Leases
argument_list|(
name|this
operator|.
name|threadWakeFrequency
argument_list|)
expr_stmt|;
comment|// Create the thread to clean the moved regions list
name|movedRegionsCleaner
operator|=
name|MovedRegionsCleaner
operator|.
name|create
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|nonceManager
operator|!=
literal|null
condition|)
block|{
comment|// Create the scheduled chore that cleans up nonces.
name|nonceManagerChore
operator|=
name|this
operator|.
name|nonceManager
operator|.
name|createCleanupScheduledChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// Setup the Quota Manager
name|rsQuotaManager
operator|=
operator|new
name|RegionServerQuotaManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Setup RPC client for master communication
name|rpcClient
operator|=
name|RpcClientFactory
operator|.
name|createClient
argument_list|(
name|conf
argument_list|,
name|clusterId
argument_list|,
operator|new
name|InetSocketAddress
argument_list|(
name|rpcServices
operator|.
name|isa
operator|.
name|getAddress
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|,
name|clusterConnection
operator|.
name|getConnectionMetrics
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|onlyMetaRefresh
init|=
literal|false
decl_stmt|;
name|int
name|storefileRefreshPeriod
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|StorefileRefresherChore
operator|.
name|REGIONSERVER_STOREFILE_REFRESH_PERIOD
argument_list|,
name|StorefileRefresherChore
operator|.
name|DEFAULT_REGIONSERVER_STOREFILE_REFRESH_PERIOD
argument_list|)
decl_stmt|;
if|if
condition|(
name|storefileRefreshPeriod
operator|==
literal|0
condition|)
block|{
name|storefileRefreshPeriod
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|StorefileRefresherChore
operator|.
name|REGIONSERVER_META_STOREFILE_REFRESH_PERIOD
argument_list|,
name|StorefileRefresherChore
operator|.
name|DEFAULT_REGIONSERVER_STOREFILE_REFRESH_PERIOD
argument_list|)
expr_stmt|;
name|onlyMetaRefresh
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|storefileRefreshPeriod
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|storefileRefresher
operator|=
operator|new
name|StorefileRefresherChore
argument_list|(
name|storefileRefreshPeriod
argument_list|,
name|onlyMetaRefresh
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|registerConfigurationObservers
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|registerConfigurationObservers
parameter_list|()
block|{
comment|// Registering the compactSplitThread object with the ConfigurationManager.
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
operator|.
name|compactSplitThread
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
operator|.
name|rpcServices
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * The HRegionServer sticks in this loop until closed.    */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// Do pre-registration initializations; zookeeper, lease threads, etc.
name|preRegistrationInitialization
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|abort
argument_list|(
literal|"Fatal exception during initialization"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|isStopped
argument_list|()
operator|&&
operator|!
name|isAborted
argument_list|()
condition|)
block|{
name|ShutdownHook
operator|.
name|install
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|this
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
comment|// Set our ephemeral znode up in zookeeper now we have a name.
name|createMyEphemeralNode
argument_list|()
expr_stmt|;
comment|// Initialize the RegionServerCoprocessorHost now that our ephemeral
comment|// node was created, in case any coprocessors want to use ZooKeeper
name|this
operator|.
name|rsHost
operator|=
operator|new
name|RegionServerCoprocessorHost
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// Try and register with the Master; tell it we are here.  Break if
comment|// server is stopped or the clusterup flag is down or hdfs went wacky.
while|while
condition|(
name|keepLooping
argument_list|()
condition|)
block|{
name|RegionServerStartupResponse
name|w
init|=
name|reportForDuty
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"reportForDuty failed; sleeping and then retrying."
argument_list|)
expr_stmt|;
name|this
operator|.
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|handleReportForDutyResponse
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|isStopped
argument_list|()
operator|&&
name|isHealthy
argument_list|()
condition|)
block|{
comment|// start the snapshot handler and other procedure handlers,
comment|// since the server is ready to run
name|rspmHost
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Start the Quota Manager
name|rsQuotaManager
operator|.
name|start
argument_list|(
name|getRpcServer
argument_list|()
operator|.
name|getScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// We registered with the Master.  Go into run mode.
name|long
name|lastMsg
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|oldRequestCount
init|=
operator|-
literal|1
decl_stmt|;
comment|// The main run loop.
while|while
condition|(
operator|!
name|isStopped
argument_list|()
operator|&&
name|isHealthy
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|isClusterUp
argument_list|()
condition|)
block|{
if|if
condition|(
name|isOnlineRegionsEmpty
argument_list|()
condition|)
block|{
name|stop
argument_list|(
literal|"Exiting; cluster shutdown set and not carrying any regions"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|this
operator|.
name|stopping
condition|)
block|{
name|this
operator|.
name|stopping
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Closing user regions"
argument_list|)
expr_stmt|;
name|closeUserRegions
argument_list|(
name|this
operator|.
name|abortRequested
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|stopping
condition|)
block|{
name|boolean
name|allUserRegionsOffline
init|=
name|areAllUserRegionsOffline
argument_list|()
decl_stmt|;
if|if
condition|(
name|allUserRegionsOffline
condition|)
block|{
comment|// Set stopped if no more write requests tp meta tables
comment|// since last time we went around the loop.  Any open
comment|// meta regions will be closed on our way out.
if|if
condition|(
name|oldRequestCount
operator|==
name|getWriteRequestCount
argument_list|()
condition|)
block|{
name|stop
argument_list|(
literal|"Stopped; only catalog regions remaining online"
argument_list|)
expr_stmt|;
break|break;
block|}
name|oldRequestCount
operator|=
name|getWriteRequestCount
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Make sure all regions have been closed -- some regions may
comment|// have not got it because we were splitting at the time of
comment|// the call to closeUserRegions.
name|closeUserRegions
argument_list|(
name|this
operator|.
name|abortRequested
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting on "
operator|+
name|getOnlineRegionsAsPrintableString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|now
operator|-
name|lastMsg
operator|)
operator|>=
name|msgInterval
condition|)
block|{
name|tryRegionServerReport
argument_list|(
name|lastMsg
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|lastMsg
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isStopped
argument_list|()
operator|&&
operator|!
name|isAborted
argument_list|()
condition|)
block|{
name|this
operator|.
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
comment|// for
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rpcServices
operator|.
name|checkOOME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|String
name|prefix
init|=
name|t
operator|instanceof
name|YouAreDeadException
condition|?
literal|""
else|:
literal|"Unhandled: "
decl_stmt|;
name|abort
argument_list|(
name|prefix
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Run shutdown.
if|if
condition|(
name|mxBean
operator|!=
literal|null
condition|)
block|{
name|MBeans
operator|.
name|unregister
argument_list|(
name|mxBean
argument_list|)
expr_stmt|;
name|mxBean
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|leases
operator|!=
literal|null
condition|)
name|this
operator|.
name|leases
operator|.
name|closeAfterLeasesExpire
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|splitLogWorker
operator|!=
literal|null
condition|)
block|{
name|splitLogWorker
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|infoServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping infoServer"
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|infoServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to stop infoServer"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Send cache a shutdown.
if|if
condition|(
name|cacheConfig
operator|!=
literal|null
operator|&&
name|cacheConfig
operator|.
name|isBlockCacheEnabled
argument_list|()
condition|)
block|{
name|cacheConfig
operator|.
name|getBlockCache
argument_list|()
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|mobCacheConfig
operator|.
name|getMobFileCache
argument_list|()
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|movedRegionsCleaner
operator|!=
literal|null
condition|)
block|{
name|movedRegionsCleaner
operator|.
name|stop
argument_list|(
literal|"Region Server stopping"
argument_list|)
expr_stmt|;
block|}
comment|// Send interrupts to wake up threads if sleeping so they notice shutdown.
comment|// TODO: Should we check they are alive? If OOME could have exited already
if|if
condition|(
name|this
operator|.
name|hMemManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|hMemManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cacheFlusher
operator|!=
literal|null
condition|)
name|this
operator|.
name|cacheFlusher
operator|.
name|interruptIfNecessary
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|compactSplitThread
operator|!=
literal|null
condition|)
name|this
operator|.
name|compactSplitThread
operator|.
name|interruptIfNecessary
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|compactionChecker
operator|!=
literal|null
condition|)
name|this
operator|.
name|compactionChecker
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|healthCheckChore
operator|!=
literal|null
condition|)
name|this
operator|.
name|healthCheckChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|nonceManagerChore
operator|!=
literal|null
condition|)
name|this
operator|.
name|nonceManagerChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|storefileRefresher
operator|!=
literal|null
condition|)
name|this
operator|.
name|storefileRefresher
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|sendShutdownInterrupt
argument_list|()
expr_stmt|;
comment|// Stop the quota manager
if|if
condition|(
name|rsQuotaManager
operator|!=
literal|null
condition|)
block|{
name|rsQuotaManager
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
comment|// Stop the snapshot and other procedure handlers, forcefully killing all running tasks
if|if
condition|(
name|rspmHost
operator|!=
literal|null
condition|)
block|{
name|rspmHost
operator|.
name|stop
argument_list|(
name|this
operator|.
name|abortRequested
operator|||
name|this
operator|.
name|killed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|killed
condition|)
block|{
comment|// Just skip out w/o closing regions.  Used when testing.
block|}
elseif|else
if|if
condition|(
name|abortRequested
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|fsOk
condition|)
block|{
name|closeUserRegions
argument_list|(
name|abortRequested
argument_list|)
expr_stmt|;
comment|// Don't leave any open file handles
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"aborting server "
operator|+
name|this
operator|.
name|serverName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|closeUserRegions
argument_list|(
name|abortRequested
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"stopping server "
operator|+
name|this
operator|.
name|serverName
argument_list|)
expr_stmt|;
block|}
comment|// so callers waiting for meta without timeout can stop
if|if
condition|(
name|this
operator|.
name|metaTableLocator
operator|!=
literal|null
condition|)
name|this
operator|.
name|metaTableLocator
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|clusterConnection
operator|!=
literal|null
operator|&&
operator|!
name|clusterConnection
operator|.
name|isClosed
argument_list|()
condition|)
block|{
try|try
block|{
name|this
operator|.
name|clusterConnection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Although the {@link Closeable} interface throws an {@link
comment|// IOException}, in reality, the implementation would never do that.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempt to close server's short circuit ClusterConnection failed."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Closing the compactSplit thread before closing meta regions
if|if
condition|(
operator|!
name|this
operator|.
name|killed
operator|&&
name|containsMetaTableRegions
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|abortRequested
operator|||
name|this
operator|.
name|fsOk
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|compactSplitThread
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|compactSplitThread
operator|.
name|join
argument_list|()
expr_stmt|;
name|this
operator|.
name|compactSplitThread
operator|=
literal|null
expr_stmt|;
block|}
name|closeMetaTableRegions
argument_list|(
name|abortRequested
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|killed
operator|&&
name|this
operator|.
name|fsOk
condition|)
block|{
name|waitOnAllRegionsToClose
argument_list|(
name|abortRequested
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"stopping server "
operator|+
name|this
operator|.
name|serverName
operator|+
literal|"; all regions closed."
argument_list|)
expr_stmt|;
block|}
comment|//fsOk flag may be changed when closing regions throws exception.
if|if
condition|(
name|this
operator|.
name|fsOk
condition|)
block|{
name|shutdownWAL
argument_list|(
operator|!
name|abortRequested
argument_list|)
expr_stmt|;
block|}
comment|// Make sure the proxy is down.
if|if
condition|(
name|this
operator|.
name|rssStub
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|rssStub
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|rpcClient
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|rpcClient
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|leases
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|leases
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|pauseMonitor
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|pauseMonitor
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|killed
condition|)
block|{
name|stopServiceThreads
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|rpcServices
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|rpcServices
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|deleteMyEphemeralNode
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nn
parameter_list|)
block|{     }
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed deleting my ephemeral node"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// We may have failed to delete the znode at the previous step, but
comment|//  we delete the file anyway: a second attempt to delete the znode is likely to fail again.
name|ZNodeClearer
operator|.
name|deleteMyEphemeralNodeOnDisk
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|zooKeeper
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|zooKeeper
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"stopping server "
operator|+
name|this
operator|.
name|serverName
operator|+
literal|"; zookeeper connection closed."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" exiting"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|containsMetaTableRegions
parameter_list|()
block|{
return|return
name|onlineRegions
operator|.
name|containsKey
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
operator|.
name|getEncodedName
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|areAllUserRegionsOffline
parameter_list|()
block|{
if|if
condition|(
name|getNumberOfOnlineRegions
argument_list|()
operator|>
literal|2
condition|)
return|return
literal|false
return|;
name|boolean
name|allUserRegionsOffline
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Region
argument_list|>
name|e
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|allUserRegionsOffline
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
return|return
name|allUserRegionsOffline
return|;
block|}
comment|/**    * @return Current write count for all online regions.    */
specifier|private
name|long
name|getWriteRequestCount
parameter_list|()
block|{
name|long
name|writeCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Region
argument_list|>
name|e
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|writeCount
operator|+=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getWriteRequestsCount
argument_list|()
expr_stmt|;
block|}
return|return
name|writeCount
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|tryRegionServerReport
parameter_list|(
name|long
name|reportStartTime
parameter_list|,
name|long
name|reportEndTime
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionServerStatusService
operator|.
name|BlockingInterface
name|rss
init|=
name|rssStub
decl_stmt|;
if|if
condition|(
name|rss
operator|==
literal|null
condition|)
block|{
comment|// the current server could be stopping.
return|return;
block|}
name|ClusterStatusProtos
operator|.
name|ServerLoad
name|sl
init|=
name|buildServerLoad
argument_list|(
name|reportStartTime
argument_list|,
name|reportEndTime
argument_list|)
decl_stmt|;
try|try
block|{
name|RegionServerReportRequest
operator|.
name|Builder
name|request
init|=
name|RegionServerReportRequest
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ServerName
name|sn
init|=
name|ServerName
operator|.
name|parseVersionedServerName
argument_list|(
name|this
operator|.
name|serverName
operator|.
name|getVersionedBytes
argument_list|()
argument_list|)
decl_stmt|;
name|request
operator|.
name|setServer
argument_list|(
name|ProtobufUtil
operator|.
name|toServerName
argument_list|(
name|sn
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|.
name|setLoad
argument_list|(
name|sl
argument_list|)
expr_stmt|;
name|rss
operator|.
name|regionServerReport
argument_list|(
literal|null
argument_list|,
name|request
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
name|IOException
name|ioe
init|=
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
decl_stmt|;
if|if
condition|(
name|ioe
operator|instanceof
name|YouAreDeadException
condition|)
block|{
comment|// This will be caught and handled as a fatal error in run()
throw|throw
name|ioe
throw|;
block|}
if|if
condition|(
name|rssStub
operator|==
name|rss
condition|)
block|{
name|rssStub
operator|=
literal|null
expr_stmt|;
block|}
comment|// Couldn't connect to the master, get location from zk and reconnect
comment|// Method blocks until new master is found or we are stopped
name|createRegionServerStatusStub
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|ClusterStatusProtos
operator|.
name|ServerLoad
name|buildServerLoad
parameter_list|(
name|long
name|reportStartTime
parameter_list|,
name|long
name|reportEndTime
parameter_list|)
throws|throws
name|IOException
block|{
comment|// We're getting the MetricsRegionServerWrapper here because the wrapper computes requests
comment|// per second, and other metrics  As long as metrics are part of ServerLoad it's best to use
comment|// the wrapper to compute those numbers in one place.
comment|// In the long term most of these should be moved off of ServerLoad and the heart beat.
comment|// Instead they should be stored in an HBase table so that external visibility into HBase is
comment|// improved; Additionally the load balancer will be able to take advantage of a more complete
comment|// history.
name|MetricsRegionServerWrapper
name|regionServerWrapper
init|=
name|metricsRegionServer
operator|.
name|getRegionServerWrapper
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Region
argument_list|>
name|regions
init|=
name|getOnlineRegionsLocalContext
argument_list|()
decl_stmt|;
name|MemoryUsage
name|memory
init|=
name|ManagementFactory
operator|.
name|getMemoryMXBean
argument_list|()
operator|.
name|getHeapMemoryUsage
argument_list|()
decl_stmt|;
name|ClusterStatusProtos
operator|.
name|ServerLoad
operator|.
name|Builder
name|serverLoad
init|=
name|ClusterStatusProtos
operator|.
name|ServerLoad
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|serverLoad
operator|.
name|setNumberOfRequests
argument_list|(
operator|(
name|int
operator|)
name|regionServerWrapper
operator|.
name|getRequestsPerSecond
argument_list|()
argument_list|)
expr_stmt|;
name|serverLoad
operator|.
name|setTotalNumberOfRequests
argument_list|(
operator|(
name|int
operator|)
name|regionServerWrapper
operator|.
name|getTotalRequestCount
argument_list|()
argument_list|)
expr_stmt|;
name|serverLoad
operator|.
name|setUsedHeapMB
argument_list|(
call|(
name|int
call|)
argument_list|(
name|memory
operator|.
name|getUsed
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|serverLoad
operator|.
name|setMaxHeapMB
argument_list|(
call|(
name|int
call|)
argument_list|(
name|memory
operator|.
name|getMax
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|coprocessors
init|=
name|getWAL
argument_list|(
literal|null
argument_list|)
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|getCoprocessors
argument_list|()
decl_stmt|;
name|Builder
name|coprocessorBuilder
init|=
name|Coprocessor
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|coprocessor
range|:
name|coprocessors
control|)
block|{
name|serverLoad
operator|.
name|addCoprocessors
argument_list|(
name|coprocessorBuilder
operator|.
name|setName
argument_list|(
name|coprocessor
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RegionLoad
operator|.
name|Builder
name|regionLoadBldr
init|=
name|RegionLoad
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|RegionSpecifier
operator|.
name|Builder
name|regionSpecifier
init|=
name|RegionSpecifier
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Region
name|region
range|:
name|regions
control|)
block|{
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|regionCoprocessors
init|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|getCoprocessors
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
init|=
name|regionCoprocessors
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|serverLoad
operator|.
name|addCoprocessors
argument_list|(
name|coprocessorBuilder
operator|.
name|setName
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|serverLoad
operator|.
name|addRegionLoads
argument_list|(
name|createRegionLoad
argument_list|(
name|region
argument_list|,
name|regionLoadBldr
argument_list|,
name|regionSpecifier
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|coprocessor
range|:
name|getWAL
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|getCoprocessors
argument_list|()
control|)
block|{
name|serverLoad
operator|.
name|addCoprocessors
argument_list|(
name|coprocessorBuilder
operator|.
name|setName
argument_list|(
name|coprocessor
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|serverLoad
operator|.
name|setReportStartTime
argument_list|(
name|reportStartTime
argument_list|)
expr_stmt|;
name|serverLoad
operator|.
name|setReportEndTime
argument_list|(
name|reportEndTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|infoServer
operator|!=
literal|null
condition|)
block|{
name|serverLoad
operator|.
name|setInfoServerPort
argument_list|(
name|this
operator|.
name|infoServer
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serverLoad
operator|.
name|setInfoServerPort
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// for the replicationLoad purpose. Only need to get from one service
comment|// either source or sink will get the same info
name|ReplicationSourceService
name|rsources
init|=
name|getReplicationSourceService
argument_list|()
decl_stmt|;
if|if
condition|(
name|rsources
operator|!=
literal|null
condition|)
block|{
comment|// always refresh first to get the latest value
name|ReplicationLoad
name|rLoad
init|=
name|rsources
operator|.
name|refreshAndGetReplicationLoad
argument_list|()
decl_stmt|;
if|if
condition|(
name|rLoad
operator|!=
literal|null
condition|)
block|{
name|serverLoad
operator|.
name|setReplLoadSink
argument_list|(
name|rLoad
operator|.
name|getReplicationLoadSink
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ClusterStatusProtos
operator|.
name|ReplicationLoadSource
name|rLS
range|:
name|rLoad
operator|.
name|getReplicationLoadSourceList
argument_list|()
control|)
block|{
name|serverLoad
operator|.
name|addReplLoadSource
argument_list|(
name|rLS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|serverLoad
operator|.
name|build
argument_list|()
return|;
block|}
name|String
name|getOnlineRegionsAsPrintableString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Region
name|r
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Wait on regions close.    */
specifier|private
name|void
name|waitOnAllRegionsToClose
parameter_list|(
specifier|final
name|boolean
name|abort
parameter_list|)
block|{
comment|// Wait till all regions are closed before going out.
name|int
name|lastCount
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|previousLogTime
init|=
literal|0
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|closedRegions
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|isOnlineRegionsEmpty
argument_list|()
condition|)
block|{
name|int
name|count
init|=
name|getNumberOfOnlineRegions
argument_list|()
decl_stmt|;
comment|// Only print a message if the count of regions has changed.
if|if
condition|(
name|count
operator|!=
name|lastCount
condition|)
block|{
comment|// Log every second at most
if|if
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|>
operator|(
name|previousLogTime
operator|+
literal|1000
operator|)
condition|)
block|{
name|previousLogTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|lastCount
operator|=
name|count
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting on "
operator|+
name|count
operator|+
literal|" regions to close"
argument_list|)
expr_stmt|;
comment|// Only print out regions still closing if a small number else will
comment|// swamp the log.
if|if
condition|(
name|count
operator|<
literal|10
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|this
operator|.
name|onlineRegions
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Ensure all user regions have been sent a close. Use this to
comment|// protect against the case where an open comes in after we start the
comment|// iterator of onlineRegions to close all user regions.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Region
argument_list|>
name|e
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HRegionInfo
name|hri
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|regionsInTransitionInRS
operator|.
name|containsKey
argument_list|(
name|hri
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
operator|&&
operator|!
name|closedRegions
operator|.
name|contains
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
condition|)
block|{
name|closedRegions
operator|.
name|add
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Don't update zk with this close transition; pass false.
name|closeRegionIgnoreErrors
argument_list|(
name|hri
argument_list|,
name|abort
argument_list|)
expr_stmt|;
block|}
block|}
comment|// No regions in RIT, we could stop waiting now.
if|if
condition|(
name|this
operator|.
name|regionsInTransitionInRS
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|isOnlineRegionsEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"We were exiting though online regions are not empty,"
operator|+
literal|" because some regions failed closing"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|sleep
argument_list|(
literal|200
argument_list|)
condition|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|sleep
parameter_list|(
name|long
name|millis
parameter_list|)
block|{
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|millis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while sleeping"
argument_list|)
expr_stmt|;
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|interrupted
return|;
block|}
specifier|private
name|void
name|shutdownWAL
parameter_list|(
specifier|final
name|boolean
name|close
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|walFactory
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|close
condition|)
block|{
name|walFactory
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|walFactory
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|e
operator|=
name|e
operator|instanceof
name|RemoteException
condition|?
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
else|:
name|e
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Shutdown / close of WAL failed: "
operator|+
name|e
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Shutdown / close exception details:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Run init. Sets up wal and starts up all server threads.    *    * @param c Extra configuration.    */
specifier|protected
name|void
name|handleReportForDutyResponse
parameter_list|(
specifier|final
name|RegionServerStartupResponse
name|c
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|boolean
name|updateRootDir
init|=
literal|false
decl_stmt|;
for|for
control|(
name|NameStringPair
name|e
range|:
name|c
operator|.
name|getMapEntriesList
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|e
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// The hostname the master sees us as.
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
name|HConstants
operator|.
name|KEY_FOR_HOSTNAME_SEEN_BY_MASTER
argument_list|)
condition|)
block|{
name|String
name|hostnameFromMasterPOV
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|this
operator|.
name|serverName
operator|=
name|ServerName
operator|.
name|valueOf
argument_list|(
name|hostnameFromMasterPOV
argument_list|,
name|rpcServices
operator|.
name|isa
operator|.
name|getPort
argument_list|()
argument_list|,
name|this
operator|.
name|startcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldUseThisHostnameInstead
argument_list|()
operator|&&
operator|!
name|hostnameFromMasterPOV
operator|.
name|equals
argument_list|(
name|useThisHostnameInstead
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Master passed us a different hostname to use; was="
operator|+
name|this
operator|.
name|useThisHostnameInstead
operator|+
literal|", but now="
operator|+
name|hostnameFromMasterPOV
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|shouldUseThisHostnameInstead
argument_list|()
operator|&&
operator|!
name|hostnameFromMasterPOV
operator|.
name|equals
argument_list|(
name|rpcServices
operator|.
name|isa
operator|.
name|getHostName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Master passed us a different hostname to use; was="
operator|+
name|rpcServices
operator|.
name|isa
operator|.
name|getHostName
argument_list|()
operator|+
literal|", but now="
operator|+
name|hostnameFromMasterPOV
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|String
name|value
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|equals
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
condition|)
block|{
name|updateRootDir
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Config from master: "
operator|+
name|key
operator|+
literal|"="
operator|+
name|value
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|updateRootDir
condition|)
block|{
comment|// initialize file system by the config fs.defaultFS and hbase.rootdir from master
name|initializeFileSystem
argument_list|()
expr_stmt|;
block|}
comment|// hack! Maps DFSClient => RegionServer for logs.  HDFS made this
comment|// config param for task trackers, but we can piggyback off of it.
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"mapreduce.task.attempt.id"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"mapreduce.task.attempt.id"
argument_list|,
literal|"hb_rs_"
operator|+
name|this
operator|.
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Save it in a file, this will allow to see if we crash
name|ZNodeClearer
operator|.
name|writeMyEphemeralNodeOnDisk
argument_list|(
name|getMyEphemeralNodePath
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|cacheConfig
operator|=
operator|new
name|CacheConfig
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|walFactory
operator|=
name|setupWALAndReplication
argument_list|()
expr_stmt|;
comment|// Init in here rather than in constructor after thread name has been set
name|this
operator|.
name|metricsRegionServer
operator|=
operator|new
name|MetricsRegionServer
argument_list|(
operator|new
name|MetricsRegionServerWrapperImpl
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|metricsTable
operator|=
operator|new
name|MetricsTable
argument_list|(
operator|new
name|MetricsTableWrapperAggregateImpl
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now that we have a metrics source, start the pause monitor
name|this
operator|.
name|pauseMonitor
operator|=
operator|new
name|JvmPauseMonitor
argument_list|(
name|conf
argument_list|,
name|getMetrics
argument_list|()
operator|.
name|getMetricsSource
argument_list|()
argument_list|)
expr_stmt|;
name|pauseMonitor
operator|.
name|start
argument_list|()
expr_stmt|;
name|startServiceThreads
argument_list|()
expr_stmt|;
name|startHeapMemoryManager
argument_list|()
expr_stmt|;
comment|// Call it after starting HeapMemoryManager.
name|initializeMemStoreChunkPool
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Serving as "
operator|+
name|this
operator|.
name|serverName
operator|+
literal|", RpcServer on "
operator|+
name|rpcServices
operator|.
name|isa
operator|+
literal|", sessionid=0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getSessionId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Wake up anyone waiting for this server to online
synchronized|synchronized
init|(
name|online
init|)
block|{
name|online
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|online
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|stop
argument_list|(
literal|"Failed initialization"
argument_list|)
expr_stmt|;
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|e
argument_list|,
literal|"Failed init"
argument_list|)
argument_list|,
literal|"Region server startup failed"
argument_list|)
throw|;
block|}
finally|finally
block|{
name|sleeper
operator|.
name|skipSleepCycle
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|initializeMemStoreChunkPool
parameter_list|()
block|{
if|if
condition|(
name|MemStoreLAB
operator|.
name|isEnabled
argument_list|(
name|conf
argument_list|)
condition|)
block|{
comment|// MSLAB is enabled. So initialize MemStoreChunkPool
comment|// By this time, the MemstoreFlusher is already initialized. We can get the global limits from
comment|// it.
name|Pair
argument_list|<
name|Long
argument_list|,
name|MemoryType
argument_list|>
name|pair
init|=
name|MemorySizeUtil
operator|.
name|getGlobalMemstoreSize
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|long
name|globalMemStoreSize
init|=
name|pair
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|boolean
name|offheap
init|=
name|this
operator|.
name|regionServerAccounting
operator|.
name|isOffheap
argument_list|()
decl_stmt|;
comment|// When off heap memstore in use, take full area for chunk pool.
name|float
name|poolSizePercentage
init|=
name|offheap
condition|?
literal|1.0F
else|:
name|conf
operator|.
name|getFloat
argument_list|(
name|MemStoreLAB
operator|.
name|CHUNK_POOL_MAXSIZE_KEY
argument_list|,
name|MemStoreLAB
operator|.
name|POOL_MAX_SIZE_DEFAULT
argument_list|)
decl_stmt|;
name|float
name|initialCountPercentage
init|=
name|conf
operator|.
name|getFloat
argument_list|(
name|MemStoreLAB
operator|.
name|CHUNK_POOL_INITIALSIZE_KEY
argument_list|,
name|MemStoreLAB
operator|.
name|POOL_INITIAL_SIZE_DEFAULT
argument_list|)
decl_stmt|;
name|int
name|chunkSize
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|MemStoreLAB
operator|.
name|CHUNK_SIZE_KEY
argument_list|,
name|MemStoreLAB
operator|.
name|CHUNK_SIZE_DEFAULT
argument_list|)
decl_stmt|;
name|MemStoreChunkPool
name|pool
init|=
name|MemStoreChunkPool
operator|.
name|initialize
argument_list|(
name|globalMemStoreSize
argument_list|,
name|poolSizePercentage
argument_list|,
name|initialCountPercentage
argument_list|,
name|chunkSize
argument_list|,
name|offheap
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|!=
literal|null
operator|&&
name|this
operator|.
name|hMemManager
operator|!=
literal|null
condition|)
block|{
comment|// Register with Heap Memory manager
name|this
operator|.
name|hMemManager
operator|.
name|registerTuneObserver
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|startHeapMemoryManager
parameter_list|()
block|{
name|this
operator|.
name|hMemManager
operator|=
name|HeapMemoryManager
operator|.
name|create
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|cacheFlusher
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|regionServerAccounting
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|hMemManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|hMemManager
operator|.
name|start
argument_list|(
name|getChoreService
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|createMyEphemeralNode
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
name|RegionServerInfo
operator|.
name|Builder
name|rsInfo
init|=
name|RegionServerInfo
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|rsInfo
operator|.
name|setInfoPort
argument_list|(
name|infoServer
operator|!=
literal|null
condition|?
name|infoServer
operator|.
name|getPort
argument_list|()
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rsInfo
operator|.
name|setVersionInfo
argument_list|(
name|ProtobufUtil
operator|.
name|getVersionInfo
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|data
init|=
name|ProtobufUtil
operator|.
name|prependPBMagic
argument_list|(
name|rsInfo
operator|.
name|build
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|ZKUtil
operator|.
name|createEphemeralNodeAndWatch
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|getMyEphemeralNodePath
argument_list|()
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|deleteMyEphemeralNode
parameter_list|()
throws|throws
name|KeeperException
block|{
name|ZKUtil
operator|.
name|deleteNode
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|getMyEphemeralNodePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RegionServerAccounting
name|getRegionServerAccounting
parameter_list|()
block|{
return|return
name|regionServerAccounting
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableLockManager
name|getTableLockManager
parameter_list|()
block|{
return|return
name|tableLockManager
return|;
block|}
comment|/*    * @param r Region to get RegionLoad for.    * @param regionLoadBldr the RegionLoad.Builder, can be null    * @param regionSpecifier the RegionSpecifier.Builder, can be null    * @return RegionLoad instance.    *    * @throws IOException    */
name|RegionLoad
name|createRegionLoad
parameter_list|(
specifier|final
name|Region
name|r
parameter_list|,
name|RegionLoad
operator|.
name|Builder
name|regionLoadBldr
parameter_list|,
name|RegionSpecifier
operator|.
name|Builder
name|regionSpecifier
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|name
init|=
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|int
name|stores
init|=
literal|0
decl_stmt|;
name|int
name|storefiles
init|=
literal|0
decl_stmt|;
name|int
name|storeUncompressedSizeMB
init|=
literal|0
decl_stmt|;
name|int
name|storefileSizeMB
init|=
literal|0
decl_stmt|;
name|int
name|memstoreSizeMB
init|=
call|(
name|int
call|)
argument_list|(
name|r
operator|.
name|getMemstoreSize
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
decl_stmt|;
name|int
name|storefileIndexSizeMB
init|=
literal|0
decl_stmt|;
name|int
name|rootIndexSizeKB
init|=
literal|0
decl_stmt|;
name|int
name|totalStaticIndexSizeKB
init|=
literal|0
decl_stmt|;
name|int
name|totalStaticBloomSizeKB
init|=
literal|0
decl_stmt|;
name|long
name|totalCompactingKVs
init|=
literal|0
decl_stmt|;
name|long
name|currentCompactedKVs
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Store
argument_list|>
name|storeList
init|=
name|r
operator|.
name|getStores
argument_list|()
decl_stmt|;
name|stores
operator|+=
name|storeList
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|Store
name|store
range|:
name|storeList
control|)
block|{
name|storefiles
operator|+=
name|store
operator|.
name|getStorefilesCount
argument_list|()
expr_stmt|;
name|storeUncompressedSizeMB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStoreSizeUncompressed
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|storefileSizeMB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStorefilesSize
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|storefileIndexSizeMB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStorefilesIndexSize
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|CompactionProgress
name|progress
init|=
name|store
operator|.
name|getCompactionProgress
argument_list|()
decl_stmt|;
if|if
condition|(
name|progress
operator|!=
literal|null
condition|)
block|{
name|totalCompactingKVs
operator|+=
name|progress
operator|.
name|totalCompactingKVs
expr_stmt|;
name|currentCompactedKVs
operator|+=
name|progress
operator|.
name|currentCompactedKVs
expr_stmt|;
block|}
name|rootIndexSizeKB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStorefilesIndexSize
argument_list|()
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|totalStaticIndexSizeKB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getTotalStaticIndexSize
argument_list|()
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|totalStaticBloomSizeKB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getTotalStaticBloomSize
argument_list|()
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
name|float
name|dataLocality
init|=
name|r
operator|.
name|getHDFSBlocksDistribution
argument_list|()
operator|.
name|getBlockLocalityIndex
argument_list|(
name|serverName
operator|.
name|getHostname
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionLoadBldr
operator|==
literal|null
condition|)
block|{
name|regionLoadBldr
operator|=
name|RegionLoad
operator|.
name|newBuilder
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|regionSpecifier
operator|==
literal|null
condition|)
block|{
name|regionSpecifier
operator|=
name|RegionSpecifier
operator|.
name|newBuilder
argument_list|()
expr_stmt|;
block|}
name|regionSpecifier
operator|.
name|setType
argument_list|(
name|RegionSpecifierType
operator|.
name|REGION_NAME
argument_list|)
expr_stmt|;
name|regionSpecifier
operator|.
name|setValue
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|regionLoadBldr
operator|.
name|setRegionSpecifier
argument_list|(
name|regionSpecifier
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|setStores
argument_list|(
name|stores
argument_list|)
operator|.
name|setStorefiles
argument_list|(
name|storefiles
argument_list|)
operator|.
name|setStoreUncompressedSizeMB
argument_list|(
name|storeUncompressedSizeMB
argument_list|)
operator|.
name|setStorefileSizeMB
argument_list|(
name|storefileSizeMB
argument_list|)
operator|.
name|setMemstoreSizeMB
argument_list|(
name|memstoreSizeMB
argument_list|)
operator|.
name|setStorefileIndexSizeMB
argument_list|(
name|storefileIndexSizeMB
argument_list|)
operator|.
name|setRootIndexSizeKB
argument_list|(
name|rootIndexSizeKB
argument_list|)
operator|.
name|setTotalStaticIndexSizeKB
argument_list|(
name|totalStaticIndexSizeKB
argument_list|)
operator|.
name|setTotalStaticBloomSizeKB
argument_list|(
name|totalStaticBloomSizeKB
argument_list|)
operator|.
name|setReadRequestsCount
argument_list|(
name|r
operator|.
name|getReadRequestsCount
argument_list|()
argument_list|)
operator|.
name|setFilteredReadRequestsCount
argument_list|(
name|r
operator|.
name|getFilteredReadRequestsCount
argument_list|()
argument_list|)
operator|.
name|setWriteRequestsCount
argument_list|(
name|r
operator|.
name|getWriteRequestsCount
argument_list|()
argument_list|)
operator|.
name|setTotalCompactingKVs
argument_list|(
name|totalCompactingKVs
argument_list|)
operator|.
name|setCurrentCompactedKVs
argument_list|(
name|currentCompactedKVs
argument_list|)
operator|.
name|setDataLocality
argument_list|(
name|dataLocality
argument_list|)
operator|.
name|setLastMajorCompactionTs
argument_list|(
name|r
operator|.
name|getOldestHfileTs
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|HRegion
operator|)
name|r
operator|)
operator|.
name|setCompleteSequenceId
argument_list|(
name|regionLoadBldr
argument_list|)
expr_stmt|;
return|return
name|regionLoadBldr
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * @param encodedRegionName    * @return An instance of RegionLoad.    */
specifier|public
name|RegionLoad
name|createRegionLoad
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
throws|throws
name|IOException
block|{
name|Region
name|r
init|=
name|onlineRegions
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
return|return
name|r
operator|!=
literal|null
condition|?
name|createRegionLoad
argument_list|(
name|r
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
else|:
literal|null
return|;
block|}
comment|/*    * Inner class that runs on a long period checking if regions need compaction.    */
specifier|private
specifier|static
class|class
name|CompactionChecker
extends|extends
name|ScheduledChore
block|{
specifier|private
specifier|final
name|HRegionServer
name|instance
decl_stmt|;
specifier|private
specifier|final
name|int
name|majorCompactPriority
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|DEFAULT_PRIORITY
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
name|long
name|iteration
init|=
literal|0
decl_stmt|;
name|CompactionChecker
parameter_list|(
specifier|final
name|HRegionServer
name|h
parameter_list|,
specifier|final
name|int
name|sleepTime
parameter_list|,
specifier|final
name|Stoppable
name|stopper
parameter_list|)
block|{
name|super
argument_list|(
literal|"CompactionChecker"
argument_list|,
name|stopper
argument_list|,
name|sleepTime
argument_list|)
expr_stmt|;
name|this
operator|.
name|instance
operator|=
name|h
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|this
operator|.
name|getName
argument_list|()
operator|+
literal|" runs every "
operator|+
name|StringUtils
operator|.
name|formatTime
argument_list|(
name|sleepTime
argument_list|)
argument_list|)
expr_stmt|;
comment|/* MajorCompactPriority is configurable.        * If not set, the compaction will use default priority.        */
name|this
operator|.
name|majorCompactPriority
operator|=
name|this
operator|.
name|instance
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.compactionChecker.majorCompactPriority"
argument_list|,
name|DEFAULT_PRIORITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
for|for
control|(
name|Region
name|r
range|:
name|this
operator|.
name|instance
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|==
literal|null
condition|)
continue|continue;
for|for
control|(
name|Store
name|s
range|:
name|r
operator|.
name|getStores
argument_list|()
control|)
block|{
try|try
block|{
name|long
name|multiplier
init|=
name|s
operator|.
name|getCompactionCheckMultiplier
argument_list|()
decl_stmt|;
assert|assert
name|multiplier
operator|>
literal|0
assert|;
if|if
condition|(
name|iteration
operator|%
name|multiplier
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|.
name|needsCompaction
argument_list|()
condition|)
block|{
comment|// Queue a compaction. Will recognize if major is needed.
name|this
operator|.
name|instance
operator|.
name|compactSplitThread
operator|.
name|requestSystemCompaction
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
name|getName
argument_list|()
operator|+
literal|" requests compaction"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|isMajorCompaction
argument_list|()
condition|)
block|{
if|if
condition|(
name|majorCompactPriority
operator|==
name|DEFAULT_PRIORITY
operator|||
name|majorCompactPriority
operator|>
operator|(
operator|(
name|HRegion
operator|)
name|r
operator|)
operator|.
name|getCompactPriority
argument_list|()
condition|)
block|{
name|this
operator|.
name|instance
operator|.
name|compactSplitThread
operator|.
name|requestCompaction
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
name|getName
argument_list|()
operator|+
literal|" requests major compaction; use default priority"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|instance
operator|.
name|compactSplitThread
operator|.
name|requestCompaction
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
name|getName
argument_list|()
operator|+
literal|" requests major compaction; use configured priority"
argument_list|,
name|this
operator|.
name|majorCompactPriority
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed major compaction check on "
operator|+
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|iteration
operator|=
operator|(
name|iteration
operator|==
name|Long
operator|.
name|MAX_VALUE
operator|)
condition|?
literal|0
else|:
operator|(
name|iteration
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
specifier|static
class|class
name|PeriodicMemstoreFlusher
extends|extends
name|ScheduledChore
block|{
specifier|final
name|HRegionServer
name|server
decl_stmt|;
specifier|final
specifier|static
name|int
name|RANGE_OF_DELAY
init|=
literal|5
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
comment|// 5 min in milliseconds
specifier|final
specifier|static
name|int
name|MIN_DELAY_TIME
init|=
literal|0
decl_stmt|;
comment|// millisec
specifier|public
name|PeriodicMemstoreFlusher
parameter_list|(
name|int
name|cacheFlushInterval
parameter_list|,
specifier|final
name|HRegionServer
name|server
parameter_list|)
block|{
name|super
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|"-MemstoreFlusherChore"
argument_list|,
name|server
argument_list|,
name|cacheFlushInterval
argument_list|)
expr_stmt|;
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
specifier|final
name|StringBuffer
name|whyFlush
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|Region
name|r
range|:
name|this
operator|.
name|server
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|HRegion
operator|)
name|r
operator|)
operator|.
name|shouldFlush
argument_list|(
name|whyFlush
argument_list|)
condition|)
block|{
name|FlushRequester
name|requester
init|=
name|server
operator|.
name|getFlushRequester
argument_list|()
decl_stmt|;
if|if
condition|(
name|requester
operator|!=
literal|null
condition|)
block|{
name|long
name|randomDelay
init|=
name|RandomUtils
operator|.
name|nextInt
argument_list|(
name|RANGE_OF_DELAY
argument_list|)
operator|+
name|MIN_DELAY_TIME
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|" requesting flush of "
operator|+
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" because "
operator|+
name|whyFlush
operator|.
name|toString
argument_list|()
operator|+
literal|" after random delay "
operator|+
name|randomDelay
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
comment|//Throttle the flushes by putting a delay. If we don't throttle, and there
comment|//is a balanced write-load on the regions in a table, we might end up
comment|//overwhelming the filesystem with too many flushes at once.
name|requester
operator|.
name|requestDelayedFlush
argument_list|(
name|r
argument_list|,
name|randomDelay
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Report the status of the server. A server is online once all the startup is    * completed (setting up filesystem, starting service threads, etc.). This    * method is designed mostly to be useful in tests.    *    * @return true if online, false if not.    */
specifier|public
name|boolean
name|isOnline
parameter_list|()
block|{
return|return
name|online
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Setup WAL log and replication if enabled.    * Replication setup is done in here because it wants to be hooked up to WAL.    * @return A WAL instance.    * @throws IOException    */
specifier|private
name|WALFactory
name|setupWALAndReplication
parameter_list|()
throws|throws
name|IOException
block|{
comment|// TODO Replication make assumptions here based on the default filesystem impl
specifier|final
name|Path
name|oldLogDir
init|=
operator|new
name|Path
argument_list|(
name|rootDir
argument_list|,
name|HConstants
operator|.
name|HREGION_OLDLOGDIR_NAME
argument_list|)
decl_stmt|;
specifier|final
name|String
name|logName
init|=
name|AbstractFSWALProvider
operator|.
name|getWALDirectoryName
argument_list|(
name|this
operator|.
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|logdir
init|=
operator|new
name|Path
argument_list|(
name|rootDir
argument_list|,
name|logName
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"logdir="
operator|+
name|logdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|fs
operator|.
name|exists
argument_list|(
name|logdir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RegionServerRunningException
argument_list|(
literal|"Region server has already "
operator|+
literal|"created directory at "
operator|+
name|this
operator|.
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|// Instantiate replication manager if replication enabled.  Pass it the
comment|// log directories.
name|createNewReplicationInstance
argument_list|(
name|conf
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|fs
argument_list|,
name|logdir
argument_list|,
name|oldLogDir
argument_list|)
expr_stmt|;
comment|// listeners the wal factory will add to wals it creates.
specifier|final
name|List
argument_list|<
name|WALActionsListener
argument_list|>
name|listeners
init|=
operator|new
name|ArrayList
argument_list|<
name|WALActionsListener
argument_list|>
argument_list|()
decl_stmt|;
name|listeners
operator|.
name|add
argument_list|(
operator|new
name|MetricsWAL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicationSourceHandler
operator|!=
literal|null
operator|&&
name|this
operator|.
name|replicationSourceHandler
operator|.
name|getWALActionsListener
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// Replication handler is an implementation of WALActionsListener.
name|listeners
operator|.
name|add
argument_list|(
name|this
operator|.
name|replicationSourceHandler
operator|.
name|getWALActionsListener
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|WALFactory
argument_list|(
name|conf
argument_list|,
name|listeners
argument_list|,
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|MetricsRegionServer
name|getRegionServerMetrics
parameter_list|()
block|{
return|return
name|this
operator|.
name|metricsRegionServer
return|;
block|}
comment|/**    * @return Master address tracker instance.    */
specifier|public
name|MasterAddressTracker
name|getMasterAddressTracker
parameter_list|()
block|{
return|return
name|this
operator|.
name|masterAddressTracker
return|;
block|}
comment|/*    * Start maintenance Threads, Server, Worker and lease checker threads.    * Install an UncaughtExceptionHandler that calls abort of RegionServer if we    * get an unhandled exception. We cannot set the handler on all threads.    * Server's internal Listener thread is off limits. For Server, if an OOME, it    * waits a while then retries. Meantime, a flush or a compaction that tries to    * run should trigger same critical condition and the shutdown will run. On    * its way out, this server will shut down Server. Leases are sort of    * inbetween. It has an internal thread that while it inherits from Chore, it    * keeps its own internal stop mechanism so needs to be stopped by this    * hosting server. Worker logs the exception and exits.    */
specifier|private
name|void
name|startServiceThreads
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Start executor services
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_OPEN_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.openregion.threads"
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_OPEN_META
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.openmeta.threads"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_OPEN_PRIORITY_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.openpriorityregion.threads"
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_CLOSE_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.closeregion.threads"
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_CLOSE_META
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.closemeta.threads"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|StoreScanner
operator|.
name|STORESCANNER_PARALLEL_SEEK_ENABLE
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_PARALLEL_SEEK
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.storescanner.parallel.seek.threads"
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_LOG_REPLAY_OPS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.wal.max.splitters"
argument_list|,
name|SplitLogWorkerCoordination
operator|.
name|DEFAULT_MAX_SPLITTERS
argument_list|)
argument_list|)
expr_stmt|;
comment|// Start the threads for compacted files discharger
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_COMPACTED_FILES_DISCHARGER
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|CompactionConfiguration
operator|.
name|HBASE_HFILE_COMPACTION_DISCHARGER_THREAD_COUNT
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ServerRegionReplicaUtil
operator|.
name|isRegionReplicaWaitForPrimaryFlushEnabled
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_REGION_REPLICA_FLUSH_OPS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.region.replica.flusher.threads"
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.openregion.threads"
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|walRoller
operator|.
name|getThread
argument_list|()
argument_list|,
name|getName
argument_list|()
operator|+
literal|".logRoller"
argument_list|,
name|uncaughtExceptionHandler
argument_list|)
expr_stmt|;
name|this
operator|.
name|cacheFlusher
operator|.
name|start
argument_list|(
name|uncaughtExceptionHandler
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|compactionChecker
operator|!=
literal|null
condition|)
name|choreService
operator|.
name|scheduleChore
argument_list|(
name|compactionChecker
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|periodicFlusher
operator|!=
literal|null
condition|)
name|choreService
operator|.
name|scheduleChore
argument_list|(
name|periodicFlusher
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|healthCheckChore
operator|!=
literal|null
condition|)
name|choreService
operator|.
name|scheduleChore
argument_list|(
name|healthCheckChore
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|nonceManagerChore
operator|!=
literal|null
condition|)
name|choreService
operator|.
name|scheduleChore
argument_list|(
name|nonceManagerChore
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|storefileRefresher
operator|!=
literal|null
condition|)
name|choreService
operator|.
name|scheduleChore
argument_list|(
name|storefileRefresher
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|movedRegionsCleaner
operator|!=
literal|null
condition|)
name|choreService
operator|.
name|scheduleChore
argument_list|(
name|movedRegionsCleaner
argument_list|)
expr_stmt|;
comment|// Leases is not a Thread. Internally it runs a daemon thread. If it gets
comment|// an unhandled exception, it will just exit.
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|leases
operator|.
name|getThread
argument_list|()
argument_list|,
name|getName
argument_list|()
operator|+
literal|".leaseChecker"
argument_list|,
name|uncaughtExceptionHandler
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicationSourceHandler
operator|==
name|this
operator|.
name|replicationSinkHandler
operator|&&
name|this
operator|.
name|replicationSourceHandler
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|replicationSourceHandler
operator|.
name|startReplicationService
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|this
operator|.
name|replicationSourceHandler
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|replicationSourceHandler
operator|.
name|startReplicationService
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|replicationSinkHandler
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|replicationSinkHandler
operator|.
name|startReplicationService
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Create the log splitting worker and start it
comment|// set a smaller retries to fast fail otherwise splitlogworker could be blocked for
comment|// quite a while inside Connection layer. The worker won't be available for other
comment|// tasks even after current task is preempted after a split task times out.
name|Configuration
name|sinkConf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|sinkConf
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.log.replay.retries.number"
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|// 8 retries take about 23 seconds
name|sinkConf
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|HBASE_RPC_TIMEOUT_KEY
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.log.replay.rpc.timeout"
argument_list|,
literal|30000
argument_list|)
argument_list|)
expr_stmt|;
comment|// default 30 seconds
name|sinkConf
operator|.
name|setInt
argument_list|(
literal|"hbase.client.serverside.retries.multiplier"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|splitLogWorker
operator|=
operator|new
name|SplitLogWorker
argument_list|(
name|this
argument_list|,
name|sinkConf
argument_list|,
name|this
argument_list|,
name|this
argument_list|,
name|walFactory
argument_list|)
expr_stmt|;
name|splitLogWorker
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**    * Puts up the webui.    * @return Returns final port -- maybe different from what we started with.    * @throws IOException    */
specifier|private
name|int
name|putUpWebUI
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|port
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|REGIONSERVER_INFO_PORT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_REGIONSERVER_INFOPORT
argument_list|)
decl_stmt|;
name|String
name|addr
init|=
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|instanceof
name|HMaster
condition|)
block|{
name|port
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|MASTER_INFO_PORT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_INFOPORT
argument_list|)
expr_stmt|;
name|addr
operator|=
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.master.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
expr_stmt|;
block|}
comment|// -1 is for disabling info server
if|if
condition|(
name|port
operator|<
literal|0
condition|)
return|return
name|port
return|;
if|if
condition|(
operator|!
name|Addressing
operator|.
name|isLocalAddress
argument_list|(
name|InetAddress
operator|.
name|getByName
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Failed to start http info server. Address "
operator|+
name|addr
operator|+
literal|" does not belong to this host. Correct configuration parameter: "
operator|+
literal|"hbase.regionserver.info.bindAddress"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|// check if auto port bind enabled
name|boolean
name|auto
init|=
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|REGIONSERVER_INFO_PORT_AUTO
argument_list|,
literal|false
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|this
operator|.
name|infoServer
operator|=
operator|new
name|InfoServer
argument_list|(
name|getProcessName
argument_list|()
argument_list|,
name|addr
argument_list|,
name|port
argument_list|,
literal|false
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|"dump"
argument_list|,
literal|"/dump"
argument_list|,
name|getDumpServlet
argument_list|()
argument_list|)
expr_stmt|;
name|configureInfoServer
argument_list|()
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|BindException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|auto
condition|)
block|{
comment|// auto bind disabled throw BindException
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed binding http info server to port: "
operator|+
name|port
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
comment|// auto bind enabled, try to use another port
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed binding http info server to port: "
operator|+
name|port
argument_list|)
expr_stmt|;
name|port
operator|++
expr_stmt|;
block|}
block|}
name|port
operator|=
name|this
operator|.
name|infoServer
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|REGIONSERVER_INFO_PORT
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|int
name|masterInfoPort
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|MASTER_INFO_PORT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_INFOPORT
argument_list|)
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
literal|"hbase.master.info.port.orig"
argument_list|,
name|masterInfoPort
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|MASTER_INFO_PORT
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|port
return|;
block|}
comment|/*    * Verify that server is healthy    */
specifier|private
name|boolean
name|isHealthy
parameter_list|()
block|{
if|if
condition|(
operator|!
name|fsOk
condition|)
block|{
comment|// File system problem
return|return
literal|false
return|;
block|}
comment|// Verify that all threads are alive
if|if
condition|(
operator|!
operator|(
name|leases
operator|.
name|isAlive
argument_list|()
operator|&&
name|cacheFlusher
operator|.
name|isAlive
argument_list|()
operator|&&
name|walRoller
operator|.
name|isAlive
argument_list|()
operator|&&
name|this
operator|.
name|compactionChecker
operator|.
name|isScheduled
argument_list|()
operator|&&
name|this
operator|.
name|periodicFlusher
operator|.
name|isScheduled
argument_list|()
operator|)
condition|)
block|{
name|stop
argument_list|(
literal|"One or more threads are no longer alive -- stop"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|UNSPECIFIED_REGION
init|=
operator|new
name|byte
index|[]
block|{}
decl_stmt|;
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|WAL
argument_list|>
name|getWALs
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|walFactory
operator|.
name|getWALs
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|WAL
name|getWAL
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|WAL
name|wal
decl_stmt|;
comment|// _ROOT_ and hbase:meta regions have separate WAL.
if|if
condition|(
name|regionInfo
operator|!=
literal|null
operator|&&
name|regionInfo
operator|.
name|isMetaTable
argument_list|()
operator|&&
name|regionInfo
operator|.
name|getReplicaId
argument_list|()
operator|==
name|HRegionInfo
operator|.
name|DEFAULT_REPLICA_ID
condition|)
block|{
name|wal
operator|=
name|walFactory
operator|.
name|getMetaWAL
argument_list|(
name|regionInfo
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regionInfo
operator|==
literal|null
condition|)
block|{
name|wal
operator|=
name|walFactory
operator|.
name|getWAL
argument_list|(
name|UNSPECIFIED_REGION
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|namespace
init|=
name|regionInfo
operator|.
name|getTable
argument_list|()
operator|.
name|getNamespace
argument_list|()
decl_stmt|;
name|wal
operator|=
name|walFactory
operator|.
name|getWAL
argument_list|(
name|regionInfo
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
block|}
name|walRoller
operator|.
name|addWAL
argument_list|(
name|wal
argument_list|)
expr_stmt|;
return|return
name|wal
return|;
block|}
annotation|@
name|Override
specifier|public
name|Connection
name|getConnection
parameter_list|()
block|{
return|return
name|getClusterConnection
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|ClusterConnection
name|getClusterConnection
parameter_list|()
block|{
return|return
name|this
operator|.
name|clusterConnection
return|;
block|}
annotation|@
name|Override
specifier|public
name|MetaTableLocator
name|getMetaTableLocator
parameter_list|()
block|{
return|return
name|this
operator|.
name|metaTableLocator
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|stopped
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"***** STOPPING region server '"
operator|+
name|this
operator|+
literal|"' *****"
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|this
operator|.
name|rsHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|rsHost
operator|.
name|preStop
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|stopped
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"STOPPED: "
operator|+
name|msg
argument_list|)
expr_stmt|;
comment|// Wakes run() if it is sleeping
name|sleeper
operator|.
name|skipSleepCycle
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exp
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The region server did not stop"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|waitForServerOnline
parameter_list|()
block|{
while|while
condition|(
operator|!
name|isStopped
argument_list|()
operator|&&
operator|!
name|isOnline
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|online
init|)
block|{
try|try
block|{
name|online
operator|.
name|wait
argument_list|(
name|msgInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|postOpenDeployTasks
parameter_list|(
specifier|final
name|Region
name|r
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
name|postOpenDeployTasks
argument_list|(
operator|new
name|PostOpenDeployContext
argument_list|(
name|r
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|postOpenDeployTasks
parameter_list|(
specifier|final
name|PostOpenDeployContext
name|context
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
name|Region
name|r
init|=
name|context
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|long
name|masterSystemTime
init|=
name|context
operator|.
name|getMasterSystemTime
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|r
operator|instanceof
name|HRegion
argument_list|,
literal|"r must be an HRegion"
argument_list|)
expr_stmt|;
name|rpcServices
operator|.
name|checkOpen
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Post open deploy tasks for "
operator|+
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Do checks to see if we need to compact (references or too many files)
for|for
control|(
name|Store
name|s
range|:
name|r
operator|.
name|getStores
argument_list|()
control|)
block|{
if|if
condition|(
name|s
operator|.
name|hasReferences
argument_list|()
operator|||
name|s
operator|.
name|needsCompaction
argument_list|()
condition|)
block|{
name|this
operator|.
name|compactSplitThread
operator|.
name|requestSystemCompaction
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
literal|"Opening Region"
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|openSeqNum
init|=
name|r
operator|.
name|getOpenSeqNum
argument_list|()
decl_stmt|;
if|if
condition|(
name|openSeqNum
operator|==
name|HConstants
operator|.
name|NO_SEQNUM
condition|)
block|{
comment|// If we opened a region, we should have read some sequence number from it.
name|LOG
operator|.
name|error
argument_list|(
literal|"No sequence number found when opening "
operator|+
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|openSeqNum
operator|=
literal|0
expr_stmt|;
block|}
comment|// Update flushed sequence id of a recovering region in ZK
name|updateRecoveringRegionLastFlushedSequenceId
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|// Notify master
if|if
condition|(
operator|!
name|reportRegionStateTransition
argument_list|(
operator|new
name|RegionStateTransitionContext
argument_list|(
name|TransitionCode
operator|.
name|OPENED
argument_list|,
name|openSeqNum
argument_list|,
name|masterSystemTime
argument_list|,
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to report opened region to master: "
operator|+
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
throw|;
block|}
name|triggerFlushInPrimaryRegion
argument_list|(
operator|(
name|HRegion
operator|)
name|r
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Finished post open deploy task for "
operator|+
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|reportRegionStateTransition
parameter_list|(
name|TransitionCode
name|code
parameter_list|,
name|HRegionInfo
modifier|...
name|hris
parameter_list|)
block|{
return|return
name|reportRegionStateTransition
argument_list|(
name|code
argument_list|,
name|HConstants
operator|.
name|NO_SEQNUM
argument_list|,
name|hris
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|reportRegionStateTransition
parameter_list|(
name|TransitionCode
name|code
parameter_list|,
name|long
name|openSeqNum
parameter_list|,
name|HRegionInfo
modifier|...
name|hris
parameter_list|)
block|{
return|return
name|reportRegionStateTransition
argument_list|(
operator|new
name|RegionStateTransitionContext
argument_list|(
name|code
argument_list|,
name|HConstants
operator|.
name|NO_SEQNUM
argument_list|,
operator|-
literal|1
argument_list|,
name|hris
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|reportRegionStateTransition
parameter_list|(
specifier|final
name|RegionStateTransitionContext
name|context
parameter_list|)
block|{
name|TransitionCode
name|code
init|=
name|context
operator|.
name|getCode
argument_list|()
decl_stmt|;
name|long
name|openSeqNum
init|=
name|context
operator|.
name|getOpenSeqNum
argument_list|()
decl_stmt|;
name|long
name|masterSystemTime
init|=
name|context
operator|.
name|getMasterSystemTime
argument_list|()
decl_stmt|;
name|HRegionInfo
index|[]
name|hris
init|=
name|context
operator|.
name|getHris
argument_list|()
decl_stmt|;
if|if
condition|(
name|TEST_SKIP_REPORTING_TRANSITION
condition|)
block|{
comment|// This is for testing only in case there is no master
comment|// to handle the region transition report at all.
if|if
condition|(
name|code
operator|==
name|TransitionCode
operator|.
name|OPENED
condition|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|hris
operator|!=
literal|null
operator|&&
name|hris
operator|.
name|length
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hris
index|[
literal|0
index|]
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
try|try
block|{
name|MetaTableLocator
operator|.
name|setMetaLocation
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|serverName
argument_list|,
name|hris
index|[
literal|0
index|]
operator|.
name|getReplicaId
argument_list|()
argument_list|,
name|State
operator|.
name|OPEN
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to update meta location"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
try|try
block|{
name|MetaTableAccessor
operator|.
name|updateRegionLocation
argument_list|(
name|clusterConnection
argument_list|,
name|hris
index|[
literal|0
index|]
argument_list|,
name|serverName
argument_list|,
name|openSeqNum
argument_list|,
name|masterSystemTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to update meta"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
name|ReportRegionStateTransitionRequest
operator|.
name|Builder
name|builder
init|=
name|ReportRegionStateTransitionRequest
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setServer
argument_list|(
name|ProtobufUtil
operator|.
name|toServerName
argument_list|(
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
name|RegionStateTransition
operator|.
name|Builder
name|transition
init|=
name|builder
operator|.
name|addTransitionBuilder
argument_list|()
decl_stmt|;
name|transition
operator|.
name|setTransitionCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TransitionCode
operator|.
name|OPENED
operator|&&
name|openSeqNum
operator|>=
literal|0
condition|)
block|{
name|transition
operator|.
name|setOpenSeqNum
argument_list|(
name|openSeqNum
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|hris
control|)
block|{
name|transition
operator|.
name|addRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|hri
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ReportRegionStateTransitionRequest
name|request
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
while|while
condition|(
name|keepLooping
argument_list|()
condition|)
block|{
name|RegionServerStatusService
operator|.
name|BlockingInterface
name|rss
init|=
name|rssStub
decl_stmt|;
try|try
block|{
if|if
condition|(
name|rss
operator|==
literal|null
condition|)
block|{
name|createRegionServerStatusStub
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|ReportRegionStateTransitionResponse
name|response
init|=
name|rss
operator|.
name|reportRegionStateTransition
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
if|if
condition|(
name|response
operator|.
name|hasErrorMessage
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to transition "
operator|+
name|hris
index|[
literal|0
index|]
operator|+
literal|" to "
operator|+
name|code
operator|+
literal|": "
operator|+
name|response
operator|.
name|getErrorMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
name|IOException
name|ioe
init|=
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to report region transition, will retry"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|rssStub
operator|==
name|rss
condition|)
block|{
name|rssStub
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|requestRegionSplit
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|byte
index|[]
name|splitRow
parameter_list|)
block|{
name|NonceGenerator
name|ng
init|=
name|clusterConnection
operator|.
name|getNonceGenerator
argument_list|()
decl_stmt|;
specifier|final
name|long
name|nonceGroup
init|=
name|ng
operator|.
name|getNonceGroup
argument_list|()
decl_stmt|;
specifier|final
name|long
name|nonce
init|=
name|ng
operator|.
name|newNonce
argument_list|()
decl_stmt|;
name|long
name|procId
init|=
operator|-
literal|1
decl_stmt|;
name|SplitTableRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildSplitTableRegionRequest
argument_list|(
name|regionInfo
argument_list|,
name|splitRow
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
while|while
condition|(
name|keepLooping
argument_list|()
condition|)
block|{
name|RegionServerStatusService
operator|.
name|BlockingInterface
name|rss
init|=
name|rssStub
decl_stmt|;
try|try
block|{
if|if
condition|(
name|rss
operator|==
literal|null
condition|)
block|{
name|createRegionServerStatusStub
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|SplitTableRegionResponse
name|response
init|=
name|rss
operator|.
name|splitRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
comment|//TODO: should we limit the retry number before quitting?
if|if
condition|(
name|response
operator|==
literal|null
operator|||
operator|(
name|procId
operator|=
name|response
operator|.
name|getProcId
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to split "
operator|+
name|regionInfo
operator|+
literal|" retrying..."
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
comment|// TODO: retry or just fail
name|IOException
name|ioe
init|=
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to split region, will retry"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|rssStub
operator|==
name|rss
condition|)
block|{
name|rssStub
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|return
name|procId
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isProcedureFinished
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|)
throws|throws
name|IOException
block|{
name|GetProcedureResultRequest
name|request
init|=
name|GetProcedureResultRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setProcId
argument_list|(
name|procId
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
while|while
condition|(
name|keepLooping
argument_list|()
condition|)
block|{
name|RegionServerStatusService
operator|.
name|BlockingInterface
name|rss
init|=
name|rssStub
decl_stmt|;
try|try
block|{
if|if
condition|(
name|rss
operator|==
literal|null
condition|)
block|{
name|createRegionServerStatusStub
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// TODO: find a way to get proc result
name|GetProcedureResultResponse
name|response
init|=
name|rss
operator|.
name|getProcedureResult
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
if|if
condition|(
name|response
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get procedure (id="
operator|+
name|procId
operator|+
literal|") status."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|response
operator|.
name|getState
argument_list|()
operator|==
name|GetProcedureResultResponse
operator|.
name|State
operator|.
name|RUNNING
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|response
operator|.
name|hasException
argument_list|()
condition|)
block|{
comment|// Procedure failed.
throw|throw
name|ForeignExceptionUtil
operator|.
name|toIOException
argument_list|(
name|response
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
comment|// Procedure completes successfully
break|break;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
comment|// TODO: retry or just fail
name|IOException
name|ioe
init|=
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get split region procedure result.  Retrying"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|rssStub
operator|==
name|rss
condition|)
block|{
name|rssStub
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Trigger a flush in the primary region replica if this region is a secondary replica. Does not    * block this thread. See RegionReplicaFlushHandler for details.    */
name|void
name|triggerFlushInPrimaryRegion
parameter_list|(
specifier|final
name|HRegion
name|region
parameter_list|)
block|{
if|if
condition|(
name|ServerRegionReplicaUtil
operator|.
name|isDefaultReplica
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|ServerRegionReplicaUtil
operator|.
name|isRegionReplicaReplicationEnabled
argument_list|(
name|region
operator|.
name|conf
argument_list|)
operator|||
operator|!
name|ServerRegionReplicaUtil
operator|.
name|isRegionReplicaWaitForPrimaryFlushEnabled
argument_list|(
name|region
operator|.
name|conf
argument_list|)
condition|)
block|{
name|region
operator|.
name|setReadsEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|region
operator|.
name|setReadsEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// disable reads before marking the region as opened.
comment|// RegionReplicaFlushHandler might reset this.
comment|// submit it to be handled by one of the handlers so that we do not block OpenRegionHandler
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
operator|new
name|RegionReplicaFlushHandler
argument_list|(
name|this
argument_list|,
name|clusterConnection
argument_list|,
name|rpcRetryingCallerFactory
argument_list|,
name|rpcControllerFactory
argument_list|,
name|operationTimeout
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RpcServerInterface
name|getRpcServer
parameter_list|()
block|{
return|return
name|rpcServices
operator|.
name|rpcServer
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|RSRpcServices
name|getRSRpcServices
parameter_list|()
block|{
return|return
name|rpcServices
return|;
block|}
comment|/**    * Cause the server to exit without closing the regions it is serving, the log    * it is using and without notifying the master. Used unit testing and on    * catastrophic events such as HDFS is yanked out from under hbase or we OOME.    *    * @param reason    *          the reason we are aborting    * @param cause    *          the exception that caused the abort, or null    */
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|reason
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"***** ABORTING region server "
operator|+
name|this
operator|+
literal|": "
operator|+
name|reason
operator|+
literal|" *****"
decl_stmt|;
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|abortRequested
operator|=
literal|true
expr_stmt|;
comment|// HBASE-4014: show list of coprocessors that were loaded to help debug
comment|// regionserver crashes.Note that we're implicitly using
comment|// java.util.HashSet's toString() method to print the coprocessor names.
name|LOG
operator|.
name|fatal
argument_list|(
literal|"RegionServer abort: loaded coprocessors are: "
operator|+
name|CoprocessorHost
operator|.
name|getLoadedCoprocessors
argument_list|()
argument_list|)
expr_stmt|;
comment|// Try and dump metrics if abort -- might give clue as to how fatal came about....
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Dump of metrics as JSON on abort: "
operator|+
name|JSONBean
operator|.
name|dumpRegionServerMetrics
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedObjectNameException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed dumping metrics"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Do our best to report our abort to the master, but this may not work
try|try
block|{
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
name|msg
operator|+=
literal|"\nCause:\n"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|cause
argument_list|)
expr_stmt|;
block|}
comment|// Report to the master but only if we have already registered with the master.
if|if
condition|(
name|rssStub
operator|!=
literal|null
operator|&&
name|this
operator|.
name|serverName
operator|!=
literal|null
condition|)
block|{
name|ReportRSFatalErrorRequest
operator|.
name|Builder
name|builder
init|=
name|ReportRSFatalErrorRequest
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ServerName
name|sn
init|=
name|ServerName
operator|.
name|parseVersionedServerName
argument_list|(
name|this
operator|.
name|serverName
operator|.
name|getVersionedBytes
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|setServer
argument_list|(
name|ProtobufUtil
operator|.
name|toServerName
argument_list|(
name|sn
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setErrorMessage
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|rssStub
operator|.
name|reportRSFatalError
argument_list|(
literal|null
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to report fatal error to master"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|stop
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
comment|/**    * @see HRegionServer#abort(String, Throwable)    */
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
name|abort
argument_list|(
name|reason
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAborted
parameter_list|()
block|{
return|return
name|this
operator|.
name|abortRequested
return|;
block|}
comment|/*    * Simulate a kill -9 of this server. Exits w/o closing regions or cleaninup    * logs but it does close socket in case want to bring up server on old    * hostname+port immediately.    */
specifier|protected
name|void
name|kill
parameter_list|()
block|{
name|this
operator|.
name|killed
operator|=
literal|true
expr_stmt|;
name|abort
argument_list|(
literal|"Simulated kill"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called on stop/abort before closing the cluster connection and meta locator.    */
specifier|protected
name|void
name|sendShutdownInterrupt
parameter_list|()
block|{   }
comment|/**    * Wait on all threads to finish. Presumption is that all closes and stops    * have already been called.    */
specifier|protected
name|void
name|stopServiceThreads
parameter_list|()
block|{
comment|// clean up the scheduled chores
if|if
condition|(
name|this
operator|.
name|choreService
operator|!=
literal|null
condition|)
name|choreService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|nonceManagerChore
operator|!=
literal|null
condition|)
name|nonceManagerChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|compactionChecker
operator|!=
literal|null
condition|)
name|compactionChecker
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|periodicFlusher
operator|!=
literal|null
condition|)
name|periodicFlusher
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|healthCheckChore
operator|!=
literal|null
condition|)
name|healthCheckChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|storefileRefresher
operator|!=
literal|null
condition|)
name|storefileRefresher
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|movedRegionsCleaner
operator|!=
literal|null
condition|)
name|movedRegionsCleaner
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cacheFlusher
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|spanReceiverHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|spanReceiverHost
operator|.
name|closeReceivers
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|walRoller
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|walRoller
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|compactSplitThread
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|compactSplitThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|service
operator|!=
literal|null
condition|)
name|this
operator|.
name|service
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicationSourceHandler
operator|!=
literal|null
operator|&&
name|this
operator|.
name|replicationSourceHandler
operator|==
name|this
operator|.
name|replicationSinkHandler
condition|)
block|{
name|this
operator|.
name|replicationSourceHandler
operator|.
name|stopReplicationService
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|this
operator|.
name|replicationSourceHandler
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|replicationSourceHandler
operator|.
name|stopReplicationService
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|replicationSinkHandler
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|replicationSinkHandler
operator|.
name|stopReplicationService
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @return Return the object that implements the replication    * source service.    */
name|ReplicationSourceService
name|getReplicationSourceService
parameter_list|()
block|{
return|return
name|replicationSourceHandler
return|;
block|}
comment|/**    * @return Return the object that implements the replication    * sink service.    */
name|ReplicationSinkService
name|getReplicationSinkService
parameter_list|()
block|{
return|return
name|replicationSinkHandler
return|;
block|}
comment|/**    * Get the current master from ZooKeeper and open the RPC connection to it.    * To get a fresh connection, the current rssStub must be null.    * Method will block until a master is available. You can break from this    * block by requesting the server stop.    *    * @return master + port, or null if server has been stopped    */
annotation|@
name|VisibleForTesting
specifier|protected
specifier|synchronized
name|ServerName
name|createRegionServerStatusStub
parameter_list|()
block|{
comment|// Create RS stub without refreshing the master node from ZK, use cached data
return|return
name|createRegionServerStatusStub
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/**    * Get the current master from ZooKeeper and open the RPC connection to it. To get a fresh    * connection, the current rssStub must be null. Method will block until a master is available.    * You can break from this block by requesting the server stop.    * @param refresh If true then master address will be read from ZK, otherwise use cached data    * @return master + port, or null if server has been stopped    */
annotation|@
name|VisibleForTesting
specifier|protected
specifier|synchronized
name|ServerName
name|createRegionServerStatusStub
parameter_list|(
name|boolean
name|refresh
parameter_list|)
block|{
if|if
condition|(
name|rssStub
operator|!=
literal|null
condition|)
block|{
return|return
name|masterAddressTracker
operator|.
name|getMasterAddress
argument_list|()
return|;
block|}
name|ServerName
name|sn
init|=
literal|null
decl_stmt|;
name|long
name|previousLogTime
init|=
literal|0
decl_stmt|;
name|RegionServerStatusService
operator|.
name|BlockingInterface
name|intf
init|=
literal|null
decl_stmt|;
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
while|while
condition|(
name|keepLooping
argument_list|()
condition|)
block|{
name|sn
operator|=
name|this
operator|.
name|masterAddressTracker
operator|.
name|getMasterAddress
argument_list|(
name|refresh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sn
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|keepLooping
argument_list|()
condition|)
block|{
comment|// give up with no connection.
name|LOG
operator|.
name|debug
argument_list|(
literal|"No master found and cluster is stopped; bailing out"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|>
operator|(
name|previousLogTime
operator|+
literal|1000
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No master found; retry"
argument_list|)
expr_stmt|;
name|previousLogTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
name|refresh
operator|=
literal|true
expr_stmt|;
comment|// let's try pull it from ZK directly
if|if
condition|(
name|sleep
argument_list|(
literal|200
argument_list|)
condition|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
continue|continue;
block|}
comment|// If we are on the active master, use the shortcut
if|if
condition|(
name|this
operator|instanceof
name|HMaster
operator|&&
name|sn
operator|.
name|equals
argument_list|(
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|intf
operator|=
operator|(
operator|(
name|HMaster
operator|)
name|this
operator|)
operator|.
name|getMasterRpcServices
argument_list|()
expr_stmt|;
break|break;
block|}
try|try
block|{
name|BlockingRpcChannel
name|channel
init|=
name|this
operator|.
name|rpcClient
operator|.
name|createBlockingRpcChannel
argument_list|(
name|sn
argument_list|,
name|userProvider
operator|.
name|getCurrent
argument_list|()
argument_list|,
name|shortOperationTimeout
argument_list|)
decl_stmt|;
name|intf
operator|=
name|RegionServerStatusService
operator|.
name|newBlockingStub
argument_list|(
name|channel
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|>
operator|(
name|previousLogTime
operator|+
literal|1000
operator|)
condition|)
block|{
name|e
operator|=
name|e
operator|instanceof
name|RemoteException
condition|?
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
else|:
name|e
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|ServerNotRunningYetException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Master isn't available yet, retrying"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to connect to master. Retrying. Error was:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|previousLogTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sleep
argument_list|(
literal|200
argument_list|)
condition|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
name|rssStub
operator|=
name|intf
expr_stmt|;
return|return
name|sn
return|;
block|}
comment|/**    * @return True if we should break loop because cluster is going down or    * this server has been stopped or hdfs has gone bad.    */
specifier|private
name|boolean
name|keepLooping
parameter_list|()
block|{
return|return
operator|!
name|this
operator|.
name|stopped
operator|&&
name|isClusterUp
argument_list|()
return|;
block|}
comment|/*    * Let the master know we're here Run initialization using parameters passed    * us by the master.    * @return A Map of key/value configurations we got from the Master else    * null if we failed to register.    * @throws IOException    */
specifier|private
name|RegionServerStartupResponse
name|reportForDuty
parameter_list|()
throws|throws
name|IOException
block|{
name|ServerName
name|masterServerName
init|=
name|createRegionServerStatusStub
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|masterServerName
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|RegionServerStartupResponse
name|result
init|=
literal|null
decl_stmt|;
try|try
block|{
name|rpcServices
operator|.
name|requestCount
operator|.
name|reset
argument_list|()
expr_stmt|;
name|rpcServices
operator|.
name|rpcGetRequestCount
operator|.
name|reset
argument_list|()
expr_stmt|;
name|rpcServices
operator|.
name|rpcScanRequestCount
operator|.
name|reset
argument_list|()
expr_stmt|;
name|rpcServices
operator|.
name|rpcMultiRequestCount
operator|.
name|reset
argument_list|()
expr_stmt|;
name|rpcServices
operator|.
name|rpcMutateRequestCount
operator|.
name|reset
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"reportForDuty to master="
operator|+
name|masterServerName
operator|+
literal|" with port="
operator|+
name|rpcServices
operator|.
name|isa
operator|.
name|getPort
argument_list|()
operator|+
literal|", startcode="
operator|+
name|this
operator|.
name|startcode
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
name|int
name|port
init|=
name|rpcServices
operator|.
name|isa
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|RegionServerStartupRequest
operator|.
name|Builder
name|request
init|=
name|RegionServerStartupRequest
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|shouldUseThisHostnameInstead
argument_list|()
condition|)
block|{
name|request
operator|.
name|setUseThisHostnameInstead
argument_list|(
name|useThisHostnameInstead
argument_list|)
expr_stmt|;
block|}
name|request
operator|.
name|setPort
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|request
operator|.
name|setServerStartCode
argument_list|(
name|this
operator|.
name|startcode
argument_list|)
expr_stmt|;
name|request
operator|.
name|setServerCurrentTime
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|result
operator|=
name|this
operator|.
name|rssStub
operator|.
name|regionServerStartup
argument_list|(
literal|null
argument_list|,
name|request
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
name|IOException
name|ioe
init|=
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
decl_stmt|;
if|if
condition|(
name|ioe
operator|instanceof
name|ClockOutOfSyncException
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Master rejected startup because clock is out of sync"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
comment|// Re-throw IOE will cause RS to abort
throw|throw
name|ioe
throw|;
block|}
elseif|else
if|if
condition|(
name|ioe
operator|instanceof
name|ServerNotRunningYetException
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Master is not running yet"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error telling master we are up"
argument_list|,
name|se
argument_list|)
expr_stmt|;
block|}
name|rssStub
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|RegionStoreSequenceIds
name|getLastSequenceId
parameter_list|(
name|byte
index|[]
name|encodedRegionName
parameter_list|)
block|{
try|try
block|{
name|GetLastFlushedSequenceIdRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetLastFlushedSequenceIdRequest
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
name|RegionServerStatusService
operator|.
name|BlockingInterface
name|rss
init|=
name|rssStub
decl_stmt|;
if|if
condition|(
name|rss
operator|==
literal|null
condition|)
block|{
comment|// Try to connect one more time
name|createRegionServerStatusStub
argument_list|()
expr_stmt|;
name|rss
operator|=
name|rssStub
expr_stmt|;
if|if
condition|(
name|rss
operator|==
literal|null
condition|)
block|{
comment|// Still no luck, we tried
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to connect to the master to check "
operator|+
literal|"the last flushed sequence id"
argument_list|)
expr_stmt|;
return|return
name|RegionStoreSequenceIds
operator|.
name|newBuilder
argument_list|()
operator|.
name|setLastFlushedSequenceId
argument_list|(
name|HConstants
operator|.
name|NO_SEQNUM
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
name|GetLastFlushedSequenceIdResponse
name|resp
init|=
name|rss
operator|.
name|getLastFlushedSequenceId
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
decl_stmt|;
return|return
name|RegionStoreSequenceIds
operator|.
name|newBuilder
argument_list|()
operator|.
name|setLastFlushedSequenceId
argument_list|(
name|resp
operator|.
name|getLastFlushedSequenceId
argument_list|()
argument_list|)
operator|.
name|addAllStoreSequenceId
argument_list|(
name|resp
operator|.
name|getStoreLastFlushedSequenceIdList
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to connect to the master to check the last flushed sequence id"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|RegionStoreSequenceIds
operator|.
name|newBuilder
argument_list|()
operator|.
name|setLastFlushedSequenceId
argument_list|(
name|HConstants
operator|.
name|NO_SEQNUM
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
comment|/**    * Closes all regions.  Called on our way out.    * Assumes that its not possible for new regions to be added to onlineRegions    * while this method runs.    */
specifier|protected
name|void
name|closeAllRegions
parameter_list|(
specifier|final
name|boolean
name|abort
parameter_list|)
block|{
name|closeUserRegions
argument_list|(
name|abort
argument_list|)
expr_stmt|;
name|closeMetaTableRegions
argument_list|(
name|abort
argument_list|)
expr_stmt|;
block|}
comment|/**    * Close meta region if we carry it    * @param abort Whether we're running an abort.    */
name|void
name|closeMetaTableRegions
parameter_list|(
specifier|final
name|boolean
name|abort
parameter_list|)
block|{
name|Region
name|meta
init|=
literal|null
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Region
argument_list|>
name|e
range|:
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HRegionInfo
name|hri
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|hri
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|meta
operator|=
name|e
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|meta
operator|!=
literal|null
condition|)
break|break;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|meta
operator|!=
literal|null
condition|)
name|closeRegionIgnoreErrors
argument_list|(
name|meta
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|abort
argument_list|)
expr_stmt|;
block|}
comment|/**    * Schedule closes on all user regions.    * Should be safe calling multiple times because it wont' close regions    * that are already closed or that are closing.    * @param abort Whether we're running an abort.    */
name|void
name|closeUserRegions
parameter_list|(
specifier|final
name|boolean
name|abort
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Region
argument_list|>
name|e
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Region
name|r
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
operator|&&
name|r
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
comment|// Don't update zk with this close transition; pass false.
name|closeRegionIgnoreErrors
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|abort
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** @return the info server */
specifier|public
name|InfoServer
name|getInfoServer
parameter_list|()
block|{
return|return
name|infoServer
return|;
block|}
comment|/**    * @return true if a stop has been requested.    */
annotation|@
name|Override
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|this
operator|.
name|stopped
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStopping
parameter_list|()
block|{
return|return
name|this
operator|.
name|stopping
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Region
argument_list|>
name|getRecoveringRegions
parameter_list|()
block|{
return|return
name|this
operator|.
name|recoveringRegions
return|;
block|}
comment|/**    *    * @return the configuration    */
annotation|@
name|Override
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|/** @return the write lock for the server */
name|ReentrantReadWriteLock
operator|.
name|WriteLock
name|getWriteLock
parameter_list|()
block|{
return|return
name|lock
operator|.
name|writeLock
argument_list|()
return|;
block|}
specifier|public
name|int
name|getNumberOfOnlineRegions
parameter_list|()
block|{
return|return
name|this
operator|.
name|onlineRegions
operator|.
name|size
argument_list|()
return|;
block|}
name|boolean
name|isOnlineRegionsEmpty
parameter_list|()
block|{
return|return
name|this
operator|.
name|onlineRegions
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * For tests, web ui and metrics.    * This method will only work if HRegionServer is in the same JVM as client;    * HRegion cannot be serialized to cross an rpc.    */
specifier|public
name|Collection
argument_list|<
name|Region
argument_list|>
name|getOnlineRegionsLocalContext
parameter_list|()
block|{
name|Collection
argument_list|<
name|Region
argument_list|>
name|regions
init|=
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
decl_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|regions
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addToOnlineRegions
parameter_list|(
name|Region
name|region
parameter_list|)
block|{
name|this
operator|.
name|onlineRegions
operator|.
name|put
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return A new Map of online regions sorted by region size with the first entry being the    * biggest.  If two regions are the same size, then the last one found wins; i.e. this method    * may NOT return all regions.    */
name|SortedMap
argument_list|<
name|Long
argument_list|,
name|Region
argument_list|>
name|getCopyOfOnlineRegionsSortedBySize
parameter_list|()
block|{
comment|// we'll sort the regions in reverse
name|SortedMap
argument_list|<
name|Long
argument_list|,
name|Region
argument_list|>
name|sortedRegions
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Region
argument_list|>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Long
name|a
parameter_list|,
name|Long
name|b
parameter_list|)
block|{
return|return
operator|-
literal|1
operator|*
name|a
operator|.
name|compareTo
argument_list|(
name|b
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|// Copy over all regions. Regions are sorted by size with biggest first.
for|for
control|(
name|Region
name|region
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
name|sortedRegions
operator|.
name|put
argument_list|(
name|region
operator|.
name|getMemstoreSize
argument_list|()
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
return|return
name|sortedRegions
return|;
block|}
comment|/**    * @return time stamp in millis of when this region server was started    */
specifier|public
name|long
name|getStartcode
parameter_list|()
block|{
return|return
name|this
operator|.
name|startcode
return|;
block|}
comment|/** @return reference to FlushRequester */
annotation|@
name|Override
specifier|public
name|FlushRequester
name|getFlushRequester
parameter_list|()
block|{
return|return
name|this
operator|.
name|cacheFlusher
return|;
block|}
comment|/**    * Get the top N most loaded regions this server is serving so we can tell the    * master which regions it can reallocate if we're overloaded. TODO: actually    * calculate which regions are most loaded. (Right now, we're just grabbing    * the first N regions being served regardless of load.)    */
specifier|protected
name|HRegionInfo
index|[]
name|getMostLoadedRegions
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Region
name|r
range|:
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|r
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|regions
operator|.
name|size
argument_list|()
operator|<
name|numRegionsToReport
condition|)
block|{
name|regions
operator|.
name|add
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|regions
operator|.
name|toArray
argument_list|(
operator|new
name|HRegionInfo
index|[
name|regions
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Leases
name|getLeases
parameter_list|()
block|{
return|return
name|leases
return|;
block|}
comment|/**    * @return Return the rootDir.    */
specifier|protected
name|Path
name|getRootDir
parameter_list|()
block|{
return|return
name|rootDir
return|;
block|}
comment|/**    * @return Return the fs.    */
annotation|@
name|Override
specifier|public
name|FileSystem
name|getFileSystem
parameter_list|()
block|{
return|return
name|fs
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Interval at which threads should run    *    * @return the interval    */
specifier|public
name|int
name|getThreadWakeFrequency
parameter_list|()
block|{
return|return
name|threadWakeFrequency
return|;
block|}
annotation|@
name|Override
specifier|public
name|ZooKeeperWatcher
name|getZooKeeper
parameter_list|()
block|{
return|return
name|zooKeeper
return|;
block|}
annotation|@
name|Override
specifier|public
name|BaseCoordinatedStateManager
name|getCoordinatedStateManager
parameter_list|()
block|{
return|return
name|csm
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerName
name|getServerName
parameter_list|()
block|{
return|return
name|serverName
return|;
block|}
annotation|@
name|Override
specifier|public
name|CompactionRequestor
name|getCompactionRequester
parameter_list|()
block|{
return|return
name|this
operator|.
name|compactSplitThread
return|;
block|}
specifier|public
name|RegionServerCoprocessorHost
name|getRegionServerCoprocessorHost
parameter_list|()
block|{
return|return
name|this
operator|.
name|rsHost
return|;
block|}
annotation|@
name|Override
specifier|public
name|ConcurrentMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Boolean
argument_list|>
name|getRegionsInTransitionInRS
parameter_list|()
block|{
return|return
name|this
operator|.
name|regionsInTransitionInRS
return|;
block|}
annotation|@
name|Override
specifier|public
name|ExecutorService
name|getExecutorService
parameter_list|()
block|{
return|return
name|service
return|;
block|}
annotation|@
name|Override
specifier|public
name|ChoreService
name|getChoreService
parameter_list|()
block|{
return|return
name|choreService
return|;
block|}
annotation|@
name|Override
specifier|public
name|RegionServerQuotaManager
name|getRegionServerQuotaManager
parameter_list|()
block|{
return|return
name|rsQuotaManager
return|;
block|}
comment|//
comment|// Main program and support routines
comment|//
comment|/**    * Load the replication service objects, if any    */
specifier|static
specifier|private
name|void
name|createNewReplicationInstance
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|HRegionServer
name|server
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|Path
name|logDir
parameter_list|,
name|Path
name|oldLogDir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|server
operator|instanceof
name|HMaster
operator|)
operator|&&
operator|(
operator|!
name|BaseLoadBalancer
operator|.
name|userTablesOnMaster
argument_list|(
name|conf
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
comment|// read in the name of the source replication class from the config file.
name|String
name|sourceClassname
init|=
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|REPLICATION_SOURCE_SERVICE_CLASSNAME
argument_list|,
name|HConstants
operator|.
name|REPLICATION_SERVICE_CLASSNAME_DEFAULT
argument_list|)
decl_stmt|;
comment|// read in the name of the sink replication class from the config file.
name|String
name|sinkClassname
init|=
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|REPLICATION_SINK_SERVICE_CLASSNAME
argument_list|,
name|HConstants
operator|.
name|REPLICATION_SERVICE_CLASSNAME_DEFAULT
argument_list|)
decl_stmt|;
comment|// If both the sink and the source class names are the same, then instantiate
comment|// only one object.
if|if
condition|(
name|sourceClassname
operator|.
name|equals
argument_list|(
name|sinkClassname
argument_list|)
condition|)
block|{
name|server
operator|.
name|replicationSourceHandler
operator|=
operator|(
name|ReplicationSourceService
operator|)
name|newReplicationInstance
argument_list|(
name|sourceClassname
argument_list|,
name|conf
argument_list|,
name|server
argument_list|,
name|fs
argument_list|,
name|logDir
argument_list|,
name|oldLogDir
argument_list|)
expr_stmt|;
name|server
operator|.
name|replicationSinkHandler
operator|=
operator|(
name|ReplicationSinkService
operator|)
name|server
operator|.
name|replicationSourceHandler
expr_stmt|;
block|}
else|else
block|{
name|server
operator|.
name|replicationSourceHandler
operator|=
operator|(
name|ReplicationSourceService
operator|)
name|newReplicationInstance
argument_list|(
name|sourceClassname
argument_list|,
name|conf
argument_list|,
name|server
argument_list|,
name|fs
argument_list|,
name|logDir
argument_list|,
name|oldLogDir
argument_list|)
expr_stmt|;
name|server
operator|.
name|replicationSinkHandler
operator|=
operator|(
name|ReplicationSinkService
operator|)
name|newReplicationInstance
argument_list|(
name|sinkClassname
argument_list|,
name|conf
argument_list|,
name|server
argument_list|,
name|fs
argument_list|,
name|logDir
argument_list|,
name|oldLogDir
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
specifier|private
name|ReplicationService
name|newReplicationInstance
parameter_list|(
name|String
name|classname
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|HRegionServer
name|server
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|Path
name|logDir
parameter_list|,
name|Path
name|oldLogDir
parameter_list|)
throws|throws
name|IOException
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ClassLoader
name|classLoader
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
decl_stmt|;
name|clazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|classname
argument_list|,
literal|true
argument_list|,
name|classLoader
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|ClassNotFoundException
name|nfe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not find class for "
operator|+
name|classname
argument_list|)
throw|;
block|}
comment|// create an instance of the replication object.
name|ReplicationService
name|service
init|=
operator|(
name|ReplicationService
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|clazz
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|service
operator|.
name|initialize
argument_list|(
name|server
argument_list|,
name|fs
argument_list|,
name|logDir
argument_list|,
name|oldLogDir
argument_list|)
expr_stmt|;
return|return
name|service
return|;
block|}
comment|/**    * Utility for constructing an instance of the passed HRegionServer class.    *    * @param regionServerClass    * @param conf2    * @return HRegionServer instance.    */
specifier|public
specifier|static
name|HRegionServer
name|constructRegionServer
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|regionServerClass
parameter_list|,
specifier|final
name|Configuration
name|conf2
parameter_list|,
name|CoordinatedStateManager
name|cp
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|c
init|=
name|regionServerClass
operator|.
name|getConstructor
argument_list|(
name|Configuration
operator|.
name|class
argument_list|,
name|CoordinatedStateManager
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|c
operator|.
name|newInstance
argument_list|(
name|conf2
argument_list|,
name|cp
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of "
operator|+
literal|"Regionserver: "
operator|+
name|regionServerClass
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * @see org.apache.hadoop.hbase.regionserver.HRegionServerCommandLine    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"***** STARTING service '"
operator|+
name|HRegionServer
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"' *****"
argument_list|)
expr_stmt|;
name|VersionInfo
operator|.
name|logVersion
argument_list|()
expr_stmt|;
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|regionServerClass
init|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
operator|)
name|conf
operator|.
name|getClass
argument_list|(
name|HConstants
operator|.
name|REGION_SERVER_IMPL
argument_list|,
name|HRegionServer
operator|.
name|class
argument_list|)
decl_stmt|;
operator|new
name|HRegionServerCommandLine
argument_list|(
name|regionServerClass
argument_list|)
operator|.
name|doMain
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
comment|/**    * Gets the online regions of the specified table.    * This method looks at the in-memory onlineRegions.  It does not go to<code>hbase:meta</code>.    * Only returns<em>online</em> regions.  If a region on this table has been    * closed during a disable, etc., it will not be included in the returned list.    * So, the returned list may not necessarily be ALL regions in this table, its    * all the ONLINE regions in the table.    * @param tableName    * @return Online regions from<code>tableName</code>    */
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Region
argument_list|>
name|getOnlineRegions
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
name|List
argument_list|<
name|Region
argument_list|>
name|tableRegions
init|=
operator|new
name|ArrayList
argument_list|<
name|Region
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|onlineRegions
init|)
block|{
for|for
control|(
name|Region
name|region
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
name|HRegionInfo
name|regionInfo
init|=
name|region
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionInfo
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|tableRegions
operator|.
name|add
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|tableRegions
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Region
argument_list|>
name|getOnlineRegions
parameter_list|()
block|{
name|List
argument_list|<
name|Region
argument_list|>
name|allRegions
init|=
operator|new
name|ArrayList
argument_list|<
name|Region
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|onlineRegions
init|)
block|{
comment|// Return a clone copy of the onlineRegions
name|allRegions
operator|.
name|addAll
argument_list|(
name|onlineRegions
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|allRegions
return|;
block|}
comment|/**    * Gets the online tables in this RS.    * This method looks at the in-memory onlineRegions.    * @return all the online tables in this RS    */
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|TableName
argument_list|>
name|getOnlineTables
parameter_list|()
block|{
name|Set
argument_list|<
name|TableName
argument_list|>
name|tables
init|=
operator|new
name|HashSet
argument_list|<
name|TableName
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|onlineRegions
init|)
block|{
for|for
control|(
name|Region
name|region
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
name|tables
operator|.
name|add
argument_list|(
name|region
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tables
return|;
block|}
comment|// used by org/apache/hbase/tmpl/regionserver/RSStatusTmpl.jamon (HBASE-4070).
specifier|public
name|String
index|[]
name|getRegionServerCoprocessors
parameter_list|()
block|{
name|TreeSet
argument_list|<
name|String
argument_list|>
name|coprocessors
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|coprocessors
operator|.
name|addAll
argument_list|(
name|getWAL
argument_list|(
literal|null
argument_list|)
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|getCoprocessors
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception attempting to fetch wal coprocessor information for the common wal; "
operator|+
literal|"skipping."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception details for failure to fetch wal coprocessor information."
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
name|Collection
argument_list|<
name|Region
argument_list|>
name|regions
init|=
name|getOnlineRegionsLocalContext
argument_list|()
decl_stmt|;
for|for
control|(
name|Region
name|region
range|:
name|regions
control|)
block|{
name|coprocessors
operator|.
name|addAll
argument_list|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|getCoprocessors
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|coprocessors
operator|.
name|addAll
argument_list|(
name|getWAL
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|getCoprocessors
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception attempting to fetch wal coprocessor information for region "
operator|+
name|region
operator|+
literal|"; skipping."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception details for failure to fetch wal coprocessor information."
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|coprocessors
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|coprocessors
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Try to close the region, logs a warning on failure but continues.    * @param region Region to close    */
specifier|private
name|void
name|closeRegionIgnoreErrors
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|boolean
name|abort
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|closeRegion
argument_list|(
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|abort
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" - ignoring and continuing"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" - ignoring and continuing"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Close asynchronously a region, can be called from the master or internally by the regionserver    * when stopping. If called from the master, the region will update the znode status.    *    *<p>    * If an opening was in progress, this method will cancel it, but will not start a new close. The    * coprocessors are not called in this case. A NotServingRegionException exception is thrown.    *</p>     *<p>    *   If a close was in progress, this new request will be ignored, and an exception thrown.    *</p>    *    * @param encodedName Region to close    * @param abort True if we are aborting    * @return True if closed a region.    * @throws NotServingRegionException if the region is not online    */
specifier|protected
name|boolean
name|closeRegion
parameter_list|(
name|String
name|encodedName
parameter_list|,
specifier|final
name|boolean
name|abort
parameter_list|,
specifier|final
name|ServerName
name|sn
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
comment|//Check for permissions to close.
name|Region
name|actualRegion
init|=
name|this
operator|.
name|getFromOnlineRegions
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
comment|// Can be null if we're calling close on a region that's not online
if|if
condition|(
operator|(
name|actualRegion
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|actualRegion
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
operator|)
condition|)
block|{
try|try
block|{
name|actualRegion
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|preClose
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exp
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to close region: the coprocessor launched an error "
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
specifier|final
name|Boolean
name|previous
init|=
name|this
operator|.
name|regionsInTransitionInRS
operator|.
name|putIfAbsent
argument_list|(
name|encodedName
operator|.
name|getBytes
argument_list|()
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
name|previous
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Received CLOSE for the region:"
operator|+
name|encodedName
operator|+
literal|" , which we are already "
operator|+
literal|"trying to OPEN. Cancelling OPENING."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regionsInTransitionInRS
operator|.
name|replace
argument_list|(
name|encodedName
operator|.
name|getBytes
argument_list|()
argument_list|,
name|previous
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
condition|)
block|{
comment|// The replace failed. That should be an exceptional case, but theoretically it can happen.
comment|// We're going to try to do a standard close then.
name|LOG
operator|.
name|warn
argument_list|(
literal|"The opening for region "
operator|+
name|encodedName
operator|+
literal|" was done before we could cancel it."
operator|+
literal|" Doing a standard close now"
argument_list|)
expr_stmt|;
return|return
name|closeRegion
argument_list|(
name|encodedName
argument_list|,
name|abort
argument_list|,
name|sn
argument_list|)
return|;
block|}
comment|// Let's get the region from the online region list again
name|actualRegion
operator|=
name|this
operator|.
name|getFromOnlineRegions
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|actualRegion
operator|==
literal|null
condition|)
block|{
comment|// If already online, we still need to close it.
name|LOG
operator|.
name|info
argument_list|(
literal|"The opening previously in progress has been cancelled by a CLOSE request."
argument_list|)
expr_stmt|;
comment|// The master deletes the znode when it receives this exception.
throw|throw
operator|new
name|NotServingRegionException
argument_list|(
literal|"The region "
operator|+
name|encodedName
operator|+
literal|" was opening but not yet served. Opening is cancelled."
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|Boolean
operator|.
name|FALSE
operator|.
name|equals
argument_list|(
name|previous
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Received CLOSE for the region: "
operator|+
name|encodedName
operator|+
literal|", which we are already trying to CLOSE, but not completed yet"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|actualRegion
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Received CLOSE for a region which is not online, and we're not opening."
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionsInTransitionInRS
operator|.
name|remove
argument_list|(
name|encodedName
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
comment|// The master deletes the znode when it receives this exception.
throw|throw
operator|new
name|NotServingRegionException
argument_list|(
literal|"The region "
operator|+
name|encodedName
operator|+
literal|" is not online, and is not opening."
argument_list|)
throw|;
block|}
name|CloseRegionHandler
name|crh
decl_stmt|;
specifier|final
name|HRegionInfo
name|hri
init|=
name|actualRegion
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|hri
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|crh
operator|=
operator|new
name|CloseMetaHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|hri
argument_list|,
name|abort
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|crh
operator|=
operator|new
name|CloseRegionHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|hri
argument_list|,
name|abort
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
name|crh
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Close and offline the region for split or merge    *    * @param regionEncodedName the name of the region(s) to close    * @return true if closed the region successfully.    * @throws IOException   */
specifier|protected
name|boolean
name|closeAndOfflineRegionForSplitOrMerge
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|regionEncodedName
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionEncodedName
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Region
name|regionToClose
init|=
name|this
operator|.
name|getFromOnlineRegions
argument_list|(
name|regionEncodedName
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionToClose
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|StoreFile
argument_list|>
argument_list|>
name|hstoreFiles
init|=
literal|null
decl_stmt|;
name|Exception
name|exceptionToThrow
init|=
literal|null
decl_stmt|;
try|try
block|{
name|hstoreFiles
operator|=
operator|(
operator|(
name|HRegion
operator|)
name|regionToClose
operator|)
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|exceptionToThrow
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|exceptionToThrow
operator|==
literal|null
operator|&&
name|hstoreFiles
operator|==
literal|null
condition|)
block|{
comment|// The region was closed by someone else
name|exceptionToThrow
operator|=
operator|new
name|IOException
argument_list|(
literal|"Failed to close region: already closed by another thread"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exceptionToThrow
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|exceptionToThrow
operator|instanceof
name|IOException
condition|)
throw|throw
operator|(
name|IOException
operator|)
name|exceptionToThrow
throw|;
throw|throw
operator|new
name|IOException
argument_list|(
name|exceptionToThrow
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionToClose
operator|.
name|getTableDesc
argument_list|()
operator|.
name|hasSerialReplicationScope
argument_list|()
condition|)
block|{
comment|// For serial replication, we need add a final barrier on this region. But the splitting
comment|// or merging may be reverted, so we should make sure if we reopen this region, the open
comment|// barrier is same as this final barrier
name|long
name|seq
init|=
name|regionToClose
operator|.
name|getMaxFlushedSeqId
argument_list|()
decl_stmt|;
if|if
condition|(
name|seq
operator|==
name|HConstants
operator|.
name|NO_SEQNUM
condition|)
block|{
comment|// No edits in WAL for this region; get the sequence number when the region was opened.
name|seq
operator|=
name|regionToClose
operator|.
name|getOpenSeqNum
argument_list|()
expr_stmt|;
if|if
condition|(
name|seq
operator|==
name|HConstants
operator|.
name|NO_SEQNUM
condition|)
block|{
comment|// This region has no data
name|seq
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|seq
operator|++
expr_stmt|;
block|}
name|Put
name|finalBarrier
init|=
name|MetaTableAccessor
operator|.
name|makeBarrierPut
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|regionEncodedName
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|seq
argument_list|,
name|regionToClose
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getTableName
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|MetaTableAccessor
operator|.
name|putToMetaTable
argument_list|(
name|getConnection
argument_list|()
argument_list|,
name|finalBarrier
argument_list|)
expr_stmt|;
block|}
comment|// Offline the region
name|this
operator|.
name|removeFromOnlineRegions
argument_list|(
name|regionToClose
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * @param regionName    * @return HRegion for the passed binary<code>regionName</code> or null if    *         named region is not member of the online regions.    */
specifier|public
name|Region
name|getOnlineRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
name|String
name|encodedRegionName
init|=
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
return|return
name|this
operator|.
name|onlineRegions
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
return|;
block|}
specifier|public
name|InetSocketAddress
index|[]
name|getRegionBlockLocations
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
block|{
return|return
name|this
operator|.
name|regionFavoredNodesMap
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Region
name|getFromOnlineRegions
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
block|{
return|return
name|this
operator|.
name|onlineRegions
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|removeFromOnlineRegions
parameter_list|(
specifier|final
name|Region
name|r
parameter_list|,
name|ServerName
name|destination
parameter_list|)
block|{
name|Region
name|toReturn
init|=
name|this
operator|.
name|onlineRegions
operator|.
name|remove
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|destination
operator|!=
literal|null
condition|)
block|{
name|long
name|closeSeqNum
init|=
name|r
operator|.
name|getMaxFlushedSeqId
argument_list|()
decl_stmt|;
if|if
condition|(
name|closeSeqNum
operator|==
name|HConstants
operator|.
name|NO_SEQNUM
condition|)
block|{
comment|// No edits in WAL for this region; get the sequence number when the region was opened.
name|closeSeqNum
operator|=
name|r
operator|.
name|getOpenSeqNum
argument_list|()
expr_stmt|;
if|if
condition|(
name|closeSeqNum
operator|==
name|HConstants
operator|.
name|NO_SEQNUM
condition|)
name|closeSeqNum
operator|=
literal|0
expr_stmt|;
block|}
name|addToMovedRegions
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|destination
argument_list|,
name|closeSeqNum
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|regionFavoredNodesMap
operator|.
name|remove
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|toReturn
operator|!=
literal|null
return|;
block|}
comment|/**    * Protected utility method for safely obtaining an HRegion handle.    *    * @param regionName    *          Name of online {@link HRegion} to return    * @return {@link HRegion} for<code>regionName</code>    * @throws NotServingRegionException    */
specifier|protected
name|Region
name|getRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
name|String
name|encodedRegionName
init|=
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
return|return
name|getRegionByEncodedName
argument_list|(
name|regionName
argument_list|,
name|encodedRegionName
argument_list|)
return|;
block|}
specifier|public
name|Region
name|getRegionByEncodedName
parameter_list|(
name|String
name|encodedRegionName
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
return|return
name|getRegionByEncodedName
argument_list|(
literal|null
argument_list|,
name|encodedRegionName
argument_list|)
return|;
block|}
specifier|protected
name|Region
name|getRegionByEncodedName
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|String
name|encodedRegionName
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
name|Region
name|region
init|=
name|this
operator|.
name|onlineRegions
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
name|MovedRegionInfo
name|moveInfo
init|=
name|getMovedRegion
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|moveInfo
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|RegionMovedException
argument_list|(
name|moveInfo
operator|.
name|getServerName
argument_list|()
argument_list|,
name|moveInfo
operator|.
name|getSeqNum
argument_list|()
argument_list|)
throw|;
block|}
name|Boolean
name|isOpening
init|=
name|this
operator|.
name|regionsInTransitionInRS
operator|.
name|get
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|regionNameStr
init|=
name|regionName
operator|==
literal|null
condition|?
name|encodedRegionName
else|:
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|isOpening
operator|!=
literal|null
operator|&&
name|isOpening
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RegionOpeningException
argument_list|(
literal|"Region "
operator|+
name|regionNameStr
operator|+
literal|" is opening on "
operator|+
name|this
operator|.
name|serverName
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|NotServingRegionException
argument_list|(
literal|"Region "
operator|+
name|regionNameStr
operator|+
literal|" is not online on "
operator|+
name|this
operator|.
name|serverName
argument_list|)
throw|;
block|}
return|return
name|region
return|;
block|}
comment|/*    * Cleanup after Throwable caught invoking method. Converts<code>t</code> to    * IOE if it isn't already.    *    * @param t Throwable    *    * @param msg Message to log in error. Can be null.    *    * @return Throwable converted to an IOE; methods can only let out IOEs.    */
specifier|private
name|Throwable
name|cleanup
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|)
block|{
comment|// Don't log as error if NSRE; NSRE is 'normal' operation.
if|if
condition|(
name|t
operator|instanceof
name|NotServingRegionException
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"NotServingRegionException; "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
name|Throwable
name|e
init|=
name|t
operator|instanceof
name|RemoteException
condition|?
operator|(
operator|(
name|RemoteException
operator|)
name|t
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
else|:
name|t
decl_stmt|;
if|if
condition|(
name|msg
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rpcServices
operator|.
name|checkOOME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/*    * @param t    *    * @param msg Message to put in new IOE if passed<code>t</code> is not an IOE    *    * @return Make<code>t</code> an IOE if it isn't already.    */
specifier|protected
name|IOException
name|convertThrowableToIOE
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|)
block|{
return|return
operator|(
name|t
operator|instanceof
name|IOException
condition|?
operator|(
name|IOException
operator|)
name|t
else|:
name|msg
operator|==
literal|null
operator|||
name|msg
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|?
operator|new
name|IOException
argument_list|(
name|t
argument_list|)
else|:
operator|new
name|IOException
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
operator|)
return|;
block|}
comment|/**    * Checks to see if the file system is still accessible. If not, sets    * abortRequested and stopRequested    *    * @return false if file system is not available    */
specifier|public
name|boolean
name|checkFileSystem
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|fsOk
operator|&&
name|this
operator|.
name|fs
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|FSUtils
operator|.
name|checkFileSystemAvailable
argument_list|(
name|this
operator|.
name|fs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abort
argument_list|(
literal|"File System not available"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|this
operator|.
name|fsOk
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|this
operator|.
name|fsOk
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|updateRegionFavoredNodesMapping
parameter_list|(
name|String
name|encodedRegionName
parameter_list|,
name|List
argument_list|<
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|ServerName
argument_list|>
name|favoredNodes
parameter_list|)
block|{
name|InetSocketAddress
index|[]
name|addr
init|=
operator|new
name|InetSocketAddress
index|[
name|favoredNodes
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
comment|// Refer to the comment on the declaration of regionFavoredNodesMap on why
comment|// it is a map of region name to InetSocketAddress[]
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|favoredNodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|addr
index|[
name|i
index|]
operator|=
name|InetSocketAddress
operator|.
name|createUnresolved
argument_list|(
name|favoredNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getHostName
argument_list|()
argument_list|,
name|favoredNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|regionFavoredNodesMap
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the favored nodes for a region given its encoded name. Look at the    * comment around {@link #regionFavoredNodesMap} on why it is InetSocketAddress[]    * @param encodedRegionName    * @return array of favored locations    */
annotation|@
name|Override
specifier|public
name|InetSocketAddress
index|[]
name|getFavoredNodesForRegion
parameter_list|(
name|String
name|encodedRegionName
parameter_list|)
block|{
return|return
name|regionFavoredNodesMap
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerNonceManager
name|getNonceManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|nonceManager
return|;
block|}
specifier|private
specifier|static
class|class
name|MovedRegionInfo
block|{
specifier|private
specifier|final
name|ServerName
name|serverName
decl_stmt|;
specifier|private
specifier|final
name|long
name|seqNum
decl_stmt|;
specifier|private
specifier|final
name|long
name|ts
decl_stmt|;
specifier|public
name|MovedRegionInfo
parameter_list|(
name|ServerName
name|serverName
parameter_list|,
name|long
name|closeSeqNum
parameter_list|)
block|{
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
name|this
operator|.
name|seqNum
operator|=
name|closeSeqNum
expr_stmt|;
name|ts
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
expr_stmt|;
block|}
specifier|public
name|ServerName
name|getServerName
parameter_list|()
block|{
return|return
name|serverName
return|;
block|}
specifier|public
name|long
name|getSeqNum
parameter_list|()
block|{
return|return
name|seqNum
return|;
block|}
specifier|public
name|long
name|getMoveTime
parameter_list|()
block|{
return|return
name|ts
return|;
block|}
block|}
comment|// This map will contains all the regions that we closed for a move.
comment|//  We add the time it was moved as we don't want to keep too old information
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|MovedRegionInfo
argument_list|>
name|movedRegions
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|MovedRegionInfo
argument_list|>
argument_list|(
literal|3000
argument_list|)
decl_stmt|;
comment|// We need a timeout. If not there is a risk of giving a wrong information: this would double
comment|//  the number of network calls instead of reducing them.
specifier|private
specifier|static
specifier|final
name|int
name|TIMEOUT_REGION_MOVED
init|=
operator|(
literal|2
operator|*
literal|60
operator|*
literal|1000
operator|)
decl_stmt|;
specifier|protected
name|void
name|addToMovedRegions
parameter_list|(
name|String
name|encodedName
parameter_list|,
name|ServerName
name|destination
parameter_list|,
name|long
name|closeSeqNum
parameter_list|)
block|{
if|if
condition|(
name|ServerName
operator|.
name|isSameHostnameAndPort
argument_list|(
name|destination
argument_list|,
name|this
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not adding moved region record: "
operator|+
name|encodedName
operator|+
literal|" to self."
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding moved region record: "
operator|+
name|encodedName
operator|+
literal|" to "
operator|+
name|destination
operator|+
literal|" as of "
operator|+
name|closeSeqNum
argument_list|)
expr_stmt|;
name|movedRegions
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
operator|new
name|MovedRegionInfo
argument_list|(
name|destination
argument_list|,
name|closeSeqNum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|removeFromMovedRegions
parameter_list|(
name|String
name|encodedName
parameter_list|)
block|{
name|movedRegions
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
block|}
specifier|private
name|MovedRegionInfo
name|getMovedRegion
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
block|{
name|MovedRegionInfo
name|dest
init|=
name|movedRegions
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
name|long
name|now
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|dest
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|dest
operator|.
name|getMoveTime
argument_list|()
operator|>
operator|(
name|now
operator|-
name|TIMEOUT_REGION_MOVED
operator|)
condition|)
block|{
return|return
name|dest
return|;
block|}
else|else
block|{
name|movedRegions
operator|.
name|remove
argument_list|(
name|encodedRegionName
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Remove the expired entries from the moved regions list.    */
specifier|protected
name|void
name|cleanMovedRegions
parameter_list|()
block|{
specifier|final
name|long
name|cutOff
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|TIMEOUT_REGION_MOVED
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|MovedRegionInfo
argument_list|>
argument_list|>
name|it
init|=
name|movedRegions
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|MovedRegionInfo
argument_list|>
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getMoveTime
argument_list|()
operator|<
name|cutOff
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Use this to allow tests to override and schedule more frequently.    */
specifier|protected
name|int
name|movedRegionCleanerPeriod
parameter_list|()
block|{
return|return
name|TIMEOUT_REGION_MOVED
return|;
block|}
comment|/**    * Creates a Chore thread to clean the moved region cache.    */
specifier|protected
specifier|final
specifier|static
class|class
name|MovedRegionsCleaner
extends|extends
name|ScheduledChore
implements|implements
name|Stoppable
block|{
specifier|private
name|HRegionServer
name|regionServer
decl_stmt|;
name|Stoppable
name|stoppable
decl_stmt|;
specifier|private
name|MovedRegionsCleaner
parameter_list|(
name|HRegionServer
name|regionServer
parameter_list|,
name|Stoppable
name|stoppable
parameter_list|)
block|{
name|super
argument_list|(
literal|"MovedRegionsCleaner for region "
operator|+
name|regionServer
argument_list|,
name|stoppable
argument_list|,
name|regionServer
operator|.
name|movedRegionCleanerPeriod
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServer
operator|=
name|regionServer
expr_stmt|;
name|this
operator|.
name|stoppable
operator|=
name|stoppable
expr_stmt|;
block|}
specifier|static
name|MovedRegionsCleaner
name|create
parameter_list|(
name|HRegionServer
name|rs
parameter_list|)
block|{
name|Stoppable
name|stoppable
init|=
operator|new
name|Stoppable
argument_list|()
block|{
specifier|private
specifier|volatile
name|boolean
name|isStopped
init|=
literal|false
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
name|String
name|why
parameter_list|)
block|{
name|isStopped
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|isStopped
return|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|MovedRegionsCleaner
argument_list|(
name|rs
argument_list|,
name|stoppable
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
name|regionServer
operator|.
name|cleanMovedRegions
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
name|String
name|why
parameter_list|)
block|{
name|stoppable
operator|.
name|stop
argument_list|(
name|why
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|stoppable
operator|.
name|isStopped
argument_list|()
return|;
block|}
block|}
specifier|private
name|String
name|getMyEphemeralNodePath
parameter_list|()
block|{
return|return
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|znodePaths
operator|.
name|rsZNode
argument_list|,
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isHealthCheckerConfigured
parameter_list|()
block|{
name|String
name|healthScriptLocation
init|=
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HEALTH_SCRIPT_LOC
argument_list|)
decl_stmt|;
return|return
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
operator|.
name|isNotBlank
argument_list|(
name|healthScriptLocation
argument_list|)
return|;
block|}
comment|/**    * @return the underlying {@link CompactSplitThread} for the servers    */
specifier|public
name|CompactSplitThread
name|getCompactSplitThread
parameter_list|()
block|{
return|return
name|this
operator|.
name|compactSplitThread
return|;
block|}
comment|/**    * A helper function to store the last flushed sequence Id with the previous failed RS for a    * recovering region. The Id is used to skip wal edits which are flushed. Since the flushed    * sequence id is only valid for each RS, we associate the Id with corresponding failed RS.    * @throws KeeperException    * @throws IOException    */
specifier|private
name|void
name|updateRecoveringRegionLastFlushedSequenceId
parameter_list|(
name|Region
name|r
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
if|if
condition|(
operator|!
name|r
operator|.
name|isRecovering
argument_list|()
condition|)
block|{
comment|// return immdiately for non-recovering regions
return|return;
block|}
name|HRegionInfo
name|regionInfo
init|=
name|r
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|ZooKeeperWatcher
name|zkw
init|=
name|getZooKeeper
argument_list|()
decl_stmt|;
name|String
name|previousRSName
init|=
name|this
operator|.
name|getLastFailedRSFromZK
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|maxSeqIdInStores
init|=
name|r
operator|.
name|getMaxStoreSeqId
argument_list|()
decl_stmt|;
name|long
name|minSeqIdForLogReplay
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Long
name|storeSeqIdForReplay
range|:
name|maxSeqIdInStores
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|minSeqIdForLogReplay
operator|==
operator|-
literal|1
operator|||
name|storeSeqIdForReplay
operator|<
name|minSeqIdForLogReplay
condition|)
block|{
name|minSeqIdForLogReplay
operator|=
name|storeSeqIdForReplay
expr_stmt|;
block|}
block|}
try|try
block|{
name|long
name|lastRecordedFlushedSequenceId
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|nodePath
init|=
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|znodePaths
operator|.
name|recoveringRegionsZNode
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
comment|// recovering-region level
name|byte
index|[]
name|data
decl_stmt|;
try|try
block|{
name|data
operator|=
name|ZKUtil
operator|.
name|getData
argument_list|(
name|zkw
argument_list|,
name|nodePath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
block|}
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|lastRecordedFlushedSequenceId
operator|=
name|ZKSplitLog
operator|.
name|parseLastFlushedSequenceIdFrom
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|==
literal|null
operator|||
name|lastRecordedFlushedSequenceId
operator|<
name|minSeqIdForLogReplay
condition|)
block|{
name|ZKUtil
operator|.
name|setData
argument_list|(
name|zkw
argument_list|,
name|nodePath
argument_list|,
name|ZKUtil
operator|.
name|positionToByteArray
argument_list|(
name|minSeqIdForLogReplay
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|previousRSName
operator|!=
literal|null
condition|)
block|{
comment|// one level deeper for the failed RS
name|nodePath
operator|=
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|nodePath
argument_list|,
name|previousRSName
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|setData
argument_list|(
name|zkw
argument_list|,
name|nodePath
argument_list|,
name|ZKUtil
operator|.
name|regionSequenceIdsToByteArray
argument_list|(
name|minSeqIdForLogReplay
argument_list|,
name|maxSeqIdInStores
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Update last flushed sequence id of region "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" for "
operator|+
name|previousRSName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can't find failed region server for recovering region "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoNodeException
name|ignore
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Region "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" must have completed recovery because its recovery znode has been removed"
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return the last failed RS name under /hbase/recovering-regions/encodedRegionName    * @param encodedRegionName    * @throws KeeperException    */
specifier|private
name|String
name|getLastFailedRSFromZK
parameter_list|(
name|String
name|encodedRegionName
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|result
init|=
literal|null
decl_stmt|;
name|long
name|maxZxid
init|=
literal|0
decl_stmt|;
name|ZooKeeperWatcher
name|zkw
init|=
name|this
operator|.
name|getZooKeeper
argument_list|()
decl_stmt|;
name|String
name|nodePath
init|=
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|zkw
operator|.
name|znodePaths
operator|.
name|recoveringRegionsZNode
argument_list|,
name|encodedRegionName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|failedServers
init|=
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|zkw
argument_list|,
name|nodePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|failedServers
operator|==
literal|null
operator|||
name|failedServers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|result
return|;
block|}
for|for
control|(
name|String
name|failedServer
range|:
name|failedServers
control|)
block|{
name|String
name|rsPath
init|=
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|nodePath
argument_list|,
name|failedServer
argument_list|)
decl_stmt|;
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|ZKUtil
operator|.
name|getDataNoWatch
argument_list|(
name|zkw
argument_list|,
name|rsPath
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxZxid
operator|<
name|stat
operator|.
name|getCzxid
argument_list|()
condition|)
block|{
name|maxZxid
operator|=
name|stat
operator|.
name|getCzxid
argument_list|()
expr_stmt|;
name|result
operator|=
name|failedServer
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|public
name|CoprocessorServiceResponse
name|execRegionServerService
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UnusedParameters"
argument_list|)
specifier|final
name|RpcController
name|controller
parameter_list|,
specifier|final
name|CoprocessorServiceRequest
name|serviceRequest
parameter_list|)
throws|throws
name|ServiceException
block|{
try|try
block|{
name|ServerRpcController
name|serviceController
init|=
operator|new
name|ServerRpcController
argument_list|()
decl_stmt|;
name|CoprocessorServiceCall
name|call
init|=
name|serviceRequest
operator|.
name|getCall
argument_list|()
decl_stmt|;
name|String
name|serviceName
init|=
name|call
operator|.
name|getServiceName
argument_list|()
decl_stmt|;
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Service
name|service
init|=
name|coprocessorServiceHandlers
operator|.
name|get
argument_list|(
name|serviceName
argument_list|)
decl_stmt|;
if|if
condition|(
name|service
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownProtocolException
argument_list|(
literal|null
argument_list|,
literal|"No registered coprocessor service found for "
operator|+
name|serviceName
argument_list|)
throw|;
block|}
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|ServiceDescriptor
name|serviceDesc
init|=
name|service
operator|.
name|getDescriptorForType
argument_list|()
decl_stmt|;
name|String
name|methodName
init|=
name|call
operator|.
name|getMethodName
argument_list|()
decl_stmt|;
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|MethodDescriptor
name|methodDesc
init|=
name|serviceDesc
operator|.
name|findMethodByName
argument_list|(
name|methodName
argument_list|)
decl_stmt|;
if|if
condition|(
name|methodDesc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownProtocolException
argument_list|(
name|service
operator|.
name|getClass
argument_list|()
argument_list|,
literal|"Unknown method "
operator|+
name|methodName
operator|+
literal|" called on service "
operator|+
name|serviceName
argument_list|)
throw|;
block|}
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
name|request
init|=
name|CoprocessorRpcUtils
operator|.
name|getRequest
argument_list|(
name|service
argument_list|,
name|methodDesc
argument_list|,
name|call
operator|.
name|getRequest
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
operator|.
name|Builder
name|responseBuilder
init|=
name|service
operator|.
name|getResponsePrototype
argument_list|(
name|methodDesc
argument_list|)
operator|.
name|newBuilderForType
argument_list|()
decl_stmt|;
name|service
operator|.
name|callMethod
argument_list|(
name|methodDesc
argument_list|,
name|serviceController
argument_list|,
name|request
argument_list|,
operator|new
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcCallback
argument_list|<
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|(
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
name|message
parameter_list|)
block|{
if|if
condition|(
name|message
operator|!=
literal|null
condition|)
block|{
name|responseBuilder
operator|.
name|mergeFrom
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|IOException
name|exception
init|=
name|CoprocessorRpcUtils
operator|.
name|getControllerException
argument_list|(
name|serviceController
argument_list|)
decl_stmt|;
if|if
condition|(
name|exception
operator|!=
literal|null
condition|)
block|{
throw|throw
name|exception
throw|;
block|}
return|return
name|CoprocessorRpcUtils
operator|.
name|getResponse
argument_list|(
name|responseBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|ServiceException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return The cache config instance used by the regionserver.    */
specifier|public
name|CacheConfig
name|getCacheConfig
parameter_list|()
block|{
return|return
name|this
operator|.
name|cacheConfig
return|;
block|}
comment|/**    * @return : Returns the ConfigurationManager object for testing purposes.    */
specifier|protected
name|ConfigurationManager
name|getConfigurationManager
parameter_list|()
block|{
return|return
name|configurationManager
return|;
block|}
comment|/**    * @return Return table descriptors implementation.    */
specifier|public
name|TableDescriptors
name|getTableDescriptors
parameter_list|()
block|{
return|return
name|this
operator|.
name|tableDescriptors
return|;
block|}
comment|/**    * Reload the configuration from disk.    */
specifier|public
name|void
name|updateConfiguration
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reloading the configuration from disk."
argument_list|)
expr_stmt|;
comment|// Reload the configuration from disk.
name|conf
operator|.
name|reloadConfiguration
argument_list|()
expr_stmt|;
name|configurationManager
operator|.
name|notifyAllObservers
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|double
name|getCompactionPressure
parameter_list|()
block|{
name|double
name|max
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Region
name|region
range|:
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|Store
name|store
range|:
name|region
operator|.
name|getStores
argument_list|()
control|)
block|{
name|double
name|normCount
init|=
name|store
operator|.
name|getCompactionPressure
argument_list|()
decl_stmt|;
if|if
condition|(
name|normCount
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|normCount
expr_stmt|;
block|}
block|}
block|}
return|return
name|max
return|;
block|}
annotation|@
name|Override
specifier|public
name|HeapMemoryManager
name|getHeapMemoryManager
parameter_list|()
block|{
return|return
name|hMemManager
return|;
block|}
comment|/**    * For testing    * @return whether all wal roll request finished for this regionserver    */
annotation|@
name|VisibleForTesting
specifier|public
name|boolean
name|walRollRequestFinished
parameter_list|()
block|{
return|return
name|this
operator|.
name|walRoller
operator|.
name|walRollFinished
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|ThroughputController
name|getFlushThroughputController
parameter_list|()
block|{
return|return
name|flushThroughputController
return|;
block|}
annotation|@
name|Override
specifier|public
name|double
name|getFlushPressure
parameter_list|()
block|{
if|if
condition|(
name|getRegionServerAccounting
argument_list|()
operator|==
literal|null
operator|||
name|cacheFlusher
operator|==
literal|null
condition|)
block|{
comment|// return 0 during RS initialization
return|return
literal|0.0
return|;
block|}
return|return
name|getRegionServerAccounting
argument_list|()
operator|.
name|getFlushPressure
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onConfigurationChange
parameter_list|(
name|Configuration
name|newConf
parameter_list|)
block|{
name|ThroughputController
name|old
init|=
name|this
operator|.
name|flushThroughputController
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|old
operator|.
name|stop
argument_list|(
literal|"configuration change"
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|flushThroughputController
operator|=
name|FlushThroughputControllerFactory
operator|.
name|create
argument_list|(
name|this
argument_list|,
name|newConf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|MetricsRegionServer
name|getMetrics
parameter_list|()
block|{
return|return
name|metricsRegionServer
return|;
block|}
annotation|@
name|Override
specifier|public
name|SecureBulkLoadManager
name|getSecureBulkLoadManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|secureBulkLoadManager
return|;
block|}
block|}
end_class

end_unit

