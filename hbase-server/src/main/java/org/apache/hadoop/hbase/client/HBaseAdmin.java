begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Abortable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotEnabledException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ZooKeeperConnectionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|CatalogTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitorBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|CoprocessorRpcChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|MasterCoprocessorRpcChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|RequestConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ResponseConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|CloseRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|CloseRegionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|CompactRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|FlushRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|GetRegionInfoRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|GetRegionInfoResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|GetRegionInfoResponse
operator|.
name|CompactionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|RollWALWriterRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|RollWALWriterResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|StopServerRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|ScanRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|ScanResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|SnapshotDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|TableSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|AddColumnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|AssignRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|CreateTableRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|DeleteColumnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|DeleteSnapshotRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|DeleteTableRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|DisableTableRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|EnableTableRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|IsRestoreSnapshotDoneRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|IsRestoreSnapshotDoneResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|IsSnapshotDoneRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|IsSnapshotDoneResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|ListSnapshotRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|ModifyColumnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|ModifyTableRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|MoveRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|RestoreSnapshotRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|RestoreSnapshotResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|SetBalancerRunningRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|ShutdownRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|StopMasterRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|TakeSnapshotRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|TakeSnapshotResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterAdminProtos
operator|.
name|UnassignRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterMonitorProtos
operator|.
name|GetClusterStatusRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterMonitorProtos
operator|.
name|GetSchemaAlterStatusRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterMonitorProtos
operator|.
name|GetSchemaAlterStatusResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterMonitorProtos
operator|.
name|GetTableDescriptorsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterMonitorProtos
operator|.
name|GetTableDescriptorsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|FailedLogCloseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
operator|.
name|HBaseSnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
operator|.
name|RestoreSnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
operator|.
name|SnapshotCreationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
operator|.
name|SnapshotDescriptionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
operator|.
name|UnknownSnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Addressing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ServiceException
import|;
end_import

begin_comment
comment|/**  * Provides an interface to manage HBase database table metadata + general  * administrative functions.  Use HBaseAdmin to create, drop, list, enable and  * disable tables. Use it also to add and drop table column families.  *  *<p>See {@link HTable} to add, update, and delete data from an individual table.  *<p>Currently HBaseAdmin instances are not expected to be long-lived.  For  * example, an HBaseAdmin instance will not ride over a Master restart.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|HBaseAdmin
implements|implements
name|Abortable
implements|,
name|Closeable
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HBaseAdmin
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// We use the implementation class rather then the interface because we
comment|//  need the package protected functions to get the connection to master
specifier|private
name|HConnection
name|connection
decl_stmt|;
specifier|private
specifier|volatile
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|long
name|pause
decl_stmt|;
specifier|private
specifier|final
name|int
name|numRetries
decl_stmt|;
comment|// Some operations can take a long time such as disable of big table.
comment|// numRetries is for 'normal' stuff... Multiply by this factor when
comment|// want to wait a long time.
specifier|private
specifier|final
name|int
name|retryLongerMultiplier
decl_stmt|;
specifier|private
name|boolean
name|aborted
decl_stmt|;
comment|/**    * Constructor.    * See {@link #HBaseAdmin(HConnection connection)}    *    * @param c Configuration object. Copied internally.    */
specifier|public
name|HBaseAdmin
parameter_list|(
name|Configuration
name|c
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
comment|// Will not leak connections, as the new implementation of the constructor
comment|// does not throw exceptions anymore.
name|this
argument_list|(
name|HConnectionManager
operator|.
name|getConnection
argument_list|(
operator|new
name|Configuration
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**   * Constructor for externally managed HConnections.   * The connection to master will be created when required by admin functions.   *   * @param connection The HConnection instance to use   * @throws MasterNotRunningException, ZooKeeperConnectionException are not   *  thrown anymore but kept into the interface for backward api compatibility   */
specifier|public
name|HBaseAdmin
parameter_list|(
name|HConnection
name|connection
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
name|this
operator|.
name|conf
operator|=
name|connection
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|pause
operator|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.client.pause"
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|numRetries
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|retryLongerMultiplier
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.longer.multiplier"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return A new CatalogTracker instance; call {@link #cleanupCatalogTracker(CatalogTracker)}    * to cleanup the returned catalog tracker.    * @throws ZooKeeperConnectionException    * @throws IOException    * @see #cleanupCatalogTracker(CatalogTracker)    */
specifier|private
specifier|synchronized
name|CatalogTracker
name|getCatalogTracker
parameter_list|()
throws|throws
name|ZooKeeperConnectionException
throws|,
name|IOException
block|{
name|CatalogTracker
name|ct
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ct
operator|=
operator|new
name|CatalogTracker
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|ct
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Let it out as an IOE for now until we redo all so tolerate IEs
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|ct
return|;
block|}
specifier|private
name|void
name|cleanupCatalogTracker
parameter_list|(
specifier|final
name|CatalogTracker
name|ct
parameter_list|)
block|{
name|ct
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|why
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
comment|// Currently does nothing but throw the passed message and exception
name|this
operator|.
name|aborted
operator|=
literal|true
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|why
argument_list|,
name|e
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAborted
parameter_list|()
block|{
return|return
name|this
operator|.
name|aborted
return|;
block|}
comment|/** @return HConnection used by this object. */
specifier|public
name|HConnection
name|getConnection
parameter_list|()
block|{
return|return
name|connection
return|;
block|}
comment|/** @return - true if the master server is running. Throws an exception    *  otherwise.    * @throws ZooKeeperConnectionException    * @throws MasterNotRunningException    */
specifier|public
name|boolean
name|isMasterRunning
parameter_list|()
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
return|return
name|connection
operator|.
name|isMasterRunning
argument_list|()
return|;
block|}
comment|/**    * @param tableName Table to check.    * @return True if table exists already.    * @throws IOException    */
specifier|public
name|boolean
name|tableExists
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|b
init|=
literal|false
decl_stmt|;
name|CatalogTracker
name|ct
init|=
name|getCatalogTracker
argument_list|()
decl_stmt|;
try|try
block|{
name|b
operator|=
name|MetaReader
operator|.
name|tableExists
argument_list|(
name|ct
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cleanupCatalogTracker
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
comment|/**    * @param tableName Table to check.    * @return True if table exists already.    * @throws IOException    */
specifier|public
name|boolean
name|tableExists
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|tableExists
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * List all the userspace tables.  In other words, scan the META table.    *    * If we wanted this to be really fast, we could implement a special    * catalog table that just contains table names and their descriptors.    * Right now, it only exists as part of the META table's region info.    *    * @return - returns an array of HTableDescriptors    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|connection
operator|.
name|listTables
argument_list|()
return|;
block|}
comment|/**    * List all the userspace tables matching the given pattern.    *    * @param pattern The compiled regular expression to match against    * @return - returns an array of HTableDescriptors    * @throws IOException if a remote or network exception occurs    * @see #listTables()    */
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|(
name|Pattern
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|matched
init|=
operator|new
name|LinkedList
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|HTableDescriptor
index|[]
name|tables
init|=
name|listTables
argument_list|()
decl_stmt|;
for|for
control|(
name|HTableDescriptor
name|table
range|:
name|tables
control|)
block|{
if|if
condition|(
name|pattern
operator|.
name|matcher
argument_list|(
name|table
operator|.
name|getNameAsString
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|matched
operator|.
name|add
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|matched
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[
name|matched
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * List all the userspace tables matching the given regular expression.    *    * @param regex The regular expression to match against    * @return - returns an array of HTableDescriptors    * @throws IOException if a remote or network exception occurs    * @see #listTables(java.util.regex.Pattern)    */
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listTables
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Method for getting the tableDescriptor    * @param tableName as a byte []    * @return the tableDescriptor    * @throws TableNotFoundException    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HTableDescriptor
name|getTableDescriptor
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|TableNotFoundException
throws|,
name|IOException
block|{
return|return
name|this
operator|.
name|connection
operator|.
name|getHTableDescriptor
argument_list|(
name|tableName
argument_list|)
return|;
block|}
specifier|private
name|long
name|getPauseTime
parameter_list|(
name|int
name|tries
parameter_list|)
block|{
name|int
name|triesCount
init|=
name|tries
decl_stmt|;
if|if
condition|(
name|triesCount
operator|>=
name|HConstants
operator|.
name|RETRY_BACKOFF
operator|.
name|length
condition|)
block|{
name|triesCount
operator|=
name|HConstants
operator|.
name|RETRY_BACKOFF
operator|.
name|length
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|this
operator|.
name|pause
operator|*
name|HConstants
operator|.
name|RETRY_BACKOFF
index|[
name|triesCount
index|]
return|;
block|}
comment|/**    * Creates a new table.    * Synchronous operation.    *    * @param desc table descriptor for table    *    * @throws IllegalArgumentException if the table name is reserved    * @throws MasterNotRunningException if master is not running    * @throws TableExistsException if table already exists (If concurrent    * threads, the table may have been created between test-for-existence    * and attempt-at-creation).    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|)
throws|throws
name|IOException
block|{
name|createTable
argument_list|(
name|desc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new table with the specified number of regions.  The start key    * specified will become the end key of the first region of the table, and    * the end key specified will become the start key of the last region of the    * table (the first region has a null start key and the last region has a    * null end key).    *    * BigInteger math will be used to divide the key range specified into    * enough segments to make the required number of total regions.    *    * Synchronous operation.    *    * @param desc table descriptor for table    * @param startKey beginning of key range    * @param endKey end of key range    * @param numRegions the total number of regions to create    *    * @throws IllegalArgumentException if the table name is reserved    * @throws MasterNotRunningException if master is not running    * @throws TableExistsException if table already exists (If concurrent    * threads, the table may have been created between test-for-existence    * and attempt-at-creation).    * @throws IOException    */
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|,
name|byte
index|[]
name|startKey
parameter_list|,
name|byte
index|[]
name|endKey
parameter_list|,
name|int
name|numRegions
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|numRegions
operator|<
literal|3
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must create at least three regions"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|startKey
argument_list|,
name|endKey
argument_list|)
operator|>=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Start key must be smaller than end key"
argument_list|)
throw|;
block|}
name|byte
index|[]
index|[]
name|splitKeys
init|=
name|Bytes
operator|.
name|split
argument_list|(
name|startKey
argument_list|,
name|endKey
argument_list|,
name|numRegions
operator|-
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|splitKeys
operator|==
literal|null
operator|||
name|splitKeys
operator|.
name|length
operator|!=
name|numRegions
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to split key range into enough regions"
argument_list|)
throw|;
block|}
name|createTable
argument_list|(
name|desc
argument_list|,
name|splitKeys
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new table with an initial set of empty regions defined by the    * specified split keys.  The total number of regions created will be the    * number of split keys plus one. Synchronous operation.    * Note : Avoid passing empty split key.    *    * @param desc table descriptor for table    * @param splitKeys array of split keys for the initial regions of the table    *    * @throws IllegalArgumentException if the table name is reserved, if the split keys    * are repeated and if the split key has empty byte array.    * @throws MasterNotRunningException if master is not running    * @throws TableExistsException if table already exists (If concurrent    * threads, the table may have been created between test-for-existence    * and attempt-at-creation).    * @throws IOException    */
specifier|public
name|void
name|createTable
parameter_list|(
specifier|final
name|HTableDescriptor
name|desc
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|createTableAsync
argument_list|(
name|desc
argument_list|,
name|splitKeys
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|ste
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Creating "
operator|+
name|desc
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|" took too long"
argument_list|,
name|ste
argument_list|)
expr_stmt|;
block|}
name|int
name|numRegs
init|=
name|splitKeys
operator|==
literal|null
condition|?
literal|1
else|:
name|splitKeys
operator|.
name|length
operator|+
literal|1
decl_stmt|;
name|int
name|prevRegCount
init|=
literal|0
decl_stmt|;
name|boolean
name|doneWithMetaScan
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
condition|;
operator|++
name|tries
control|)
block|{
if|if
condition|(
operator|!
name|doneWithMetaScan
condition|)
block|{
comment|// Wait for new table to come on-line
specifier|final
name|AtomicInteger
name|actualRegCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitorBase
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|rowResult
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInfo
name|info
init|=
name|HRegionInfo
operator|.
name|getHRegionInfo
argument_list|(
name|rowResult
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No serialized HRegionInfo in "
operator|+
name|rowResult
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|Bytes
operator|.
name|equals
argument_list|(
name|info
operator|.
name|getTableName
argument_list|()
argument_list|,
name|desc
operator|.
name|getName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ServerName
name|serverName
init|=
name|HRegionInfo
operator|.
name|getServerName
argument_list|(
name|rowResult
argument_list|)
decl_stmt|;
comment|// Make sure that regions are assigned to server
if|if
condition|(
operator|!
operator|(
name|info
operator|.
name|isOffline
argument_list|()
operator|||
name|info
operator|.
name|isSplit
argument_list|()
operator|)
operator|&&
name|serverName
operator|!=
literal|null
operator|&&
name|serverName
operator|.
name|getHostAndPort
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|actualRegCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|visitor
argument_list|,
name|desc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|actualRegCount
operator|.
name|get
argument_list|()
operator|!=
name|numRegs
condition|)
block|{
if|if
condition|(
name|tries
operator|==
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|RegionOfflineException
argument_list|(
literal|"Only "
operator|+
name|actualRegCount
operator|.
name|get
argument_list|()
operator|+
literal|" of "
operator|+
name|numRegs
operator|+
literal|" regions are online; retries exhausted."
argument_list|)
throw|;
block|}
try|try
block|{
comment|// Sleep
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted when opening"
operator|+
literal|" regions; "
operator|+
name|actualRegCount
operator|.
name|get
argument_list|()
operator|+
literal|" of "
operator|+
name|numRegs
operator|+
literal|" regions processed so far"
argument_list|)
throw|;
block|}
if|if
condition|(
name|actualRegCount
operator|.
name|get
argument_list|()
operator|>
name|prevRegCount
condition|)
block|{
comment|// Making progress
name|prevRegCount
operator|=
name|actualRegCount
operator|.
name|get
argument_list|()
expr_stmt|;
name|tries
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|doneWithMetaScan
operator|=
literal|true
expr_stmt|;
name|tries
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isTableEnabled
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
else|else
block|{
try|try
block|{
comment|// Sleep
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted when waiting"
operator|+
literal|" for table to be enabled; meta scan was done"
argument_list|)
throw|;
block|}
block|}
block|}
throw|throw
operator|new
name|TableNotEnabledException
argument_list|(
literal|"Retries exhausted while still waiting for table: "
operator|+
name|desc
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|" to be enabled"
argument_list|)
throw|;
block|}
comment|/**    * Creates a new table but does not block and wait for it to come online.    * Asynchronous operation.  To check if the table exists, use    * {@link #isTableAvailable} -- it is not safe to create an HTable    * instance to this table before it is available.    * Note : Avoid passing empty split key.    * @param desc table descriptor for table    *    * @throws IllegalArgumentException Bad table name, if the split keys    * are repeated and if the split key has empty byte array.    * @throws MasterNotRunningException if master is not running    * @throws TableExistsException if table already exists (If concurrent    * threads, the table may have been created between test-for-existence    * and attempt-at-creation).    * @throws IOException    */
specifier|public
name|void
name|createTableAsync
parameter_list|(
specifier|final
name|HTableDescriptor
name|desc
parameter_list|,
specifier|final
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|splitKeys
operator|!=
literal|null
operator|&&
name|splitKeys
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|splitKeys
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
comment|// Verify there are no duplicate split keys
name|byte
index|[]
name|lastKey
init|=
literal|null
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|splitKey
range|:
name|splitKeys
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|splitKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Empty split key must not be passed in the split keys."
argument_list|)
throw|;
block|}
if|if
condition|(
name|lastKey
operator|!=
literal|null
operator|&&
name|Bytes
operator|.
name|equals
argument_list|(
name|splitKey
argument_list|,
name|lastKey
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"All split keys must be unique, "
operator|+
literal|"found duplicate: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|splitKey
argument_list|)
operator|+
literal|", "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|lastKey
argument_list|)
argument_list|)
throw|;
block|}
name|lastKey
operator|=
name|splitKey
expr_stmt|;
block|}
block|}
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|CreateTableRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildCreateTableRequest
argument_list|(
name|desc
argument_list|,
name|splitKeys
argument_list|)
decl_stmt|;
name|masterAdmin
operator|.
name|createTable
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Deletes a table.    * Synchronous operation.    *    * @param tableName name of table to delete    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteTable
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Deletes a table.    * Synchronous operation.    *    * @param tableName name of table to delete    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|HRegionLocation
name|firstMetaServer
init|=
name|getFirstMetaServerForTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|boolean
name|tableExists
init|=
literal|true
decl_stmt|;
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|DeleteTableRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildDeleteTableRequest
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|masterAdmin
operator|.
name|deleteTable
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Wait until all regions deleted
name|ClientProtocol
name|server
init|=
name|connection
operator|.
name|getClient
argument_list|(
name|firstMetaServer
operator|.
name|getHostname
argument_list|()
argument_list|,
name|firstMetaServer
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
operator|(
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
operator|)
condition|;
name|tries
operator|++
control|)
block|{
try|try
block|{
name|Scan
name|scan
init|=
name|MetaReader
operator|.
name|getScanForTableName
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|REGIONINFO_QUALIFIER
argument_list|)
expr_stmt|;
name|ScanRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildScanRequest
argument_list|(
name|firstMetaServer
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|scan
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Result
index|[]
name|values
init|=
literal|null
decl_stmt|;
comment|// Get a batch at a time.
try|try
block|{
name|ScanResponse
name|response
init|=
name|server
operator|.
name|scan
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
name|values
operator|=
name|ResponseConverter
operator|.
name|getResults
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
comment|// let us wait until .META. table is updated and
comment|// HMaster removes the table from its HTableDescriptors
if|if
condition|(
name|values
operator|==
literal|null
operator|||
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|tableExists
operator|=
literal|false
expr_stmt|;
name|GetTableDescriptorsResponse
name|htds
decl_stmt|;
name|MasterMonitorKeepAliveConnection
name|master
init|=
name|connection
operator|.
name|getKeepAliveMasterMonitor
argument_list|()
decl_stmt|;
try|try
block|{
name|GetTableDescriptorsRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetTableDescriptorsRequest
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|htds
operator|=
name|master
operator|.
name|getTableDescriptors
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
finally|finally
block|{
name|master
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|TableSchema
name|ts
range|:
name|htds
operator|.
name|getTableSchemaList
argument_list|()
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|ts
operator|.
name|getName
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|)
condition|)
block|{
name|tableExists
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|tableExists
condition|)
block|{
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// no more tries left
if|if
condition|(
name|ex
operator|instanceof
name|RemoteException
condition|)
block|{
throw|throw
operator|(
operator|(
name|RemoteException
operator|)
name|ex
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
else|else
block|{
throw|throw
name|ex
throw|;
block|}
block|}
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
if|if
condition|(
name|tableExists
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Retries exhausted, it took too long to wait"
operator|+
literal|" for the table "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|" to be deleted."
argument_list|)
throw|;
block|}
comment|// Delete cached information to prevent clients from using old locations
name|this
operator|.
name|connection
operator|.
name|clearRegionCache
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Deletes tables matching the passed in pattern and wait on completion.    *    * Warning: Use this method carefully, there is no prompting and the effect is    * immediate. Consider using {@link #listTables(java.lang.String)} and    * {@link #deleteTable(byte[])}    *    * @param regex The regular expression to match table names against    * @return Table descriptors for tables that couldn't be deleted    * @throws IOException    * @see #deleteTables(java.util.regex.Pattern)    * @see #deleteTable(java.lang.String)    */
specifier|public
name|HTableDescriptor
index|[]
name|deleteTables
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|deleteTables
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Delete tables matching the passed in pattern and wait on completion.    *    * Warning: Use this method carefully, there is no prompting and the effect is    * immediate. Consider using {@link #listTables(java.util.regex.Pattern) } and    * {@link #deleteTable(byte[])}    *    * @param pattern The pattern to match table names against    * @return Table descriptors for tables that couldn't be deleted    * @throws IOException    */
specifier|public
name|HTableDescriptor
index|[]
name|deleteTables
parameter_list|(
name|Pattern
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|failed
init|=
operator|new
name|LinkedList
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HTableDescriptor
name|table
range|:
name|listTables
argument_list|(
name|pattern
argument_list|)
control|)
block|{
try|try
block|{
name|deleteTable
argument_list|(
name|table
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to delete table "
operator|+
name|table
operator|.
name|getNameAsString
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|failed
operator|.
name|add
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|failed
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[
name|failed
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|public
name|void
name|enableTable
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|enableTable
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Enable a table.  May timeout.  Use {@link #enableTableAsync(byte[])}    * and {@link #isTableEnabled(byte[])} instead.    * The table has to be in disabled state for it to be enabled.    * @param tableName name of the table    * @throws IOException if a remote or network exception occurs    * There could be couple types of IOException    * TableNotFoundException means the table doesn't exist.    * TableNotDisabledException means the table isn't in disabled state.    * @see #isTableEnabled(byte[])    * @see #disableTable(byte[])    * @see #enableTableAsync(byte[])    */
specifier|public
name|void
name|enableTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|enableTableAsync
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// Wait until all regions are enabled
name|waitUntilTableIsEnabled
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Enabled table "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait for the table to be enabled and available    * If enabling the table exceeds the retry period, an exception is thrown.    * @param tableName name of the table    * @throws IOException if a remote or network exception occurs or    *    table is not enabled after the retries period.    */
specifier|private
name|void
name|waitUntilTableIsEnabled
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|enabled
init|=
literal|false
decl_stmt|;
name|long
name|start
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
operator|(
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
operator|)
condition|;
name|tries
operator|++
control|)
block|{
name|enabled
operator|=
name|isTableEnabled
argument_list|(
name|tableName
argument_list|)
operator|&&
name|isTableAvailable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
block|{
break|break;
block|}
name|long
name|sleep
init|=
name|getPauseTime
argument_list|(
name|tries
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping= "
operator|+
name|sleep
operator|+
literal|"ms, waiting for all regions to be "
operator|+
literal|"enabled in "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|// Do this conversion rather than let it out because do not want to
comment|// change the method signature.
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|enabled
condition|)
block|{
name|long
name|msec
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Table '"
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|"' not yet enabled, after "
operator|+
name|msec
operator|+
literal|"ms."
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|enableTableAsync
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|enableTableAsync
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Brings a table on-line (enables it).  Method returns immediately though    * enable of table may take some time to complete, especially if the table    * is large (All regions are opened as part of enabling process).  Check    * {@link #isTableEnabled(byte[])} to learn when table is fully online.  If    * table is taking too long to online, check server logs.    * @param tableName    * @throws IOException    * @since 0.90.0    */
specifier|public
name|void
name|enableTableAsync
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Started enable of "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|EnableTableRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildEnableTableRequest
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|masterAdmin
operator|.
name|enableTable
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Enable tables matching the passed in pattern and wait on completion.    *    * Warning: Use this method carefully, there is no prompting and the effect is    * immediate. Consider using {@link #listTables(java.lang.String)} and    * {@link #enableTable(byte[])}    *    * @param regex The regular expression to match table names against    * @throws IOException    * @see #enableTables(java.util.regex.Pattern)    * @see #enableTable(java.lang.String)    */
specifier|public
name|HTableDescriptor
index|[]
name|enableTables
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|enableTables
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Enable tables matching the passed in pattern and wait on completion.    *    * Warning: Use this method carefully, there is no prompting and the effect is    * immediate. Consider using {@link #listTables(java.util.regex.Pattern) } and    * {@link #enableTable(byte[])}    *    * @param pattern The pattern to match table names against    * @throws IOException    */
specifier|public
name|HTableDescriptor
index|[]
name|enableTables
parameter_list|(
name|Pattern
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|failed
init|=
operator|new
name|LinkedList
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HTableDescriptor
name|table
range|:
name|listTables
argument_list|(
name|pattern
argument_list|)
control|)
block|{
if|if
condition|(
name|isTableDisabled
argument_list|(
name|table
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
try|try
block|{
name|enableTable
argument_list|(
name|table
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to enable table "
operator|+
name|table
operator|.
name|getNameAsString
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|failed
operator|.
name|add
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|failed
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[
name|failed
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|public
name|void
name|disableTableAsync
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|disableTableAsync
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Starts the disable of a table.  If it is being served, the master    * will tell the servers to stop serving it.  This method returns immediately.    * The disable of a table can take some time if the table is large (all    * regions are closed as part of table disable operation).    * Call {@link #isTableDisabled(byte[])} to check for when disable completes.    * If table is taking too long to online, check server logs.    * @param tableName name of table    * @throws IOException if a remote or network exception occurs    * @see #isTableDisabled(byte[])    * @see #isTableEnabled(byte[])    * @since 0.90.0    */
specifier|public
name|void
name|disableTableAsync
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Started disable of "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|DisableTableRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildDisableTableRequest
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|masterAdmin
operator|.
name|disableTable
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|disableTable
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|disableTable
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Disable table and wait on completion.  May timeout eventually.  Use    * {@link #disableTableAsync(byte[])} and {@link #isTableDisabled(String)}    * instead.    * The table has to be in enabled state for it to be disabled.    * @param tableName    * @throws IOException    * There could be couple types of IOException    * TableNotFoundException means the table doesn't exist.    * TableNotEnabledException means the table isn't in enabled state.    */
specifier|public
name|void
name|disableTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|disableTableAsync
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// Wait until table is disabled
name|boolean
name|disabled
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
operator|(
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
operator|)
condition|;
name|tries
operator|++
control|)
block|{
name|disabled
operator|=
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|disabled
condition|)
block|{
break|break;
block|}
name|long
name|sleep
init|=
name|getPauseTime
argument_list|(
name|tries
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping= "
operator|+
name|sleep
operator|+
literal|"ms, waiting for all regions to be "
operator|+
literal|"disabled in "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Do this conversion rather than let it out because do not want to
comment|// change the method signature.
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|disabled
condition|)
block|{
throw|throw
operator|new
name|RegionException
argument_list|(
literal|"Retries exhausted, it took too long to wait"
operator|+
literal|" for the table "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|" to be disabled."
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabled "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Disable tables matching the passed in pattern and wait on completion.    *    * Warning: Use this method carefully, there is no prompting and the effect is    * immediate. Consider using {@link #listTables(java.lang.String)} and    * {@link #disableTable(byte[])}    *    * @param regex The regular expression to match table names against    * @return Table descriptors for tables that couldn't be disabled    * @throws IOException    * @see #disableTables(java.util.regex.Pattern)    * @see #disableTable(java.lang.String)    */
specifier|public
name|HTableDescriptor
index|[]
name|disableTables
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|disableTables
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Disable tables matching the passed in pattern and wait on completion.    *    * Warning: Use this method carefully, there is no prompting and the effect is    * immediate. Consider using {@link #listTables(java.util.regex.Pattern) } and    * {@link #disableTable(byte[])}    *    * @param pattern The pattern to match table names against    * @return Table descriptors for tables that couldn't be disabled    * @throws IOException    */
specifier|public
name|HTableDescriptor
index|[]
name|disableTables
parameter_list|(
name|Pattern
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|failed
init|=
operator|new
name|LinkedList
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HTableDescriptor
name|table
range|:
name|listTables
argument_list|(
name|pattern
argument_list|)
control|)
block|{
if|if
condition|(
name|isTableEnabled
argument_list|(
name|table
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
try|try
block|{
name|disableTable
argument_list|(
name|table
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to disable table "
operator|+
name|table
operator|.
name|getNameAsString
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|failed
operator|.
name|add
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|failed
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[
name|failed
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if table is on-line    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableEnabled
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if table is on-line    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|HTableDescriptor
operator|.
name|isMetaTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
return|return
name|connection
operator|.
name|isTableEnabled
argument_list|(
name|tableName
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if table is off-line    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableDisabled
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if table is off-line    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|HTableDescriptor
operator|.
name|isMetaTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
return|return
name|connection
operator|.
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if all regions of the table are available    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|isTableAvailable
argument_list|(
name|tableName
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if all regions of the table are available    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|isTableAvailable
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the status of alter command - indicates how many regions have received    * the updated schema Asynchronous operation.    *    * @param tableName    *          name of the table to get the status of    * @return Pair indicating the number of regions updated Pair.getFirst() is the    *         regions that are yet to be updated Pair.getSecond() is the total number    *         of regions of the table    * @throws IOException    *           if a remote or network exception occurs    */
specifier|public
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|getAlterStatus
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
return|return
name|execute
argument_list|(
operator|new
name|MasterMonitorCallable
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|GetSchemaAlterStatusRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetSchemaAlterStatusRequest
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|GetSchemaAlterStatusResponse
name|ret
init|=
name|masterMonitor
operator|.
name|getSchemaAlterStatus
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
decl_stmt|;
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|pair
init|=
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|ret
operator|.
name|getYetToUpdateRegions
argument_list|()
argument_list|)
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|ret
operator|.
name|getTotalRegions
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|pair
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Add a column to an existing table.    * Asynchronous operation.    *    * @param tableName name of the table to add column to    * @param column column descriptor of column to be added    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|addColumn
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|,
name|HColumnDescriptor
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|addColumn
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a column to an existing table.    * Asynchronous operation.    *    * @param tableName name of the table to add column to    * @param column column descriptor of column to be added    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|addColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|HColumnDescriptor
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|AddColumnRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildAddColumnRequest
argument_list|(
name|tableName
argument_list|,
name|column
argument_list|)
decl_stmt|;
name|masterAdmin
operator|.
name|addColumn
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a column from a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param columnName name of column to be deleted    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|deleteColumn
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|,
specifier|final
name|String
name|columnName
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteColumn
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|columnName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a column from a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param columnName name of column to be deleted    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|deleteColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnName
parameter_list|)
throws|throws
name|IOException
block|{
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|DeleteColumnRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildDeleteColumnRequest
argument_list|(
name|tableName
argument_list|,
name|columnName
argument_list|)
decl_stmt|;
name|masterAdmin
operator|.
name|deleteColumn
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing column family on a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param descriptor new column descriptor to use    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|modifyColumn
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|,
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|modifyColumn
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing column family on a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param descriptor new column descriptor to use    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|modifyColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|ModifyColumnRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildModifyColumnRequest
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
decl_stmt|;
name|masterAdmin
operator|.
name|modifyColumn
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Close a region. For expert-admins.  Runs close on the regionserver.  The    * master will not be informed of the close.    * @param regionname region name to close    * @param serverName If supplied, we'll use this location rather than    * the one currently in<code>.META.</code>    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|closeRegion
parameter_list|(
specifier|final
name|String
name|regionname
parameter_list|,
specifier|final
name|String
name|serverName
parameter_list|)
throws|throws
name|IOException
block|{
name|closeRegion
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|regionname
argument_list|)
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Close a region.  For expert-admins  Runs close on the regionserver.  The    * master will not be informed of the close.    * @param regionname region name to close    * @param serverName The servername of the regionserver.  If passed null we    * will use servername found in the .META. table. A server name    * is made of host, port and startcode.  Here is an example:    *<code> host187.example.com,60020,1289493121758</code>    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|closeRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionname
parameter_list|,
specifier|final
name|String
name|serverName
parameter_list|)
throws|throws
name|IOException
block|{
name|CatalogTracker
name|ct
init|=
name|getCatalogTracker
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|serverName
operator|!=
literal|null
condition|)
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|ct
argument_list|,
name|regionname
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
operator|||
name|pair
operator|.
name|getFirst
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionname
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|closeRegion
argument_list|(
operator|new
name|ServerName
argument_list|(
name|serverName
argument_list|)
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|ct
argument_list|,
name|regionname
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionname
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionname
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|closeRegion
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|cleanupCatalogTracker
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * For expert-admins. Runs close on the regionserver. Closes a region based on    * the encoded region name. The region server name is mandatory. If the    * servername is provided then based on the online regions in the specified    * regionserver the specified region will be closed. The master will not be    * informed of the close. Note that the regionname is the encoded regionname.    *    * @param encodedRegionName    *          The encoded region name; i.e. the hash that makes up the region    *          name suffix: e.g. if regionname is    *<code>TestTable,0094429456,1289497600452.527db22f95c8a9e0116f0cc13c680396.</code>    *          , then the encoded region name is:    *<code>527db22f95c8a9e0116f0cc13c680396</code>.    * @param serverName    *          The servername of the regionserver. A server name is made of host,    *          port and startcode. This is mandatory. Here is an example:    *<code> host187.example.com,60020,1289493121758</code>    * @return true if the region was closed, false if not.    * @throws IOException    *           if a remote or network exception occurs    */
specifier|public
name|boolean
name|closeRegionWithEncodedRegionName
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|,
specifier|final
name|String
name|serverName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
literal|null
operator|==
name|serverName
operator|||
operator|(
literal|""
operator|)
operator|.
name|equals
argument_list|(
name|serverName
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The servername cannot be null or empty."
argument_list|)
throw|;
block|}
name|ServerName
name|sn
init|=
operator|new
name|ServerName
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
name|AdminProtocol
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
comment|// Close the region without updating zk state.
name|CloseRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildCloseRegionRequest
argument_list|(
name|encodedRegionName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
try|try
block|{
name|CloseRegionResponse
name|response
init|=
name|admin
operator|.
name|closeRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
name|boolean
name|isRegionClosed
init|=
name|response
operator|.
name|getClosed
argument_list|()
decl_stmt|;
if|if
condition|(
literal|false
operator|==
name|isRegionClosed
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Not able to close the region "
operator|+
name|encodedRegionName
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
return|return
name|isRegionClosed
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
comment|/**    * Close a region.  For expert-admins  Runs close on the regionserver.  The    * master will not be informed of the close.    * @param sn    * @param hri    * @throws IOException    */
specifier|public
name|void
name|closeRegion
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|IOException
block|{
name|AdminProtocol
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
comment|// Close the region without updating zk state.
name|ProtobufUtil
operator|.
name|closeRegion
argument_list|(
name|admin
argument_list|,
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get all the online regions on a region server.    */
specifier|public
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|getOnlineRegions
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
throws|throws
name|IOException
block|{
name|AdminProtocol
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|getOnlineRegions
argument_list|(
name|admin
argument_list|)
return|;
block|}
comment|/**    * Flush a table or an individual region.    * Synchronous operation.    *    * @param tableNameOrRegionName table or region to flush    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|flush
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|flush
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Flush a table or an individual region.    * Synchronous operation.    *    * @param tableNameOrRegionName table or region to flush    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|flush
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|CatalogTracker
name|ct
init|=
name|getCatalogTracker
argument_list|()
decl_stmt|;
try|try
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regionServerPair
init|=
name|getRegion
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|ct
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionServerPair
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|flush
argument_list|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|regionServerPair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|String
name|tableName
init|=
name|tableNameString
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|ct
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|pairs
init|=
name|MetaReader
operator|.
name|getTableRegionsAndLocations
argument_list|(
name|ct
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|isOffline
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
try|try
block|{
name|flush
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to flush "
operator|+
name|pair
operator|.
name|getFirst
argument_list|()
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|cleanupCatalogTracker
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|flush
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|IOException
block|{
name|AdminProtocol
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|FlushRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildFlushRegionRequest
argument_list|(
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|admin
operator|.
name|flushRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
comment|/**    * Compact a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to compact    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|compact
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|compact
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compact a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to compact    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|compact
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|compact
argument_list|(
name|tableNameOrRegionName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compact a column family within a table or region.    * Asynchronous operation.    *    * @param tableOrRegionName table or region to compact    * @param columnFamily column family within a table or region    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|compact
parameter_list|(
name|String
name|tableOrRegionName
parameter_list|,
name|String
name|columnFamily
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|compact
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableOrRegionName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|columnFamily
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compact a column family within a table or region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to compact    * @param columnFamily column family within a table or region    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|compact
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|compact
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|columnFamily
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Major compact a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to major compact    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|majorCompact
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|majorCompact
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Major compact a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to major compact    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|majorCompact
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|compact
argument_list|(
name|tableNameOrRegionName
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Major compact a column family within a table or region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to major compact    * @param columnFamily column family within a table or region    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|majorCompact
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|String
name|columnFamily
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|majorCompact
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|columnFamily
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Major compact a column family within a table or region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to major compact    * @param columnFamily column family within a table or region    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|majorCompact
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|compact
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|columnFamily
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compact a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to compact    * @param columnFamily column family within a table or region    * @param major True if we are to do a major compaction.    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|private
name|void
name|compact
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|,
specifier|final
name|boolean
name|major
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|CatalogTracker
name|ct
init|=
name|getCatalogTracker
argument_list|()
decl_stmt|;
try|try
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regionServerPair
init|=
name|getRegion
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|ct
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionServerPair
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|compact
argument_list|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|regionServerPair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|major
argument_list|,
name|columnFamily
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|String
name|tableName
init|=
name|tableNameString
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|ct
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|pairs
init|=
name|MetaReader
operator|.
name|getTableRegionsAndLocations
argument_list|(
name|ct
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|isOffline
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
try|try
block|{
name|compact
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|major
argument_list|,
name|columnFamily
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to"
operator|+
operator|(
name|major
condition|?
literal|" major"
else|:
literal|""
operator|)
operator|+
literal|" compact "
operator|+
name|pair
operator|.
name|getFirst
argument_list|()
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|cleanupCatalogTracker
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|compact
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
specifier|final
name|boolean
name|major
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|)
throws|throws
name|IOException
block|{
name|AdminProtocol
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|CompactRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildCompactRegionRequest
argument_list|(
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|major
argument_list|,
name|family
argument_list|)
decl_stmt|;
try|try
block|{
name|admin
operator|.
name|compactRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
comment|/**    * Move the region<code>r</code> to<code>dest</code>.    * @param encodedRegionName The encoded region name; i.e. the hash that makes    * up the region name suffix: e.g. if regionname is    *<code>TestTable,0094429456,1289497600452.527db22f95c8a9e0116f0cc13c680396.</code>,    * then the encoded region name is:<code>527db22f95c8a9e0116f0cc13c680396</code>.    * @param destServerName The servername of the destination regionserver.  If    * passed the empty byte array we'll assign to a random server.  A server name    * is made of host, port and startcode.  Here is an example:    *<code> host187.example.com,60020,1289493121758</code>    * @throws UnknownRegionException Thrown if we can't find a region named    *<code>encodedRegionName</code>    * @throws ZooKeeperConnectionException    * @throws MasterNotRunningException    */
specifier|public
name|void
name|move
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|destServerName
parameter_list|)
throws|throws
name|UnknownRegionException
throws|,
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
name|MasterAdminKeepAliveConnection
name|master
init|=
name|connection
operator|.
name|getKeepAliveMasterAdmin
argument_list|()
decl_stmt|;
try|try
block|{
name|MoveRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildMoveRegionRequest
argument_list|(
name|encodedRegionName
argument_list|,
name|destServerName
argument_list|)
decl_stmt|;
name|master
operator|.
name|moveRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
name|IOException
name|ioe
init|=
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
decl_stmt|;
if|if
condition|(
name|ioe
operator|instanceof
name|UnknownRegionException
condition|)
block|{
throw|throw
operator|(
name|UnknownRegionException
operator|)
name|ioe
throw|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected exception: "
operator|+
name|se
operator|+
literal|" from calling HMaster.moveRegion"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|de
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not parse destination server name: "
operator|+
name|de
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|master
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @param regionName    *          Region name to assign.    * @throws MasterNotRunningException    * @throws ZooKeeperConnectionException    * @throws IOException    */
specifier|public
name|void
name|assign
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
throws|,
name|IOException
block|{
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|AssignRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildAssignRegionRequest
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|masterAdmin
operator|.
name|assignRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Unassign a region from current hosting regionserver.  Region will then be    * assigned to a regionserver chosen at random.  Region could be reassigned    * back to the same server.  Use {@link #move(byte[], byte[])} if you want    * to control the region movement.    * @param regionName Region to unassign. Will clear any existing RegionPlan    * if one found.    * @param force If true, force unassign (Will remove region from    * regions-in-transition too if present. If results in double assignment    * use hbck -fix to resolve. To be used by experts).    * @throws MasterNotRunningException    * @throws ZooKeeperConnectionException    * @throws IOException    */
specifier|public
name|void
name|unassign
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|boolean
name|force
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
throws|,
name|IOException
block|{
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|UnassignRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildUnassignRegionRequest
argument_list|(
name|regionName
argument_list|,
name|force
argument_list|)
decl_stmt|;
name|masterAdmin
operator|.
name|unassignRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Special method, only used by hbck.    */
specifier|public
name|void
name|offline
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
name|MasterAdminKeepAliveConnection
name|master
init|=
name|connection
operator|.
name|getKeepAliveMasterAdmin
argument_list|()
decl_stmt|;
try|try
block|{
name|master
operator|.
name|offlineRegion
argument_list|(
literal|null
argument_list|,
name|RequestConverter
operator|.
name|buildOfflineRegionRequest
argument_list|(
name|regionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
finally|finally
block|{
name|master
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Turn the load balancer on or off.    * @param on If true, enable balancer. If false, disable balancer.    * @param synchronous If true, it waits until current balance() call, if outstanding, to return.    * @return Previous balancer value    */
specifier|public
name|boolean
name|setBalancerRunning
parameter_list|(
specifier|final
name|boolean
name|on
parameter_list|,
specifier|final
name|boolean
name|synchronous
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
name|MasterAdminKeepAliveConnection
name|master
init|=
name|connection
operator|.
name|getKeepAliveMasterAdmin
argument_list|()
decl_stmt|;
try|try
block|{
name|SetBalancerRunningRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildSetBalancerRunningRequest
argument_list|(
name|on
argument_list|,
name|synchronous
argument_list|)
decl_stmt|;
return|return
name|master
operator|.
name|setBalancerRunning
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
operator|.
name|getPrevBalanceValue
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
name|IOException
name|ioe
init|=
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
decl_stmt|;
if|if
condition|(
name|ioe
operator|instanceof
name|MasterNotRunningException
condition|)
block|{
throw|throw
operator|(
name|MasterNotRunningException
operator|)
name|ioe
throw|;
block|}
if|if
condition|(
name|ioe
operator|instanceof
name|ZooKeeperConnectionException
condition|)
block|{
throw|throw
operator|(
name|ZooKeeperConnectionException
operator|)
name|ioe
throw|;
block|}
comment|// Throwing MasterNotRunningException even though not really valid in order to not
comment|// break interface by adding additional exception type.
throw|throw
operator|new
name|MasterNotRunningException
argument_list|(
literal|"Unexpected exception when calling balanceSwitch"
argument_list|,
name|se
argument_list|)
throw|;
block|}
finally|finally
block|{
name|master
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Invoke the balancer.  Will run the balancer and if regions to move, it will    * go ahead and do the reassignments.  Can NOT run for various reasons.  Check    * logs.    * @return True if balancer ran, false otherwise.    */
specifier|public
name|boolean
name|balancer
parameter_list|()
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
throws|,
name|ServiceException
block|{
name|MasterAdminKeepAliveConnection
name|master
init|=
name|connection
operator|.
name|getKeepAliveMasterAdmin
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|master
operator|.
name|balance
argument_list|(
literal|null
argument_list|,
name|RequestConverter
operator|.
name|buildBalanceRequest
argument_list|()
argument_list|)
operator|.
name|getBalancerRan
argument_list|()
return|;
block|}
finally|finally
block|{
name|master
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Enable/Disable the catalog janitor    * @param enable if true enables the catalog janitor    * @return the previous state    * @throws ServiceException    * @throws MasterNotRunningException    */
specifier|public
name|boolean
name|enableCatalogJanitor
parameter_list|(
name|boolean
name|enable
parameter_list|)
throws|throws
name|ServiceException
throws|,
name|MasterNotRunningException
block|{
name|MasterAdminKeepAliveConnection
name|master
init|=
name|connection
operator|.
name|getKeepAliveMasterAdmin
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|master
operator|.
name|enableCatalogJanitor
argument_list|(
literal|null
argument_list|,
name|RequestConverter
operator|.
name|buildEnableCatalogJanitorRequest
argument_list|(
name|enable
argument_list|)
argument_list|)
operator|.
name|getPrevValue
argument_list|()
return|;
block|}
finally|finally
block|{
name|master
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Ask for a scan of the catalog table    * @return the number of entries cleaned    * @throws ServiceException    * @throws MasterNotRunningException    */
specifier|public
name|int
name|runCatalogScan
parameter_list|()
throws|throws
name|ServiceException
throws|,
name|MasterNotRunningException
block|{
name|MasterAdminKeepAliveConnection
name|master
init|=
name|connection
operator|.
name|getKeepAliveMasterAdmin
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|master
operator|.
name|runCatalogScan
argument_list|(
literal|null
argument_list|,
name|RequestConverter
operator|.
name|buildCatalogScanRequest
argument_list|()
argument_list|)
operator|.
name|getScanResult
argument_list|()
return|;
block|}
finally|finally
block|{
name|master
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Query on the catalog janitor state (Enabled/Disabled?)    * @throws ServiceException    * @throws MasterNotRunningException    */
specifier|public
name|boolean
name|isCatalogJanitorEnabled
parameter_list|()
throws|throws
name|ServiceException
throws|,
name|MasterNotRunningException
block|{
name|MasterAdminKeepAliveConnection
name|master
init|=
name|connection
operator|.
name|getKeepAliveMasterAdmin
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|master
operator|.
name|isCatalogJanitorEnabled
argument_list|(
literal|null
argument_list|,
name|RequestConverter
operator|.
name|buildIsCatalogJanitorEnabledRequest
argument_list|()
argument_list|)
operator|.
name|getValue
argument_list|()
return|;
block|}
finally|finally
block|{
name|master
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Split a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to split    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|split
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Split a table or an individual region.  Implicitly finds an optimal split    * point.  Asynchronous operation.    *    * @param tableNameOrRegionName table to region to split    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|split
argument_list|(
name|tableNameOrRegionName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|String
name|splitPoint
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|split
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|splitPoint
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Split a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table to region to split    * @param splitPoint the explicit position to split on    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException interrupt exception occurred    */
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|splitPoint
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|CatalogTracker
name|ct
init|=
name|getCatalogTracker
argument_list|()
decl_stmt|;
try|try
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regionServerPair
init|=
name|getRegion
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|ct
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionServerPair
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|split
argument_list|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|regionServerPair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|splitPoint
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|String
name|tableName
init|=
name|tableNameString
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|ct
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|pairs
init|=
name|MetaReader
operator|.
name|getTableRegionsAndLocations
argument_list|(
name|ct
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
comment|// May not be a server for a particular row
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
name|HRegionInfo
name|r
init|=
name|pair
operator|.
name|getFirst
argument_list|()
decl_stmt|;
comment|// check for parents
if|if
condition|(
name|r
operator|.
name|isSplitParent
argument_list|()
condition|)
continue|continue;
comment|// if a split point given, only split that particular region
if|if
condition|(
name|splitPoint
operator|!=
literal|null
operator|&&
operator|!
name|r
operator|.
name|containsRow
argument_list|(
name|splitPoint
argument_list|)
condition|)
continue|continue;
comment|// call out to region server to do split now
name|split
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|splitPoint
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|cleanupCatalogTracker
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|split
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
name|byte
index|[]
name|splitPoint
parameter_list|)
throws|throws
name|IOException
block|{
name|AdminProtocol
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|ProtobufUtil
operator|.
name|split
argument_list|(
name|admin
argument_list|,
name|hri
argument_list|,
name|splitPoint
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing table, more IRB friendly version.    * Asynchronous operation.  This means that it may be a while before your    * schema change is updated across all of the table.    *    * @param tableName name of table.    * @param htd modified description of the table    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|modifyTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|ModifyTableRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildModifyTableRequest
argument_list|(
name|tableName
argument_list|,
name|htd
argument_list|)
decl_stmt|;
name|masterAdmin
operator|.
name|modifyTable
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param tableNameOrRegionName Name of a table or name of a region.    * @param ct A {@link CatalogTracker} instance (caller of this method usually has one).    * @return a pair of HRegionInfo and ServerName if<code>tableNameOrRegionName</code> is    *  a verified region name (we call {@link  MetaReader#getRegion( CatalogTracker, byte[])}    *  else null.    * Throw an exception if<code>tableNameOrRegionName</code> is null.    * @throws IOException    */
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|getRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|CatalogTracker
name|ct
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableNameOrRegionName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Pass a table name or region name"
argument_list|)
throw|;
block|}
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|ct
argument_list|,
name|tableNameOrRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
specifier|final
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|String
name|encodedName
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|tableNameOrRegionName
argument_list|)
decl_stmt|;
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitorBase
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInfo
name|info
init|=
name|HRegionInfo
operator|.
name|getHRegionInfo
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No serialized HRegionInfo in "
operator|+
name|data
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|encodedName
operator|.
name|equals
argument_list|(
name|info
operator|.
name|getEncodedName
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
name|ServerName
name|sn
init|=
name|HRegionInfo
operator|.
name|getServerName
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|result
operator|.
name|set
argument_list|(
operator|new
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|(
name|info
argument_list|,
name|sn
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// found the region, stop
block|}
block|}
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
name|pair
operator|=
name|result
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
return|return
name|pair
return|;
block|}
comment|/**    * Convert the table name byte array into a table name string and check if table    * exists or not.    * @param tableNameBytes Name of a table.    * @param ct A {@link CatalogTracker} instance (caller of this method usually has one).    * @return tableName in string form.    * @throws IOException if a remote or network exception occurs.    * @throws TableNotFoundException if table does not exist.    */
specifier|private
name|String
name|tableNameString
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameBytes
parameter_list|,
name|CatalogTracker
name|ct
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|tableNameString
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|tableNameBytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|MetaReader
operator|.
name|tableExists
argument_list|(
name|ct
argument_list|,
name|tableNameString
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableNameString
argument_list|)
throw|;
block|}
return|return
name|tableNameString
return|;
block|}
comment|/**    * Shuts down the HBase cluster    * @throws IOException if a remote or network exception occurs    */
specifier|public
specifier|synchronized
name|void
name|shutdown
parameter_list|()
throws|throws
name|IOException
block|{
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|masterAdmin
operator|.
name|shutdown
argument_list|(
literal|null
argument_list|,
name|ShutdownRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Shuts down the current HBase master only.    * Does not shutdown the cluster.    * @see #shutdown()    * @throws IOException if a remote or network exception occurs    */
specifier|public
specifier|synchronized
name|void
name|stopMaster
parameter_list|()
throws|throws
name|IOException
block|{
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|masterAdmin
operator|.
name|stopMaster
argument_list|(
literal|null
argument_list|,
name|StopMasterRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stop the designated regionserver    * @param hostnamePort Hostname and port delimited by a<code>:</code> as in    *<code>example.org:1234</code>    * @throws IOException if a remote or network exception occurs    */
specifier|public
specifier|synchronized
name|void
name|stopRegionServer
parameter_list|(
specifier|final
name|String
name|hostnamePort
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|hostname
init|=
name|Addressing
operator|.
name|parseHostname
argument_list|(
name|hostnamePort
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|Addressing
operator|.
name|parsePort
argument_list|(
name|hostnamePort
argument_list|)
decl_stmt|;
name|AdminProtocol
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|hostname
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|StopServerRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildStopServerRequest
argument_list|(
literal|"Called by admin client "
operator|+
name|this
operator|.
name|connection
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|admin
operator|.
name|stopServer
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return cluster status    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|ClusterStatus
name|getClusterStatus
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|execute
argument_list|(
operator|new
name|MasterMonitorCallable
argument_list|<
name|ClusterStatus
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ClusterStatus
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|GetClusterStatusRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetClusterStatusRequest
argument_list|()
decl_stmt|;
return|return
name|ClusterStatus
operator|.
name|convert
argument_list|(
name|masterMonitor
operator|.
name|getClusterStatus
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
operator|.
name|getClusterStatus
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|private
name|HRegionLocation
name|getFirstMetaServerForTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|locateRegion
argument_list|(
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|,
name|HRegionInfo
operator|.
name|createRegionName
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
name|HConstants
operator|.
name|NINES
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return Configuration used by the instance.    */
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|this
operator|.
name|conf
return|;
block|}
comment|/**    * Check to see if HBase is running. Throw an exception if not.    * We consider that HBase is running if ZooKeeper and Master are running.    *    * @param conf system configuration    * @throws MasterNotRunningException if the master is not running    * @throws ZooKeeperConnectionException if unable to connect to zookeeper    */
specifier|public
specifier|static
name|void
name|checkHBaseAvailable
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
throws|,
name|ServiceException
block|{
name|Configuration
name|copyOfConf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// We set it to make it fail as soon as possible if HBase is not available
name|copyOfConf
operator|.
name|setInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|copyOfConf
operator|.
name|setInt
argument_list|(
literal|"zookeeper.recovery.retry"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HConnectionManager
operator|.
name|HConnectionImplementation
name|connection
init|=
operator|(
name|HConnectionManager
operator|.
name|HConnectionImplementation
operator|)
name|HConnectionManager
operator|.
name|getConnection
argument_list|(
name|copyOfConf
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Check ZK first.
comment|// If the connection exists, we may have a connection to ZK that does
comment|//  not work anymore
name|ZooKeeperKeepAliveConnection
name|zkw
init|=
literal|null
decl_stmt|;
try|try
block|{
name|zkw
operator|=
name|connection
operator|.
name|getKeepAliveZooKeeperWatcher
argument_list|()
expr_stmt|;
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getZooKeeper
argument_list|()
operator|.
name|exists
argument_list|(
name|zkw
operator|.
name|baseZNode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ZooKeeperConnectionException
argument_list|(
literal|"Can't connect to ZooKeeper"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ZooKeeperConnectionException
argument_list|(
literal|"Can't connect to ZooKeeper"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ZooKeeperConnectionException
argument_list|(
literal|"Can't connect to ZooKeeper"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|zkw
operator|!=
literal|null
condition|)
block|{
name|zkw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Check Master
name|connection
operator|.
name|isMasterRunning
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * get the regions of a given table.    *    * @param tableName the name of the table    * @return Ordered list of {@link HRegionInfo}.    * @throws IOException    */
specifier|public
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|getTableRegions
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|CatalogTracker
name|ct
init|=
name|getCatalogTracker
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|Regions
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Regions
operator|=
name|MetaReader
operator|.
name|getTableRegions
argument_list|(
name|ct
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cleanupCatalogTracker
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
return|return
name|Regions
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|connection
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**  * Get tableDescriptors  * @param tableNames List of table names  * @return HTD[] the tableDescriptor  * @throws IOException if a remote or network exception occurs  */
specifier|public
name|HTableDescriptor
index|[]
name|getTableDescriptors
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|tableNames
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|connection
operator|.
name|getHTableDescriptors
argument_list|(
name|tableNames
argument_list|)
return|;
block|}
comment|/**    * Roll the log writer. That is, start writing log messages to a new file.    *    * @param serverName    *          The servername of the regionserver. A server name is made of host,    *          port and startcode. This is mandatory. Here is an example:    *<code> host187.example.com,60020,1289493121758</code>    * @return If lots of logs, flush the returned regions so next time through    * we can clean logs. Returns null if nothing to flush.  Names are actual    * region names as returned by {@link HRegionInfo#getEncodedName()}    * @throws IOException if a remote or network exception occurs    * @throws FailedLogCloseException    */
specifier|public
specifier|synchronized
name|byte
index|[]
index|[]
name|rollHLogWriter
parameter_list|(
name|String
name|serverName
parameter_list|)
throws|throws
name|IOException
throws|,
name|FailedLogCloseException
block|{
name|ServerName
name|sn
init|=
operator|new
name|ServerName
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
name|AdminProtocol
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|RollWALWriterRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildRollWALWriterRequest
argument_list|()
decl_stmt|;
empty_stmt|;
try|try
block|{
name|RollWALWriterResponse
name|response
init|=
name|admin
operator|.
name|rollWALWriter
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
name|int
name|regionCount
init|=
name|response
operator|.
name|getRegionToFlushCount
argument_list|()
decl_stmt|;
name|byte
index|[]
index|[]
name|regionsToFlush
init|=
operator|new
name|byte
index|[
name|regionCount
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionCount
condition|;
name|i
operator|++
control|)
block|{
name|ByteString
name|region
init|=
name|response
operator|.
name|getRegionToFlush
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|regionsToFlush
index|[
name|i
index|]
operator|=
name|region
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
return|return
name|regionsToFlush
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
specifier|public
name|String
index|[]
name|getMasterCoprocessors
parameter_list|()
block|{
try|try
block|{
return|return
name|getClusterStatus
argument_list|()
operator|.
name|getMasterCoprocessors
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not getClusterStatus()"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get the current compaction state of a table or region.    * It could be in a major compaction, a minor compaction, both, or none.    *    * @param tableNameOrRegionName table or region to major compact    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    * @return the current compaction state    */
specifier|public
name|CompactionState
name|getCompactionState
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|getCompactionState
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the current compaction state of a table or region.    * It could be in a major compaction, a minor compaction, both, or none.    *    * @param tableNameOrRegionName table or region to major compact    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    * @return the current compaction state    */
specifier|public
name|CompactionState
name|getCompactionState
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|CompactionState
name|state
init|=
name|CompactionState
operator|.
name|NONE
decl_stmt|;
name|CatalogTracker
name|ct
init|=
name|getCatalogTracker
argument_list|()
decl_stmt|;
try|try
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regionServerPair
init|=
name|getRegion
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|ct
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionServerPair
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|ServerName
name|sn
init|=
name|regionServerPair
operator|.
name|getSecond
argument_list|()
decl_stmt|;
name|AdminProtocol
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|GetRegionInfoRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildGetRegionInfoRequest
argument_list|(
name|regionServerPair
operator|.
name|getFirst
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|GetRegionInfoResponse
name|response
init|=
name|admin
operator|.
name|getRegionInfo
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
return|return
name|response
operator|.
name|getCompactionState
argument_list|()
return|;
block|}
block|}
else|else
block|{
specifier|final
name|String
name|tableName
init|=
name|tableNameString
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|ct
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|pairs
init|=
name|MetaReader
operator|.
name|getTableRegionsAndLocations
argument_list|(
name|ct
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|isOffline
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
try|try
block|{
name|ServerName
name|sn
init|=
name|pair
operator|.
name|getSecond
argument_list|()
decl_stmt|;
name|AdminProtocol
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|GetRegionInfoRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildGetRegionInfoRequest
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|GetRegionInfoResponse
name|response
init|=
name|admin
operator|.
name|getRegionInfo
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|response
operator|.
name|getCompactionState
argument_list|()
condition|)
block|{
case|case
name|MAJOR_AND_MINOR
case|:
return|return
name|CompactionState
operator|.
name|MAJOR_AND_MINOR
return|;
case|case
name|MAJOR
case|:
if|if
condition|(
name|state
operator|==
name|CompactionState
operator|.
name|MINOR
condition|)
block|{
return|return
name|CompactionState
operator|.
name|MAJOR_AND_MINOR
return|;
block|}
name|state
operator|=
name|CompactionState
operator|.
name|MAJOR
expr_stmt|;
break|break;
case|case
name|MINOR
case|:
if|if
condition|(
name|state
operator|==
name|CompactionState
operator|.
name|MAJOR
condition|)
block|{
return|return
name|CompactionState
operator|.
name|MAJOR_AND_MINOR
return|;
block|}
name|state
operator|=
name|CompactionState
operator|.
name|MINOR
expr_stmt|;
break|break;
case|case
name|NONE
case|:
default|default:
comment|// nothing, continue
block|}
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to get compaction state of "
operator|+
name|pair
operator|.
name|getFirst
argument_list|()
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
finally|finally
block|{
name|cleanupCatalogTracker
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
return|return
name|state
return|;
block|}
comment|/**    * Create a timestamp consistent snapshot for the given table.    *<p>    * Snapshots are considered unique based on<b>the name of the snapshot</b>. Attempts to take a    * snapshot with the same name (even a different type or with different parameters) will fail with    * a {@link SnapshotCreationException} indicating the duplicate naming.    *<p>    * Snapshot names follow the same naming constraints as tables in HBase. See    * {@link HTableDescriptor#isLegalTableName(byte[])}.    * @param snapshotName name of the snapshot to be created    * @param tableName name of the table for which snapshot is created    * @throws IOException if a remote or network exception occurs    * @throws SnapshotCreationException if snapshot creation failed    * @throws IllegalArgumentException if the snapshot request is formatted incorrectly    */
specifier|public
name|void
name|snapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
name|snapshot
argument_list|(
name|snapshotName
argument_list|,
name|tableName
argument_list|,
name|SnapshotDescription
operator|.
name|Type
operator|.
name|FLUSH
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a timestamp consistent snapshot for the given table.    *<p>    * Snapshots are considered unique based on<b>the name of the snapshot</b>. Attempts to take a    * snapshot with the same name (even a different type or with different parameters) will fail with    * a {@link SnapshotCreationException} indicating the duplicate naming.    *<p>    * Snapshot names follow the same naming constraints as tables in HBase. See    * {@link HTableDescriptor#isLegalTableName(byte[])}.    * @param snapshotName name of the snapshot to be created    * @param tableName name of the table for which snapshot is created    * @throws IOException if a remote or network exception occurs    * @throws SnapshotCreationException if snapshot creation failed    * @throws IllegalArgumentException if the snapshot request is formatted incorrectly    */
specifier|public
name|void
name|snapshot
parameter_list|(
specifier|final
name|byte
index|[]
name|snapshotName
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
name|snapshot
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|snapshotName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create typed snapshot of the table.    *<p>    * Snapshots are considered unique based on<b>the name of the snapshot</b>. Attempts to take a    * snapshot with the same name (even a different type or with different parameters) will fail with    * a {@link SnapshotCreationException} indicating the duplicate naming.    *<p>    * Snapshot names follow the same naming constraints as tables in HBase. See    * {@link HTableDescriptor#isLegalTableName(byte[])}.    *<p>    * @param snapshotName name to give the snapshot on the filesystem. Must be unique from all other    *          snapshots stored on the cluster    * @param tableName name of the table to snapshot    * @param type type of snapshot to take    * @throws IOException we fail to reach the master    * @throws SnapshotCreationException if snapshot creation failed    * @throws IllegalArgumentException if the snapshot request is formatted incorrectly    */
specifier|public
name|void
name|snapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|,
name|SnapshotDescription
operator|.
name|Type
name|type
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
name|SnapshotDescription
operator|.
name|Builder
name|builder
init|=
name|SnapshotDescription
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setName
argument_list|(
name|snapshotName
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|snapshot
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Take a snapshot and wait for the server to complete that snapshot (blocking).    *<p>    * Only a single snapshot should be taken at a time for an instance of HBase, or results may be    * undefined (you can tell multiple HBase clusters to snapshot at the same time, but only one at a    * time for a single cluster).    *<p>    * Snapshots are considered unique based on<b>the name of the snapshot</b>. Attempts to take a    * snapshot with the same name (even a different type or with different parameters) will fail with    * a {@link SnapshotCreationException} indicating the duplicate naming.    *<p>    * Snapshot names follow the same naming constraints as tables in HBase. See    * {@link HTableDescriptor#isLegalTableName(byte[])}.    *<p>    * You should probably use {@link #snapshot(String, String)} or {@link #snapshot(byte[], byte[])}    * unless you are sure about the type of snapshot that you want to take.    * @param snapshot snapshot to take    * @throws IOException or we lose contact with the master.    * @throws SnapshotCreationException if snapshot failed to be taken    * @throws IllegalArgumentException if the snapshot request is formatted incorrectly    */
specifier|public
name|void
name|snapshot
parameter_list|(
name|SnapshotDescription
name|snapshot
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
comment|// make sure the snapshot is valid
name|SnapshotDescriptionUtils
operator|.
name|assertSnapshotRequestIsValid
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
comment|// actually take the snapshot
name|TakeSnapshotResponse
name|response
init|=
name|takeSnapshotAsync
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
specifier|final
name|IsSnapshotDoneRequest
name|request
init|=
name|IsSnapshotDoneRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|snapshot
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|IsSnapshotDoneResponse
name|done
init|=
literal|null
decl_stmt|;
name|long
name|start
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|max
init|=
name|response
operator|.
name|getExpectedTimeout
argument_list|()
decl_stmt|;
name|long
name|maxPauseTime
init|=
name|max
operator|/
name|this
operator|.
name|numRetries
decl_stmt|;
name|int
name|tries
init|=
literal|0
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting a max of "
operator|+
name|max
operator|+
literal|" ms for snapshot '"
operator|+
name|SnapshotDescriptionUtils
operator|.
name|toString
argument_list|(
name|snapshot
argument_list|)
operator|+
literal|"'' to complete. (max "
operator|+
name|maxPauseTime
operator|+
literal|" ms per retry)"
argument_list|)
expr_stmt|;
while|while
condition|(
name|tries
operator|==
literal|0
operator|||
operator|(
operator|(
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
operator|<
name|max
operator|&&
operator|!
name|done
operator|.
name|getDone
argument_list|()
operator|)
condition|)
block|{
try|try
block|{
comment|// sleep a backoff<= pauseTime amount
name|long
name|sleep
init|=
name|getPauseTime
argument_list|(
name|tries
operator|++
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found sleep:"
operator|+
name|sleep
argument_list|)
expr_stmt|;
name|sleep
operator|=
name|sleep
operator|>
name|maxPauseTime
condition|?
name|maxPauseTime
else|:
name|sleep
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|tries
operator|+
literal|") Sleeping: "
operator|+
name|sleep
operator|+
literal|" ms while we wait for snapshot to complete."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Interrupted while waiting for snapshot "
operator|+
name|snapshot
operator|+
literal|" to complete"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Getting current status of snapshot from master..."
argument_list|)
expr_stmt|;
name|done
operator|=
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|IsSnapshotDoneResponse
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|IsSnapshotDoneResponse
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
return|return
name|masterAdmin
operator|.
name|isSnapshotDone
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|done
operator|.
name|getDone
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SnapshotCreationException
argument_list|(
literal|"Snapshot '"
operator|+
name|snapshot
operator|.
name|getName
argument_list|()
operator|+
literal|"' wasn't completed in expectedTime:"
operator|+
name|max
operator|+
literal|" ms"
argument_list|,
name|snapshot
argument_list|)
throw|;
block|}
block|}
comment|/**    * Take a snapshot and wait for the server to complete that snapshot (asynchronous)    *<p>    * Only a single snapshot should be taken at a time, or results may be undefined.    * @param snapshot snapshot to take    * @return response from the server indicating the max time to wait for the snapshot    * @throws IOException if the snapshot did not succeed or we lose contact with the master.    * @throws SnapshotCreationException if snapshot creation failed    * @throws IllegalArgumentException if the snapshot request is formatted incorrectly    */
specifier|public
name|TakeSnapshotResponse
name|takeSnapshotAsync
parameter_list|(
name|SnapshotDescription
name|snapshot
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
block|{
name|SnapshotDescriptionUtils
operator|.
name|assertSnapshotRequestIsValid
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
specifier|final
name|TakeSnapshotRequest
name|request
init|=
name|TakeSnapshotRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|snapshot
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// run the snapshot on the master
return|return
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|TakeSnapshotResponse
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TakeSnapshotResponse
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
return|return
name|masterAdmin
operator|.
name|snapshot
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Check the current state of the passed snapshot.    *<p>    * There are three possible states:    *<ol>    *<li>running - returns<tt>false</tt></li>    *<li>finished - returns<tt>true</tt></li>    *<li>finished with error - throws the exception that caused the snapshot to fail</li>    *</ol>    *<p>    * The cluster only knows about the most recent snapshot. Therefore, if another snapshot has been    * run/started since the snapshot your are checking, you will recieve an    * {@link UnknownSnapshotException}.    * @param snapshot description of the snapshot to check    * @return<tt>true</tt> if the snapshot is completed,<tt>false</tt> if the snapshot is still    *         running    * @throws IOException if we have a network issue    * @throws HBaseSnapshotException if the snapshot failed    * @throws UnknownSnapshotException if the requested snapshot is unknown    */
specifier|public
name|boolean
name|isSnapshotFinished
parameter_list|(
specifier|final
name|SnapshotDescription
name|snapshot
parameter_list|)
throws|throws
name|IOException
throws|,
name|HBaseSnapshotException
throws|,
name|UnknownSnapshotException
block|{
return|return
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|IsSnapshotDoneResponse
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|IsSnapshotDoneResponse
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
return|return
name|masterAdmin
operator|.
name|isSnapshotDone
argument_list|(
literal|null
argument_list|,
name|IsSnapshotDoneRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|snapshot
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
operator|.
name|getDone
argument_list|()
return|;
block|}
comment|/**    * Restore the specified snapshot on the original table. (The table must be disabled)    * Before restoring the table, a new snapshot with the current table state is created.    * In case of failure, the table will be rolled back to the its original state.    *    * @param snapshotName name of the snapshot to restore    * @throws IOException if a remote or network exception occurs    * @throws RestoreSnapshotException if snapshot failed to be restored    * @throws IllegalArgumentException if the restore request is formatted incorrectly    */
specifier|public
name|void
name|restoreSnapshot
parameter_list|(
specifier|final
name|byte
index|[]
name|snapshotName
parameter_list|)
throws|throws
name|IOException
throws|,
name|RestoreSnapshotException
block|{
name|restoreSnapshot
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|snapshotName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Restore the specified snapshot on the original table. (The table must be disabled)    * Before restoring the table, a new snapshot with the current table state is created.    * In case of failure, the table will be rolled back to the its original state.    *    * @param snapshotName name of the snapshot to restore    * @throws IOException if a remote or network exception occurs    * @throws RestoreSnapshotException if snapshot failed to be restored    * @throws IllegalArgumentException if the restore request is formatted incorrectly    */
specifier|public
name|void
name|restoreSnapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|)
throws|throws
name|IOException
throws|,
name|RestoreSnapshotException
block|{
name|String
name|rollbackSnapshot
init|=
name|snapshotName
operator|+
literal|"-"
operator|+
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|String
name|tableName
init|=
literal|null
decl_stmt|;
for|for
control|(
name|SnapshotDescription
name|snapshotInfo
range|:
name|listSnapshots
argument_list|()
control|)
block|{
if|if
condition|(
name|snapshotInfo
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|snapshotName
argument_list|)
condition|)
block|{
name|tableName
operator|=
name|snapshotInfo
operator|.
name|getTable
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tableName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RestoreSnapshotException
argument_list|(
literal|"Unable to find the table name for snapshot="
operator|+
name|snapshotName
argument_list|)
throw|;
block|}
comment|// Take a snapshot of the current state
name|snapshot
argument_list|(
name|rollbackSnapshot
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
comment|// Restore snapshot
try|try
block|{
name|internalRestoreSnapshot
argument_list|(
name|snapshotName
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Try to rollback
try|try
block|{
name|String
name|msg
init|=
literal|"Restore snapshot="
operator|+
name|snapshotName
operator|+
literal|" failed. Rollback to snapshot="
operator|+
name|rollbackSnapshot
operator|+
literal|" succeded."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|internalRestoreSnapshot
argument_list|(
name|rollbackSnapshot
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RestoreSnapshotException
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Failed to restore and rollback to snapshot="
operator|+
name|rollbackSnapshot
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RestoreSnapshotException
argument_list|(
name|msg
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Create a new table by cloning the snapshot content.    *    * @param snapshotName name of the snapshot to be cloned    * @param tableName name of the table where the snapshot will be restored    * @throws IOException if a remote or network exception occurs    * @throws TableExistsException if table to be created already exists    * @throws RestoreSnapshotException if snapshot failed to be cloned    * @throws IllegalArgumentException if the specified table has not a valid name    */
specifier|public
name|void
name|cloneSnapshot
parameter_list|(
specifier|final
name|byte
index|[]
name|snapshotName
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|TableExistsException
throws|,
name|RestoreSnapshotException
throws|,
name|InterruptedException
block|{
name|cloneSnapshot
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|snapshotName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a new table by cloning the snapshot content.    *    * @param snapshotName name of the snapshot to be cloned    * @param tableName name of the table where the snapshot will be restored    * @throws IOException if a remote or network exception occurs    * @throws TableExistsException if table to be created already exists    * @throws RestoreSnapshotException if snapshot failed to be cloned    * @throws IllegalArgumentException if the specified table has not a valid name    */
specifier|public
name|void
name|cloneSnapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|TableExistsException
throws|,
name|RestoreSnapshotException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|tableExists
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableExistsException
argument_list|(
literal|"Table '"
operator|+
name|tableName
operator|+
literal|" already exists"
argument_list|)
throw|;
block|}
name|internalRestoreSnapshot
argument_list|(
name|snapshotName
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|waitUntilTableIsEnabled
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute Restore/Clone snapshot and wait for the server to complete (blocking).    * To check if the cloned table exists, use {@link #isTableAvailable} -- it is not safe to    * create an HTable instance to this table before it is available.    * @param snapshot snapshot to restore    * @param tableName table name to restore the snapshot on    * @throws IOException if a remote or network exception occurs    * @throws RestoreSnapshotException if snapshot failed to be restored    * @throws IllegalArgumentException if the restore request is formatted incorrectly    */
specifier|private
name|void
name|internalRestoreSnapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|RestoreSnapshotException
block|{
name|SnapshotDescription
name|snapshot
init|=
name|SnapshotDescription
operator|.
name|newBuilder
argument_list|()
operator|.
name|setName
argument_list|(
name|snapshotName
argument_list|)
operator|.
name|setTable
argument_list|(
name|tableName
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// actually restore the snapshot
name|internalRestoreSnapshotAsync
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
specifier|final
name|IsRestoreSnapshotDoneRequest
name|request
init|=
name|IsRestoreSnapshotDoneRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|snapshot
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|IsRestoreSnapshotDoneResponse
name|done
init|=
name|IsRestoreSnapshotDoneResponse
operator|.
name|newBuilder
argument_list|()
operator|.
name|buildPartial
argument_list|()
decl_stmt|;
specifier|final
name|long
name|maxPauseTime
init|=
literal|5000
decl_stmt|;
name|int
name|tries
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
operator|.
name|getDone
argument_list|()
condition|)
block|{
try|try
block|{
comment|// sleep a backoff<= pauseTime amount
name|long
name|sleep
init|=
name|getPauseTime
argument_list|(
name|tries
operator|++
argument_list|)
decl_stmt|;
name|sleep
operator|=
name|sleep
operator|>
name|maxPauseTime
condition|?
name|maxPauseTime
else|:
name|sleep
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|tries
operator|+
literal|") Sleeping: "
operator|+
name|sleep
operator|+
literal|" ms while we wait for snapshot restore to complete."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Interrupted while waiting for snapshot "
operator|+
name|snapshot
operator|+
literal|" restore to complete"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Getting current status of snapshot restore from master..."
argument_list|)
expr_stmt|;
name|done
operator|=
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|IsRestoreSnapshotDoneResponse
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|IsRestoreSnapshotDoneResponse
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
return|return
name|masterAdmin
operator|.
name|isRestoreSnapshotDone
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
operator|.
name|getDone
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RestoreSnapshotException
argument_list|(
literal|"Snapshot '"
operator|+
name|snapshot
operator|.
name|getName
argument_list|()
operator|+
literal|"' wasn't restored."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Execute Restore/Clone snapshot and wait for the server to complete (asynchronous)    *<p>    * Only a single snapshot should be restored at a time, or results may be undefined.    * @param snapshot snapshot to restore    * @return response from the server indicating the max time to wait for the snapshot    * @throws IOException if a remote or network exception occurs    * @throws RestoreSnapshotException if snapshot failed to be restored    * @throws IllegalArgumentException if the restore request is formatted incorrectly    */
specifier|private
name|RestoreSnapshotResponse
name|internalRestoreSnapshotAsync
parameter_list|(
specifier|final
name|SnapshotDescription
name|snapshot
parameter_list|)
throws|throws
name|IOException
throws|,
name|RestoreSnapshotException
block|{
name|SnapshotDescriptionUtils
operator|.
name|assertSnapshotRequestIsValid
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
specifier|final
name|RestoreSnapshotRequest
name|request
init|=
name|RestoreSnapshotRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|snapshot
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// run the snapshot restore on the master
return|return
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|RestoreSnapshotResponse
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RestoreSnapshotResponse
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
return|return
name|masterAdmin
operator|.
name|restoreSnapshot
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * List existing snapshots.    * @return a list of snapshot descriptor for existing snapshots    * @throws IOException if a network error occurs    */
specifier|public
name|List
argument_list|<
name|SnapshotDescription
argument_list|>
name|listSnapshots
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|List
argument_list|<
name|SnapshotDescription
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|SnapshotDescription
argument_list|>
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
return|return
name|masterAdmin
operator|.
name|listSnapshots
argument_list|(
literal|null
argument_list|,
name|ListSnapshotRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|getSnapshotsList
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Delete an existing snapshot.    * @param snapshotName name of the snapshot    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|deleteSnapshot
parameter_list|(
specifier|final
name|byte
index|[]
name|snapshotName
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteSnapshot
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|snapshotName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete an existing snapshot.    * @param snapshotName name of the snapshot    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|deleteSnapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// make sure the snapshot is possibly valid
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|snapshotName
argument_list|)
argument_list|)
expr_stmt|;
comment|// do the delete
name|execute
argument_list|(
operator|new
name|MasterAdminCallable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|ServiceException
block|{
name|masterAdmin
operator|.
name|deleteSnapshot
argument_list|(
literal|null
argument_list|,
name|DeleteSnapshotRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|SnapshotDescription
operator|.
name|newBuilder
argument_list|()
operator|.
name|setName
argument_list|(
name|snapshotName
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * @see {@link #execute(MasterAdminCallable<V>)}    */
specifier|private
specifier|abstract
specifier|static
class|class
name|MasterAdminCallable
parameter_list|<
name|V
parameter_list|>
implements|implements
name|Callable
argument_list|<
name|V
argument_list|>
block|{
specifier|protected
name|MasterAdminKeepAliveConnection
name|masterAdmin
decl_stmt|;
block|}
comment|/**    * @see {@link #execute(MasterMonitorCallable<V>)}    */
specifier|private
specifier|abstract
specifier|static
class|class
name|MasterMonitorCallable
parameter_list|<
name|V
parameter_list|>
implements|implements
name|Callable
argument_list|<
name|V
argument_list|>
block|{
specifier|protected
name|MasterMonitorKeepAliveConnection
name|masterMonitor
decl_stmt|;
block|}
comment|/**    * This method allows to execute a function requiring a connection to    * master without having to manage the connection creation/close.    * Create a {@link MasterAdminCallable} to use it.    */
specifier|private
parameter_list|<
name|V
parameter_list|>
name|V
name|execute
parameter_list|(
name|MasterAdminCallable
argument_list|<
name|V
argument_list|>
name|function
parameter_list|)
throws|throws
name|IOException
block|{
name|function
operator|.
name|masterAdmin
operator|=
name|connection
operator|.
name|getKeepAliveMasterAdmin
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|executeCallable
argument_list|(
name|function
argument_list|)
return|;
block|}
finally|finally
block|{
name|function
operator|.
name|masterAdmin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This method allows to execute a function requiring a connection to    * master without having to manage the connection creation/close.    * Create a {@link MasterAdminCallable} to use it.    */
specifier|private
parameter_list|<
name|V
parameter_list|>
name|V
name|execute
parameter_list|(
name|MasterMonitorCallable
argument_list|<
name|V
argument_list|>
name|function
parameter_list|)
throws|throws
name|IOException
block|{
name|function
operator|.
name|masterMonitor
operator|=
name|connection
operator|.
name|getKeepAliveMasterMonitor
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|executeCallable
argument_list|(
name|function
argument_list|)
return|;
block|}
finally|finally
block|{
name|function
operator|.
name|masterMonitor
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Helper function called by other execute functions.    */
specifier|private
parameter_list|<
name|V
parameter_list|>
name|V
name|executeCallable
parameter_list|(
name|Callable
argument_list|<
name|V
argument_list|>
name|function
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|function
operator|.
name|call
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// This should not happen...
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected exception when calling master"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Creates and returns a {@link com.google.protobuf.RpcChannel} instance    * connected to the active master.    *    *<p>    * The obtained {@link com.google.protobuf.RpcChannel} instance can be used to access a published    * coprocessor {@link com.google.protobuf.Service} using standard protobuf service invocations:    *</p>    *    *<div style="background-color: #cccccc; padding: 2px">    *<blockquote><pre>    * CoprocessorRpcChannel channel = myAdmin.coprocessorService();    * MyService.BlockingInterface service = MyService.newBlockingStub(channel);    * MyCallRequest request = MyCallRequest.newBuilder()    *     ...    *     .build();    * MyCallResponse response = service.myCall(null, request);    *</pre></blockquote></div>    *    * @return A MasterCoprocessorRpcChannel instance    */
specifier|public
name|CoprocessorRpcChannel
name|coprocessorService
parameter_list|()
block|{
return|return
operator|new
name|MasterCoprocessorRpcChannel
argument_list|(
name|connection
argument_list|)
return|;
block|}
block|}
end_class

end_unit

