begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodeAssignmentHelper
operator|.
name|FAVORED_NODES_NUM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesPlan
operator|.
name|Position
operator|.
name|PRIMARY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesPlan
operator|.
name|Position
operator|.
name|SECONDARY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesPlan
operator|.
name|Position
operator|.
name|TERTIARY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
operator|.
name|NON_STARTCODE
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodeAssignmentHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesPlan
operator|.
name|Position
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesPromoter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterServices
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_comment
comment|/**  * An implementation of the {@link org.apache.hadoop.hbase.master.LoadBalancer} that  * assigns favored nodes for each region. There is a Primary RegionServer that hosts  * the region, and then there is Secondary and Tertiary RegionServers. Currently, the  * favored nodes information is used in creating HDFS files - the Primary RegionServer  * passes the primary, secondary, tertiary node addresses as hints to the  * DistributedFileSystem API for creating files on the filesystem. These nodes are  * treated as hints by the HDFS to place the blocks of the file. This alleviates the  * problem to do with reading from remote nodes (since we can make the Secondary  * RegionServer as the new Primary RegionServer) after a region is recovered. This  * should help provide consistent read latencies for the regions even when their  * primary region servers die. This provides two  * {@link org.apache.hadoop.hbase.master.balancer.StochasticLoadBalancer.CandidateGenerator}  *  */
end_comment

begin_class
specifier|public
class|class
name|FavoredStochasticBalancer
extends|extends
name|StochasticLoadBalancer
implements|implements
name|FavoredNodesPromoter
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FavoredStochasticBalancer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|FavoredNodesManager
name|fnm
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|initialize
parameter_list|()
throws|throws
name|HBaseIOException
block|{
name|configureGenerators
argument_list|()
expr_stmt|;
name|super
operator|.
name|initialize
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|void
name|configureGenerators
parameter_list|()
block|{
name|List
argument_list|<
name|CandidateGenerator
argument_list|>
name|fnPickers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|fnPickers
operator|.
name|add
argument_list|(
operator|new
name|FavoredNodeLoadPicker
argument_list|()
argument_list|)
expr_stmt|;
name|fnPickers
operator|.
name|add
argument_list|(
operator|new
name|FavoredNodeLocalityPicker
argument_list|()
argument_list|)
expr_stmt|;
name|setCandidateGenerators
argument_list|(
name|fnPickers
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setMasterServices
parameter_list|(
name|MasterServices
name|masterServices
parameter_list|)
block|{
name|super
operator|.
name|setMasterServices
argument_list|(
name|masterServices
argument_list|)
expr_stmt|;
name|fnm
operator|=
name|masterServices
operator|.
name|getFavoredNodesManager
argument_list|()
expr_stmt|;
block|}
comment|/*    * Round robin assignment: Segregate the regions into two types:    *    * 1. The regions that have favored node assignment where at least one of the favored node    * is still alive. In this case, try to adhere to the current favored nodes assignment as    * much as possible - i.e., if the current primary is gone, then make the secondary or    * tertiary as the new host for the region (based on their current load). Note that we don't    * change the favored node assignments here (even though one or more favored node is    * currently down). That will be done by the admin operations.    *    * 2. The regions that currently don't have favored node assignments. Generate favored nodes    * for them and then assign. Generate the primary fn in round robin fashion and generate    * secondary and tertiary as per favored nodes constraints.    */
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|roundRobinAssignment
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|)
throws|throws
name|HBaseIOException
block|{
name|metricsBalancer
operator|.
name|incrMiscInvocations
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|regionSet
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|regions
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|assignmentMap
init|=
name|assignMasterRegions
argument_list|(
name|regions
argument_list|,
name|servers
argument_list|)
decl_stmt|;
if|if
condition|(
name|assignmentMap
operator|!=
literal|null
operator|&&
operator|!
name|assignmentMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|servers
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|servers
argument_list|)
expr_stmt|;
comment|// Guarantee not to put other regions on master
name|servers
operator|.
name|remove
argument_list|(
name|masterServerName
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|masterRegions
init|=
name|assignmentMap
operator|.
name|get
argument_list|(
name|masterServerName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|masterRegions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|HRegionInfo
name|region
range|:
name|masterRegions
control|)
block|{
name|regionSet
operator|.
name|remove
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|regionSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|assignmentMap
return|;
block|}
try|try
block|{
name|FavoredNodeAssignmentHelper
name|helper
init|=
operator|new
name|FavoredNodeAssignmentHelper
argument_list|(
name|servers
argument_list|,
name|fnm
operator|.
name|getRackManager
argument_list|()
argument_list|)
decl_stmt|;
name|helper
operator|.
name|initialize
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|systemRegions
init|=
name|FavoredNodesManager
operator|.
name|filterNonFNApplicableRegions
argument_list|(
name|regionSet
argument_list|)
decl_stmt|;
name|regionSet
operator|.
name|removeAll
argument_list|(
name|systemRegions
argument_list|)
expr_stmt|;
comment|// Assign all system regions
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|systemAssignments
init|=
name|super
operator|.
name|roundRobinAssignment
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|systemRegions
argument_list|)
argument_list|,
name|servers
argument_list|)
decl_stmt|;
comment|// Segregate favored and non-favored nodes regions and assign accordingly.
name|Pair
argument_list|<
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|segregatedRegions
init|=
name|segregateRegionsAndAssignRegionsWithFavoredNodes
argument_list|(
name|regionSet
argument_list|,
name|servers
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|regionsWithFavoredNodesMap
init|=
name|segregatedRegions
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|regionsWithoutFN
init|=
name|generateFNForRegionsWithoutFN
argument_list|(
name|helper
argument_list|,
name|segregatedRegions
operator|.
name|getSecond
argument_list|()
argument_list|)
decl_stmt|;
comment|// merge the assignment maps
name|mergeAssignmentMaps
argument_list|(
name|assignmentMap
argument_list|,
name|systemAssignments
argument_list|)
expr_stmt|;
name|mergeAssignmentMaps
argument_list|(
name|assignmentMap
argument_list|,
name|regionsWithFavoredNodesMap
argument_list|)
expr_stmt|;
name|mergeAssignmentMaps
argument_list|(
name|assignmentMap
argument_list|,
name|regionsWithoutFN
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
literal|"Encountered exception while doing favored-nodes assignment "
operator|+
name|ex
operator|+
literal|" Falling back to regular assignment"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
return|return
name|assignmentMap
return|;
block|}
specifier|private
name|void
name|mergeAssignmentMaps
parameter_list|(
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|assignmentMap
parameter_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|otherAssignments
parameter_list|)
block|{
if|if
condition|(
name|otherAssignments
operator|==
literal|null
operator|||
name|otherAssignments
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|entry
range|:
name|otherAssignments
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ServerName
name|sn
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regionsList
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|assignmentMap
operator|.
name|get
argument_list|(
name|sn
argument_list|)
operator|==
literal|null
condition|)
block|{
name|assignmentMap
operator|.
name|put
argument_list|(
name|sn
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|regionsList
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assignmentMap
operator|.
name|get
argument_list|(
name|sn
argument_list|)
operator|.
name|addAll
argument_list|(
name|regionsList
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|generateFNForRegionsWithoutFN
parameter_list|(
name|FavoredNodeAssignmentHelper
name|helper
parameter_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|assignmentMap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
name|regionsNoFNMap
decl_stmt|;
if|if
condition|(
name|regions
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|regionsNoFNMap
operator|=
name|helper
operator|.
name|generateFavoredNodesRoundRobin
argument_list|(
name|assignmentMap
argument_list|,
name|regions
argument_list|)
expr_stmt|;
name|fnm
operator|.
name|updateFavoredNodes
argument_list|(
name|regionsNoFNMap
argument_list|)
expr_stmt|;
block|}
return|return
name|assignmentMap
return|;
block|}
comment|/*    * Return a pair - one with assignments when favored nodes are present and another with regions    * without favored nodes.    */
specifier|private
name|Pair
argument_list|<
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|segregateRegionsAndAssignRegionsWithFavoredNodes
parameter_list|(
name|Collection
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
name|onlineServers
parameter_list|)
throws|throws
name|HBaseIOException
block|{
comment|// Since we expect FN to be present most of the time, lets create map with same size
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|assignmentMapForFavoredNodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|onlineServers
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regionsWithNoFavoredNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
init|=
name|fnm
operator|.
name|getFavoredNodes
argument_list|(
name|region
argument_list|)
decl_stmt|;
name|ServerName
name|primaryHost
init|=
literal|null
decl_stmt|;
name|ServerName
name|secondaryHost
init|=
literal|null
decl_stmt|;
name|ServerName
name|tertiaryHost
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|favoredNodes
operator|!=
literal|null
operator|&&
operator|!
name|favoredNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ServerName
name|s
range|:
name|favoredNodes
control|)
block|{
name|ServerName
name|serverWithLegitStartCode
init|=
name|getServerFromFavoredNode
argument_list|(
name|onlineServers
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverWithLegitStartCode
operator|!=
literal|null
condition|)
block|{
name|FavoredNodesPlan
operator|.
name|Position
name|position
init|=
name|FavoredNodesPlan
operator|.
name|getFavoredServerPosition
argument_list|(
name|favoredNodes
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|Position
operator|.
name|PRIMARY
operator|.
name|equals
argument_list|(
name|position
argument_list|)
condition|)
block|{
name|primaryHost
operator|=
name|serverWithLegitStartCode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Position
operator|.
name|SECONDARY
operator|.
name|equals
argument_list|(
name|position
argument_list|)
condition|)
block|{
name|secondaryHost
operator|=
name|serverWithLegitStartCode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Position
operator|.
name|TERTIARY
operator|.
name|equals
argument_list|(
name|position
argument_list|)
condition|)
block|{
name|tertiaryHost
operator|=
name|serverWithLegitStartCode
expr_stmt|;
block|}
block|}
block|}
name|assignRegionToAvailableFavoredNode
argument_list|(
name|assignmentMapForFavoredNodes
argument_list|,
name|region
argument_list|,
name|primaryHost
argument_list|,
name|secondaryHost
argument_list|,
name|tertiaryHost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regionsWithNoFavoredNodes
operator|.
name|add
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Pair
argument_list|<>
argument_list|(
name|assignmentMapForFavoredNodes
argument_list|,
name|regionsWithNoFavoredNodes
argument_list|)
return|;
block|}
specifier|private
name|void
name|addRegionToMap
parameter_list|(
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|assignmentMapForFavoredNodes
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|host
parameter_list|)
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regionsOnServer
decl_stmt|;
if|if
condition|(
operator|(
name|regionsOnServer
operator|=
name|assignmentMapForFavoredNodes
operator|.
name|get
argument_list|(
name|host
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|regionsOnServer
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|()
expr_stmt|;
name|assignmentMapForFavoredNodes
operator|.
name|put
argument_list|(
name|host
argument_list|,
name|regionsOnServer
argument_list|)
expr_stmt|;
block|}
name|regionsOnServer
operator|.
name|add
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
comment|/*    * Get the ServerName for the FavoredNode. Since FN's startcode is -1, we could want to get the    * ServerName with the correct start code from the list of provided servers.    */
specifier|private
name|ServerName
name|getServerFromFavoredNode
parameter_list|(
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|,
name|ServerName
name|fn
parameter_list|)
block|{
for|for
control|(
name|ServerName
name|server
range|:
name|servers
control|)
block|{
if|if
condition|(
name|ServerName
operator|.
name|isSameHostnameAndPort
argument_list|(
name|fn
argument_list|,
name|server
argument_list|)
condition|)
block|{
return|return
name|server
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/*    * Assign the region to primary if its available. If both secondary and tertiary are available,    * assign to the host which has less load. Else assign to secondary or tertiary whichever is    * available (in that order).    */
specifier|private
name|void
name|assignRegionToAvailableFavoredNode
parameter_list|(
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|assignmentMapForFavoredNodes
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|primaryHost
parameter_list|,
name|ServerName
name|secondaryHost
parameter_list|,
name|ServerName
name|tertiaryHost
parameter_list|)
block|{
if|if
condition|(
name|primaryHost
operator|!=
literal|null
condition|)
block|{
name|addRegionToMap
argument_list|(
name|assignmentMapForFavoredNodes
argument_list|,
name|region
argument_list|,
name|primaryHost
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|secondaryHost
operator|!=
literal|null
operator|&&
name|tertiaryHost
operator|!=
literal|null
condition|)
block|{
comment|// Assign the region to the one with a lower load (both have the desired hdfs blocks)
name|ServerName
name|s
decl_stmt|;
name|ServerLoad
name|tertiaryLoad
init|=
name|super
operator|.
name|services
operator|.
name|getServerManager
argument_list|()
operator|.
name|getLoad
argument_list|(
name|tertiaryHost
argument_list|)
decl_stmt|;
name|ServerLoad
name|secondaryLoad
init|=
name|super
operator|.
name|services
operator|.
name|getServerManager
argument_list|()
operator|.
name|getLoad
argument_list|(
name|secondaryHost
argument_list|)
decl_stmt|;
if|if
condition|(
name|secondaryLoad
operator|!=
literal|null
operator|&&
name|tertiaryLoad
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|secondaryLoad
operator|.
name|getLoad
argument_list|()
operator|<
name|tertiaryLoad
operator|.
name|getLoad
argument_list|()
condition|)
block|{
name|s
operator|=
name|secondaryHost
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|tertiaryHost
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We don't have one/more load, lets just choose a random node
name|s
operator|=
name|RANDOM
operator|.
name|nextBoolean
argument_list|()
condition|?
name|secondaryHost
else|:
name|tertiaryHost
expr_stmt|;
block|}
name|addRegionToMap
argument_list|(
name|assignmentMapForFavoredNodes
argument_list|,
name|region
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|secondaryHost
operator|!=
literal|null
condition|)
block|{
name|addRegionToMap
argument_list|(
name|assignmentMapForFavoredNodes
argument_list|,
name|region
argument_list|,
name|secondaryHost
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tertiaryHost
operator|!=
literal|null
condition|)
block|{
name|addRegionToMap
argument_list|(
name|assignmentMapForFavoredNodes
argument_list|,
name|region
argument_list|,
name|tertiaryHost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No favored nodes are online, lets assign to BOGUS server
name|addRegionToMap
argument_list|(
name|assignmentMapForFavoredNodes
argument_list|,
name|region
argument_list|,
name|BOGUS_SERVER_NAME
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * If we have favored nodes for a region, we will return one of the FN as destination. If    * favored nodes are not present for a region, we will generate and return one of the FN as    * destination. If we can't generate anything, lets fallback.    */
annotation|@
name|Override
specifier|public
name|ServerName
name|randomAssignment
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|)
throws|throws
name|HBaseIOException
block|{
if|if
condition|(
name|servers
operator|!=
literal|null
operator|&&
name|servers
operator|.
name|contains
argument_list|(
name|masterServerName
argument_list|)
condition|)
block|{
if|if
condition|(
name|shouldBeOnMaster
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
name|metricsBalancer
operator|.
name|incrMiscInvocations
argument_list|()
expr_stmt|;
return|return
name|masterServerName
return|;
block|}
name|servers
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|servers
argument_list|)
expr_stmt|;
comment|// Guarantee not to put other regions on master
name|servers
operator|.
name|remove
argument_list|(
name|masterServerName
argument_list|)
expr_stmt|;
block|}
name|ServerName
name|destination
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|FavoredNodesManager
operator|.
name|isFavoredNodeApplicable
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
return|return
name|super
operator|.
name|randomAssignment
argument_list|(
name|regionInfo
argument_list|,
name|servers
argument_list|)
return|;
block|}
name|metricsBalancer
operator|.
name|incrMiscInvocations
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
init|=
name|fnm
operator|.
name|getFavoredNodes
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|favoredNodes
operator|==
literal|null
operator|||
name|favoredNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Generate new favored nodes and return primary
name|FavoredNodeAssignmentHelper
name|helper
init|=
operator|new
name|FavoredNodeAssignmentHelper
argument_list|(
name|servers
argument_list|,
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|helper
operator|.
name|initialize
argument_list|()
expr_stmt|;
try|try
block|{
name|favoredNodes
operator|=
name|helper
operator|.
name|generateFavoredNodes
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|updateFavoredNodesForRegion
argument_list|(
name|regionInfo
argument_list|,
name|favoredNodes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception while doing favored-nodes (random)assignment "
operator|+
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HBaseIOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|List
argument_list|<
name|ServerName
argument_list|>
name|onlineServers
init|=
name|getOnlineFavoredNodes
argument_list|(
name|servers
argument_list|,
name|favoredNodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|onlineServers
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|destination
operator|=
name|onlineServers
operator|.
name|get
argument_list|(
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|onlineServers
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|boolean
name|alwaysAssign
init|=
name|getConf
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|FAVORED_ALWAYS_ASSIGN_REGIONS
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|destination
operator|==
literal|null
operator|&&
name|alwaysAssign
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can't generate FN for region: "
operator|+
name|regionInfo
operator|+
literal|" falling back"
argument_list|)
expr_stmt|;
name|destination
operator|=
name|super
operator|.
name|randomAssignment
argument_list|(
name|regionInfo
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
return|return
name|destination
return|;
block|}
specifier|private
name|void
name|updateFavoredNodesForRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
name|newFavoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
name|regionFNMap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|regionFNMap
operator|.
name|put
argument_list|(
name|regionInfo
argument_list|,
name|newFavoredNodes
argument_list|)
expr_stmt|;
name|fnm
operator|.
name|updateFavoredNodes
argument_list|(
name|regionFNMap
argument_list|)
expr_stmt|;
block|}
comment|/*    * Reuse BaseLoadBalancer's retainAssignment, but generate favored nodes when its missing.    */
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|retainAssignment
parameter_list|(
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regions
parameter_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|)
throws|throws
name|HBaseIOException
block|{
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|assignmentMap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|result
init|=
name|super
operator|.
name|retainAssignment
argument_list|(
name|regions
argument_list|,
name|servers
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
operator|||
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Nothing to assign to, probably no servers or no regions"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Guarantee not to put other regions on master
if|if
condition|(
name|servers
operator|!=
literal|null
operator|&&
name|servers
operator|.
name|contains
argument_list|(
name|masterServerName
argument_list|)
condition|)
block|{
name|servers
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|servers
argument_list|)
expr_stmt|;
name|servers
operator|.
name|remove
argument_list|(
name|masterServerName
argument_list|)
expr_stmt|;
block|}
comment|// Lets check if favored nodes info is in META, if not generate now.
name|FavoredNodeAssignmentHelper
name|helper
init|=
operator|new
name|FavoredNodeAssignmentHelper
argument_list|(
name|servers
argument_list|,
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|helper
operator|.
name|initialize
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Generating favored nodes for regions missing them."
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
name|regionFNMap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|entry
range|:
name|result
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ServerName
name|sn
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ServerName
name|primary
init|=
name|ServerName
operator|.
name|valueOf
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|,
name|NON_STARTCODE
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
name|FavoredNodesManager
operator|.
name|isFavoredNodeApplicable
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
init|=
name|fnm
operator|.
name|getFavoredNodes
argument_list|(
name|hri
argument_list|)
decl_stmt|;
if|if
condition|(
name|favoredNodes
operator|==
literal|null
operator|||
name|favoredNodes
operator|.
name|size
argument_list|()
operator|<
name|FAVORED_NODES_NUM
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Generating favored nodes for: "
operator|+
name|hri
operator|+
literal|" with primary: "
operator|+
name|primary
argument_list|)
expr_stmt|;
name|ServerName
index|[]
name|secondaryAndTertiaryNodes
init|=
name|helper
operator|.
name|getSecondaryAndTertiary
argument_list|(
name|hri
argument_list|,
name|primary
argument_list|)
decl_stmt|;
if|if
condition|(
name|secondaryAndTertiaryNodes
operator|!=
literal|null
operator|&&
name|secondaryAndTertiaryNodes
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|newFavoredNodes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|newFavoredNodes
operator|.
name|add
argument_list|(
name|primary
argument_list|)
expr_stmt|;
name|newFavoredNodes
operator|.
name|add
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|secondaryAndTertiaryNodes
index|[
literal|0
index|]
operator|.
name|getHostname
argument_list|()
argument_list|,
name|secondaryAndTertiaryNodes
index|[
literal|0
index|]
operator|.
name|getPort
argument_list|()
argument_list|,
name|NON_STARTCODE
argument_list|)
argument_list|)
expr_stmt|;
name|newFavoredNodes
operator|.
name|add
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|secondaryAndTertiaryNodes
index|[
literal|1
index|]
operator|.
name|getHostname
argument_list|()
argument_list|,
name|secondaryAndTertiaryNodes
index|[
literal|1
index|]
operator|.
name|getPort
argument_list|()
argument_list|,
name|NON_STARTCODE
argument_list|)
argument_list|)
expr_stmt|;
name|regionFNMap
operator|.
name|put
argument_list|(
name|hri
argument_list|,
name|newFavoredNodes
argument_list|)
expr_stmt|;
name|addRegionToMap
argument_list|(
name|assignmentMap
argument_list|,
name|hri
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
literal|"Cannot generate secondary/tertiary FN for "
operator|+
name|hri
operator|+
literal|" generated "
operator|+
operator|(
name|secondaryAndTertiaryNodes
operator|!=
literal|null
condition|?
name|secondaryAndTertiaryNodes
else|:
literal|" nothing"
operator|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|onlineFN
init|=
name|getOnlineFavoredNodes
argument_list|(
name|servers
argument_list|,
name|favoredNodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|onlineFN
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// All favored nodes are dead, lets assign it to BOGUS
name|addRegionToMap
argument_list|(
name|assignmentMap
argument_list|,
name|hri
argument_list|,
name|BOGUS_SERVER_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Is primary not on FN? Less likely, but we can still take care of this.
if|if
condition|(
name|FavoredNodesPlan
operator|.
name|getFavoredServerPosition
argument_list|(
name|favoredNodes
argument_list|,
name|sn
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|addRegionToMap
argument_list|(
name|assignmentMap
argument_list|,
name|hri
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ServerName
name|destination
init|=
name|onlineFN
operator|.
name|get
argument_list|(
name|RANDOM
operator|.
name|nextInt
argument_list|(
name|onlineFN
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region: "
operator|+
name|hri
operator|+
literal|" not hosted on favored nodes: "
operator|+
name|favoredNodes
operator|+
literal|" current: "
operator|+
name|sn
operator|+
literal|" moving to: "
operator|+
name|destination
argument_list|)
expr_stmt|;
name|addRegionToMap
argument_list|(
name|assignmentMap
argument_list|,
name|hri
argument_list|,
name|destination
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|addRegionToMap
argument_list|(
name|assignmentMap
argument_list|,
name|hri
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|regionFNMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating FN in meta for missing regions, count: "
operator|+
name|regionFNMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|fnm
operator|.
name|updateFavoredNodes
argument_list|(
name|regionFNMap
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
literal|"Cannot generate/update FN for regions: "
operator|+
name|regionFNMap
operator|.
name|keySet
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|assignmentMap
return|;
block|}
comment|/*    * Return list of favored nodes that are online.    */
specifier|private
name|List
argument_list|<
name|ServerName
argument_list|>
name|getOnlineFavoredNodes
parameter_list|(
name|List
argument_list|<
name|ServerName
argument_list|>
name|onlineServers
parameter_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
name|serversWithoutStartCodes
parameter_list|)
block|{
if|if
condition|(
name|serversWithoutStartCodes
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|result
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|ServerName
name|sn
range|:
name|serversWithoutStartCodes
control|)
block|{
for|for
control|(
name|ServerName
name|online
range|:
name|onlineServers
control|)
block|{
if|if
condition|(
name|ServerName
operator|.
name|isSameHostnameAndPort
argument_list|(
name|sn
argument_list|,
name|online
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|online
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
block|}
specifier|public
specifier|synchronized
name|List
argument_list|<
name|ServerName
argument_list|>
name|getFavoredNodes
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
return|return
name|this
operator|.
name|fnm
operator|.
name|getFavoredNodes
argument_list|(
name|regionInfo
argument_list|)
return|;
block|}
comment|/*    * Generate Favored Nodes for daughters during region split.    *    * If the parent does not have FN, regenerates them for the daughters.    *    * If the parent has FN, inherit two FN from parent for each daughter and generate the remaining.    * The primary FN for both the daughters should be the same as parent. Inherit the secondary    * FN from the parent but keep it different for each daughter. Choose the remaining FN    * randomly. This would give us better distribution over a period of time after enough splits.    */
annotation|@
name|Override
specifier|public
name|void
name|generateFavoredNodesForDaughter
parameter_list|(
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|,
name|HRegionInfo
name|parent
parameter_list|,
name|HRegionInfo
name|regionA
parameter_list|,
name|HRegionInfo
name|regionB
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|FavoredNodeAssignmentHelper
name|helper
init|=
operator|new
name|FavoredNodeAssignmentHelper
argument_list|(
name|servers
argument_list|,
name|rackManager
argument_list|)
decl_stmt|;
name|helper
operator|.
name|initialize
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|parentFavoredNodes
init|=
name|fnm
operator|.
name|getFavoredNodes
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentFavoredNodes
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to find favored nodes for parent, "
operator|+
name|parent
operator|+
literal|" generating new favored nodes for daughter"
argument_list|)
expr_stmt|;
name|result
operator|.
name|put
argument_list|(
name|regionA
argument_list|,
name|helper
operator|.
name|generateFavoredNodes
argument_list|(
name|regionA
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|put
argument_list|(
name|regionB
argument_list|,
name|helper
operator|.
name|generateFavoredNodes
argument_list|(
name|regionB
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Lets get the primary and secondary from parent for regionA
name|Set
argument_list|<
name|ServerName
argument_list|>
name|regionAFN
init|=
name|getInheritedFNForDaughter
argument_list|(
name|helper
argument_list|,
name|parentFavoredNodes
argument_list|,
name|PRIMARY
argument_list|,
name|SECONDARY
argument_list|)
decl_stmt|;
name|result
operator|.
name|put
argument_list|(
name|regionA
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|regionAFN
argument_list|)
argument_list|)
expr_stmt|;
comment|// Lets get the primary and tertiary from parent for regionB
name|Set
argument_list|<
name|ServerName
argument_list|>
name|regionBFN
init|=
name|getInheritedFNForDaughter
argument_list|(
name|helper
argument_list|,
name|parentFavoredNodes
argument_list|,
name|PRIMARY
argument_list|,
name|TERTIARY
argument_list|)
decl_stmt|;
name|result
operator|.
name|put
argument_list|(
name|regionB
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|regionBFN
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fnm
operator|.
name|updateFavoredNodes
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Set
argument_list|<
name|ServerName
argument_list|>
name|getInheritedFNForDaughter
parameter_list|(
name|FavoredNodeAssignmentHelper
name|helper
parameter_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
name|parentFavoredNodes
parameter_list|,
name|Position
name|primary
parameter_list|,
name|Position
name|secondary
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|ServerName
argument_list|>
name|daughterFN
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentFavoredNodes
operator|.
name|size
argument_list|()
operator|>=
name|primary
operator|.
name|ordinal
argument_list|()
condition|)
block|{
name|daughterFN
operator|.
name|add
argument_list|(
name|parentFavoredNodes
operator|.
name|get
argument_list|(
name|primary
operator|.
name|ordinal
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parentFavoredNodes
operator|.
name|size
argument_list|()
operator|>=
name|secondary
operator|.
name|ordinal
argument_list|()
condition|)
block|{
name|daughterFN
operator|.
name|add
argument_list|(
name|parentFavoredNodes
operator|.
name|get
argument_list|(
name|secondary
operator|.
name|ordinal
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|daughterFN
operator|.
name|size
argument_list|()
operator|<
name|FAVORED_NODES_NUM
condition|)
block|{
name|ServerName
name|newNode
init|=
name|helper
operator|.
name|generateMissingFavoredNode
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|daughterFN
argument_list|)
argument_list|)
decl_stmt|;
name|daughterFN
operator|.
name|add
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
block|}
return|return
name|daughterFN
return|;
block|}
comment|/*    * Generate favored nodes for a region during merge. Choose the FN from one of the sources to    * keep it simple.    */
annotation|@
name|Override
specifier|public
name|void
name|generateFavoredNodesForMergedRegion
parameter_list|(
name|HRegionInfo
name|merged
parameter_list|,
name|HRegionInfo
name|regionA
parameter_list|,
name|HRegionInfo
name|regionB
parameter_list|)
throws|throws
name|IOException
block|{
name|updateFavoredNodesForRegion
argument_list|(
name|merged
argument_list|,
name|fnm
operator|.
name|getFavoredNodes
argument_list|(
name|regionA
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*    * Pick favored nodes with the highest locality for a region with lowest locality.    */
specifier|private
class|class
name|FavoredNodeLocalityPicker
extends|extends
name|CandidateGenerator
block|{
annotation|@
name|Override
specifier|protected
name|Cluster
operator|.
name|Action
name|generate
parameter_list|(
name|Cluster
name|cluster
parameter_list|)
block|{
name|int
name|thisServer
init|=
name|pickRandomServer
argument_list|(
name|cluster
argument_list|)
decl_stmt|;
name|int
name|thisRegion
decl_stmt|;
if|if
condition|(
name|thisServer
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Could not pick lowest local region server"
argument_list|)
expr_stmt|;
return|return
name|Cluster
operator|.
name|NullAction
return|;
block|}
else|else
block|{
comment|// Pick lowest local region on this server
name|thisRegion
operator|=
name|pickLowestLocalRegionOnServer
argument_list|(
name|cluster
argument_list|,
name|thisServer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thisRegion
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|cluster
operator|.
name|regionsPerServer
index|[
name|thisServer
index|]
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Could not pick lowest local region even when region server held "
operator|+
name|cluster
operator|.
name|regionsPerServer
index|[
name|thisServer
index|]
operator|.
name|length
operator|+
literal|" regions"
argument_list|)
expr_stmt|;
block|}
return|return
name|Cluster
operator|.
name|NullAction
return|;
block|}
name|HRegionInfo
name|hri
init|=
name|cluster
operator|.
name|regions
index|[
name|thisRegion
index|]
decl_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
init|=
name|fnm
operator|.
name|getFavoredNodes
argument_list|(
name|hri
argument_list|)
decl_stmt|;
name|int
name|otherServer
decl_stmt|;
if|if
condition|(
name|favoredNodes
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|FavoredNodesManager
operator|.
name|isFavoredNodeApplicable
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|otherServer
operator|=
name|pickOtherRandomServer
argument_list|(
name|cluster
argument_list|,
name|thisServer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No FN, ignore
name|LOG
operator|.
name|trace
argument_list|(
literal|"Ignoring, no favored nodes for region: "
operator|+
name|hri
argument_list|)
expr_stmt|;
return|return
name|Cluster
operator|.
name|NullAction
return|;
block|}
block|}
else|else
block|{
comment|// Pick other favored node with the highest locality
name|otherServer
operator|=
name|getDifferentFavoredNode
argument_list|(
name|cluster
argument_list|,
name|favoredNodes
argument_list|,
name|thisServer
argument_list|)
expr_stmt|;
block|}
return|return
name|getAction
argument_list|(
name|thisServer
argument_list|,
name|thisRegion
argument_list|,
name|otherServer
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
specifier|private
name|int
name|getDifferentFavoredNode
parameter_list|(
name|Cluster
name|cluster
parameter_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
parameter_list|,
name|int
name|currentServer
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|fnIndex
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ServerName
name|sn
range|:
name|favoredNodes
control|)
block|{
if|if
condition|(
name|cluster
operator|.
name|serversToIndex
operator|.
name|containsKey
argument_list|(
name|sn
operator|.
name|getHostAndPort
argument_list|()
argument_list|)
condition|)
block|{
name|fnIndex
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|serversToIndex
operator|.
name|get
argument_list|(
name|sn
operator|.
name|getHostAndPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|float
name|locality
init|=
literal|0
decl_stmt|;
name|int
name|highestLocalRSIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Integer
name|index
range|:
name|fnIndex
control|)
block|{
if|if
condition|(
name|index
operator|!=
name|currentServer
condition|)
block|{
name|float
name|temp
init|=
name|cluster
operator|.
name|localityPerServer
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|temp
operator|>=
name|locality
condition|)
block|{
name|locality
operator|=
name|temp
expr_stmt|;
name|highestLocalRSIndex
operator|=
name|index
expr_stmt|;
block|}
block|}
block|}
return|return
name|highestLocalRSIndex
return|;
block|}
specifier|private
name|int
name|pickLowestLocalRegionOnServer
parameter_list|(
name|Cluster
name|cluster
parameter_list|,
name|int
name|server
parameter_list|)
block|{
return|return
name|cluster
operator|.
name|getLowestLocalityRegionOnServer
argument_list|(
name|server
argument_list|)
return|;
block|}
block|}
comment|/*    * This is like LoadCandidateGenerator, but we choose appropriate FN for the region on the    * most loaded server.    */
class|class
name|FavoredNodeLoadPicker
extends|extends
name|CandidateGenerator
block|{
annotation|@
name|Override
name|Cluster
operator|.
name|Action
name|generate
parameter_list|(
name|Cluster
name|cluster
parameter_list|)
block|{
name|cluster
operator|.
name|sortServersByRegionCount
argument_list|()
expr_stmt|;
name|int
name|thisServer
init|=
name|pickMostLoadedServer
argument_list|(
name|cluster
argument_list|)
decl_stmt|;
name|int
name|thisRegion
init|=
name|pickRandomRegion
argument_list|(
name|cluster
argument_list|,
name|thisServer
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HRegionInfo
name|hri
init|=
name|cluster
operator|.
name|regions
index|[
name|thisRegion
index|]
decl_stmt|;
name|int
name|otherServer
decl_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
init|=
name|fnm
operator|.
name|getFavoredNodes
argument_list|(
name|hri
argument_list|)
decl_stmt|;
if|if
condition|(
name|favoredNodes
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|FavoredNodesManager
operator|.
name|isFavoredNodeApplicable
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|otherServer
operator|=
name|pickLeastLoadedServer
argument_list|(
name|cluster
argument_list|,
name|thisServer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|Cluster
operator|.
name|NullAction
return|;
block|}
block|}
else|else
block|{
name|otherServer
operator|=
name|pickLeastLoadedFNServer
argument_list|(
name|cluster
argument_list|,
name|favoredNodes
argument_list|,
name|thisServer
argument_list|)
expr_stmt|;
block|}
return|return
name|getAction
argument_list|(
name|thisServer
argument_list|,
name|thisRegion
argument_list|,
name|otherServer
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
specifier|private
name|int
name|pickLeastLoadedServer
parameter_list|(
specifier|final
name|Cluster
name|cluster
parameter_list|,
name|int
name|thisServer
parameter_list|)
block|{
name|Integer
index|[]
name|servers
init|=
name|cluster
operator|.
name|serverIndicesSortedByRegionCount
decl_stmt|;
name|int
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|servers
operator|.
name|length
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|servers
index|[
name|index
index|]
operator|!=
literal|null
operator|)
operator|&&
name|servers
index|[
name|index
index|]
operator|!=
name|thisServer
condition|)
block|{
break|break;
block|}
block|}
return|return
name|servers
index|[
name|index
index|]
return|;
block|}
specifier|private
name|int
name|pickLeastLoadedFNServer
parameter_list|(
specifier|final
name|Cluster
name|cluster
parameter_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
parameter_list|,
name|int
name|currentServerIndex
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|fnIndex
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ServerName
name|sn
range|:
name|favoredNodes
control|)
block|{
if|if
condition|(
name|cluster
operator|.
name|serversToIndex
operator|.
name|containsKey
argument_list|(
name|sn
operator|.
name|getHostAndPort
argument_list|()
argument_list|)
condition|)
block|{
name|fnIndex
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|serversToIndex
operator|.
name|get
argument_list|(
name|sn
operator|.
name|getHostAndPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|leastLoadedFN
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|load
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|Integer
name|index
range|:
name|fnIndex
control|)
block|{
if|if
condition|(
name|index
operator|!=
name|currentServerIndex
condition|)
block|{
name|int
name|temp
init|=
name|cluster
operator|.
name|getNumRegions
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|<
name|load
condition|)
block|{
name|load
operator|=
name|temp
expr_stmt|;
name|leastLoadedFN
operator|=
name|index
expr_stmt|;
block|}
block|}
block|}
return|return
name|leastLoadedFN
return|;
block|}
specifier|private
name|int
name|pickMostLoadedServer
parameter_list|(
specifier|final
name|Cluster
name|cluster
parameter_list|)
block|{
name|Integer
index|[]
name|servers
init|=
name|cluster
operator|.
name|serverIndicesSortedByRegionCount
decl_stmt|;
name|int
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
name|servers
operator|.
name|length
operator|-
literal|1
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
block|{
if|if
condition|(
name|servers
index|[
name|index
index|]
operator|!=
literal|null
condition|)
block|{
break|break;
block|}
block|}
return|return
name|servers
index|[
name|index
index|]
return|;
block|}
block|}
comment|/*    * For all regions correctly assigned to favored nodes, we just use the stochastic balancer    * implementation. For the misplaced regions, we assign a bogus server to it and AM takes care.    */
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|balanceCluster
parameter_list|(
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|clusterState
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|services
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|regionPlans
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|correctAssignments
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|misplacedRegions
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|entry
range|:
name|clusterState
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ServerName
name|current
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|correctAssignments
operator|.
name|put
argument_list|(
name|current
argument_list|,
name|regions
argument_list|)
expr_stmt|;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
init|=
name|fnm
operator|.
name|getFavoredNodes
argument_list|(
name|hri
argument_list|)
decl_stmt|;
if|if
condition|(
name|FavoredNodesPlan
operator|.
name|getFavoredServerPosition
argument_list|(
name|favoredNodes
argument_list|,
name|current
argument_list|)
operator|!=
literal|null
operator|||
operator|!
name|FavoredNodesManager
operator|.
name|isFavoredNodeApplicable
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|regions
operator|.
name|add
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No favored nodes, lets unassign.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region not on favored nodes, unassign. Region: "
operator|+
name|hri
operator|+
literal|" current: "
operator|+
name|current
operator|+
literal|" favored nodes: "
operator|+
name|favoredNodes
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|services
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|unassign
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed unassign"
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RegionPlan
name|rp
init|=
operator|new
name|RegionPlan
argument_list|(
name|hri
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|regionPlans
operator|.
name|add
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|misplacedRegions
operator|++
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found misplaced regions: "
operator|+
name|misplacedRegions
operator|+
literal|", not on favored nodes."
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|regionPlansFromBalance
init|=
name|super
operator|.
name|balanceCluster
argument_list|(
name|correctAssignments
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionPlansFromBalance
operator|!=
literal|null
condition|)
block|{
name|regionPlans
operator|.
name|addAll
argument_list|(
name|regionPlansFromBalance
argument_list|)
expr_stmt|;
block|}
return|return
name|regionPlans
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|balanceCluster
argument_list|(
name|clusterState
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

