begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|BindException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ServerSocket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|CancelledKeyException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|GatheringByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SelectionKey
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|Selector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ServerSocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Timer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimerTask
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MonitoredRPCHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBasePolicyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|BlockingService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|MethodDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ServiceAuthorizationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_comment
comment|/**  * The RPC server with native java NIO implementation deriving from Hadoop to  * host protobuf described Services. It's the original one before HBASE-17262,  * and the default RPC server for now.  *  * An RpcServer instance has a Listener that hosts the socket.  Listener has fixed number  * of Readers in an ExecutorPool, 10 by default.  The Listener does an accept and then  * round robin a Reader is chosen to do the read.  The reader is registered on Selector.  Read does  * total read off the channel and the parse from which it makes a Call.  The call is wrapped in a  * CallRunner and passed to the scheduler to be run.  Reader goes back to see if more to be done  * and loops till done.  *  *<p>Scheduler can be variously implemented but default simple scheduler has handlers to which it  * has given the queues into which calls (i.e. CallRunner instances) are inserted.  Handlers run  * taking from the queue.  They run the CallRunner#run method on each item gotten from queue  * and keep taking while the server is up.  *  * CallRunner#run executes the call.  When done, asks the included Call to put itself on new  * queue for Responder to pull from and return result to client.  *  * @see BlockingRpcClient  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|SimpleRpcServer
extends|extends
name|RpcServer
block|{
specifier|protected
name|int
name|port
decl_stmt|;
comment|// port we listen on
specifier|protected
name|InetSocketAddress
name|address
decl_stmt|;
comment|// inet address we listen on
specifier|private
name|int
name|readThreads
decl_stmt|;
comment|// number of read threads
specifier|protected
name|int
name|socketSendBufferSize
decl_stmt|;
specifier|protected
specifier|final
name|long
name|purgeTimeout
decl_stmt|;
comment|// in milliseconds
comment|// maintains the set of client connections and handles idle timeouts
specifier|private
name|ConnectionManager
name|connectionManager
decl_stmt|;
specifier|private
name|Listener
name|listener
init|=
literal|null
decl_stmt|;
specifier|protected
name|SimpleRpcServerResponder
name|responder
init|=
literal|null
decl_stmt|;
comment|/** Listens on the socket. Creates jobs for the handler threads*/
specifier|private
class|class
name|Listener
extends|extends
name|Thread
block|{
specifier|private
name|ServerSocketChannel
name|acceptChannel
init|=
literal|null
decl_stmt|;
comment|//the accept channel
specifier|private
name|Selector
name|selector
init|=
literal|null
decl_stmt|;
comment|//the selector that we use for the server
specifier|private
name|Reader
index|[]
name|readers
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|currentReader
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|int
name|readerPendingConnectionQueueLength
decl_stmt|;
specifier|private
name|ExecutorService
name|readPool
decl_stmt|;
specifier|public
name|Listener
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// The backlog of requests that we will have the serversocket carry.
name|int
name|backlogLength
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.listen.queue.size"
argument_list|,
literal|128
argument_list|)
decl_stmt|;
name|readerPendingConnectionQueueLength
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.read.connection-queue.size"
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|// Create a new server socket and set to non blocking mode
name|acceptChannel
operator|=
name|ServerSocketChannel
operator|.
name|open
argument_list|()
expr_stmt|;
name|acceptChannel
operator|.
name|configureBlocking
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Bind the server socket to the binding addrees (can be different from the default interface)
name|bind
argument_list|(
name|acceptChannel
operator|.
name|socket
argument_list|()
argument_list|,
name|bindAddress
argument_list|,
name|backlogLength
argument_list|)
expr_stmt|;
name|port
operator|=
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|getLocalPort
argument_list|()
expr_stmt|;
comment|//Could be an ephemeral port
name|address
operator|=
operator|(
name|InetSocketAddress
operator|)
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|getLocalSocketAddress
argument_list|()
expr_stmt|;
comment|// create a selector;
name|selector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
name|readers
operator|=
operator|new
name|Reader
index|[
name|readThreads
index|]
expr_stmt|;
comment|// Why this executor thing? Why not like hadoop just start up all the threads? I suppose it
comment|// has an advantage in that it is easy to shutdown the pool.
name|readPool
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|readThreads
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"Reader=%d,bindAddress="
operator|+
name|bindAddress
operator|.
name|getHostName
argument_list|()
operator|+
literal|",port="
operator|+
name|port
argument_list|)
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setUncaughtExceptionHandler
argument_list|(
name|Threads
operator|.
name|LOGGING_EXCEPTION_HANDLER
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|readThreads
condition|;
operator|++
name|i
control|)
block|{
name|Reader
name|reader
init|=
operator|new
name|Reader
argument_list|()
decl_stmt|;
name|readers
index|[
name|i
index|]
operator|=
name|reader
expr_stmt|;
name|readPool
operator|.
name|execute
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": started "
operator|+
name|readThreads
operator|+
literal|" reader(s) listening on port="
operator|+
name|port
argument_list|)
expr_stmt|;
comment|// Register accepts on the server socket with the selector.
name|acceptChannel
operator|.
name|register
argument_list|(
name|selector
argument_list|,
name|SelectionKey
operator|.
name|OP_ACCEPT
argument_list|)
expr_stmt|;
name|this
operator|.
name|setName
argument_list|(
literal|"Listener,port="
operator|+
name|port
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
class|class
name|Reader
implements|implements
name|Runnable
block|{
specifier|final
specifier|private
name|LinkedBlockingQueue
argument_list|<
name|SimpleServerRpcConnection
argument_list|>
name|pendingConnections
decl_stmt|;
specifier|private
specifier|final
name|Selector
name|readSelector
decl_stmt|;
name|Reader
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|pendingConnections
operator|=
operator|new
name|LinkedBlockingQueue
argument_list|<>
argument_list|(
name|readerPendingConnectionQueueLength
argument_list|)
expr_stmt|;
name|this
operator|.
name|readSelector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|doRunLoop
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|readSelector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getName
argument_list|()
operator|+
literal|": error closing read selector in "
operator|+
name|getName
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|synchronized
name|void
name|doRunLoop
parameter_list|()
block|{
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
comment|// Consume as many connections as currently queued to avoid
comment|// unbridled acceptance of connections that starves the select
name|int
name|size
init|=
name|pendingConnections
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|size
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|SimpleServerRpcConnection
name|conn
init|=
name|pendingConnections
operator|.
name|take
argument_list|()
decl_stmt|;
name|conn
operator|.
name|channel
operator|.
name|register
argument_list|(
name|readSelector
argument_list|,
name|SelectionKey
operator|.
name|OP_READ
argument_list|,
name|conn
argument_list|)
expr_stmt|;
block|}
name|readSelector
operator|.
name|select
argument_list|()
expr_stmt|;
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|readSelector
operator|.
name|selectedKeys
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SelectionKey
name|key
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|key
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|isReadable
argument_list|()
condition|)
block|{
name|doRead
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
name|key
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|running
condition|)
block|{
comment|// unexpected -- log it
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" unexpectedly interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CancelledKeyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getName
argument_list|()
operator|+
literal|": CancelledKeyException in Reader"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": IOException in Reader"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**        * Updating the readSelector while it's being used is not thread-safe,        * so the connection must be queued.  The reader will drain the queue        * and update its readSelector before performing the next select        */
specifier|public
name|void
name|addConnection
parameter_list|(
name|SimpleServerRpcConnection
name|conn
parameter_list|)
throws|throws
name|IOException
block|{
name|pendingConnections
operator|.
name|add
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|readSelector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"IS2_INCONSISTENT_SYNC"
argument_list|,
name|justification
operator|=
literal|"selector access is not synchronized; seems fine but concerned changing "
operator|+
literal|"it will have per impact"
argument_list|)
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": starting"
argument_list|)
expr_stmt|;
name|connectionManager
operator|.
name|startIdleScan
argument_list|()
expr_stmt|;
while|while
condition|(
name|running
condition|)
block|{
name|SelectionKey
name|key
init|=
literal|null
decl_stmt|;
try|try
block|{
name|selector
operator|.
name|select
argument_list|()
expr_stmt|;
comment|// FindBugs IS2_INCONSISTENT_SYNC
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|selector
operator|.
name|selectedKeys
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|key
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|key
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|isAcceptable
argument_list|()
condition|)
name|doAccept
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
name|key
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|e
parameter_list|)
block|{
if|if
condition|(
name|errorHandler
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|errorHandler
operator|.
name|checkOOME
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exiting on OutOfMemoryError"
argument_list|)
expr_stmt|;
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|connectionManager
operator|.
name|closeIdle
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// we can run out of memory if we have too many threads
comment|// log the event and sleep for a minute and give
comment|// some thread(s) a chance to finish
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|": OutOfMemoryError in server select"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|connectionManager
operator|.
name|closeIdle
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|60000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Interrupted while sleeping"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": stopping"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|acceptChannel
operator|.
name|close
argument_list|()
expr_stmt|;
name|selector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
name|selector
operator|=
literal|null
expr_stmt|;
name|acceptChannel
operator|=
literal|null
expr_stmt|;
comment|// close all connections
name|connectionManager
operator|.
name|stopIdleScan
argument_list|()
expr_stmt|;
name|connectionManager
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|closeCurrentConnection
parameter_list|(
name|SelectionKey
name|key
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|SimpleServerRpcConnection
name|c
init|=
operator|(
name|SimpleServerRpcConnection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|closeConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|key
operator|.
name|attach
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|InetSocketAddress
name|getAddress
parameter_list|()
block|{
return|return
name|address
return|;
block|}
name|void
name|doAccept
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
throws|,
name|OutOfMemoryError
block|{
name|ServerSocketChannel
name|server
init|=
operator|(
name|ServerSocketChannel
operator|)
name|key
operator|.
name|channel
argument_list|()
decl_stmt|;
name|SocketChannel
name|channel
decl_stmt|;
while|while
condition|(
operator|(
name|channel
operator|=
name|server
operator|.
name|accept
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|channel
operator|.
name|configureBlocking
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|channel
operator|.
name|socket
argument_list|()
operator|.
name|setTcpNoDelay
argument_list|(
name|tcpNoDelay
argument_list|)
expr_stmt|;
name|channel
operator|.
name|socket
argument_list|()
operator|.
name|setKeepAlive
argument_list|(
name|tcpKeepAlive
argument_list|)
expr_stmt|;
name|Reader
name|reader
init|=
name|getReader
argument_list|()
decl_stmt|;
name|SimpleServerRpcConnection
name|c
init|=
name|connectionManager
operator|.
name|register
argument_list|(
name|channel
argument_list|)
decl_stmt|;
comment|// If the connectionManager can't take it, close the connection.
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|key
operator|.
name|attach
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// so closeCurrentConnection can get the object
name|reader
operator|.
name|addConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|doRead
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|int
name|count
decl_stmt|;
name|SimpleServerRpcConnection
name|c
init|=
operator|(
name|SimpleServerRpcConnection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|c
operator|.
name|setLastContact
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|count
operator|=
name|c
operator|.
name|readAndProcess
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ieo
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": readAndProcess caught InterruptedException"
argument_list|,
name|ieo
argument_list|)
expr_stmt|;
throw|throw
name|ieo
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Caught exception while reading:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
operator|-
literal|1
expr_stmt|;
comment|//so that the (count< 0) block is executed
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|closeConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|setLastContact
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|synchronized
name|void
name|doStop
parameter_list|()
block|{
if|if
condition|(
name|selector
operator|!=
literal|null
condition|)
block|{
name|selector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|acceptChannel
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exception in closing listener socket. "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|readPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
comment|// The method that will return the next reader to work with
comment|// Simplistic implementation of round robin for now
name|Reader
name|getReader
parameter_list|()
block|{
name|currentReader
operator|=
operator|(
name|currentReader
operator|+
literal|1
operator|)
operator|%
name|readers
operator|.
name|length
expr_stmt|;
return|return
name|readers
index|[
name|currentReader
index|]
return|;
block|}
block|}
comment|/**    * Constructs a server listening on the named port and address.    * @param server hosting instance of {@link Server}. We will do authentications if an    * instance else pass null for no authentication check.    * @param name Used keying this rpc servers' metrics and for naming the Listener thread.    * @param services A list of services.    * @param bindAddress Where to listen    * @param conf    * @param scheduler    */
specifier|public
name|SimpleRpcServer
parameter_list|(
specifier|final
name|Server
name|server
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|InetSocketAddress
name|bindAddress
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|RpcScheduler
name|scheduler
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|server
argument_list|,
name|name
argument_list|,
name|services
argument_list|,
name|bindAddress
argument_list|,
name|conf
argument_list|,
name|scheduler
argument_list|)
expr_stmt|;
name|this
operator|.
name|socketSendBufferSize
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|readThreads
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.read.threadpool.size"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|purgeTimeout
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.ipc.client.call.purge.timeout"
argument_list|,
literal|2
operator|*
name|HConstants
operator|.
name|DEFAULT_HBASE_RPC_TIMEOUT
argument_list|)
expr_stmt|;
comment|// Start the listener here and let it bind to the port
name|listener
operator|=
operator|new
name|Listener
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|port
operator|=
name|listener
operator|.
name|getAddress
argument_list|()
operator|.
name|getPort
argument_list|()
expr_stmt|;
comment|// Create the responder here
name|responder
operator|=
operator|new
name|SimpleRpcServerResponder
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|connectionManager
operator|=
operator|new
name|ConnectionManager
argument_list|()
expr_stmt|;
name|initReconfigurable
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|scheduler
operator|.
name|init
argument_list|(
operator|new
name|RpcSchedulerContext
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Subclasses of HBaseServer can override this to provide their own    * Connection implementations.    */
specifier|protected
name|SimpleServerRpcConnection
name|getConnection
parameter_list|(
name|SocketChannel
name|channel
parameter_list|,
name|long
name|time
parameter_list|)
block|{
return|return
operator|new
name|SimpleServerRpcConnection
argument_list|(
name|this
argument_list|,
name|channel
argument_list|,
name|time
argument_list|)
return|;
block|}
specifier|protected
name|void
name|closeConnection
parameter_list|(
name|SimpleServerRpcConnection
name|connection
parameter_list|)
block|{
name|connectionManager
operator|.
name|close
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
comment|/** Sets the socket buffer size used for responding to RPCs.    * @param size send size    */
annotation|@
name|Override
specifier|public
name|void
name|setSocketSendBufSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|socketSendBufferSize
operator|=
name|size
expr_stmt|;
block|}
comment|/** Starts the service.  Must be called before any calls will be handled. */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|start
parameter_list|()
block|{
if|if
condition|(
name|started
condition|)
return|return;
name|authTokenSecretMgr
operator|=
name|createSecretManager
argument_list|()
expr_stmt|;
if|if
condition|(
name|authTokenSecretMgr
operator|!=
literal|null
condition|)
block|{
name|setSecretManager
argument_list|(
name|authTokenSecretMgr
argument_list|)
expr_stmt|;
name|authTokenSecretMgr
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|authManager
operator|=
operator|new
name|ServiceAuthorizationManager
argument_list|()
expr_stmt|;
name|HBasePolicyProvider
operator|.
name|init
argument_list|(
name|conf
argument_list|,
name|authManager
argument_list|)
expr_stmt|;
name|responder
operator|.
name|start
argument_list|()
expr_stmt|;
name|listener
operator|.
name|start
argument_list|()
expr_stmt|;
name|scheduler
operator|.
name|start
argument_list|()
expr_stmt|;
name|started
operator|=
literal|true
expr_stmt|;
block|}
comment|/** Stops the service.  No new calls will be handled after this is called. */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|stop
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping server on "
operator|+
name|port
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|authTokenSecretMgr
operator|!=
literal|null
condition|)
block|{
name|authTokenSecretMgr
operator|.
name|stop
argument_list|()
expr_stmt|;
name|authTokenSecretMgr
operator|=
literal|null
expr_stmt|;
block|}
name|listener
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|listener
operator|.
name|doStop
argument_list|()
expr_stmt|;
name|responder
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|scheduler
operator|.
name|stop
argument_list|()
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/** Wait for the server to be stopped.    * Does not wait for all subthreads to finish.    *  See {@link #stop()}.    * @throws InterruptedException e    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|join
parameter_list|()
throws|throws
name|InterruptedException
block|{
while|while
condition|(
name|running
condition|)
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Return the socket (ip+port) on which the RPC server is listening to. May return null if    * the listener channel is closed.    * @return the socket (ip+port) on which the RPC server is listening to, or null if this    * information cannot be determined    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|InetSocketAddress
name|getListenerAddress
parameter_list|()
block|{
if|if
condition|(
name|listener
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|listener
operator|.
name|getAddress
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
name|call
parameter_list|(
name|BlockingService
name|service
parameter_list|,
name|MethodDescriptor
name|md
parameter_list|,
name|Message
name|param
parameter_list|,
name|CellScanner
name|cellScanner
parameter_list|,
name|long
name|receiveTime
parameter_list|,
name|MonitoredRPCHandler
name|status
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|call
argument_list|(
name|service
argument_list|,
name|md
argument_list|,
name|param
argument_list|,
name|cellScanner
argument_list|,
name|receiveTime
argument_list|,
name|status
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
name|call
parameter_list|(
name|BlockingService
name|service
parameter_list|,
name|MethodDescriptor
name|md
parameter_list|,
name|Message
name|param
parameter_list|,
name|CellScanner
name|cellScanner
parameter_list|,
name|long
name|receiveTime
parameter_list|,
name|MonitoredRPCHandler
name|status
parameter_list|,
name|long
name|startTime
parameter_list|,
name|int
name|timeout
parameter_list|)
throws|throws
name|IOException
block|{
name|SimpleServerCall
name|fakeCall
init|=
operator|new
name|SimpleServerCall
argument_list|(
operator|-
literal|1
argument_list|,
name|service
argument_list|,
name|md
argument_list|,
literal|null
argument_list|,
name|param
argument_list|,
name|cellScanner
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|receiveTime
argument_list|,
name|timeout
argument_list|,
name|reservoir
argument_list|,
name|cellBlockBuilder
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|call
argument_list|(
name|fakeCall
argument_list|,
name|status
argument_list|)
return|;
block|}
comment|/**    * This is a wrapper around {@link java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)}.    * If the amount of data is large, it writes to channel in smaller chunks.    * This is to avoid jdk from creating many direct buffers as the size of    * buffer increases. This also minimizes extra copies in NIO layer    * as a result of multiple write operations required to write a large    * buffer.    *    * @param channel writable byte channel to write to    * @param bufferChain Chain of buffers to write    * @return number of bytes written    * @throws java.io.IOException e    * @see java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)    */
specifier|protected
name|long
name|channelWrite
parameter_list|(
name|GatheringByteChannel
name|channel
parameter_list|,
name|BufferChain
name|bufferChain
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|count
init|=
name|bufferChain
operator|.
name|write
argument_list|(
name|channel
argument_list|,
name|NIO_BUFFER_LIMIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|this
operator|.
name|metrics
operator|.
name|sentBytes
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
comment|/**    * A convenience method to bind to a given address and report    * better exceptions if the address is not a valid host.    * @param socket the socket to bind    * @param address the address to bind to    * @param backlog the number of connections allowed in the queue    * @throws BindException if the address can't be bound    * @throws UnknownHostException if the address isn't a valid host name    * @throws IOException other random errors from bind    */
specifier|public
specifier|static
name|void
name|bind
parameter_list|(
name|ServerSocket
name|socket
parameter_list|,
name|InetSocketAddress
name|address
parameter_list|,
name|int
name|backlog
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|socket
operator|.
name|bind
argument_list|(
name|address
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BindException
name|e
parameter_list|)
block|{
name|BindException
name|bindException
init|=
operator|new
name|BindException
argument_list|(
literal|"Problem binding to "
operator|+
name|address
operator|+
literal|" : "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|bindException
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|bindException
throw|;
block|}
catch|catch
parameter_list|(
name|SocketException
name|e
parameter_list|)
block|{
comment|// If they try to bind to a different host's address, give a better
comment|// error message.
if|if
condition|(
literal|"Unresolved address"
operator|.
name|equals
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnknownHostException
argument_list|(
literal|"Invalid hostname for server: "
operator|+
name|address
operator|.
name|getHostName
argument_list|()
argument_list|)
throw|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * The number of open RPC conections    * @return the number of open rpc connections    */
specifier|public
name|int
name|getNumOpenConnections
parameter_list|()
block|{
return|return
name|connectionManager
operator|.
name|size
argument_list|()
return|;
block|}
specifier|private
class|class
name|ConnectionManager
block|{
specifier|final
specifier|private
name|AtomicInteger
name|count
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
specifier|final
specifier|private
name|Set
argument_list|<
name|SimpleServerRpcConnection
argument_list|>
name|connections
decl_stmt|;
specifier|final
specifier|private
name|Timer
name|idleScanTimer
decl_stmt|;
specifier|final
specifier|private
name|int
name|idleScanThreshold
decl_stmt|;
specifier|final
specifier|private
name|int
name|idleScanInterval
decl_stmt|;
specifier|final
specifier|private
name|int
name|maxIdleTime
decl_stmt|;
specifier|final
specifier|private
name|int
name|maxIdleToClose
decl_stmt|;
name|ConnectionManager
parameter_list|()
block|{
name|this
operator|.
name|idleScanTimer
operator|=
operator|new
name|Timer
argument_list|(
literal|"RpcServer idle connection scanner for port "
operator|+
name|port
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|idleScanThreshold
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.idlethreshold"
argument_list|,
literal|4000
argument_list|)
expr_stmt|;
name|this
operator|.
name|idleScanInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.connection.idle-scan-interval.ms"
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxIdleTime
operator|=
literal|2
operator|*
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.connection.maxidletime"
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxIdleToClose
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.kill.max"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|int
name|handlerCount
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|REGION_SERVER_HANDLER_COUNT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_REGION_SERVER_HANDLER_COUNT
argument_list|)
decl_stmt|;
name|int
name|maxConnectionQueueSize
init|=
name|handlerCount
operator|*
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.handler.queue.size"
argument_list|,
literal|100
argument_list|)
decl_stmt|;
comment|// create a set with concurrency -and- a thread-safe iterator, add 2
comment|// for listener and idle closer threads
name|this
operator|.
name|connections
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|SimpleServerRpcConnection
argument_list|,
name|Boolean
argument_list|>
argument_list|(
name|maxConnectionQueueSize
argument_list|,
literal|0.75f
argument_list|,
name|readThreads
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|add
parameter_list|(
name|SimpleServerRpcConnection
name|connection
parameter_list|)
block|{
name|boolean
name|added
init|=
name|connections
operator|.
name|add
argument_list|(
name|connection
argument_list|)
decl_stmt|;
if|if
condition|(
name|added
condition|)
block|{
name|count
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
block|}
return|return
name|added
return|;
block|}
specifier|private
name|boolean
name|remove
parameter_list|(
name|SimpleServerRpcConnection
name|connection
parameter_list|)
block|{
name|boolean
name|removed
init|=
name|connections
operator|.
name|remove
argument_list|(
name|connection
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
condition|)
block|{
name|count
operator|.
name|getAndDecrement
argument_list|()
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
name|int
name|size
parameter_list|()
block|{
return|return
name|count
operator|.
name|get
argument_list|()
return|;
block|}
name|SimpleServerRpcConnection
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|connections
operator|.
name|toArray
argument_list|(
operator|new
name|SimpleServerRpcConnection
index|[
literal|0
index|]
argument_list|)
return|;
block|}
name|SimpleServerRpcConnection
name|register
parameter_list|(
name|SocketChannel
name|channel
parameter_list|)
block|{
name|SimpleServerRpcConnection
name|connection
init|=
name|getConnection
argument_list|(
name|channel
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|connection
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Connection from "
operator|+
name|connection
operator|+
literal|"; connections="
operator|+
name|size
argument_list|()
operator|+
literal|", queued calls size (bytes)="
operator|+
name|callQueueSizeInBytes
operator|.
name|sum
argument_list|()
operator|+
literal|", general queued calls="
operator|+
name|scheduler
operator|.
name|getGeneralQueueLength
argument_list|()
operator|+
literal|", priority queued calls="
operator|+
name|scheduler
operator|.
name|getPriorityQueueLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|connection
return|;
block|}
name|boolean
name|close
parameter_list|(
name|SimpleServerRpcConnection
name|connection
parameter_list|)
block|{
name|boolean
name|exists
init|=
name|remove
argument_list|(
name|connection
argument_list|)
decl_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": disconnecting client "
operator|+
name|connection
operator|+
literal|". Number of active connections: "
operator|+
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// only close if actually removed to avoid double-closing due
comment|// to possible races
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|exists
return|;
block|}
comment|// synch'ed to avoid explicit invocation upon OOM from colliding with
comment|// timer task firing
specifier|synchronized
name|void
name|closeIdle
parameter_list|(
name|boolean
name|scanAll
parameter_list|)
block|{
name|long
name|minLastContact
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|maxIdleTime
decl_stmt|;
comment|// concurrent iterator might miss new connections added
comment|// during the iteration, but that's ok because they won't
comment|// be idle yet anyway and will be caught on next scan
name|int
name|closed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SimpleServerRpcConnection
name|connection
range|:
name|connections
control|)
block|{
comment|// stop if connections dropped below threshold unless scanning all
if|if
condition|(
operator|!
name|scanAll
operator|&&
name|size
argument_list|()
operator|<
name|idleScanThreshold
condition|)
block|{
break|break;
block|}
comment|// stop if not scanning all and max connections are closed
if|if
condition|(
name|connection
operator|.
name|isIdle
argument_list|()
operator|&&
name|connection
operator|.
name|getLastContact
argument_list|()
operator|<
name|minLastContact
operator|&&
name|close
argument_list|(
name|connection
argument_list|)
operator|&&
operator|!
name|scanAll
operator|&&
operator|(
operator|++
name|closed
operator|==
name|maxIdleToClose
operator|)
condition|)
block|{
break|break;
block|}
block|}
block|}
name|void
name|closeAll
parameter_list|()
block|{
comment|// use a copy of the connections to be absolutely sure the concurrent
comment|// iterator doesn't miss a connection
for|for
control|(
name|SimpleServerRpcConnection
name|connection
range|:
name|toArray
argument_list|()
control|)
block|{
name|close
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|startIdleScan
parameter_list|()
block|{
name|scheduleIdleScanTask
argument_list|()
expr_stmt|;
block|}
name|void
name|stopIdleScan
parameter_list|()
block|{
name|idleScanTimer
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|scheduleIdleScanTask
parameter_list|()
block|{
if|if
condition|(
operator|!
name|running
condition|)
block|{
return|return;
block|}
name|TimerTask
name|idleScanTask
init|=
operator|new
name|TimerTask
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
operator|!
name|running
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"running"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|closeIdle
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// explicitly reschedule so next execution occurs relative
comment|// to the end of this scan, not the beginning
name|scheduleIdleScanTask
argument_list|()
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|idleScanTimer
operator|.
name|schedule
argument_list|(
name|idleScanTask
argument_list|,
name|idleScanInterval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

