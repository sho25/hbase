begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|BindException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ServerSocket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|CancelledKeyException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedChannelException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|GatheringByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ReadableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SelectionKey
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|Selector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ServerSocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Timer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimerTask
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|LongAdder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|VersionInfoUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|RequestTooBigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MonitoredRPCHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|ByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|SingleByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|AuthMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBasePolicyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|SaslStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|SaslUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|BlockingService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|CodedInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|MethodDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|RequestHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ServiceAuthorizationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|TraceInfo
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_comment
comment|/**  * The RPC server with native java NIO implementation deriving from Hadoop to  * host protobuf described Services. It's the original one before HBASE-17262,  * and the default RPC server for now.  *  * An RpcServer instance has a Listener that hosts the socket.  Listener has fixed number  * of Readers in an ExecutorPool, 10 by default.  The Listener does an accept and then  * round robin a Reader is chosen to do the read.  The reader is registered on Selector.  Read does  * total read off the channel and the parse from which it makes a Call.  The call is wrapped in a  * CallRunner and passed to the scheduler to be run.  Reader goes back to see if more to be done  * and loops till done.  *  *<p>Scheduler can be variously implemented but default simple scheduler has handlers to which it  * has given the queues into which calls (i.e. CallRunner instances) are inserted.  Handlers run  * taking from the queue.  They run the CallRunner#run method on each item gotten from queue  * and keep taking while the server is up.  *  * CallRunner#run executes the call.  When done, asks the included Call to put itself on new  * queue for Responder to pull from and return result to client.  *  * @see BlockingRpcClient  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|SimpleRpcServer
extends|extends
name|RpcServer
block|{
specifier|protected
name|int
name|port
decl_stmt|;
comment|// port we listen on
specifier|protected
name|InetSocketAddress
name|address
decl_stmt|;
comment|// inet address we listen on
specifier|private
name|int
name|readThreads
decl_stmt|;
comment|// number of read threads
specifier|protected
name|int
name|socketSendBufferSize
decl_stmt|;
specifier|protected
specifier|final
name|long
name|purgeTimeout
decl_stmt|;
comment|// in milliseconds
comment|// maintains the set of client connections and handles idle timeouts
specifier|private
name|ConnectionManager
name|connectionManager
decl_stmt|;
specifier|private
name|Listener
name|listener
init|=
literal|null
decl_stmt|;
specifier|protected
name|Responder
name|responder
init|=
literal|null
decl_stmt|;
comment|/**    * Datastructure that holds all necessary to a method invocation and then afterward, carries    * the result.    */
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|Call
extends|extends
name|RpcServer
operator|.
name|Call
block|{
specifier|protected
name|Responder
name|responder
decl_stmt|;
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"NP_NULL_ON_SOME_PATH"
argument_list|,
name|justification
operator|=
literal|"Can't figure why this complaint is happening... see below"
argument_list|)
name|Call
parameter_list|(
name|int
name|id
parameter_list|,
specifier|final
name|BlockingService
name|service
parameter_list|,
specifier|final
name|MethodDescriptor
name|md
parameter_list|,
name|RequestHeader
name|header
parameter_list|,
name|Message
name|param
parameter_list|,
name|CellScanner
name|cellScanner
parameter_list|,
name|RpcServer
operator|.
name|Connection
name|connection
parameter_list|,
name|long
name|size
parameter_list|,
name|TraceInfo
name|tinfo
parameter_list|,
specifier|final
name|InetAddress
name|remoteAddress
parameter_list|,
name|int
name|timeout
parameter_list|,
name|CallCleanup
name|reqCleanup
parameter_list|,
name|Responder
name|responder
parameter_list|)
block|{
name|super
argument_list|(
name|id
argument_list|,
name|service
argument_list|,
name|md
argument_list|,
name|header
argument_list|,
name|param
argument_list|,
name|cellScanner
argument_list|,
name|connection
argument_list|,
name|size
argument_list|,
name|tinfo
argument_list|,
name|remoteAddress
argument_list|,
name|timeout
argument_list|,
name|reqCleanup
argument_list|)
expr_stmt|;
name|this
operator|.
name|responder
operator|=
name|responder
expr_stmt|;
block|}
comment|/**      * Call is done. Execution happened and we returned results to client. It is now safe to      * cleanup.      */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"IS2_INCONSISTENT_SYNC"
argument_list|,
name|justification
operator|=
literal|"Presume the lock on processing request held by caller is protection enough"
argument_list|)
annotation|@
name|Override
name|void
name|done
parameter_list|()
block|{
name|super
operator|.
name|done
argument_list|()
expr_stmt|;
name|this
operator|.
name|getConnection
argument_list|()
operator|.
name|decRpcCount
argument_list|()
expr_stmt|;
comment|// Say that we're done with this call.
block|}
annotation|@
name|Override
specifier|public
name|long
name|disconnectSince
parameter_list|()
block|{
if|if
condition|(
operator|!
name|getConnection
argument_list|()
operator|.
name|isConnectionOpen
argument_list|()
condition|)
block|{
return|return
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|timestamp
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1L
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|sendResponseIfReady
parameter_list|()
throws|throws
name|IOException
block|{
comment|// set param null to reduce memory pressure
name|this
operator|.
name|param
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|responder
operator|.
name|doRespond
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|Connection
name|getConnection
parameter_list|()
block|{
return|return
operator|(
name|Connection
operator|)
name|this
operator|.
name|connection
return|;
block|}
block|}
comment|/** Listens on the socket. Creates jobs for the handler threads*/
specifier|private
class|class
name|Listener
extends|extends
name|Thread
block|{
specifier|private
name|ServerSocketChannel
name|acceptChannel
init|=
literal|null
decl_stmt|;
comment|//the accept channel
specifier|private
name|Selector
name|selector
init|=
literal|null
decl_stmt|;
comment|//the selector that we use for the server
specifier|private
name|Reader
index|[]
name|readers
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|currentReader
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|int
name|readerPendingConnectionQueueLength
decl_stmt|;
specifier|private
name|ExecutorService
name|readPool
decl_stmt|;
specifier|public
name|Listener
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// The backlog of requests that we will have the serversocket carry.
name|int
name|backlogLength
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.listen.queue.size"
argument_list|,
literal|128
argument_list|)
decl_stmt|;
name|readerPendingConnectionQueueLength
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.read.connection-queue.size"
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|// Create a new server socket and set to non blocking mode
name|acceptChannel
operator|=
name|ServerSocketChannel
operator|.
name|open
argument_list|()
expr_stmt|;
name|acceptChannel
operator|.
name|configureBlocking
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Bind the server socket to the binding addrees (can be different from the default interface)
name|bind
argument_list|(
name|acceptChannel
operator|.
name|socket
argument_list|()
argument_list|,
name|bindAddress
argument_list|,
name|backlogLength
argument_list|)
expr_stmt|;
name|port
operator|=
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|getLocalPort
argument_list|()
expr_stmt|;
comment|//Could be an ephemeral port
name|address
operator|=
operator|(
name|InetSocketAddress
operator|)
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|getLocalSocketAddress
argument_list|()
expr_stmt|;
comment|// create a selector;
name|selector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
name|readers
operator|=
operator|new
name|Reader
index|[
name|readThreads
index|]
expr_stmt|;
comment|// Why this executor thing? Why not like hadoop just start up all the threads? I suppose it
comment|// has an advantage in that it is easy to shutdown the pool.
name|readPool
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|readThreads
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"RpcServer.reader=%d,bindAddress="
operator|+
name|bindAddress
operator|.
name|getHostName
argument_list|()
operator|+
literal|",port="
operator|+
name|port
argument_list|)
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setUncaughtExceptionHandler
argument_list|(
name|Threads
operator|.
name|LOGGING_EXCEPTION_HANDLER
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|readThreads
condition|;
operator|++
name|i
control|)
block|{
name|Reader
name|reader
init|=
operator|new
name|Reader
argument_list|()
decl_stmt|;
name|readers
index|[
name|i
index|]
operator|=
name|reader
expr_stmt|;
name|readPool
operator|.
name|execute
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": started "
operator|+
name|readThreads
operator|+
literal|" reader(s) listening on port="
operator|+
name|port
argument_list|)
expr_stmt|;
comment|// Register accepts on the server socket with the selector.
name|acceptChannel
operator|.
name|register
argument_list|(
name|selector
argument_list|,
name|SelectionKey
operator|.
name|OP_ACCEPT
argument_list|)
expr_stmt|;
name|this
operator|.
name|setName
argument_list|(
literal|"RpcServer.listener,port="
operator|+
name|port
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
class|class
name|Reader
implements|implements
name|Runnable
block|{
specifier|final
specifier|private
name|LinkedBlockingQueue
argument_list|<
name|Connection
argument_list|>
name|pendingConnections
decl_stmt|;
specifier|private
specifier|final
name|Selector
name|readSelector
decl_stmt|;
name|Reader
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|pendingConnections
operator|=
operator|new
name|LinkedBlockingQueue
argument_list|<>
argument_list|(
name|readerPendingConnectionQueueLength
argument_list|)
expr_stmt|;
name|this
operator|.
name|readSelector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|doRunLoop
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|readSelector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getName
argument_list|()
operator|+
literal|": error closing read selector in "
operator|+
name|getName
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|synchronized
name|void
name|doRunLoop
parameter_list|()
block|{
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
comment|// Consume as many connections as currently queued to avoid
comment|// unbridled acceptance of connections that starves the select
name|int
name|size
init|=
name|pendingConnections
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|size
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|Connection
name|conn
init|=
name|pendingConnections
operator|.
name|take
argument_list|()
decl_stmt|;
name|conn
operator|.
name|channel
operator|.
name|register
argument_list|(
name|readSelector
argument_list|,
name|SelectionKey
operator|.
name|OP_READ
argument_list|,
name|conn
argument_list|)
expr_stmt|;
block|}
name|readSelector
operator|.
name|select
argument_list|()
expr_stmt|;
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|readSelector
operator|.
name|selectedKeys
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SelectionKey
name|key
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|key
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|isReadable
argument_list|()
condition|)
block|{
name|doRead
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
name|key
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|running
condition|)
block|{
comment|// unexpected -- log it
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" unexpectedly interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CancelledKeyException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getName
argument_list|()
operator|+
literal|": CancelledKeyException in Reader"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": IOException in Reader"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**        * Updating the readSelector while it's being used is not thread-safe,        * so the connection must be queued.  The reader will drain the queue        * and update its readSelector before performing the next select        */
specifier|public
name|void
name|addConnection
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|IOException
block|{
name|pendingConnections
operator|.
name|add
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|readSelector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"IS2_INCONSISTENT_SYNC"
argument_list|,
name|justification
operator|=
literal|"selector access is not synchronized; seems fine but concerned changing "
operator|+
literal|"it will have per impact"
argument_list|)
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": starting"
argument_list|)
expr_stmt|;
name|connectionManager
operator|.
name|startIdleScan
argument_list|()
expr_stmt|;
while|while
condition|(
name|running
condition|)
block|{
name|SelectionKey
name|key
init|=
literal|null
decl_stmt|;
try|try
block|{
name|selector
operator|.
name|select
argument_list|()
expr_stmt|;
comment|// FindBugs IS2_INCONSISTENT_SYNC
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|selector
operator|.
name|selectedKeys
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|key
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|key
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|isAcceptable
argument_list|()
condition|)
name|doAccept
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
name|key
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|e
parameter_list|)
block|{
if|if
condition|(
name|errorHandler
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|errorHandler
operator|.
name|checkOOME
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exiting on OutOfMemoryError"
argument_list|)
expr_stmt|;
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|connectionManager
operator|.
name|closeIdle
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// we can run out of memory if we have too many threads
comment|// log the event and sleep for a minute and give
comment|// some thread(s) a chance to finish
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|": OutOfMemoryError in server select"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|connectionManager
operator|.
name|closeIdle
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|60000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Interrupted while sleeping"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": stopping"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|acceptChannel
operator|.
name|close
argument_list|()
expr_stmt|;
name|selector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
name|selector
operator|=
literal|null
expr_stmt|;
name|acceptChannel
operator|=
literal|null
expr_stmt|;
comment|// close all connections
name|connectionManager
operator|.
name|stopIdleScan
argument_list|()
expr_stmt|;
name|connectionManager
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|closeCurrentConnection
parameter_list|(
name|SelectionKey
name|key
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|Connection
name|c
init|=
operator|(
name|Connection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|closeConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|key
operator|.
name|attach
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|InetSocketAddress
name|getAddress
parameter_list|()
block|{
return|return
name|address
return|;
block|}
name|void
name|doAccept
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
throws|,
name|OutOfMemoryError
block|{
name|ServerSocketChannel
name|server
init|=
operator|(
name|ServerSocketChannel
operator|)
name|key
operator|.
name|channel
argument_list|()
decl_stmt|;
name|SocketChannel
name|channel
decl_stmt|;
while|while
condition|(
operator|(
name|channel
operator|=
name|server
operator|.
name|accept
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|channel
operator|.
name|configureBlocking
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|channel
operator|.
name|socket
argument_list|()
operator|.
name|setTcpNoDelay
argument_list|(
name|tcpNoDelay
argument_list|)
expr_stmt|;
name|channel
operator|.
name|socket
argument_list|()
operator|.
name|setKeepAlive
argument_list|(
name|tcpKeepAlive
argument_list|)
expr_stmt|;
name|Reader
name|reader
init|=
name|getReader
argument_list|()
decl_stmt|;
name|Connection
name|c
init|=
name|connectionManager
operator|.
name|register
argument_list|(
name|channel
argument_list|)
decl_stmt|;
comment|// If the connectionManager can't take it, close the connection.
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|key
operator|.
name|attach
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// so closeCurrentConnection can get the object
name|reader
operator|.
name|addConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|doRead
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|int
name|count
decl_stmt|;
name|Connection
name|c
init|=
operator|(
name|Connection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|c
operator|.
name|setLastContact
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|count
operator|=
name|c
operator|.
name|readAndProcess
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ieo
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": readAndProcess caught InterruptedException"
argument_list|,
name|ieo
argument_list|)
expr_stmt|;
throw|throw
name|ieo
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": Caught exception while reading:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
operator|-
literal|1
expr_stmt|;
comment|//so that the (count< 0) block is executed
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|closeConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|setLastContact
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|synchronized
name|void
name|doStop
parameter_list|()
block|{
if|if
condition|(
name|selector
operator|!=
literal|null
condition|)
block|{
name|selector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|acceptChannel
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exception in closing listener socket. "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|readPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
comment|// The method that will return the next reader to work with
comment|// Simplistic implementation of round robin for now
name|Reader
name|getReader
parameter_list|()
block|{
name|currentReader
operator|=
operator|(
name|currentReader
operator|+
literal|1
operator|)
operator|%
name|readers
operator|.
name|length
expr_stmt|;
return|return
name|readers
index|[
name|currentReader
index|]
return|;
block|}
block|}
comment|// Sends responses of RPC back to clients.
specifier|protected
class|class
name|Responder
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|Selector
name|writeSelector
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|Connection
argument_list|>
name|writingCons
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|Connection
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|Responder
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|setName
argument_list|(
literal|"RpcServer.responder"
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|setUncaughtExceptionHandler
argument_list|(
name|Threads
operator|.
name|LOGGING_EXCEPTION_HANDLER
argument_list|)
expr_stmt|;
name|writeSelector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
comment|// create a selector
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": starting"
argument_list|)
expr_stmt|;
try|try
block|{
name|doRunLoop
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": stopping"
argument_list|)
expr_stmt|;
try|try
block|{
name|writeSelector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getName
argument_list|()
operator|+
literal|": couldn't close write selector"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Take the list of the connections that want to write, and register them      * in the selector.      */
specifier|private
name|void
name|registerWrites
parameter_list|()
block|{
name|Iterator
argument_list|<
name|Connection
argument_list|>
name|it
init|=
name|writingCons
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Connection
name|c
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|SelectionKey
name|sk
init|=
name|c
operator|.
name|channel
operator|.
name|keyFor
argument_list|(
name|writeSelector
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|sk
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|c
operator|.
name|channel
operator|.
name|register
argument_list|(
name|writeSelector
argument_list|,
name|SelectionKey
operator|.
name|OP_WRITE
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
comment|// ignore: the client went away.
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sk
operator|.
name|interestOps
argument_list|(
name|SelectionKey
operator|.
name|OP_WRITE
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CancelledKeyException
name|e
parameter_list|)
block|{
comment|// ignore: the client went away.
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Add a connection to the list that want to write,      */
specifier|public
name|void
name|registerForWrite
parameter_list|(
name|Connection
name|c
parameter_list|)
block|{
if|if
condition|(
name|writingCons
operator|.
name|add
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|writeSelector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|doRunLoop
parameter_list|()
block|{
name|long
name|lastPurgeTime
init|=
literal|0
decl_stmt|;
comment|// last check for old calls.
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|registerWrites
argument_list|()
expr_stmt|;
name|int
name|keyCt
init|=
name|writeSelector
operator|.
name|select
argument_list|(
name|purgeTimeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyCt
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|Set
argument_list|<
name|SelectionKey
argument_list|>
name|keys
init|=
name|writeSelector
operator|.
name|selectedKeys
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|keys
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SelectionKey
name|key
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|key
operator|.
name|isValid
argument_list|()
operator|&&
name|key
operator|.
name|isWritable
argument_list|()
condition|)
block|{
name|doAsyncWrite
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": asyncWrite"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|lastPurgeTime
operator|=
name|purge
argument_list|(
name|lastPurgeTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|e
parameter_list|)
block|{
if|if
condition|(
name|errorHandler
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|errorHandler
operator|.
name|checkOOME
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exiting on OutOfMemoryError"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|//
comment|// we can run out of memory if we have too many threads
comment|// log the event and sleep for a minute and give
comment|// some thread(s) a chance to finish
comment|//
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|": OutOfMemoryError in server select"
argument_list|,
name|e
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|60000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Interrupted while sleeping"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exception in Responder "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": stopped"
argument_list|)
expr_stmt|;
block|}
comment|/**      * If there were some calls that have not been sent out for a      * long time, we close the connection.      * @return the time of the purge.      */
specifier|private
name|long
name|purge
parameter_list|(
name|long
name|lastPurgeTime
parameter_list|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|<
name|lastPurgeTime
operator|+
name|purgeTimeout
condition|)
block|{
return|return
name|lastPurgeTime
return|;
block|}
name|ArrayList
argument_list|<
name|Connection
argument_list|>
name|conWithOldCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// get the list of channels from list of keys.
synchronized|synchronized
init|(
name|writeSelector
operator|.
name|keys
argument_list|()
init|)
block|{
for|for
control|(
name|SelectionKey
name|key
range|:
name|writeSelector
operator|.
name|keys
argument_list|()
control|)
block|{
name|Connection
name|connection
init|=
operator|(
name|Connection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Coding error: SelectionKey key without attachment."
argument_list|)
throw|;
block|}
name|Call
name|call
init|=
name|connection
operator|.
name|responseQueue
operator|.
name|peekFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
operator|&&
name|now
operator|>
name|call
operator|.
name|timestamp
operator|+
name|purgeTimeout
condition|)
block|{
name|conWithOldCalls
operator|.
name|add
argument_list|(
name|call
operator|.
name|getConnection
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Seems safer to close the connection outside of the synchronized loop...
for|for
control|(
name|Connection
name|connection
range|:
name|conWithOldCalls
control|)
block|{
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
return|return
name|now
return|;
block|}
specifier|private
name|void
name|doAsyncWrite
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|Connection
name|connection
init|=
operator|(
name|Connection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"doAsyncWrite: no connection"
argument_list|)
throw|;
block|}
if|if
condition|(
name|key
operator|.
name|channel
argument_list|()
operator|!=
name|connection
operator|.
name|channel
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"doAsyncWrite: bad channel"
argument_list|)
throw|;
block|}
if|if
condition|(
name|processAllResponses
argument_list|(
name|connection
argument_list|)
condition|)
block|{
try|try
block|{
comment|// We wrote everything, so we don't need to be told when the socket is ready for
comment|//  write anymore.
name|key
operator|.
name|interestOps
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancelledKeyException
name|e
parameter_list|)
block|{
comment|/* The Listener/reader might have closed the socket.            * We don't explicitly cancel the key, so not sure if this will            * ever fire.            * This warning could be removed.            */
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while changing ops : "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Process the response for this call. You need to have the lock on      * {@link org.apache.hadoop.hbase.ipc.SimpleRpcServer.Connection#responseWriteLock}      *      * @param call the call      * @return true if we proceed the call fully, false otherwise.      * @throws IOException      */
specifier|private
name|boolean
name|processResponse
parameter_list|(
specifier|final
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|error
init|=
literal|true
decl_stmt|;
try|try
block|{
comment|// Send as much data as we can in the non-blocking fashion
name|long
name|numBytes
init|=
name|channelWrite
argument_list|(
name|call
operator|.
name|getConnection
argument_list|()
operator|.
name|channel
argument_list|,
name|call
operator|.
name|response
argument_list|)
decl_stmt|;
if|if
condition|(
name|numBytes
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
literal|"Error writing on the socket "
operator|+
literal|"for the call:"
operator|+
name|call
operator|.
name|toShortString
argument_list|()
argument_list|)
throw|;
block|}
name|error
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|error
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
name|call
operator|.
name|toShortString
argument_list|()
operator|+
literal|": output error -- closing"
argument_list|)
expr_stmt|;
comment|// We will be closing this connection itself. Mark this call as done so that all the
comment|// buffer(s) it got from pool can get released
name|call
operator|.
name|done
argument_list|()
expr_stmt|;
name|closeConnection
argument_list|(
name|call
operator|.
name|getConnection
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|call
operator|.
name|response
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|call
operator|.
name|done
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
comment|// Socket can't take more, we will have to come back.
block|}
block|}
comment|/**      * Process all the responses for this connection      *      * @return true if all the calls were processed or that someone else is doing it.      * false if there * is still some work to do. In this case, we expect the caller to      * delay us.      * @throws IOException      */
specifier|private
name|boolean
name|processAllResponses
parameter_list|(
specifier|final
name|Connection
name|connection
parameter_list|)
throws|throws
name|IOException
block|{
comment|// We want only one writer on the channel for a connection at a time.
name|connection
operator|.
name|responseWriteLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
comment|// protection if some handlers manage to need all the responder
name|Call
name|call
init|=
name|connection
operator|.
name|responseQueue
operator|.
name|pollFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|processResponse
argument_list|(
name|call
argument_list|)
condition|)
block|{
name|connection
operator|.
name|responseQueue
operator|.
name|addFirst
argument_list|(
name|call
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
finally|finally
block|{
name|connection
operator|.
name|responseWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|connection
operator|.
name|responseQueue
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|//
comment|// Enqueue a response from the application.
comment|//
name|void
name|doRespond
parameter_list|(
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
comment|// If there is already a write in progress, we don't wait. This allows to free the handlers
comment|//  immediately for other tasks.
if|if
condition|(
name|call
operator|.
name|getConnection
argument_list|()
operator|.
name|responseQueue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|call
operator|.
name|getConnection
argument_list|()
operator|.
name|responseWriteLock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
name|call
operator|.
name|getConnection
argument_list|()
operator|.
name|responseQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If we're alone, we can try to do a direct call to the socket. It's
comment|//  an optimisation to save on context switches and data transfer between cores..
if|if
condition|(
name|processResponse
argument_list|(
name|call
argument_list|)
condition|)
block|{
return|return;
comment|// we're done.
block|}
comment|// Too big to fit, putting ahead.
name|call
operator|.
name|getConnection
argument_list|()
operator|.
name|responseQueue
operator|.
name|addFirst
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
comment|// We will register to the selector later, outside of the lock.
block|}
block|}
finally|finally
block|{
name|call
operator|.
name|getConnection
argument_list|()
operator|.
name|responseWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|call
operator|.
name|getConnection
argument_list|()
operator|.
name|responseQueue
operator|.
name|addLast
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
name|call
operator|.
name|responder
operator|.
name|registerForWrite
argument_list|(
name|call
operator|.
name|getConnection
argument_list|()
argument_list|)
expr_stmt|;
comment|// set the serve time when the response has to be sent later
name|call
operator|.
name|timestamp
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Reads calls from a connection and queues them for handling. */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"VO_VOLATILE_INCREMENT"
argument_list|,
name|justification
operator|=
literal|"False positive according to http://sourceforge.net/p/findbugs/bugs/1032/"
argument_list|)
specifier|public
class|class
name|Connection
extends|extends
name|RpcServer
operator|.
name|Connection
block|{
specifier|protected
name|SocketChannel
name|channel
decl_stmt|;
specifier|private
name|ByteBuff
name|data
decl_stmt|;
specifier|private
name|ByteBuffer
name|dataLengthBuffer
decl_stmt|;
specifier|protected
specifier|final
name|ConcurrentLinkedDeque
argument_list|<
name|Call
argument_list|>
name|responseQueue
init|=
operator|new
name|ConcurrentLinkedDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|responseWriteLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
name|LongAdder
name|rpcCount
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
comment|// number of outstanding rpcs
specifier|private
name|long
name|lastContact
decl_stmt|;
specifier|protected
name|Socket
name|socket
decl_stmt|;
specifier|public
name|Connection
parameter_list|(
name|SocketChannel
name|channel
parameter_list|,
name|long
name|lastContact
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|channel
operator|=
name|channel
expr_stmt|;
name|this
operator|.
name|lastContact
operator|=
name|lastContact
expr_stmt|;
name|this
operator|.
name|data
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|dataLengthBuffer
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|=
name|channel
operator|.
name|socket
argument_list|()
expr_stmt|;
name|this
operator|.
name|addr
operator|=
name|socket
operator|.
name|getInetAddress
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|hostAddress
operator|=
literal|"*Unknown*"
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|hostAddress
operator|=
name|addr
operator|.
name|getHostAddress
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|remotePort
operator|=
name|socket
operator|.
name|getPort
argument_list|()
expr_stmt|;
if|if
condition|(
name|socketSendBufferSize
operator|!=
literal|0
condition|)
block|{
try|try
block|{
name|socket
operator|.
name|setSendBufferSize
argument_list|(
name|socketSendBufferSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Connection: unable to set socket send buffer size to "
operator|+
name|socketSendBufferSize
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|saslCall
operator|=
operator|new
name|Call
argument_list|(
name|SASL_CALLID
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
name|responder
argument_list|)
expr_stmt|;
name|this
operator|.
name|setConnectionHeaderResponseCall
operator|=
operator|new
name|Call
argument_list|(
name|CONNECTION_HEADER_RESPONSE_CALLID
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
name|responder
argument_list|)
expr_stmt|;
name|this
operator|.
name|authFailedCall
operator|=
operator|new
name|Call
argument_list|(
name|AUTHORIZATION_FAILED_CALLID
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
name|responder
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setLastContact
parameter_list|(
name|long
name|lastContact
parameter_list|)
block|{
name|this
operator|.
name|lastContact
operator|=
name|lastContact
expr_stmt|;
block|}
specifier|public
name|long
name|getLastContact
parameter_list|()
block|{
return|return
name|lastContact
return|;
block|}
comment|/* Return true if the connection has no outstanding rpc */
specifier|private
name|boolean
name|isIdle
parameter_list|()
block|{
return|return
name|rpcCount
operator|.
name|sum
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/* Decrement the outstanding RPC count */
specifier|protected
name|void
name|decRpcCount
parameter_list|()
block|{
name|rpcCount
operator|.
name|decrement
argument_list|()
expr_stmt|;
block|}
comment|/* Increment the outstanding RPC count */
specifier|protected
name|void
name|incRpcCount
parameter_list|()
block|{
name|rpcCount
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
specifier|private
name|int
name|readPreamble
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|count
decl_stmt|;
comment|// Check for 'HBas' magic.
name|this
operator|.
name|dataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|HConstants
operator|.
name|RPC_HEADER
argument_list|,
name|dataLengthBuffer
operator|.
name|array
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|doBadPreambleHandling
argument_list|(
literal|"Expected HEADER="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|HConstants
operator|.
name|RPC_HEADER
argument_list|)
operator|+
literal|" but received HEADER="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|dataLengthBuffer
operator|.
name|array
argument_list|()
argument_list|)
operator|+
literal|" from "
operator|+
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|// Now read the next two bytes, the version and the auth to use.
name|ByteBuffer
name|versionAndAuthBytes
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|count
operator|=
name|channelRead
argument_list|(
name|channel
argument_list|,
name|versionAndAuthBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
argument_list|<
literal|0
operator|||
name|versionAndAuthBytes
operator|.
name|remaining
operator|(
operator|)
argument_list|>
literal|0
condition|)
block|{
return|return
name|count
return|;
block|}
name|int
name|version
init|=
name|versionAndAuthBytes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|byte
name|authbyte
init|=
name|versionAndAuthBytes
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|this
operator|.
name|authMethod
operator|=
name|AuthMethod
operator|.
name|valueOf
argument_list|(
name|authbyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|CURRENT_VERSION
condition|)
block|{
name|String
name|msg
init|=
name|getFatalConnectionString
argument_list|(
name|version
argument_list|,
name|authbyte
argument_list|)
decl_stmt|;
return|return
name|doBadPreambleHandling
argument_list|(
name|msg
argument_list|,
operator|new
name|WrongVersionException
argument_list|(
name|msg
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|authMethod
operator|==
literal|null
condition|)
block|{
name|String
name|msg
init|=
name|getFatalConnectionString
argument_list|(
name|version
argument_list|,
name|authbyte
argument_list|)
decl_stmt|;
return|return
name|doBadPreambleHandling
argument_list|(
name|msg
argument_list|,
operator|new
name|BadAuthException
argument_list|(
name|msg
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|isSecurityEnabled
operator|&&
name|authMethod
operator|==
name|AuthMethod
operator|.
name|SIMPLE
condition|)
block|{
if|if
condition|(
name|allowFallbackToSimpleAuth
condition|)
block|{
name|metrics
operator|.
name|authenticationFallback
argument_list|()
expr_stmt|;
name|authenticatedWithFallback
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|AccessDeniedException
name|ae
init|=
operator|new
name|AccessDeniedException
argument_list|(
literal|"Authentication is required"
argument_list|)
decl_stmt|;
name|setupResponse
argument_list|(
name|authFailedResponse
argument_list|,
name|authFailedCall
argument_list|,
name|ae
argument_list|,
name|ae
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|authFailedCall
operator|.
name|sendResponseIfReady
argument_list|()
expr_stmt|;
throw|throw
name|ae
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|isSecurityEnabled
operator|&&
name|authMethod
operator|!=
name|AuthMethod
operator|.
name|SIMPLE
condition|)
block|{
name|doRawSaslReply
argument_list|(
name|SaslStatus
operator|.
name|SUCCESS
argument_list|,
operator|new
name|IntWritable
argument_list|(
name|SaslUtil
operator|.
name|SWITCH_TO_SIMPLE_AUTH
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|authMethod
operator|=
name|AuthMethod
operator|.
name|SIMPLE
expr_stmt|;
comment|// client has already sent the initial Sasl message and we
comment|// should ignore it. Both client and server should fall back
comment|// to simple auth from now on.
name|skipInitialSaslHandshake
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|authMethod
operator|!=
name|AuthMethod
operator|.
name|SIMPLE
condition|)
block|{
name|useSasl
operator|=
literal|true
expr_stmt|;
block|}
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|connectionPreambleRead
operator|=
literal|true
expr_stmt|;
return|return
name|count
return|;
block|}
specifier|private
name|int
name|read4Bytes
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|dataLengthBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
name|channelRead
argument_list|(
name|channel
argument_list|,
name|this
operator|.
name|dataLengthBuffer
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/**      * Read off the wire. If there is not enough data to read, update the connection state with      *  what we have and returns.      * @return Returns -1 if failure (and caller will close connection), else zero or more.      * @throws IOException      * @throws InterruptedException      */
specifier|public
name|int
name|readAndProcess
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// Try and read in an int.  If new connection, the int will hold the 'HBas' HEADER.  If it
comment|// does, read in the rest of the connection preamble, the version and the auth method.
comment|// Else it will be length of the data to read (or -1 if a ping).  We catch the integer
comment|// length into the 4-byte this.dataLengthBuffer.
name|int
name|count
init|=
name|read4Bytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
argument_list|<
literal|0
operator|||
name|dataLengthBuffer
operator|.
name|remaining
operator|(
operator|)
argument_list|>
literal|0
condition|)
block|{
return|return
name|count
return|;
block|}
comment|// If we have not read the connection setup preamble, look to see if that is on the wire.
if|if
condition|(
operator|!
name|connectionPreambleRead
condition|)
block|{
name|count
operator|=
name|readPreamble
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|connectionPreambleRead
condition|)
block|{
return|return
name|count
return|;
block|}
name|count
operator|=
name|read4Bytes
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
argument_list|<
literal|0
operator|||
name|dataLengthBuffer
operator|.
name|remaining
operator|(
operator|)
argument_list|>
literal|0
condition|)
block|{
return|return
name|count
return|;
block|}
block|}
comment|// We have read a length and we have read the preamble.  It is either the connection header
comment|// or it is a request.
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|dataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|int
name|dataLength
init|=
name|dataLengthBuffer
operator|.
name|getInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataLength
operator|==
name|RpcClient
operator|.
name|PING_CALL_ID
condition|)
block|{
if|if
condition|(
operator|!
name|useWrap
condition|)
block|{
comment|//covers the !useSasl too
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
comment|//ping message
block|}
block|}
if|if
condition|(
name|dataLength
operator|<
literal|0
condition|)
block|{
comment|// A data length of zero is legal.
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
literal|"Unexpected data length "
operator|+
name|dataLength
operator|+
literal|"!! from "
operator|+
name|getHostAddress
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|dataLength
operator|>
name|maxRequestSize
condition|)
block|{
name|String
name|msg
init|=
literal|"RPC data length of "
operator|+
name|dataLength
operator|+
literal|" received from "
operator|+
name|getHostAddress
argument_list|()
operator|+
literal|" is greater than max allowed "
operator|+
name|maxRequestSize
operator|+
literal|". Set \""
operator|+
name|MAX_REQUEST_SIZE
operator|+
literal|"\" on server to override this limit (not recommended)"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|connectionHeaderRead
operator|&&
name|connectionPreambleRead
condition|)
block|{
name|incRpcCount
argument_list|()
expr_stmt|;
comment|// Construct InputStream for the non-blocking SocketChannel
comment|// We need the InputStream because we want to read only the request header
comment|// instead of the whole rpc.
name|ByteBuffer
name|buf
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|InputStream
name|is
init|=
operator|new
name|InputStream
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|channelRead
argument_list|(
name|channel
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|flip
argument_list|()
expr_stmt|;
name|int
name|x
init|=
name|buf
operator|.
name|get
argument_list|()
decl_stmt|;
name|buf
operator|.
name|flip
argument_list|()
expr_stmt|;
return|return
name|x
return|;
block|}
block|}
decl_stmt|;
name|CodedInputStream
name|cis
init|=
name|CodedInputStream
operator|.
name|newInstance
argument_list|(
name|is
argument_list|)
decl_stmt|;
name|int
name|headerSize
init|=
name|cis
operator|.
name|readRawVarint32
argument_list|()
decl_stmt|;
name|Message
operator|.
name|Builder
name|builder
init|=
name|RequestHeader
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ProtobufUtil
operator|.
name|mergeFrom
argument_list|(
name|builder
argument_list|,
name|cis
argument_list|,
name|headerSize
argument_list|)
expr_stmt|;
name|RequestHeader
name|header
init|=
operator|(
name|RequestHeader
operator|)
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Notify the client about the offending request
name|Call
name|reqTooBig
init|=
operator|new
name|Call
argument_list|(
name|header
operator|.
name|getCallId
argument_list|()
argument_list|,
name|this
operator|.
name|service
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
name|this
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
name|responder
argument_list|)
decl_stmt|;
name|metrics
operator|.
name|exception
argument_list|(
name|REQUEST_TOO_BIG_EXCEPTION
argument_list|)
expr_stmt|;
comment|// Make sure the client recognizes the underlying exception
comment|// Otherwise, throw a DoNotRetryIOException.
if|if
condition|(
name|VersionInfoUtil
operator|.
name|hasMinimumVersion
argument_list|(
name|connectionHeader
operator|.
name|getVersionInfo
argument_list|()
argument_list|,
name|RequestTooBigException
operator|.
name|MAJOR_VERSION
argument_list|,
name|RequestTooBigException
operator|.
name|MINOR_VERSION
argument_list|)
condition|)
block|{
name|setupResponse
argument_list|(
literal|null
argument_list|,
name|reqTooBig
argument_list|,
name|REQUEST_TOO_BIG_EXCEPTION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setupResponse
argument_list|(
literal|null
argument_list|,
name|reqTooBig
argument_list|,
operator|new
name|DoNotRetryIOException
argument_list|()
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|// We are going to close the connection, make sure we process the response
comment|// before that. In rare case when this fails, we still close the connection.
name|responseWriteLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|responder
operator|.
name|processResponse
argument_list|(
name|reqTooBig
argument_list|)
expr_stmt|;
name|responseWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Close the connection
return|return
operator|-
literal|1
return|;
block|}
comment|// Initialize this.data with a ByteBuff.
comment|// This call will allocate a ByteBuff to read request into and assign to this.data
comment|// Also when we use some buffer(s) from pool, it will create a CallCleanup instance also and
comment|// assign to this.callCleanup
name|initByteBuffToReadInto
argument_list|(
name|dataLength
argument_list|)
expr_stmt|;
comment|// Increment the rpc count. This counter will be decreased when we write
comment|//  the response.  If we want the connection to be detected as idle properly, we
comment|//  need to keep the inc / dec correct.
name|incRpcCount
argument_list|()
expr_stmt|;
block|}
name|count
operator|=
name|channelDataRead
argument_list|(
name|channel
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|0
operator|&&
name|data
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// count==0 if dataLength == 0
name|process
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|// It creates the ByteBuff and CallCleanup and assign to Connection instance.
specifier|private
name|void
name|initByteBuffToReadInto
parameter_list|(
name|int
name|length
parameter_list|)
block|{
comment|// We create random on heap buffers are read into those when
comment|// 1. ByteBufferPool is not there.
comment|// 2. When the size of the req is very small. Using a large sized (64 KB) buffer from pool is
comment|// waste then. Also if all the reqs are of this size, we will be creating larger sized
comment|// buffers and pool them permanently. This include Scan/Get request and DDL kind of reqs like
comment|// RegionOpen.
comment|// 3. If it is an initial handshake signal or initial connection request. Any way then
comment|// condition 2 itself will match
comment|// 4. When SASL use is ON.
if|if
condition|(
name|reservoir
operator|==
literal|null
operator|||
name|skipInitialSaslHandshake
operator|||
operator|!
name|connectionHeaderRead
operator|||
name|useSasl
operator|||
name|length
operator|<
name|minSizeForReservoirUse
condition|)
block|{
name|this
operator|.
name|data
operator|=
operator|new
name|SingleByteBuff
argument_list|(
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Pair
argument_list|<
name|ByteBuff
argument_list|,
name|CallCleanup
argument_list|>
name|pair
init|=
name|RpcServer
operator|.
name|allocateByteBuffToReadInto
argument_list|(
name|reservoir
argument_list|,
name|minSizeForReservoirUse
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|this
operator|.
name|data
operator|=
name|pair
operator|.
name|getFirst
argument_list|()
expr_stmt|;
name|this
operator|.
name|callCleanup
operator|=
name|pair
operator|.
name|getSecond
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
name|int
name|channelDataRead
parameter_list|(
name|ReadableByteChannel
name|channel
parameter_list|,
name|ByteBuff
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|count
init|=
name|buf
operator|.
name|read
argument_list|(
name|channel
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|metrics
operator|.
name|receivedBytes
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**      * Process the data buffer and clean the connection state for the next call.      */
specifier|private
name|void
name|process
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|data
operator|.
name|rewind
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|skipInitialSaslHandshake
condition|)
block|{
name|skipInitialSaslHandshake
operator|=
literal|false
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|useSasl
condition|)
block|{
name|saslReadAndProcess
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|processOneRpc
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Clean for the next call
name|data
operator|=
literal|null
expr_stmt|;
comment|// For the GC
name|this
operator|.
name|callCleanup
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|doBadPreambleHandling
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|doBadPreambleHandling
argument_list|(
name|msg
argument_list|,
operator|new
name|FatalConnectionException
argument_list|(
name|msg
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|int
name|doBadPreambleHandling
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|,
specifier|final
name|Exception
name|e
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|Call
name|fakeCall
init|=
operator|new
name|Call
argument_list|(
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
name|responder
argument_list|)
decl_stmt|;
name|setupResponse
argument_list|(
literal|null
argument_list|,
name|fakeCall
argument_list|,
name|e
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|responder
operator|.
name|doRespond
argument_list|(
name|fakeCall
argument_list|)
expr_stmt|;
comment|// Returning -1 closes out the connection.
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
name|disposeSasl
argument_list|()
expr_stmt|;
name|data
operator|=
literal|null
expr_stmt|;
name|callCleanup
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
return|return;
try|try
block|{
name|socket
operator|.
name|shutdownOutput
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Ignored exception"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
block|{
try|try
block|{
name|channel
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
block|}
try|try
block|{
name|socket
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Ignored exception"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isConnectionOpen
parameter_list|()
block|{
return|return
name|channel
operator|.
name|isOpen
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|RpcServer
operator|.
name|Call
name|createCall
parameter_list|(
name|int
name|id
parameter_list|,
specifier|final
name|BlockingService
name|service
parameter_list|,
specifier|final
name|MethodDescriptor
name|md
parameter_list|,
name|RequestHeader
name|header
parameter_list|,
name|Message
name|param
parameter_list|,
name|CellScanner
name|cellScanner
parameter_list|,
name|RpcServer
operator|.
name|Connection
name|connection
parameter_list|,
name|long
name|size
parameter_list|,
name|TraceInfo
name|tinfo
parameter_list|,
specifier|final
name|InetAddress
name|remoteAddress
parameter_list|,
name|int
name|timeout
parameter_list|,
name|CallCleanup
name|reqCleanup
parameter_list|)
block|{
return|return
operator|new
name|Call
argument_list|(
name|id
argument_list|,
name|service
argument_list|,
name|md
argument_list|,
name|header
argument_list|,
name|param
argument_list|,
name|cellScanner
argument_list|,
name|connection
argument_list|,
name|size
argument_list|,
name|tinfo
argument_list|,
name|remoteAddress
argument_list|,
name|timeout
argument_list|,
name|reqCleanup
argument_list|,
name|responder
argument_list|)
return|;
block|}
block|}
comment|/**    * Constructs a server listening on the named port and address.    * @param server hosting instance of {@link Server}. We will do authentications if an    * instance else pass null for no authentication check.    * @param name Used keying this rpc servers' metrics and for naming the Listener thread.    * @param services A list of services.    * @param bindAddress Where to listen    * @param conf    * @param scheduler    */
specifier|public
name|SimpleRpcServer
parameter_list|(
specifier|final
name|Server
name|server
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|InetSocketAddress
name|bindAddress
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|RpcScheduler
name|scheduler
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|server
argument_list|,
name|name
argument_list|,
name|services
argument_list|,
name|bindAddress
argument_list|,
name|conf
argument_list|,
name|scheduler
argument_list|)
expr_stmt|;
name|this
operator|.
name|socketSendBufferSize
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|readThreads
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.read.threadpool.size"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|purgeTimeout
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.ipc.client.call.purge.timeout"
argument_list|,
literal|2
operator|*
name|HConstants
operator|.
name|DEFAULT_HBASE_RPC_TIMEOUT
argument_list|)
expr_stmt|;
comment|// Start the listener here and let it bind to the port
name|listener
operator|=
operator|new
name|Listener
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|port
operator|=
name|listener
operator|.
name|getAddress
argument_list|()
operator|.
name|getPort
argument_list|()
expr_stmt|;
comment|// Create the responder here
name|responder
operator|=
operator|new
name|Responder
argument_list|()
expr_stmt|;
name|connectionManager
operator|=
operator|new
name|ConnectionManager
argument_list|()
expr_stmt|;
name|initReconfigurable
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|scheduler
operator|.
name|init
argument_list|(
operator|new
name|RpcSchedulerContext
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Subclasses of HBaseServer can override this to provide their own    * Connection implementations.    */
specifier|protected
name|Connection
name|getConnection
parameter_list|(
name|SocketChannel
name|channel
parameter_list|,
name|long
name|time
parameter_list|)
block|{
return|return
operator|new
name|Connection
argument_list|(
name|channel
argument_list|,
name|time
argument_list|)
return|;
block|}
specifier|protected
name|void
name|closeConnection
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
name|connectionManager
operator|.
name|close
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
comment|/** Sets the socket buffer size used for responding to RPCs.    * @param size send size    */
annotation|@
name|Override
specifier|public
name|void
name|setSocketSendBufSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|socketSendBufferSize
operator|=
name|size
expr_stmt|;
block|}
comment|/** Starts the service.  Must be called before any calls will be handled. */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|start
parameter_list|()
block|{
if|if
condition|(
name|started
condition|)
return|return;
name|authTokenSecretMgr
operator|=
name|createSecretManager
argument_list|()
expr_stmt|;
if|if
condition|(
name|authTokenSecretMgr
operator|!=
literal|null
condition|)
block|{
name|setSecretManager
argument_list|(
name|authTokenSecretMgr
argument_list|)
expr_stmt|;
name|authTokenSecretMgr
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|authManager
operator|=
operator|new
name|ServiceAuthorizationManager
argument_list|()
expr_stmt|;
name|HBasePolicyProvider
operator|.
name|init
argument_list|(
name|conf
argument_list|,
name|authManager
argument_list|)
expr_stmt|;
name|responder
operator|.
name|start
argument_list|()
expr_stmt|;
name|listener
operator|.
name|start
argument_list|()
expr_stmt|;
name|scheduler
operator|.
name|start
argument_list|()
expr_stmt|;
name|started
operator|=
literal|true
expr_stmt|;
block|}
comment|/** Stops the service.  No new calls will be handled after this is called. */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|stop
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping server on "
operator|+
name|port
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|authTokenSecretMgr
operator|!=
literal|null
condition|)
block|{
name|authTokenSecretMgr
operator|.
name|stop
argument_list|()
expr_stmt|;
name|authTokenSecretMgr
operator|=
literal|null
expr_stmt|;
block|}
name|listener
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|listener
operator|.
name|doStop
argument_list|()
expr_stmt|;
name|responder
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|scheduler
operator|.
name|stop
argument_list|()
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/** Wait for the server to be stopped.    * Does not wait for all subthreads to finish.    *  See {@link #stop()}.    * @throws InterruptedException e    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|join
parameter_list|()
throws|throws
name|InterruptedException
block|{
while|while
condition|(
name|running
condition|)
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Return the socket (ip+port) on which the RPC server is listening to. May return null if    * the listener channel is closed.    * @return the socket (ip+port) on which the RPC server is listening to, or null if this    * information cannot be determined    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|InetSocketAddress
name|getListenerAddress
parameter_list|()
block|{
if|if
condition|(
name|listener
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|listener
operator|.
name|getAddress
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
name|call
parameter_list|(
name|BlockingService
name|service
parameter_list|,
name|MethodDescriptor
name|md
parameter_list|,
name|Message
name|param
parameter_list|,
name|CellScanner
name|cellScanner
parameter_list|,
name|long
name|receiveTime
parameter_list|,
name|MonitoredRPCHandler
name|status
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|call
argument_list|(
name|service
argument_list|,
name|md
argument_list|,
name|param
argument_list|,
name|cellScanner
argument_list|,
name|receiveTime
argument_list|,
name|status
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
name|call
parameter_list|(
name|BlockingService
name|service
parameter_list|,
name|MethodDescriptor
name|md
parameter_list|,
name|Message
name|param
parameter_list|,
name|CellScanner
name|cellScanner
parameter_list|,
name|long
name|receiveTime
parameter_list|,
name|MonitoredRPCHandler
name|status
parameter_list|,
name|long
name|startTime
parameter_list|,
name|int
name|timeout
parameter_list|)
throws|throws
name|IOException
block|{
name|Call
name|fakeCall
init|=
operator|new
name|Call
argument_list|(
operator|-
literal|1
argument_list|,
name|service
argument_list|,
name|md
argument_list|,
literal|null
argument_list|,
name|param
argument_list|,
name|cellScanner
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|timeout
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|fakeCall
operator|.
name|setReceiveTime
argument_list|(
name|receiveTime
argument_list|)
expr_stmt|;
return|return
name|call
argument_list|(
name|fakeCall
argument_list|,
name|status
argument_list|)
return|;
block|}
comment|/**    * This is a wrapper around {@link java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)}.    * If the amount of data is large, it writes to channel in smaller chunks.    * This is to avoid jdk from creating many direct buffers as the size of    * buffer increases. This also minimizes extra copies in NIO layer    * as a result of multiple write operations required to write a large    * buffer.    *    * @param channel writable byte channel to write to    * @param bufferChain Chain of buffers to write    * @return number of bytes written    * @throws java.io.IOException e    * @see java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)    */
specifier|protected
name|long
name|channelWrite
parameter_list|(
name|GatheringByteChannel
name|channel
parameter_list|,
name|BufferChain
name|bufferChain
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|count
init|=
name|bufferChain
operator|.
name|write
argument_list|(
name|channel
argument_list|,
name|NIO_BUFFER_LIMIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|this
operator|.
name|metrics
operator|.
name|sentBytes
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
comment|/**    * A convenience method to bind to a given address and report    * better exceptions if the address is not a valid host.    * @param socket the socket to bind    * @param address the address to bind to    * @param backlog the number of connections allowed in the queue    * @throws BindException if the address can't be bound    * @throws UnknownHostException if the address isn't a valid host name    * @throws IOException other random errors from bind    */
specifier|public
specifier|static
name|void
name|bind
parameter_list|(
name|ServerSocket
name|socket
parameter_list|,
name|InetSocketAddress
name|address
parameter_list|,
name|int
name|backlog
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|socket
operator|.
name|bind
argument_list|(
name|address
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BindException
name|e
parameter_list|)
block|{
name|BindException
name|bindException
init|=
operator|new
name|BindException
argument_list|(
literal|"Problem binding to "
operator|+
name|address
operator|+
literal|" : "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|bindException
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|bindException
throw|;
block|}
catch|catch
parameter_list|(
name|SocketException
name|e
parameter_list|)
block|{
comment|// If they try to bind to a different host's address, give a better
comment|// error message.
if|if
condition|(
literal|"Unresolved address"
operator|.
name|equals
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnknownHostException
argument_list|(
literal|"Invalid hostname for server: "
operator|+
name|address
operator|.
name|getHostName
argument_list|()
argument_list|)
throw|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * The number of open RPC conections    * @return the number of open rpc connections    */
specifier|public
name|int
name|getNumOpenConnections
parameter_list|()
block|{
return|return
name|connectionManager
operator|.
name|size
argument_list|()
return|;
block|}
specifier|private
class|class
name|ConnectionManager
block|{
specifier|final
specifier|private
name|AtomicInteger
name|count
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
specifier|final
specifier|private
name|Set
argument_list|<
name|Connection
argument_list|>
name|connections
decl_stmt|;
specifier|final
specifier|private
name|Timer
name|idleScanTimer
decl_stmt|;
specifier|final
specifier|private
name|int
name|idleScanThreshold
decl_stmt|;
specifier|final
specifier|private
name|int
name|idleScanInterval
decl_stmt|;
specifier|final
specifier|private
name|int
name|maxIdleTime
decl_stmt|;
specifier|final
specifier|private
name|int
name|maxIdleToClose
decl_stmt|;
name|ConnectionManager
parameter_list|()
block|{
name|this
operator|.
name|idleScanTimer
operator|=
operator|new
name|Timer
argument_list|(
literal|"RpcServer idle connection scanner for port "
operator|+
name|port
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|idleScanThreshold
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.idlethreshold"
argument_list|,
literal|4000
argument_list|)
expr_stmt|;
name|this
operator|.
name|idleScanInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.connection.idle-scan-interval.ms"
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxIdleTime
operator|=
literal|2
operator|*
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.connection.maxidletime"
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxIdleToClose
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.kill.max"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|int
name|handlerCount
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|REGION_SERVER_HANDLER_COUNT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_REGION_SERVER_HANDLER_COUNT
argument_list|)
decl_stmt|;
name|int
name|maxConnectionQueueSize
init|=
name|handlerCount
operator|*
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.handler.queue.size"
argument_list|,
literal|100
argument_list|)
decl_stmt|;
comment|// create a set with concurrency -and- a thread-safe iterator, add 2
comment|// for listener and idle closer threads
name|this
operator|.
name|connections
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|Connection
argument_list|,
name|Boolean
argument_list|>
argument_list|(
name|maxConnectionQueueSize
argument_list|,
literal|0.75f
argument_list|,
name|readThreads
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|add
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
name|boolean
name|added
init|=
name|connections
operator|.
name|add
argument_list|(
name|connection
argument_list|)
decl_stmt|;
if|if
condition|(
name|added
condition|)
block|{
name|count
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
block|}
return|return
name|added
return|;
block|}
specifier|private
name|boolean
name|remove
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
name|boolean
name|removed
init|=
name|connections
operator|.
name|remove
argument_list|(
name|connection
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
condition|)
block|{
name|count
operator|.
name|getAndDecrement
argument_list|()
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
name|int
name|size
parameter_list|()
block|{
return|return
name|count
operator|.
name|get
argument_list|()
return|;
block|}
name|Connection
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|connections
operator|.
name|toArray
argument_list|(
operator|new
name|Connection
index|[
literal|0
index|]
argument_list|)
return|;
block|}
name|Connection
name|register
parameter_list|(
name|SocketChannel
name|channel
parameter_list|)
block|{
name|Connection
name|connection
init|=
name|getConnection
argument_list|(
name|channel
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|connection
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server connection from "
operator|+
name|connection
operator|+
literal|"; connections="
operator|+
name|size
argument_list|()
operator|+
literal|", queued calls size (bytes)="
operator|+
name|callQueueSizeInBytes
operator|.
name|sum
argument_list|()
operator|+
literal|", general queued calls="
operator|+
name|scheduler
operator|.
name|getGeneralQueueLength
argument_list|()
operator|+
literal|", priority queued calls="
operator|+
name|scheduler
operator|.
name|getPriorityQueueLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|connection
return|;
block|}
name|boolean
name|close
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
name|boolean
name|exists
init|=
name|remove
argument_list|(
name|connection
argument_list|)
decl_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": disconnecting client "
operator|+
name|connection
operator|+
literal|". Number of active connections: "
operator|+
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// only close if actually removed to avoid double-closing due
comment|// to possible races
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|exists
return|;
block|}
comment|// synch'ed to avoid explicit invocation upon OOM from colliding with
comment|// timer task firing
specifier|synchronized
name|void
name|closeIdle
parameter_list|(
name|boolean
name|scanAll
parameter_list|)
block|{
name|long
name|minLastContact
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|maxIdleTime
decl_stmt|;
comment|// concurrent iterator might miss new connections added
comment|// during the iteration, but that's ok because they won't
comment|// be idle yet anyway and will be caught on next scan
name|int
name|closed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Connection
name|connection
range|:
name|connections
control|)
block|{
comment|// stop if connections dropped below threshold unless scanning all
if|if
condition|(
operator|!
name|scanAll
operator|&&
name|size
argument_list|()
operator|<
name|idleScanThreshold
condition|)
block|{
break|break;
block|}
comment|// stop if not scanning all and max connections are closed
if|if
condition|(
name|connection
operator|.
name|isIdle
argument_list|()
operator|&&
name|connection
operator|.
name|getLastContact
argument_list|()
operator|<
name|minLastContact
operator|&&
name|close
argument_list|(
name|connection
argument_list|)
operator|&&
operator|!
name|scanAll
operator|&&
operator|(
operator|++
name|closed
operator|==
name|maxIdleToClose
operator|)
condition|)
block|{
break|break;
block|}
block|}
block|}
name|void
name|closeAll
parameter_list|()
block|{
comment|// use a copy of the connections to be absolutely sure the concurrent
comment|// iterator doesn't miss a connection
for|for
control|(
name|Connection
name|connection
range|:
name|toArray
argument_list|()
control|)
block|{
name|close
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|startIdleScan
parameter_list|()
block|{
name|scheduleIdleScanTask
argument_list|()
expr_stmt|;
block|}
name|void
name|stopIdleScan
parameter_list|()
block|{
name|idleScanTimer
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|scheduleIdleScanTask
parameter_list|()
block|{
if|if
condition|(
operator|!
name|running
condition|)
block|{
return|return;
block|}
name|TimerTask
name|idleScanTask
init|=
operator|new
name|TimerTask
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
operator|!
name|running
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"running"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|closeIdle
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// explicitly reschedule so next execution occurs relative
comment|// to the end of this scan, not the beginning
name|scheduleIdleScanTask
argument_list|()
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|idleScanTimer
operator|.
name|schedule
argument_list|(
name|idleScanTask
argument_list|,
name|idleScanInterval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

