begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CompatibilitySingletonFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationPeer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationPeer
operator|.
name|PeerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationPeerConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationPeerImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationPeers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationQueueInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationQueueStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|SyncReplicationState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|AbstractFSWALProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|SyncReplicationWALProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_comment
comment|/**  * This class is responsible to manage all the replication sources. There are two classes of  * sources:  *<ul>  *<li>Normal sources are persistent and one per peer cluster</li>  *<li>Old sources are recovered from a failed region server and our only goal is to finish  * replicating the WAL queue it had</li>  *</ul>  *<p>  * When a region server dies, this class uses a watcher to get notified and it tries to grab a lock  * in order to transfer all the queues in a local old source.  *<p>  * Synchronization specification:  *<ul>  *<li>No need synchronized on {@link #sources}. {@link #sources} is a ConcurrentHashMap and there  * is a Lock for peer id in {@link PeerProcedureHandlerImpl}. So there is no race for peer  * operations.</li>  *<li>Need synchronized on {@link #walsById}. There are four methods which modify it,  * {@link #addPeer(String)}, {@link #removePeer(String)},  * {@link #cleanOldLogs(String, boolean, ReplicationSourceInterface)} and {@link #preLogRoll(Path)}.  * {@link #walsById} is a ConcurrentHashMap and there is a Lock for peer id in  * {@link PeerProcedureHandlerImpl}. So there is no race between {@link #addPeer(String)} and  * {@link #removePeer(String)}. {@link #cleanOldLogs(String, boolean, ReplicationSourceInterface)}  * is called by {@link ReplicationSourceInterface}. So no race with {@link #addPeer(String)}.  * {@link #removePeer(String)} will terminate the {@link ReplicationSourceInterface} firstly, then  * remove the wals from {@link #walsById}. So no race with {@link #removePeer(String)}. The only  * case need synchronized is {@link #cleanOldLogs(String, boolean, ReplicationSourceInterface)} and  * {@link #preLogRoll(Path)}.</li>  *<li>No need synchronized on {@link #walsByIdRecoveredQueues}. There are three methods which  * modify it, {@link #removePeer(String)} ,  * {@link #cleanOldLogs(String, boolean, ReplicationSourceInterface)} and  * {@link ReplicationSourceManager.NodeFailoverWorker#run()}.  * {@link #cleanOldLogs(String, boolean, ReplicationSourceInterface)} is called by  * {@link ReplicationSourceInterface}. {@link #removePeer(String)} will terminate the  * {@link ReplicationSourceInterface} firstly, then remove the wals from  * {@link #walsByIdRecoveredQueues}. And {@link ReplicationSourceManager.NodeFailoverWorker#run()}  * will add the wals to {@link #walsByIdRecoveredQueues} firstly, then start up a  * {@link ReplicationSourceInterface}. So there is no race here. For  * {@link ReplicationSourceManager.NodeFailoverWorker#run()} and {@link #removePeer(String)}, there  * is already synchronized on {@link #oldsources}. So no need synchronized on  * {@link #walsByIdRecoveredQueues}.</li>  *<li>Need synchronized on {@link #latestPaths} to avoid the new open source miss new log.</li>  *<li>Need synchronized on {@link #oldsources} to avoid adding recovered source for the  * to-be-removed peer.</li>  *</ul>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|ReplicationSourceManager
implements|implements
name|ReplicationListener
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ReplicationSourceManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// all the sources that read this RS's logs and every peer only has one replication source
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|ReplicationSourceInterface
argument_list|>
name|sources
decl_stmt|;
comment|// List of all the sources we got from died RSs
specifier|private
specifier|final
name|List
argument_list|<
name|ReplicationSourceInterface
argument_list|>
name|oldsources
decl_stmt|;
specifier|private
specifier|final
name|ReplicationQueueStorage
name|queueStorage
decl_stmt|;
specifier|private
specifier|final
name|ReplicationTracker
name|replicationTracker
decl_stmt|;
specifier|private
specifier|final
name|ReplicationPeers
name|replicationPeers
decl_stmt|;
comment|// UUID for this cluster
specifier|private
specifier|final
name|UUID
name|clusterId
decl_stmt|;
comment|// All about stopping
specifier|private
specifier|final
name|Server
name|server
decl_stmt|;
comment|// All logs we are currently tracking
comment|// Index structure of the map is: queue_id->logPrefix/logGroup->logs
comment|// For normal replication source, the peer id is same with the queue id
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|NavigableSet
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|walsById
decl_stmt|;
comment|// Logs for recovered sources we are currently tracking
comment|// the map is: queue_id->logPrefix/logGroup->logs
comment|// For recovered source, the queue id's format is peer_id-servername-*
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|NavigableSet
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|walsByIdRecoveredQueues
decl_stmt|;
specifier|private
specifier|final
name|SyncReplicationPeerMappingManager
name|syncReplicationPeerMappingManager
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|FileSystem
name|fs
decl_stmt|;
comment|// The paths to the latest log of each wal group, for new coming peers
specifier|private
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|latestPaths
decl_stmt|;
comment|// Path to the wals directories
specifier|private
specifier|final
name|Path
name|logDir
decl_stmt|;
comment|// Path to the wal archive
specifier|private
specifier|final
name|Path
name|oldLogDir
decl_stmt|;
specifier|private
specifier|final
name|WALFileLengthProvider
name|walFileLengthProvider
decl_stmt|;
comment|// The number of ms that we wait before moving znodes, HBASE-3596
specifier|private
specifier|final
name|long
name|sleepBeforeFailover
decl_stmt|;
comment|// Homemade executer service for replication
specifier|private
specifier|final
name|ThreadPoolExecutor
name|executor
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|replicationForBulkLoadDataEnabled
decl_stmt|;
specifier|private
name|AtomicLong
name|totalBufferUsed
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|// How long should we sleep for each retry when deleting remote wal files for sync replication
comment|// peer.
specifier|private
specifier|final
name|long
name|sleepForRetries
decl_stmt|;
comment|// Maximum number of retries before taking bold actions when deleting remote wal files for sync
comment|// replication peer.
specifier|private
specifier|final
name|int
name|maxRetriesMultiplier
decl_stmt|;
comment|/**    * Creates a replication manager and sets the watch on all the other registered region servers    * @param queueStorage the interface for manipulating replication queues    * @param replicationPeers    * @param replicationTracker    * @param conf the configuration to use    * @param server the server for this region server    * @param fs the file system to use    * @param logDir the directory that contains all wal directories of live RSs    * @param oldLogDir the directory where old logs are archived    * @param clusterId    */
specifier|public
name|ReplicationSourceManager
parameter_list|(
name|ReplicationQueueStorage
name|queueStorage
parameter_list|,
name|ReplicationPeers
name|replicationPeers
parameter_list|,
name|ReplicationTracker
name|replicationTracker
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Server
name|server
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|Path
name|logDir
parameter_list|,
name|Path
name|oldLogDir
parameter_list|,
name|UUID
name|clusterId
parameter_list|,
name|WALFileLengthProvider
name|walFileLengthProvider
parameter_list|,
name|SyncReplicationPeerMappingManager
name|syncReplicationPeerMappingManager
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|sources
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|queueStorage
operator|=
name|queueStorage
expr_stmt|;
name|this
operator|.
name|replicationPeers
operator|=
name|replicationPeers
expr_stmt|;
name|this
operator|.
name|replicationTracker
operator|=
name|replicationTracker
expr_stmt|;
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
name|this
operator|.
name|walsById
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|walsByIdRecoveredQueues
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|oldsources
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|logDir
operator|=
name|logDir
expr_stmt|;
name|this
operator|.
name|oldLogDir
operator|=
name|oldLogDir
expr_stmt|;
comment|// 30 seconds
name|this
operator|.
name|sleepBeforeFailover
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"replication.sleep.before.failover"
argument_list|,
literal|30000
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterId
operator|=
name|clusterId
expr_stmt|;
name|this
operator|.
name|walFileLengthProvider
operator|=
name|walFileLengthProvider
expr_stmt|;
name|this
operator|.
name|syncReplicationPeerMappingManager
operator|=
name|syncReplicationPeerMappingManager
expr_stmt|;
name|this
operator|.
name|replicationTracker
operator|.
name|registerListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// It's preferable to failover 1 RS at a time, but with good zk servers
comment|// more could be processed at the same time.
name|int
name|nbWorkers
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"replication.executor.workers"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// use a short 100ms sleep since this could be done inline with a RS startup
comment|// even if we fail, other region servers can take care of it
name|this
operator|.
name|executor
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|nbWorkers
argument_list|,
name|nbWorkers
argument_list|,
literal|100
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|,
operator|new
name|LinkedBlockingQueue
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
name|ThreadFactoryBuilder
name|tfb
init|=
operator|new
name|ThreadFactoryBuilder
argument_list|()
decl_stmt|;
name|tfb
operator|.
name|setNameFormat
argument_list|(
literal|"ReplicationExecutor-%d"
argument_list|)
expr_stmt|;
name|tfb
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|executor
operator|.
name|setThreadFactory
argument_list|(
name|tfb
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|latestPaths
operator|=
operator|new
name|HashSet
argument_list|<
name|Path
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|replicationForBulkLoadDataEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|REPLICATION_BULKLOAD_ENABLE_KEY
argument_list|,
name|HConstants
operator|.
name|REPLICATION_BULKLOAD_ENABLE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|sleepForRetries
operator|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
literal|"replication.source.sync.sleepforretries"
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxRetriesMultiplier
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"replication.source.sync.maxretriesmultiplier"
argument_list|,
literal|60
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds a normal source per registered peer cluster and tries to process all old region server wal    * queues    *<p>    * The returned future is for adoptAbandonedQueues task.    */
name|Future
argument_list|<
name|?
argument_list|>
name|init
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|String
name|id
range|:
name|this
operator|.
name|replicationPeers
operator|.
name|getAllPeerIds
argument_list|()
control|)
block|{
name|addSource
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicationForBulkLoadDataEnabled
condition|)
block|{
comment|// Check if peer exists in hfile-refs queue, if not add it. This can happen in the case
comment|// when a peer was added before replication for bulk loaded data was enabled.
name|throwIOExceptionWhenFail
argument_list|(
parameter_list|()
lambda|->
name|this
operator|.
name|queueStorage
operator|.
name|addPeerToHFileRefs
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|this
operator|.
name|executor
operator|.
name|submit
argument_list|(
name|this
operator|::
name|adoptAbandonedQueues
argument_list|)
return|;
block|}
specifier|private
name|void
name|adoptAbandonedQueues
parameter_list|()
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|currentReplicators
init|=
literal|null
decl_stmt|;
try|try
block|{
name|currentReplicators
operator|=
name|queueStorage
operator|.
name|getListOfReplicators
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReplicationException
name|e
parameter_list|)
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Failed to get all replicators"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|currentReplicators
operator|==
literal|null
operator|||
name|currentReplicators
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|ServerName
argument_list|>
name|otherRegionServers
init|=
name|replicationTracker
operator|.
name|getListOfRegionServers
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|ServerName
operator|::
name|valueOf
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Current list of replicators: "
operator|+
name|currentReplicators
operator|+
literal|" other RSs: "
operator|+
name|otherRegionServers
argument_list|)
expr_stmt|;
comment|// Look if there's anything to process after a restart
for|for
control|(
name|ServerName
name|rs
range|:
name|currentReplicators
control|)
block|{
if|if
condition|(
operator|!
name|otherRegionServers
operator|.
name|contains
argument_list|(
name|rs
argument_list|)
condition|)
block|{
name|transferQueues
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    *<ol>    *<li>Add peer to replicationPeers</li>    *<li>Add the normal source and related replication queue</li>    *<li>Add HFile Refs</li>    *</ol>    * @param peerId the id of replication peer    */
specifier|public
name|void
name|addPeer
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
try|try
block|{
name|added
operator|=
name|this
operator|.
name|replicationPeers
operator|.
name|addPeer
argument_list|(
name|peerId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReplicationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|added
condition|)
block|{
name|addSource
argument_list|(
name|peerId
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicationForBulkLoadDataEnabled
condition|)
block|{
name|throwIOExceptionWhenFail
argument_list|(
parameter_list|()
lambda|->
name|this
operator|.
name|queueStorage
operator|.
name|addPeerToHFileRefs
argument_list|(
name|peerId
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    *<ol>    *<li>Remove peer for replicationPeers</li>    *<li>Remove all the recovered sources for the specified id and related replication queues</li>    *<li>Remove the normal source and related replication queue</li>    *<li>Remove HFile Refs</li>    *</ol>    * @param peerId the id of the replication peer    */
specifier|public
name|void
name|removePeer
parameter_list|(
name|String
name|peerId
parameter_list|)
block|{
name|ReplicationPeer
name|peer
init|=
name|replicationPeers
operator|.
name|removePeer
argument_list|(
name|peerId
argument_list|)
decl_stmt|;
name|String
name|terminateMessage
init|=
literal|"Replication stream was removed by a user"
decl_stmt|;
name|List
argument_list|<
name|ReplicationSourceInterface
argument_list|>
name|oldSourcesToDelete
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// synchronized on oldsources to avoid adding recovered source for the to-be-removed peer
comment|// see NodeFailoverWorker.run
synchronized|synchronized
init|(
name|this
operator|.
name|oldsources
init|)
block|{
comment|// First close all the recovered sources for this peer
for|for
control|(
name|ReplicationSourceInterface
name|src
range|:
name|oldsources
control|)
block|{
if|if
condition|(
name|peerId
operator|.
name|equals
argument_list|(
name|src
operator|.
name|getPeerId
argument_list|()
argument_list|)
condition|)
block|{
name|oldSourcesToDelete
operator|.
name|add
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|ReplicationSourceInterface
name|src
range|:
name|oldSourcesToDelete
control|)
block|{
name|src
operator|.
name|terminate
argument_list|(
name|terminateMessage
argument_list|)
expr_stmt|;
name|removeRecoveredSource
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of deleted recovered sources for "
operator|+
name|peerId
operator|+
literal|": "
operator|+
name|oldSourcesToDelete
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now close the normal source for this peer
name|ReplicationSourceInterface
name|srcToRemove
init|=
name|this
operator|.
name|sources
operator|.
name|get
argument_list|(
name|peerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|srcToRemove
operator|!=
literal|null
condition|)
block|{
name|srcToRemove
operator|.
name|terminate
argument_list|(
name|terminateMessage
argument_list|)
expr_stmt|;
name|removeSource
argument_list|(
name|srcToRemove
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This only happened in unit test TestReplicationSourceManager#testPeerRemovalCleanup
comment|// Delete queue from storage and memory and queue id is same with peer id for normal
comment|// source
name|deleteQueue
argument_list|(
name|peerId
argument_list|)
expr_stmt|;
name|this
operator|.
name|walsById
operator|.
name|remove
argument_list|(
name|peerId
argument_list|)
expr_stmt|;
block|}
name|ReplicationPeerConfig
name|peerConfig
init|=
name|peer
operator|.
name|getPeerConfig
argument_list|()
decl_stmt|;
if|if
condition|(
name|peerConfig
operator|.
name|isSyncReplication
argument_list|()
condition|)
block|{
name|syncReplicationPeerMappingManager
operator|.
name|remove
argument_list|(
name|peerId
argument_list|,
name|peerConfig
argument_list|)
expr_stmt|;
block|}
comment|// Remove HFile Refs
name|abortWhenFail
argument_list|(
parameter_list|()
lambda|->
name|this
operator|.
name|queueStorage
operator|.
name|removePeerFromHFileRefs
argument_list|(
name|peerId
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Factory method to create a replication source    * @param queueId the id of the replication queue    * @return the created source    */
specifier|private
name|ReplicationSourceInterface
name|createSource
parameter_list|(
name|String
name|queueId
parameter_list|,
name|ReplicationPeer
name|replicationPeer
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicationSourceInterface
name|src
init|=
name|ReplicationSourceFactory
operator|.
name|create
argument_list|(
name|conf
argument_list|,
name|queueId
argument_list|)
decl_stmt|;
name|MetricsSource
name|metrics
init|=
operator|new
name|MetricsSource
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
comment|// init replication source
name|src
operator|.
name|init
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|this
argument_list|,
name|queueStorage
argument_list|,
name|replicationPeer
argument_list|,
name|server
argument_list|,
name|queueId
argument_list|,
name|clusterId
argument_list|,
name|walFileLengthProvider
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
return|return
name|src
return|;
block|}
comment|/**    * Add a normal source for the given peer on this region server. Meanwhile, add new replication    * queue to storage. For the newly added peer, we only need to enqueue the latest log of each wal    * group and do replication    * @param peerId the id of the replication peer    * @return the source that was created    */
annotation|@
name|VisibleForTesting
name|ReplicationSourceInterface
name|addSource
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicationPeer
name|peer
init|=
name|replicationPeers
operator|.
name|getPeer
argument_list|(
name|peerId
argument_list|)
decl_stmt|;
name|ReplicationSourceInterface
name|src
init|=
name|createSource
argument_list|(
name|peerId
argument_list|,
name|peer
argument_list|)
decl_stmt|;
comment|// synchronized on latestPaths to avoid missing the new log
synchronized|synchronized
init|(
name|this
operator|.
name|latestPaths
init|)
block|{
name|this
operator|.
name|sources
operator|.
name|put
argument_list|(
name|peerId
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|NavigableSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|walsByGroup
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|this
operator|.
name|walsById
operator|.
name|put
argument_list|(
name|peerId
argument_list|,
name|walsByGroup
argument_list|)
expr_stmt|;
comment|// Add the latest wal to that source's queue
if|if
condition|(
name|this
operator|.
name|latestPaths
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Path
name|logPath
range|:
name|latestPaths
control|)
block|{
name|String
name|name
init|=
name|logPath
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|walPrefix
init|=
name|AbstractFSWALProvider
operator|.
name|getWALPrefixFromWALName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|NavigableSet
argument_list|<
name|String
argument_list|>
name|logs
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|logs
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|walsByGroup
operator|.
name|put
argument_list|(
name|walPrefix
argument_list|,
name|logs
argument_list|)
expr_stmt|;
comment|// Abort RS and throw exception to make add peer failed
name|abortAndThrowIOExceptionWhenFail
argument_list|(
parameter_list|()
lambda|->
name|this
operator|.
name|queueStorage
operator|.
name|addWAL
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|peerId
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|.
name|enqueueLog
argument_list|(
name|logPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ReplicationPeerConfig
name|peerConfig
init|=
name|peer
operator|.
name|getPeerConfig
argument_list|()
decl_stmt|;
if|if
condition|(
name|peerConfig
operator|.
name|isSyncReplication
argument_list|()
condition|)
block|{
name|syncReplicationPeerMappingManager
operator|.
name|add
argument_list|(
name|peer
operator|.
name|getId
argument_list|()
argument_list|,
name|peerConfig
argument_list|)
expr_stmt|;
block|}
name|src
operator|.
name|startup
argument_list|()
expr_stmt|;
return|return
name|src
return|;
block|}
comment|/**    *<p>    * This is used when we transit a sync replication peer to {@link SyncReplicationState#STANDBY}.    *</p>    *<p>    * When transiting to {@link SyncReplicationState#STANDBY}, we can remove all the pending wal    * files for a replication peer as we do not need to replicate them any more. And this is    * necessary, otherwise when we transit back to {@link SyncReplicationState#DOWNGRADE_ACTIVE}    * later, the stale data will be replicated again and cause inconsistency.    *</p>    *<p>    * See HBASE-20426 for more details.    *</p>    * @param peerId the id of the sync replication peer    */
specifier|public
name|void
name|drainSources
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|IOException
throws|,
name|ReplicationException
block|{
name|String
name|terminateMessage
init|=
literal|"Sync replication peer "
operator|+
name|peerId
operator|+
literal|" is transiting to STANDBY. Will close the previous replication source and open a new one"
decl_stmt|;
name|ReplicationPeer
name|peer
init|=
name|replicationPeers
operator|.
name|getPeer
argument_list|(
name|peerId
argument_list|)
decl_stmt|;
assert|assert
name|peer
operator|.
name|getPeerConfig
argument_list|()
operator|.
name|isSyncReplication
argument_list|()
assert|;
name|ReplicationSourceInterface
name|src
init|=
name|createSource
argument_list|(
name|peerId
argument_list|,
name|peer
argument_list|)
decl_stmt|;
comment|// synchronized here to avoid race with preLogRoll where we add new log to source and also
comment|// walsById.
name|ReplicationSourceInterface
name|toRemove
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|NavigableSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|wals
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|latestPaths
init|)
block|{
name|toRemove
operator|=
name|sources
operator|.
name|put
argument_list|(
name|peerId
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|toRemove
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Terminate replication source for "
operator|+
name|toRemove
operator|.
name|getPeerId
argument_list|()
argument_list|)
expr_stmt|;
name|toRemove
operator|.
name|terminate
argument_list|(
name|terminateMessage
argument_list|)
expr_stmt|;
name|toRemove
operator|.
name|getSourceMetrics
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// Here we make a copy of all the remaining wal files and then delete them from the
comment|// replication queue storage after releasing the lock. It is not safe to just remove the old
comment|// map from walsById since later we may fail to delete them from the replication queue
comment|// storage, and when we retry next time, we can not know the wal files that need to be deleted
comment|// from the replication queue storage.
name|walsById
operator|.
name|get
argument_list|(
name|peerId
argument_list|)
operator|.
name|forEach
argument_list|(
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
name|wals
operator|.
name|put
argument_list|(
name|k
argument_list|,
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Startup replication source for "
operator|+
name|src
operator|.
name|getPeerId
argument_list|()
argument_list|)
expr_stmt|;
name|src
operator|.
name|startup
argument_list|()
expr_stmt|;
for|for
control|(
name|NavigableSet
argument_list|<
name|String
argument_list|>
name|walsByGroup
range|:
name|wals
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|String
name|wal
range|:
name|walsByGroup
control|)
block|{
name|queueStorage
operator|.
name|removeWAL
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|peerId
argument_list|,
name|wal
argument_list|)
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|walsById
init|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|NavigableSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|oldWals
init|=
name|walsById
operator|.
name|get
argument_list|(
name|peerId
argument_list|)
decl_stmt|;
name|wals
operator|.
name|forEach
argument_list|(
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{
name|NavigableSet
argument_list|<
name|String
argument_list|>
name|walsByGroup
init|=
name|oldWals
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|walsByGroup
operator|!=
literal|null
condition|)
block|{
name|walsByGroup
operator|.
name|removeAll
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// synchronized on oldsources to avoid race with NodeFailoverWorker. Since NodeFailoverWorker is
comment|// a background task, we will delete the file from replication queue storage under the lock to
comment|// simplify the logic.
synchronized|synchronized
init|(
name|this
operator|.
name|oldsources
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|ReplicationSourceInterface
argument_list|>
name|iter
init|=
name|oldsources
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ReplicationSourceInterface
name|oldSource
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldSource
operator|.
name|getPeerId
argument_list|()
operator|.
name|equals
argument_list|(
name|peerId
argument_list|)
condition|)
block|{
name|String
name|queueId
init|=
name|oldSource
operator|.
name|getQueueId
argument_list|()
decl_stmt|;
name|oldSource
operator|.
name|terminate
argument_list|(
name|terminateMessage
argument_list|)
expr_stmt|;
name|oldSource
operator|.
name|getSourceMetrics
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|queueStorage
operator|.
name|removeQueue
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|queueId
argument_list|)
expr_stmt|;
name|walsByIdRecoveredQueues
operator|.
name|remove
argument_list|(
name|queueId
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Close the previous replication sources of this peer id and open new sources to trigger the new    * replication state changes or new replication config changes. Here we don't need to change    * replication queue storage and only to enqueue all logs to the new replication source    * @param peerId the id of the replication peer    */
specifier|public
name|void
name|refreshSources
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|terminateMessage
init|=
literal|"Peer "
operator|+
name|peerId
operator|+
literal|" state or config changed. Will close the previous replication source and open a new one"
decl_stmt|;
name|ReplicationPeer
name|peer
init|=
name|replicationPeers
operator|.
name|getPeer
argument_list|(
name|peerId
argument_list|)
decl_stmt|;
name|ReplicationSourceInterface
name|src
init|=
name|createSource
argument_list|(
name|peerId
argument_list|,
name|peer
argument_list|)
decl_stmt|;
comment|// synchronized on latestPaths to avoid missing the new log
synchronized|synchronized
init|(
name|this
operator|.
name|latestPaths
init|)
block|{
name|ReplicationSourceInterface
name|toRemove
init|=
name|this
operator|.
name|sources
operator|.
name|put
argument_list|(
name|peerId
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|toRemove
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Terminate replication source for "
operator|+
name|toRemove
operator|.
name|getPeerId
argument_list|()
argument_list|)
expr_stmt|;
name|toRemove
operator|.
name|terminate
argument_list|(
name|terminateMessage
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|NavigableSet
argument_list|<
name|String
argument_list|>
name|walsByGroup
range|:
name|walsById
operator|.
name|get
argument_list|(
name|peerId
argument_list|)
operator|.
name|values
argument_list|()
control|)
block|{
name|walsByGroup
operator|.
name|forEach
argument_list|(
name|wal
lambda|->
name|src
operator|.
name|enqueueLog
argument_list|(
operator|new
name|Path
argument_list|(
name|this
operator|.
name|logDir
argument_list|,
name|wal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Startup replication source for "
operator|+
name|src
operator|.
name|getPeerId
argument_list|()
argument_list|)
expr_stmt|;
name|src
operator|.
name|startup
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|ReplicationSourceInterface
argument_list|>
name|toStartup
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// synchronized on oldsources to avoid race with NodeFailoverWorker
synchronized|synchronized
init|(
name|this
operator|.
name|oldsources
init|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|previousQueueIds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ReplicationSourceInterface
name|oldSource
range|:
name|this
operator|.
name|oldsources
control|)
block|{
if|if
condition|(
name|oldSource
operator|.
name|getPeerId
argument_list|()
operator|.
name|equals
argument_list|(
name|peerId
argument_list|)
condition|)
block|{
name|previousQueueIds
operator|.
name|add
argument_list|(
name|oldSource
operator|.
name|getQueueId
argument_list|()
argument_list|)
expr_stmt|;
name|oldSource
operator|.
name|terminate
argument_list|(
name|terminateMessage
argument_list|)
expr_stmt|;
name|this
operator|.
name|oldsources
operator|.
name|remove
argument_list|(
name|oldSource
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|queueId
range|:
name|previousQueueIds
control|)
block|{
name|ReplicationSourceInterface
name|replicationSource
init|=
name|createSource
argument_list|(
name|queueId
argument_list|,
name|peer
argument_list|)
decl_stmt|;
name|this
operator|.
name|oldsources
operator|.
name|add
argument_list|(
name|replicationSource
argument_list|)
expr_stmt|;
for|for
control|(
name|SortedSet
argument_list|<
name|String
argument_list|>
name|walsByGroup
range|:
name|walsByIdRecoveredQueues
operator|.
name|get
argument_list|(
name|queueId
argument_list|)
operator|.
name|values
argument_list|()
control|)
block|{
name|walsByGroup
operator|.
name|forEach
argument_list|(
name|wal
lambda|->
name|src
operator|.
name|enqueueLog
argument_list|(
operator|new
name|Path
argument_list|(
name|wal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|toStartup
operator|.
name|add
argument_list|(
name|replicationSource
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|ReplicationSourceInterface
name|replicationSource
range|:
name|toStartup
control|)
block|{
name|replicationSource
operator|.
name|startup
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Clear the metrics and related replication queue of the specified old source    * @param src source to clear    */
specifier|private
name|boolean
name|removeRecoveredSource
parameter_list|(
name|ReplicationSourceInterface
name|src
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|oldsources
operator|.
name|remove
argument_list|(
name|src
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Done with the recovered queue {}"
argument_list|,
name|src
operator|.
name|getQueueId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Delete queue from storage and memory
name|deleteQueue
argument_list|(
name|src
operator|.
name|getQueueId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|walsByIdRecoveredQueues
operator|.
name|remove
argument_list|(
name|src
operator|.
name|getQueueId
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|void
name|finishRecoveredSource
parameter_list|(
name|ReplicationSourceInterface
name|src
parameter_list|)
block|{
synchronized|synchronized
init|(
name|oldsources
init|)
block|{
if|if
condition|(
operator|!
name|removeRecoveredSource
argument_list|(
name|src
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished recovering queue {} with the following stats: {}"
argument_list|,
name|src
operator|.
name|getQueueId
argument_list|()
argument_list|,
name|src
operator|.
name|getStats
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Clear the metrics and related replication queue of the specified old source    * @param src source to clear    */
name|void
name|removeSource
parameter_list|(
name|ReplicationSourceInterface
name|src
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Done with the queue "
operator|+
name|src
operator|.
name|getQueueId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|sources
operator|.
name|remove
argument_list|(
name|src
operator|.
name|getPeerId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Delete queue from storage and memory
name|deleteQueue
argument_list|(
name|src
operator|.
name|getQueueId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|walsById
operator|.
name|remove
argument_list|(
name|src
operator|.
name|getQueueId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a complete queue of wals associated with a replication source    * @param queueId the id of replication queue to delete    */
specifier|private
name|void
name|deleteQueue
parameter_list|(
name|String
name|queueId
parameter_list|)
block|{
name|abortWhenFail
argument_list|(
parameter_list|()
lambda|->
name|this
operator|.
name|queueStorage
operator|.
name|removeQueue
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|queueId
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|FunctionalInterface
specifier|private
interface|interface
name|ReplicationQueueOperation
block|{
name|void
name|exec
parameter_list|()
throws|throws
name|ReplicationException
function_decl|;
block|}
comment|/**    * Refresh replication source will terminate the old source first, then the source thread will be    * interrupted. Need to handle it instead of abort the region server.    */
specifier|private
name|void
name|interruptOrAbortWhenFail
parameter_list|(
name|ReplicationQueueOperation
name|op
parameter_list|)
block|{
try|try
block|{
name|op
operator|.
name|exec
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReplicationException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|KeeperException
operator|.
name|SystemErrorException
operator|&&
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getCause
argument_list|()
operator|instanceof
name|InterruptedException
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Thread is interrupted, the replication source may be terminated"
argument_list|)
throw|;
block|}
name|server
operator|.
name|abort
argument_list|(
literal|"Failed to operate on replication queue"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|abortWhenFail
parameter_list|(
name|ReplicationQueueOperation
name|op
parameter_list|)
block|{
try|try
block|{
name|op
operator|.
name|exec
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReplicationException
name|e
parameter_list|)
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Failed to operate on replication queue"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|throwIOExceptionWhenFail
parameter_list|(
name|ReplicationQueueOperation
name|op
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|op
operator|.
name|exec
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReplicationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|abortAndThrowIOExceptionWhenFail
parameter_list|(
name|ReplicationQueueOperation
name|op
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|op
operator|.
name|exec
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReplicationException
name|e
parameter_list|)
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Failed to operate on replication queue"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * This method will log the current position to storage. And also clean old logs from the    * replication queue.    * @param source the replication source    * @param entryBatch the wal entry batch we just shipped    */
specifier|public
name|void
name|logPositionAndCleanOldLogs
parameter_list|(
name|ReplicationSourceInterface
name|source
parameter_list|,
name|WALEntryBatch
name|entryBatch
parameter_list|)
block|{
name|String
name|fileName
init|=
name|entryBatch
operator|.
name|getLastWalPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|interruptOrAbortWhenFail
argument_list|(
parameter_list|()
lambda|->
name|this
operator|.
name|queueStorage
operator|.
name|setWALPosition
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|source
operator|.
name|getQueueId
argument_list|()
argument_list|,
name|fileName
argument_list|,
name|entryBatch
operator|.
name|getLastWalPosition
argument_list|()
argument_list|,
name|entryBatch
operator|.
name|getLastSeqIds
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|cleanOldLogs
argument_list|(
name|fileName
argument_list|,
name|entryBatch
operator|.
name|isEndOfFile
argument_list|()
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
comment|/**    * Cleans a log file and all older logs from replication queue. Called when we are sure that a log    * file is closed and has no more entries.    * @param log Path to the log    * @param inclusive whether we should also remove the given log file    * @param source the replication source    */
annotation|@
name|VisibleForTesting
name|void
name|cleanOldLogs
parameter_list|(
name|String
name|log
parameter_list|,
name|boolean
name|inclusive
parameter_list|,
name|ReplicationSourceInterface
name|source
parameter_list|)
block|{
name|String
name|logPrefix
init|=
name|AbstractFSWALProvider
operator|.
name|getWALPrefixFromWALName
argument_list|(
name|log
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|isRecovered
argument_list|()
condition|)
block|{
name|NavigableSet
argument_list|<
name|String
argument_list|>
name|wals
init|=
name|walsByIdRecoveredQueues
operator|.
name|get
argument_list|(
name|source
operator|.
name|getQueueId
argument_list|()
argument_list|)
operator|.
name|get
argument_list|(
name|logPrefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|wals
operator|!=
literal|null
condition|)
block|{
name|NavigableSet
argument_list|<
name|String
argument_list|>
name|walsToRemove
init|=
name|wals
operator|.
name|headSet
argument_list|(
name|log
argument_list|,
name|inclusive
argument_list|)
decl_stmt|;
if|if
condition|(
name|walsToRemove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|cleanOldLogs
argument_list|(
name|walsToRemove
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|walsToRemove
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|NavigableSet
argument_list|<
name|String
argument_list|>
name|wals
decl_stmt|;
name|NavigableSet
argument_list|<
name|String
argument_list|>
name|walsToRemove
decl_stmt|;
comment|// synchronized on walsById to avoid race with preLogRoll
synchronized|synchronized
init|(
name|this
operator|.
name|walsById
init|)
block|{
name|wals
operator|=
name|walsById
operator|.
name|get
argument_list|(
name|source
operator|.
name|getQueueId
argument_list|()
argument_list|)
operator|.
name|get
argument_list|(
name|logPrefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|wals
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|walsToRemove
operator|=
name|wals
operator|.
name|headSet
argument_list|(
name|log
argument_list|,
name|inclusive
argument_list|)
expr_stmt|;
if|if
condition|(
name|walsToRemove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|walsToRemove
operator|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|walsToRemove
argument_list|)
expr_stmt|;
block|}
comment|// cleanOldLogs may spend some time, especially for sync replication where we may want to
comment|// remove remote wals as the remote cluster may have already been down, so we do it outside
comment|// the lock to avoid block preLogRoll
name|cleanOldLogs
argument_list|(
name|walsToRemove
argument_list|,
name|source
argument_list|)
expr_stmt|;
comment|// now let's remove the files in the set
synchronized|synchronized
init|(
name|this
operator|.
name|walsById
init|)
block|{
name|wals
operator|.
name|removeAll
argument_list|(
name|walsToRemove
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|removeRemoteWALs
parameter_list|(
name|String
name|peerId
parameter_list|,
name|String
name|remoteWALDir
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|wals
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|remoteWALDirForPeer
init|=
name|ReplicationUtils
operator|.
name|getPeerRemoteWALDir
argument_list|(
name|remoteWALDir
argument_list|,
name|peerId
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|ReplicationUtils
operator|.
name|getRemoteWALFileSystem
argument_list|(
name|conf
argument_list|,
name|remoteWALDir
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|wal
range|:
name|wals
control|)
block|{
name|Path
name|walFile
init|=
operator|new
name|Path
argument_list|(
name|remoteWALDirForPeer
argument_list|,
name|wal
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|fs
operator|.
name|delete
argument_list|(
name|walFile
argument_list|,
literal|false
argument_list|)
operator|&&
name|fs
operator|.
name|exists
argument_list|(
name|walFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can not delete "
operator|+
name|walFile
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// Just ignore since this means the file has already been deleted.
comment|// The javadoc of the FileSystem.delete methods does not specify the behavior of deleting an
comment|// inexistent file, so here we deal with both, i.e, check the return value of the
comment|// FileSystem.delete, and also catch FNFE.
name|LOG
operator|.
name|debug
argument_list|(
literal|"The remote wal {} has already been deleted?"
argument_list|,
name|walFile
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|cleanOldLogs
parameter_list|(
name|NavigableSet
argument_list|<
name|String
argument_list|>
name|wals
parameter_list|,
name|ReplicationSourceInterface
name|source
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing {} logs in the list: {}"
argument_list|,
name|wals
operator|.
name|size
argument_list|()
argument_list|,
name|wals
argument_list|)
expr_stmt|;
comment|// The intention here is that, we want to delete the remote wal files ASAP as it may effect the
comment|// failover time if you want to transit the remote cluster from S to A. And the infinite retry
comment|// is not a problem, as if we can not contact with the remote HDFS cluster, then usually we can
comment|// not contact with the HBase cluster either, so the replication will be blocked either.
if|if
condition|(
name|source
operator|.
name|isSyncReplication
argument_list|()
condition|)
block|{
name|String
name|peerId
init|=
name|source
operator|.
name|getPeerId
argument_list|()
decl_stmt|;
name|String
name|remoteWALDir
init|=
name|source
operator|.
name|getPeer
argument_list|()
operator|.
name|getPeerConfig
argument_list|()
operator|.
name|getRemoteWALDir
argument_list|()
decl_stmt|;
comment|// Filter out the wals need to be removed from the remote directory. Its name should be the
comment|// special format, and also, the peer id in its name should match the peer id for the
comment|// replication source.
name|List
argument_list|<
name|String
argument_list|>
name|remoteWals
init|=
name|wals
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|w
lambda|->
name|SyncReplicationWALProvider
operator|.
name|getSyncReplicationPeerIdFromWALName
argument_list|(
name|w
argument_list|)
operator|.
name|map
argument_list|(
name|peerId
operator|::
name|equals
argument_list|)
operator|.
name|orElse
argument_list|(
literal|false
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing {} logs from remote dir {} in the list: {}"
argument_list|,
name|remoteWals
operator|.
name|size
argument_list|()
argument_list|,
name|remoteWALDir
argument_list|,
name|remoteWals
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remoteWals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|sleepMultiplier
init|=
literal|0
init|;
condition|;
control|)
block|{
try|try
block|{
name|removeRemoteWALs
argument_list|(
name|peerId
argument_list|,
name|remoteWALDir
argument_list|,
name|remoteWals
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to delete remote wals from remote dir {} for peer {}"
argument_list|,
name|remoteWALDir
argument_list|,
name|peerId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|source
operator|.
name|isSourceActive
argument_list|()
condition|)
block|{
comment|// skip the following operations
return|return;
block|}
if|if
condition|(
name|ReplicationUtils
operator|.
name|sleepForRetries
argument_list|(
literal|"Failed to delete remote wals"
argument_list|,
name|sleepForRetries
argument_list|,
name|sleepMultiplier
argument_list|,
name|maxRetriesMultiplier
argument_list|)
condition|)
block|{
name|sleepMultiplier
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
name|String
name|queueId
init|=
name|source
operator|.
name|getQueueId
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|wal
range|:
name|wals
control|)
block|{
name|interruptOrAbortWhenFail
argument_list|(
parameter_list|()
lambda|->
name|this
operator|.
name|queueStorage
operator|.
name|removeWAL
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|queueId
argument_list|,
name|wal
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// public because of we call it in TestReplicationEmptyWALRecovery
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|preLogRoll
parameter_list|(
name|Path
name|newLog
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|logName
init|=
name|newLog
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|logPrefix
init|=
name|AbstractFSWALProvider
operator|.
name|getWALPrefixFromWALName
argument_list|(
name|logName
argument_list|)
decl_stmt|;
comment|// synchronized on latestPaths to avoid the new open source miss the new log
synchronized|synchronized
init|(
name|this
operator|.
name|latestPaths
init|)
block|{
comment|// Add log to queue storage
for|for
control|(
name|ReplicationSourceInterface
name|source
range|:
name|this
operator|.
name|sources
operator|.
name|values
argument_list|()
control|)
block|{
comment|// If record log to queue storage failed, abort RS and throw exception to make log roll
comment|// failed
name|abortAndThrowIOExceptionWhenFail
argument_list|(
parameter_list|()
lambda|->
name|this
operator|.
name|queueStorage
operator|.
name|addWAL
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|source
operator|.
name|getQueueId
argument_list|()
argument_list|,
name|logName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// synchronized on walsById to avoid race with cleanOldLogs
synchronized|synchronized
init|(
name|this
operator|.
name|walsById
init|)
block|{
comment|// Update walsById map
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|NavigableSet
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|entry
range|:
name|this
operator|.
name|walsById
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|peerId
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|NavigableSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|walsByPrefix
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|boolean
name|existingPrefix
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|NavigableSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|walsEntry
range|:
name|walsByPrefix
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|wals
init|=
name|walsEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|sources
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If there's no slaves, don't need to keep the old wals since
comment|// we only consider the last one when a new slave comes in
name|wals
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|logPrefix
operator|.
name|equals
argument_list|(
name|walsEntry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|wals
operator|.
name|add
argument_list|(
name|logName
argument_list|)
expr_stmt|;
name|existingPrefix
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|existingPrefix
condition|)
block|{
comment|// The new log belongs to a new group, add it into this peer
name|LOG
operator|.
name|debug
argument_list|(
literal|"Start tracking logs for wal group {} for peer {}"
argument_list|,
name|logPrefix
argument_list|,
name|peerId
argument_list|)
expr_stmt|;
name|NavigableSet
argument_list|<
name|String
argument_list|>
name|wals
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|wals
operator|.
name|add
argument_list|(
name|logName
argument_list|)
expr_stmt|;
name|walsByPrefix
operator|.
name|put
argument_list|(
name|logPrefix
argument_list|,
name|wals
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Add to latestPaths
name|Iterator
argument_list|<
name|Path
argument_list|>
name|iterator
init|=
name|latestPaths
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Path
name|path
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|getName
argument_list|()
operator|.
name|contains
argument_list|(
name|logPrefix
argument_list|)
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|this
operator|.
name|latestPaths
operator|.
name|add
argument_list|(
name|newLog
argument_list|)
expr_stmt|;
block|}
block|}
comment|// public because of we call it in TestReplicationEmptyWALRecovery
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|postLogRoll
parameter_list|(
name|Path
name|newLog
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This only updates the sources we own, not the recovered ones
for|for
control|(
name|ReplicationSourceInterface
name|source
range|:
name|this
operator|.
name|sources
operator|.
name|values
argument_list|()
control|)
block|{
name|source
operator|.
name|enqueueLog
argument_list|(
name|newLog
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|regionServerRemoved
parameter_list|(
name|String
name|regionserver
parameter_list|)
block|{
name|transferQueues
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|regionserver
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Transfer all the queues of the specified to this region server. First it tries to grab a lock    * and if it works it will move the old queues and finally will delete the old queues.    *<p>    * It creates one old source for any type of source of the old rs.    */
specifier|private
name|void
name|transferQueues
parameter_list|(
name|ServerName
name|deadRS
parameter_list|)
block|{
if|if
condition|(
name|server
operator|.
name|getServerName
argument_list|()
operator|.
name|equals
argument_list|(
name|deadRS
argument_list|)
condition|)
block|{
comment|// it's just us, give up
return|return;
block|}
name|NodeFailoverWorker
name|transfer
init|=
operator|new
name|NodeFailoverWorker
argument_list|(
name|deadRS
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|executor
operator|.
name|execute
argument_list|(
name|transfer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RejectedExecutionException
name|ex
parameter_list|)
block|{
name|CompatibilitySingletonFactory
operator|.
name|getInstance
argument_list|(
name|MetricsReplicationSourceFactory
operator|.
name|class
argument_list|)
operator|.
name|getGlobalSource
argument_list|()
operator|.
name|incrFailedRecoveryQueue
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cancelling the transfer of "
operator|+
name|deadRS
operator|+
literal|" because of "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Class responsible to setup new ReplicationSources to take care of the queues from dead region    * servers.    */
class|class
name|NodeFailoverWorker
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|ServerName
name|deadRS
decl_stmt|;
comment|// After claim the queues from dead region server, the NodeFailoverWorker will skip to start
comment|// the RecoveredReplicationSource if the peer has been removed. but there's possible that
comment|// remove a peer with peerId = 2 and add a peer with peerId = 2 again during the
comment|// NodeFailoverWorker. So we need a deep copied<peerId, peer> map to decide whether we
comment|// should start the RecoveredReplicationSource. If the latest peer is not the old peer when
comment|// NodeFailoverWorker begin, we should skip to start the RecoveredReplicationSource, Otherwise
comment|// the rs will abort (See HBASE-20475).
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ReplicationPeerImpl
argument_list|>
name|peersSnapshot
decl_stmt|;
annotation|@
name|VisibleForTesting
specifier|public
name|NodeFailoverWorker
parameter_list|(
name|ServerName
name|deadRS
parameter_list|)
block|{
name|super
argument_list|(
literal|"Failover-for-"
operator|+
name|deadRS
argument_list|)
expr_stmt|;
name|this
operator|.
name|deadRS
operator|=
name|deadRS
expr_stmt|;
name|peersSnapshot
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|replicationPeers
operator|.
name|getPeerCache
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|isOldPeer
parameter_list|(
name|String
name|peerId
parameter_list|,
name|ReplicationPeerImpl
name|newPeerRef
parameter_list|)
block|{
name|ReplicationPeerImpl
name|oldPeerRef
init|=
name|peersSnapshot
operator|.
name|get
argument_list|(
name|peerId
argument_list|)
decl_stmt|;
return|return
name|oldPeerRef
operator|!=
literal|null
operator|&&
name|oldPeerRef
operator|==
name|newPeerRef
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// Wait a bit before transferring the queues, we may be shutting down.
comment|// This sleep may not be enough in some cases.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepBeforeFailover
operator|+
call|(
name|long
call|)
argument_list|(
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextFloat
argument_list|()
operator|*
name|sleepBeforeFailover
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting before transferring a queue."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|// We try to lock that rs' queue directory
if|if
condition|(
name|server
operator|.
name|isStopped
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Not transferring queue since we are shutting down"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|newQueues
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|queues
init|=
name|queueStorage
operator|.
name|getAllQueues
argument_list|(
name|deadRS
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|queues
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Pair
argument_list|<
name|String
argument_list|,
name|SortedSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|peer
init|=
name|queueStorage
operator|.
name|claimQueue
argument_list|(
name|deadRS
argument_list|,
name|queues
operator|.
name|get
argument_list|(
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|(
name|queues
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|sleep
init|=
name|sleepBeforeFailover
operator|/
literal|2
decl_stmt|;
if|if
condition|(
operator|!
name|peer
operator|.
name|getSecond
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newQueues
operator|.
name|put
argument_list|(
name|peer
operator|.
name|getFirst
argument_list|()
argument_list|,
name|peer
operator|.
name|getSecond
argument_list|()
argument_list|)
expr_stmt|;
name|sleep
operator|=
name|sleepBeforeFailover
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting before transferring a queue."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|queues
operator|=
name|queueStorage
operator|.
name|getAllQueues
argument_list|(
name|deadRS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queues
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|queueStorage
operator|.
name|removeReplicatorIfQueueIsEmpty
argument_list|(
name|deadRS
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ReplicationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"ReplicationException: cannot claim dead region (%s)'s "
operator|+
literal|"replication queue. Znode : (%s)"
operator|+
literal|" Possible solution: check if znode size exceeds jute.maxBuffer value. "
operator|+
literal|" If so, increase it for both client and server side."
operator|+
name|e
argument_list|)
argument_list|,
name|deadRS
argument_list|,
name|queueStorage
operator|.
name|getRsNode
argument_list|(
name|deadRS
argument_list|)
argument_list|)
expr_stmt|;
name|server
operator|.
name|abort
argument_list|(
literal|"Failed to claim queue from dead regionserver."
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Copying over the failed queue is completed.
if|if
condition|(
name|newQueues
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// We either didn't get the lock or the failed region server didn't have any outstanding
comment|// WALs to replicate, so we are done.
return|return;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|newQueues
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|queueId
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|walsSet
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
try|try
block|{
comment|// there is not an actual peer defined corresponding to peerId for the failover.
name|ReplicationQueueInfo
name|replicationQueueInfo
init|=
operator|new
name|ReplicationQueueInfo
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
name|String
name|actualPeerId
init|=
name|replicationQueueInfo
operator|.
name|getPeerId
argument_list|()
decl_stmt|;
name|ReplicationPeerImpl
name|peer
init|=
name|replicationPeers
operator|.
name|getPeer
argument_list|(
name|actualPeerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|peer
operator|==
literal|null
operator|||
operator|!
name|isOldPeer
argument_list|(
name|actualPeerId
argument_list|,
name|peer
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Skipping failover for peer {} of node {}, peer is null"
argument_list|,
name|actualPeerId
argument_list|,
name|deadRS
argument_list|)
expr_stmt|;
name|abortWhenFail
argument_list|(
parameter_list|()
lambda|->
name|queueStorage
operator|.
name|removeQueue
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|queueId
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|server
operator|instanceof
name|ReplicationSyncUp
operator|.
name|DummyServer
operator|&&
name|peer
operator|.
name|getPeerState
argument_list|()
operator|.
name|equals
argument_list|(
name|PeerState
operator|.
name|DISABLED
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Peer {} is disabled. ReplicationSyncUp tool will skip "
operator|+
literal|"replicating data to this peer."
argument_list|,
name|actualPeerId
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ReplicationSourceInterface
name|src
init|=
name|createSource
argument_list|(
name|queueId
argument_list|,
name|peer
argument_list|)
decl_stmt|;
comment|// synchronized on oldsources to avoid adding recovered source for the to-be-removed peer
synchronized|synchronized
init|(
name|oldsources
init|)
block|{
name|peer
operator|=
name|replicationPeers
operator|.
name|getPeer
argument_list|(
name|src
operator|.
name|getPeerId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
literal|null
operator|||
operator|!
name|isOldPeer
argument_list|(
name|src
operator|.
name|getPeerId
argument_list|()
argument_list|,
name|peer
argument_list|)
condition|)
block|{
name|src
operator|.
name|terminate
argument_list|(
literal|"Recovered queue doesn't belong to any current peer"
argument_list|)
expr_stmt|;
name|deleteQueue
argument_list|(
name|queueId
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Do not setup recovered queue if a sync replication peer is in STANDBY state, or is
comment|// transiting to STANDBY state. The only exception is we are in STANDBY state and
comment|// transiting to DA, under this state we will replay the remote WAL and they need to be
comment|// replicated back.
if|if
condition|(
name|peer
operator|.
name|getPeerConfig
argument_list|()
operator|.
name|isSyncReplication
argument_list|()
condition|)
block|{
name|Pair
argument_list|<
name|SyncReplicationState
argument_list|,
name|SyncReplicationState
argument_list|>
name|stateAndNewState
init|=
name|peer
operator|.
name|getSyncReplicationStateAndNewState
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|stateAndNewState
operator|.
name|getFirst
argument_list|()
operator|.
name|equals
argument_list|(
name|SyncReplicationState
operator|.
name|STANDBY
argument_list|)
operator|&&
name|stateAndNewState
operator|.
name|getSecond
argument_list|()
operator|.
name|equals
argument_list|(
name|SyncReplicationState
operator|.
name|NONE
argument_list|)
operator|)
operator|||
name|stateAndNewState
operator|.
name|getSecond
argument_list|()
operator|.
name|equals
argument_list|(
name|SyncReplicationState
operator|.
name|STANDBY
argument_list|)
condition|)
block|{
name|src
operator|.
name|terminate
argument_list|(
literal|"Sync replication peer is in STANDBY state"
argument_list|)
expr_stmt|;
name|deleteQueue
argument_list|(
name|queueId
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|// track sources in walsByIdRecoveredQueues
name|Map
argument_list|<
name|String
argument_list|,
name|NavigableSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|walsByGroup
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|walsByIdRecoveredQueues
operator|.
name|put
argument_list|(
name|queueId
argument_list|,
name|walsByGroup
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|wal
range|:
name|walsSet
control|)
block|{
name|String
name|walPrefix
init|=
name|AbstractFSWALProvider
operator|.
name|getWALPrefixFromWALName
argument_list|(
name|wal
argument_list|)
decl_stmt|;
name|NavigableSet
argument_list|<
name|String
argument_list|>
name|wals
init|=
name|walsByGroup
operator|.
name|get
argument_list|(
name|walPrefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|wals
operator|==
literal|null
condition|)
block|{
name|wals
operator|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
expr_stmt|;
name|walsByGroup
operator|.
name|put
argument_list|(
name|walPrefix
argument_list|,
name|wals
argument_list|)
expr_stmt|;
block|}
name|wals
operator|.
name|add
argument_list|(
name|wal
argument_list|)
expr_stmt|;
block|}
name|oldsources
operator|.
name|add
argument_list|(
name|src
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|wal
range|:
name|walsSet
control|)
block|{
name|src
operator|.
name|enqueueLog
argument_list|(
operator|new
name|Path
argument_list|(
name|oldLogDir
argument_list|,
name|wal
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|src
operator|.
name|startup
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// TODO manage it
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed creating a source"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Terminate the replication on this region server    */
specifier|public
name|void
name|join
parameter_list|()
block|{
name|this
operator|.
name|executor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
for|for
control|(
name|ReplicationSourceInterface
name|source
range|:
name|this
operator|.
name|sources
operator|.
name|values
argument_list|()
control|)
block|{
name|source
operator|.
name|terminate
argument_list|(
literal|"Region server is closing"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get a copy of the wals of the normal sources on this rs    * @return a sorted set of wal names    */
annotation|@
name|VisibleForTesting
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|NavigableSet
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|getWALs
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|walsById
argument_list|)
return|;
block|}
comment|/**    * Get a copy of the wals of the recovered sources on this rs    * @return a sorted set of wal names    */
annotation|@
name|VisibleForTesting
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|NavigableSet
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|getWalsByIdRecoveredQueues
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|walsByIdRecoveredQueues
argument_list|)
return|;
block|}
comment|/**    * Get a list of all the normal sources of this rs    * @return list of all normal sources    */
specifier|public
name|List
argument_list|<
name|ReplicationSourceInterface
argument_list|>
name|getSources
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|sources
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get a list of all the recovered sources of this rs    * @return list of all recovered sources    */
specifier|public
name|List
argument_list|<
name|ReplicationSourceInterface
argument_list|>
name|getOldSources
parameter_list|()
block|{
return|return
name|this
operator|.
name|oldsources
return|;
block|}
comment|/**    * Get the normal source for a given peer    * @return the normal source for the give peer if it exists, otherwise null.    */
annotation|@
name|VisibleForTesting
specifier|public
name|ReplicationSourceInterface
name|getSource
parameter_list|(
name|String
name|peerId
parameter_list|)
block|{
return|return
name|this
operator|.
name|sources
operator|.
name|get
argument_list|(
name|peerId
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
name|List
argument_list|<
name|String
argument_list|>
name|getAllQueues
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|allQueues
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
try|try
block|{
name|allQueues
operator|=
name|queueStorage
operator|.
name|getAllQueues
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReplicationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|allQueues
return|;
block|}
annotation|@
name|VisibleForTesting
name|int
name|getSizeOfLatestPath
parameter_list|()
block|{
synchronized|synchronized
init|(
name|latestPaths
init|)
block|{
return|return
name|latestPaths
operator|.
name|size
argument_list|()
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|AtomicLong
name|getTotalBufferUsed
parameter_list|()
block|{
return|return
name|totalBufferUsed
return|;
block|}
comment|/**    * Get the directory where wals are archived    * @return the directory where wals are archived    */
specifier|public
name|Path
name|getOldLogDir
parameter_list|()
block|{
return|return
name|this
operator|.
name|oldLogDir
return|;
block|}
comment|/**    * Get the directory where wals are stored by their RSs    * @return the directory where wals are stored by their RSs    */
specifier|public
name|Path
name|getLogDir
parameter_list|()
block|{
return|return
name|this
operator|.
name|logDir
return|;
block|}
comment|/**    * Get the handle on the local file system    * @return Handle on the local file system    */
specifier|public
name|FileSystem
name|getFs
parameter_list|()
block|{
return|return
name|this
operator|.
name|fs
return|;
block|}
comment|/**    * Get the ReplicationPeers used by this ReplicationSourceManager    * @return the ReplicationPeers used by this ReplicationSourceManager    */
specifier|public
name|ReplicationPeers
name|getReplicationPeers
parameter_list|()
block|{
return|return
name|this
operator|.
name|replicationPeers
return|;
block|}
comment|/**    * Get a string representation of all the sources' metrics    */
specifier|public
name|String
name|getStats
parameter_list|()
block|{
name|StringBuilder
name|stats
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|ReplicationSourceInterface
name|source
range|:
name|this
operator|.
name|sources
operator|.
name|values
argument_list|()
control|)
block|{
name|stats
operator|.
name|append
argument_list|(
literal|"Normal source for cluster "
operator|+
name|source
operator|.
name|getPeerId
argument_list|()
operator|+
literal|": "
argument_list|)
expr_stmt|;
name|stats
operator|.
name|append
argument_list|(
name|source
operator|.
name|getStats
argument_list|()
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ReplicationSourceInterface
name|oldSource
range|:
name|oldsources
control|)
block|{
name|stats
operator|.
name|append
argument_list|(
literal|"Recovered source for cluster/machine(s) "
operator|+
name|oldSource
operator|.
name|getPeerId
argument_list|()
operator|+
literal|": "
argument_list|)
expr_stmt|;
name|stats
operator|.
name|append
argument_list|(
name|oldSource
operator|.
name|getStats
argument_list|()
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|stats
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|void
name|addHFileRefs
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|Path
argument_list|,
name|Path
argument_list|>
argument_list|>
name|pairs
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|ReplicationSourceInterface
name|source
range|:
name|this
operator|.
name|sources
operator|.
name|values
argument_list|()
control|)
block|{
name|throwIOExceptionWhenFail
argument_list|(
parameter_list|()
lambda|->
name|source
operator|.
name|addHFileRefs
argument_list|(
name|tableName
argument_list|,
name|family
argument_list|,
name|pairs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|cleanUpHFileRefs
parameter_list|(
name|String
name|peerId
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
block|{
name|interruptOrAbortWhenFail
argument_list|(
parameter_list|()
lambda|->
name|this
operator|.
name|queueStorage
operator|.
name|removeHFileRefs
argument_list|(
name|peerId
argument_list|,
name|files
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|activeFailoverTaskCount
parameter_list|()
block|{
return|return
name|executor
operator|.
name|getActiveCount
argument_list|()
return|;
block|}
block|}
end_class

end_unit

