begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mapreduce
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Mutation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ResultScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ImmutableBytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|NullOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|GenericOptionsParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Throwables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterators
import|;
end_import

begin_class
specifier|public
class|class
name|SyncTable
extends|extends
name|Configured
implements|implements
name|Tool
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SyncTable
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|String
name|SOURCE_HASH_DIR_CONF_KEY
init|=
literal|"sync.table.source.hash.dir"
decl_stmt|;
specifier|static
specifier|final
name|String
name|SOURCE_TABLE_CONF_KEY
init|=
literal|"sync.table.source.table.name"
decl_stmt|;
specifier|static
specifier|final
name|String
name|TARGET_TABLE_CONF_KEY
init|=
literal|"sync.table.target.table.name"
decl_stmt|;
specifier|static
specifier|final
name|String
name|SOURCE_ZK_CLUSTER_CONF_KEY
init|=
literal|"sync.table.source.zk.cluster"
decl_stmt|;
specifier|static
specifier|final
name|String
name|TARGET_ZK_CLUSTER_CONF_KEY
init|=
literal|"sync.table.target.zk.cluster"
decl_stmt|;
specifier|static
specifier|final
name|String
name|DRY_RUN_CONF_KEY
init|=
literal|"sync.table.dry.run"
decl_stmt|;
name|Path
name|sourceHashDir
decl_stmt|;
name|String
name|sourceTableName
decl_stmt|;
name|String
name|targetTableName
decl_stmt|;
name|String
name|sourceZkCluster
decl_stmt|;
name|String
name|targetZkCluster
decl_stmt|;
name|boolean
name|dryRun
decl_stmt|;
name|Counters
name|counters
decl_stmt|;
specifier|public
name|SyncTable
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Job
name|createSubmittableJob
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
init|=
name|sourceHashDir
operator|.
name|getFileSystem
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|sourceHashDir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Source hash dir not found: "
operator|+
name|sourceHashDir
argument_list|)
throw|;
block|}
name|HashTable
operator|.
name|TableHash
name|tableHash
init|=
name|HashTable
operator|.
name|TableHash
operator|.
name|read
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|sourceHashDir
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Read source hash manifest: "
operator|+
name|tableHash
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Read "
operator|+
name|tableHash
operator|.
name|partitions
operator|.
name|size
argument_list|()
operator|+
literal|" partition keys"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tableHash
operator|.
name|tableName
operator|.
name|equals
argument_list|(
name|sourceTableName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Table name mismatch - manifest indicates hash was taken from: "
operator|+
name|tableHash
operator|.
name|tableName
operator|+
literal|" but job is reading from: "
operator|+
name|sourceTableName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tableHash
operator|.
name|numHashFiles
operator|!=
name|tableHash
operator|.
name|partitions
operator|.
name|size
argument_list|()
operator|+
literal|1
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Hash data appears corrupt. The number of of hash files created"
operator|+
literal|" should be 1 more than the number of partition keys.  However, the manifest file "
operator|+
literal|" says numHashFiles="
operator|+
name|tableHash
operator|.
name|numHashFiles
operator|+
literal|" but the number of partition keys"
operator|+
literal|" found in the partitions file is "
operator|+
name|tableHash
operator|.
name|partitions
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
name|Path
name|dataDir
init|=
operator|new
name|Path
argument_list|(
name|sourceHashDir
argument_list|,
name|HashTable
operator|.
name|HASH_DATA_DIR
argument_list|)
decl_stmt|;
name|int
name|dataSubdirCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FileStatus
name|file
range|:
name|fs
operator|.
name|listStatus
argument_list|(
name|dataDir
argument_list|)
control|)
block|{
if|if
condition|(
name|file
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|HashTable
operator|.
name|OUTPUT_DATA_FILE_PREFIX
argument_list|)
condition|)
block|{
name|dataSubdirCount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dataSubdirCount
operator|!=
name|tableHash
operator|.
name|numHashFiles
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Hash data appears corrupt. The number of of hash files created"
operator|+
literal|" should be 1 more than the number of partition keys.  However, the number of data dirs"
operator|+
literal|" found is "
operator|+
name|dataSubdirCount
operator|+
literal|" but the number of partition keys"
operator|+
literal|" found in the partitions file is "
operator|+
name|tableHash
operator|.
name|partitions
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
literal|"mapreduce.job.name"
argument_list|,
literal|"syncTable_"
operator|+
name|sourceTableName
operator|+
literal|"-"
operator|+
name|targetTableName
argument_list|)
argument_list|)
decl_stmt|;
name|Configuration
name|jobConf
init|=
name|job
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|job
operator|.
name|setJarByClass
argument_list|(
name|HashTable
operator|.
name|class
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
name|SOURCE_HASH_DIR_CONF_KEY
argument_list|,
name|sourceHashDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
name|SOURCE_TABLE_CONF_KEY
argument_list|,
name|sourceTableName
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|set
argument_list|(
name|TARGET_TABLE_CONF_KEY
argument_list|,
name|targetTableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceZkCluster
operator|!=
literal|null
condition|)
block|{
name|jobConf
operator|.
name|set
argument_list|(
name|SOURCE_ZK_CLUSTER_CONF_KEY
argument_list|,
name|sourceZkCluster
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetZkCluster
operator|!=
literal|null
condition|)
block|{
name|jobConf
operator|.
name|set
argument_list|(
name|TARGET_ZK_CLUSTER_CONF_KEY
argument_list|,
name|targetZkCluster
argument_list|)
expr_stmt|;
block|}
name|jobConf
operator|.
name|setBoolean
argument_list|(
name|DRY_RUN_CONF_KEY
argument_list|,
name|dryRun
argument_list|)
expr_stmt|;
name|TableMapReduceUtil
operator|.
name|initTableMapperJob
argument_list|(
name|targetTableName
argument_list|,
name|tableHash
operator|.
name|initScan
argument_list|()
argument_list|,
name|SyncMapper
operator|.
name|class
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dryRun
condition|)
block|{
name|job
operator|.
name|setOutputFormatClass
argument_list|(
name|NullOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No reducers.  Just write straight to table.  Call initTableReducerJob
comment|// because it sets up the TableOutputFormat.
name|TableMapReduceUtil
operator|.
name|initTableReducerJob
argument_list|(
name|targetTableName
argument_list|,
literal|null
argument_list|,
name|job
argument_list|,
literal|null
argument_list|,
name|targetZkCluster
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// would be nice to add an option for bulk load instead
block|}
return|return
name|job
return|;
block|}
specifier|public
specifier|static
class|class
name|SyncMapper
extends|extends
name|TableMapper
argument_list|<
name|ImmutableBytesWritable
argument_list|,
name|Mutation
argument_list|>
block|{
name|Path
name|sourceHashDir
decl_stmt|;
name|Connection
name|sourceConnection
decl_stmt|;
name|Connection
name|targetConnection
decl_stmt|;
name|Table
name|sourceTable
decl_stmt|;
name|Table
name|targetTable
decl_stmt|;
name|boolean
name|dryRun
decl_stmt|;
name|HashTable
operator|.
name|TableHash
name|sourceTableHash
decl_stmt|;
name|HashTable
operator|.
name|TableHash
operator|.
name|Reader
name|sourceHashReader
decl_stmt|;
name|ImmutableBytesWritable
name|currentSourceHash
decl_stmt|;
name|ImmutableBytesWritable
name|nextSourceKey
decl_stmt|;
name|HashTable
operator|.
name|ResultHasher
name|targetHasher
decl_stmt|;
name|Throwable
name|mapperException
decl_stmt|;
specifier|public
specifier|static
enum|enum
name|Counter
block|{
name|BATCHES
block|,
name|HASHES_MATCHED
block|,
name|HASHES_NOT_MATCHED
block|,
name|SOURCEMISSINGROWS
block|,
name|SOURCEMISSINGCELLS
block|,
name|TARGETMISSINGROWS
block|,
name|TARGETMISSINGCELLS
block|,
name|ROWSWITHDIFFS
block|,
name|DIFFERENTCELLVALUES
block|,
name|MATCHINGROWS
block|,
name|MATCHINGCELLS
block|,
name|EMPTY_BATCHES
block|,
name|RANGESMATCHED
block|,
name|RANGESNOTMATCHED
block|}
empty_stmt|;
annotation|@
name|Override
specifier|protected
name|void
name|setup
parameter_list|(
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|sourceHashDir
operator|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|SOURCE_HASH_DIR_CONF_KEY
argument_list|)
argument_list|)
expr_stmt|;
name|sourceConnection
operator|=
name|openConnection
argument_list|(
name|conf
argument_list|,
name|SOURCE_ZK_CLUSTER_CONF_KEY
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|targetConnection
operator|=
name|openConnection
argument_list|(
name|conf
argument_list|,
name|TARGET_ZK_CLUSTER_CONF_KEY
argument_list|,
name|TableOutputFormat
operator|.
name|OUTPUT_CONF_PREFIX
argument_list|)
expr_stmt|;
name|sourceTable
operator|=
name|openTable
argument_list|(
name|sourceConnection
argument_list|,
name|conf
argument_list|,
name|SOURCE_TABLE_CONF_KEY
argument_list|)
expr_stmt|;
name|targetTable
operator|=
name|openTable
argument_list|(
name|targetConnection
argument_list|,
name|conf
argument_list|,
name|TARGET_TABLE_CONF_KEY
argument_list|)
expr_stmt|;
name|dryRun
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|SOURCE_TABLE_CONF_KEY
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|sourceTableHash
operator|=
name|HashTable
operator|.
name|TableHash
operator|.
name|read
argument_list|(
name|conf
argument_list|,
name|sourceHashDir
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Read source hash manifest: "
operator|+
name|sourceTableHash
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Read "
operator|+
name|sourceTableHash
operator|.
name|partitions
operator|.
name|size
argument_list|()
operator|+
literal|" partition keys"
argument_list|)
expr_stmt|;
name|TableSplit
name|split
init|=
operator|(
name|TableSplit
operator|)
name|context
operator|.
name|getInputSplit
argument_list|()
decl_stmt|;
name|ImmutableBytesWritable
name|splitStartKey
init|=
operator|new
name|ImmutableBytesWritable
argument_list|(
name|split
operator|.
name|getStartRow
argument_list|()
argument_list|)
decl_stmt|;
name|sourceHashReader
operator|=
name|sourceTableHash
operator|.
name|newReader
argument_list|(
name|conf
argument_list|,
name|splitStartKey
argument_list|)
expr_stmt|;
name|findNextKeyHashPair
argument_list|()
expr_stmt|;
comment|// create a hasher, but don't start it right away
comment|// instead, find the first hash batch at or after the start row
comment|// and skip any rows that come before.  they will be caught by the previous task
name|targetHasher
operator|=
operator|new
name|HashTable
operator|.
name|ResultHasher
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|static
name|Connection
name|openConnection
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|zkClusterConfKey
parameter_list|,
name|String
name|configPrefix
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|zkCluster
init|=
name|conf
operator|.
name|get
argument_list|(
name|zkClusterConfKey
argument_list|)
decl_stmt|;
name|Configuration
name|clusterConf
init|=
name|HBaseConfiguration
operator|.
name|createClusterConf
argument_list|(
name|conf
argument_list|,
name|zkCluster
argument_list|,
name|configPrefix
argument_list|)
decl_stmt|;
return|return
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|clusterConf
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Table
name|openTable
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|tableNameConfKey
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|getTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|tableNameConfKey
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Attempt to read the next source key/hash pair.      * If there are no more, set nextSourceKey to null      */
specifier|private
name|void
name|findNextKeyHashPair
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|hasNext
init|=
name|sourceHashReader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasNext
condition|)
block|{
name|nextSourceKey
operator|=
name|sourceHashReader
operator|.
name|getCurrentKey
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// no more keys - last hash goes to the end
name|nextSourceKey
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|map
parameter_list|(
name|ImmutableBytesWritable
name|key
parameter_list|,
name|Result
name|value
parameter_list|,
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
comment|// first, finish any hash batches that end before the scanned row
while|while
condition|(
name|nextSourceKey
operator|!=
literal|null
operator|&&
name|key
operator|.
name|compareTo
argument_list|(
name|nextSourceKey
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|moveToNextBatch
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|// next, add the scanned row (as long as we've reached the first batch)
if|if
condition|(
name|targetHasher
operator|.
name|isBatchStarted
argument_list|()
condition|)
block|{
name|targetHasher
operator|.
name|hashResult
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|mapperException
operator|=
name|t
expr_stmt|;
name|Throwables
operator|.
name|propagateIfInstanceOf
argument_list|(
name|t
argument_list|,
name|IOException
operator|.
name|class
argument_list|)
expr_stmt|;
name|Throwables
operator|.
name|propagateIfInstanceOf
argument_list|(
name|t
argument_list|,
name|InterruptedException
operator|.
name|class
argument_list|)
expr_stmt|;
name|Throwables
operator|.
name|propagate
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * If there is an open hash batch, complete it and sync if there are diffs.      * Start a new batch, and seek to read the       */
specifier|private
name|void
name|moveToNextBatch
parameter_list|(
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|targetHasher
operator|.
name|isBatchStarted
argument_list|()
condition|)
block|{
name|finishBatchAndCompareHashes
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|targetHasher
operator|.
name|startBatch
argument_list|(
name|nextSourceKey
argument_list|)
expr_stmt|;
name|currentSourceHash
operator|=
name|sourceHashReader
operator|.
name|getCurrentHash
argument_list|()
expr_stmt|;
name|findNextKeyHashPair
argument_list|()
expr_stmt|;
block|}
comment|/**      * Finish the currently open hash batch.      * Compare the target hash to the given source hash.      * If they do not match, then sync the covered key range.      */
specifier|private
name|void
name|finishBatchAndCompareHashes
parameter_list|(
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|targetHasher
operator|.
name|finishBatch
argument_list|()
expr_stmt|;
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|BATCHES
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetHasher
operator|.
name|getBatchSize
argument_list|()
operator|==
literal|0
condition|)
block|{
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|EMPTY_BATCHES
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ImmutableBytesWritable
name|targetHash
init|=
name|targetHasher
operator|.
name|getBatchHash
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetHash
operator|.
name|equals
argument_list|(
name|currentSourceHash
argument_list|)
condition|)
block|{
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|HASHES_MATCHED
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|HASHES_NOT_MATCHED
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ImmutableBytesWritable
name|stopRow
init|=
name|nextSourceKey
operator|==
literal|null
condition|?
operator|new
name|ImmutableBytesWritable
argument_list|(
name|sourceTableHash
operator|.
name|stopRow
argument_list|)
else|:
name|nextSourceKey
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Hash mismatch.  Key range: "
operator|+
name|toHex
argument_list|(
name|targetHasher
operator|.
name|getBatchStartKey
argument_list|()
argument_list|)
operator|+
literal|" to "
operator|+
name|toHex
argument_list|(
name|stopRow
argument_list|)
operator|+
literal|" sourceHash: "
operator|+
name|toHex
argument_list|(
name|currentSourceHash
argument_list|)
operator|+
literal|" targetHash: "
operator|+
name|toHex
argument_list|(
name|targetHash
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|syncRange
argument_list|(
name|context
argument_list|,
name|targetHasher
operator|.
name|getBatchStartKey
argument_list|()
argument_list|,
name|stopRow
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|String
name|toHex
parameter_list|(
name|ImmutableBytesWritable
name|bytes
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|toHex
argument_list|(
name|bytes
operator|.
name|get
argument_list|()
argument_list|,
name|bytes
operator|.
name|getOffset
argument_list|()
argument_list|,
name|bytes
operator|.
name|getLength
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
specifier|final
name|CellScanner
name|EMPTY_CELL_SCANNER
init|=
operator|new
name|CellScanner
argument_list|(
name|Iterators
operator|.
expr|<
name|Result
operator|>
name|emptyIterator
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * Rescan the given range directly from the source and target tables.      * Count and log differences, and if this is not a dry run, output Puts and Deletes      * to make the target table match the source table for this range      */
specifier|private
name|void
name|syncRange
parameter_list|(
name|Context
name|context
parameter_list|,
name|ImmutableBytesWritable
name|startRow
parameter_list|,
name|ImmutableBytesWritable
name|stopRow
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Scan
name|scan
init|=
name|sourceTableHash
operator|.
name|initScan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|setStartRow
argument_list|(
name|startRow
operator|.
name|copyBytes
argument_list|()
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setStopRow
argument_list|(
name|stopRow
operator|.
name|copyBytes
argument_list|()
argument_list|)
expr_stmt|;
name|ResultScanner
name|sourceScanner
init|=
name|sourceTable
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|CellScanner
name|sourceCells
init|=
operator|new
name|CellScanner
argument_list|(
name|sourceScanner
operator|.
name|iterator
argument_list|()
argument_list|)
decl_stmt|;
name|ResultScanner
name|targetScanner
init|=
name|targetTable
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|CellScanner
name|targetCells
init|=
operator|new
name|CellScanner
argument_list|(
name|targetScanner
operator|.
name|iterator
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|rangeMatched
init|=
literal|true
decl_stmt|;
name|byte
index|[]
name|nextSourceRow
init|=
name|sourceCells
operator|.
name|nextRow
argument_list|()
decl_stmt|;
name|byte
index|[]
name|nextTargetRow
init|=
name|targetCells
operator|.
name|nextRow
argument_list|()
decl_stmt|;
while|while
condition|(
name|nextSourceRow
operator|!=
literal|null
operator|||
name|nextTargetRow
operator|!=
literal|null
condition|)
block|{
name|boolean
name|rowMatched
decl_stmt|;
name|int
name|rowComparison
init|=
name|compareRowKeys
argument_list|(
name|nextSourceRow
argument_list|,
name|nextTargetRow
argument_list|)
decl_stmt|;
if|if
condition|(
name|rowComparison
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Target missing row: "
operator|+
name|Bytes
operator|.
name|toHex
argument_list|(
name|nextSourceRow
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|TARGETMISSINGROWS
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rowMatched
operator|=
name|syncRowCells
argument_list|(
name|context
argument_list|,
name|nextSourceRow
argument_list|,
name|sourceCells
argument_list|,
name|EMPTY_CELL_SCANNER
argument_list|)
expr_stmt|;
name|nextSourceRow
operator|=
name|sourceCells
operator|.
name|nextRow
argument_list|()
expr_stmt|;
comment|// advance only source to next row
block|}
elseif|else
if|if
condition|(
name|rowComparison
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Source missing row: "
operator|+
name|Bytes
operator|.
name|toHex
argument_list|(
name|nextTargetRow
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|SOURCEMISSINGROWS
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rowMatched
operator|=
name|syncRowCells
argument_list|(
name|context
argument_list|,
name|nextTargetRow
argument_list|,
name|EMPTY_CELL_SCANNER
argument_list|,
name|targetCells
argument_list|)
expr_stmt|;
name|nextTargetRow
operator|=
name|targetCells
operator|.
name|nextRow
argument_list|()
expr_stmt|;
comment|// advance only target to next row
block|}
else|else
block|{
comment|// current row is the same on both sides, compare cell by cell
name|rowMatched
operator|=
name|syncRowCells
argument_list|(
name|context
argument_list|,
name|nextSourceRow
argument_list|,
name|sourceCells
argument_list|,
name|targetCells
argument_list|)
expr_stmt|;
name|nextSourceRow
operator|=
name|sourceCells
operator|.
name|nextRow
argument_list|()
expr_stmt|;
name|nextTargetRow
operator|=
name|targetCells
operator|.
name|nextRow
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rowMatched
condition|)
block|{
name|rangeMatched
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|sourceScanner
operator|.
name|close
argument_list|()
expr_stmt|;
name|targetScanner
operator|.
name|close
argument_list|()
expr_stmt|;
name|context
operator|.
name|getCounter
argument_list|(
name|rangeMatched
condition|?
name|Counter
operator|.
name|RANGESMATCHED
else|:
name|Counter
operator|.
name|RANGESNOTMATCHED
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
class|class
name|CellScanner
block|{
specifier|private
specifier|final
name|Iterator
argument_list|<
name|Result
argument_list|>
name|results
decl_stmt|;
specifier|private
name|byte
index|[]
name|currentRow
decl_stmt|;
specifier|private
name|Result
name|currentRowResult
decl_stmt|;
specifier|private
name|int
name|nextCellInRow
decl_stmt|;
specifier|private
name|Result
name|nextRowResult
decl_stmt|;
specifier|public
name|CellScanner
parameter_list|(
name|Iterator
argument_list|<
name|Result
argument_list|>
name|results
parameter_list|)
block|{
name|this
operator|.
name|results
operator|=
name|results
expr_stmt|;
block|}
comment|/**        * Advance to the next row and return its row key.        * Returns null iff there are no more rows.        */
specifier|public
name|byte
index|[]
name|nextRow
parameter_list|()
block|{
if|if
condition|(
name|nextRowResult
operator|==
literal|null
condition|)
block|{
comment|// no cached row - check scanner for more
while|while
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|nextRowResult
operator|=
name|results
operator|.
name|next
argument_list|()
expr_stmt|;
name|Cell
name|nextCell
init|=
name|nextRowResult
operator|.
name|rawCells
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|currentRow
operator|==
literal|null
operator|||
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|currentRow
argument_list|,
literal|0
argument_list|,
name|currentRow
operator|.
name|length
argument_list|,
name|nextCell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|nextCell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|nextCell
operator|.
name|getRowLength
argument_list|()
argument_list|)
condition|)
block|{
comment|// found next row
break|break;
block|}
else|else
block|{
comment|// found another result from current row, keep scanning
name|nextRowResult
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nextRowResult
operator|==
literal|null
condition|)
block|{
comment|// end of data, no more rows
name|currentRowResult
operator|=
literal|null
expr_stmt|;
name|currentRow
operator|=
literal|null
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|// advance to cached result for next row
name|currentRowResult
operator|=
name|nextRowResult
expr_stmt|;
name|nextCellInRow
operator|=
literal|0
expr_stmt|;
name|currentRow
operator|=
name|currentRowResult
operator|.
name|getRow
argument_list|()
expr_stmt|;
name|nextRowResult
operator|=
literal|null
expr_stmt|;
return|return
name|currentRow
return|;
block|}
comment|/**        * Returns the next Cell in the current row or null iff none remain.        */
specifier|public
name|Cell
name|nextCellInRow
parameter_list|()
block|{
if|if
condition|(
name|currentRowResult
operator|==
literal|null
condition|)
block|{
comment|// nothing left in current row
return|return
literal|null
return|;
block|}
name|Cell
name|nextCell
init|=
name|currentRowResult
operator|.
name|rawCells
argument_list|()
index|[
name|nextCellInRow
index|]
decl_stmt|;
name|nextCellInRow
operator|++
expr_stmt|;
if|if
condition|(
name|nextCellInRow
operator|==
name|currentRowResult
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Result
name|result
init|=
name|results
operator|.
name|next
argument_list|()
decl_stmt|;
name|Cell
name|cell
init|=
name|result
operator|.
name|rawCells
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|currentRow
argument_list|,
literal|0
argument_list|,
name|currentRow
operator|.
name|length
argument_list|,
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
condition|)
block|{
comment|// result is part of current row
name|currentRowResult
operator|=
name|result
expr_stmt|;
name|nextCellInRow
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// result is part of next row, cache it
name|nextRowResult
operator|=
name|result
expr_stmt|;
comment|// current row is complete
name|currentRowResult
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// end of data
name|currentRowResult
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
name|nextCell
return|;
block|}
block|}
comment|/**      * Compare the cells for the given row from the source and target tables.      * Count and log any differences.      * If not a dry run, output a Put and/or Delete needed to sync the target table      * to match the source table.      */
specifier|private
name|boolean
name|syncRowCells
parameter_list|(
name|Context
name|context
parameter_list|,
name|byte
index|[]
name|rowKey
parameter_list|,
name|CellScanner
name|sourceCells
parameter_list|,
name|CellScanner
name|targetCells
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Put
name|put
init|=
literal|null
decl_stmt|;
name|Delete
name|delete
init|=
literal|null
decl_stmt|;
name|long
name|matchingCells
init|=
literal|0
decl_stmt|;
name|boolean
name|matchingRow
init|=
literal|true
decl_stmt|;
name|Cell
name|sourceCell
init|=
name|sourceCells
operator|.
name|nextCellInRow
argument_list|()
decl_stmt|;
name|Cell
name|targetCell
init|=
name|targetCells
operator|.
name|nextCellInRow
argument_list|()
decl_stmt|;
while|while
condition|(
name|sourceCell
operator|!=
literal|null
operator|||
name|targetCell
operator|!=
literal|null
condition|)
block|{
name|int
name|cellKeyComparison
init|=
name|compareCellKeysWithinRow
argument_list|(
name|sourceCell
argument_list|,
name|targetCell
argument_list|)
decl_stmt|;
if|if
condition|(
name|cellKeyComparison
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Target missing cell: "
operator|+
name|sourceCell
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|TARGETMISSINGCELLS
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|matchingRow
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|dryRun
condition|)
block|{
if|if
condition|(
name|put
operator|==
literal|null
condition|)
block|{
name|put
operator|=
operator|new
name|Put
argument_list|(
name|rowKey
argument_list|)
expr_stmt|;
block|}
name|put
operator|.
name|add
argument_list|(
name|sourceCell
argument_list|)
expr_stmt|;
block|}
name|sourceCell
operator|=
name|sourceCells
operator|.
name|nextCellInRow
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cellKeyComparison
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Source missing cell: "
operator|+
name|targetCell
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|SOURCEMISSINGCELLS
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|matchingRow
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|dryRun
condition|)
block|{
if|if
condition|(
name|delete
operator|==
literal|null
condition|)
block|{
name|delete
operator|=
operator|new
name|Delete
argument_list|(
name|rowKey
argument_list|)
expr_stmt|;
block|}
comment|// add a tombstone to exactly match the target cell that is missing on the source
name|delete
operator|.
name|addColumn
argument_list|(
name|CellUtil
operator|.
name|cloneFamily
argument_list|(
name|targetCell
argument_list|)
argument_list|,
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|targetCell
argument_list|)
argument_list|,
name|targetCell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|targetCell
operator|=
name|targetCells
operator|.
name|nextCellInRow
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// the cell keys are equal, now check values
if|if
condition|(
name|CellUtil
operator|.
name|matchingValue
argument_list|(
name|sourceCell
argument_list|,
name|targetCell
argument_list|)
condition|)
block|{
name|matchingCells
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Different values: "
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"  source cell: "
operator|+
name|sourceCell
operator|+
literal|" value: "
operator|+
name|Bytes
operator|.
name|toHex
argument_list|(
name|sourceCell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|sourceCell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|sourceCell
operator|.
name|getValueLength
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"  target cell: "
operator|+
name|targetCell
operator|+
literal|" value: "
operator|+
name|Bytes
operator|.
name|toHex
argument_list|(
name|targetCell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|targetCell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|targetCell
operator|.
name|getValueLength
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|DIFFERENTCELLVALUES
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|matchingRow
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|dryRun
condition|)
block|{
comment|// overwrite target cell
if|if
condition|(
name|put
operator|==
literal|null
condition|)
block|{
name|put
operator|=
operator|new
name|Put
argument_list|(
name|rowKey
argument_list|)
expr_stmt|;
block|}
name|put
operator|.
name|add
argument_list|(
name|sourceCell
argument_list|)
expr_stmt|;
block|}
block|}
name|sourceCell
operator|=
name|sourceCells
operator|.
name|nextCellInRow
argument_list|()
expr_stmt|;
name|targetCell
operator|=
name|targetCells
operator|.
name|nextCellInRow
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dryRun
operator|&&
name|sourceTableHash
operator|.
name|scanBatch
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|put
operator|!=
literal|null
operator|&&
name|put
operator|.
name|size
argument_list|()
operator|>=
name|sourceTableHash
operator|.
name|scanBatch
condition|)
block|{
name|context
operator|.
name|write
argument_list|(
operator|new
name|ImmutableBytesWritable
argument_list|(
name|rowKey
argument_list|)
argument_list|,
name|put
argument_list|)
expr_stmt|;
name|put
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|delete
operator|!=
literal|null
operator|&&
name|delete
operator|.
name|size
argument_list|()
operator|>=
name|sourceTableHash
operator|.
name|scanBatch
condition|)
block|{
name|context
operator|.
name|write
argument_list|(
operator|new
name|ImmutableBytesWritable
argument_list|(
name|rowKey
argument_list|)
argument_list|,
name|delete
argument_list|)
expr_stmt|;
name|delete
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|dryRun
condition|)
block|{
if|if
condition|(
name|put
operator|!=
literal|null
condition|)
block|{
name|context
operator|.
name|write
argument_list|(
operator|new
name|ImmutableBytesWritable
argument_list|(
name|rowKey
argument_list|)
argument_list|,
name|put
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delete
operator|!=
literal|null
condition|)
block|{
name|context
operator|.
name|write
argument_list|(
operator|new
name|ImmutableBytesWritable
argument_list|(
name|rowKey
argument_list|)
argument_list|,
name|delete
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|matchingCells
operator|>
literal|0
condition|)
block|{
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|MATCHINGCELLS
argument_list|)
operator|.
name|increment
argument_list|(
name|matchingCells
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|matchingRow
condition|)
block|{
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|MATCHINGROWS
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|context
operator|.
name|getCounter
argument_list|(
name|Counter
operator|.
name|ROWSWITHDIFFS
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Compare row keys of the given Result objects.      * Nulls are after non-nulls      */
specifier|private
specifier|static
name|int
name|compareRowKeys
parameter_list|(
name|byte
index|[]
name|r1
parameter_list|,
name|byte
index|[]
name|r2
parameter_list|)
block|{
if|if
condition|(
name|r1
operator|==
literal|null
condition|)
block|{
return|return
literal|1
return|;
comment|// source missing row
block|}
elseif|else
if|if
condition|(
name|r2
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// target missing row
block|}
else|else
block|{
comment|// Sync on no META tables only. We can directly do what CellComparator is doing inside.
comment|// Never the call going to MetaCellComparator.
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|r1
argument_list|,
literal|0
argument_list|,
name|r1
operator|.
name|length
argument_list|,
name|r2
argument_list|,
literal|0
argument_list|,
name|r2
operator|.
name|length
argument_list|)
return|;
block|}
block|}
comment|/**      * Compare families, qualifiers, and timestamps of the given Cells.      * They are assumed to be of the same row.      * Nulls are after non-nulls.      */
specifier|private
specifier|static
name|int
name|compareCellKeysWithinRow
parameter_list|(
name|Cell
name|c1
parameter_list|,
name|Cell
name|c2
parameter_list|)
block|{
if|if
condition|(
name|c1
operator|==
literal|null
condition|)
block|{
return|return
literal|1
return|;
comment|// source missing cell
block|}
if|if
condition|(
name|c2
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// target missing cell
block|}
name|int
name|result
init|=
name|CellComparator
operator|.
name|compareFamilies
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
name|result
operator|=
name|CellComparator
operator|.
name|compareQualifiers
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// note timestamp comparison is inverted - more recent cells first
return|return
name|CellComparator
operator|.
name|compareTimestamps
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|cleanup
parameter_list|(
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|mapperException
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|finishRemainingHashRanges
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|mapperException
operator|=
name|t
expr_stmt|;
block|}
block|}
try|try
block|{
name|sourceTable
operator|.
name|close
argument_list|()
expr_stmt|;
name|targetTable
operator|.
name|close
argument_list|()
expr_stmt|;
name|sourceConnection
operator|.
name|close
argument_list|()
expr_stmt|;
name|targetConnection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|mapperException
operator|==
literal|null
condition|)
block|{
name|mapperException
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Suppressing exception from closing tables"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|// propagate first exception
if|if
condition|(
name|mapperException
operator|!=
literal|null
condition|)
block|{
name|Throwables
operator|.
name|propagateIfInstanceOf
argument_list|(
name|mapperException
argument_list|,
name|IOException
operator|.
name|class
argument_list|)
expr_stmt|;
name|Throwables
operator|.
name|propagateIfInstanceOf
argument_list|(
name|mapperException
argument_list|,
name|InterruptedException
operator|.
name|class
argument_list|)
expr_stmt|;
name|Throwables
operator|.
name|propagate
argument_list|(
name|mapperException
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|finishRemainingHashRanges
parameter_list|(
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|TableSplit
name|split
init|=
operator|(
name|TableSplit
operator|)
name|context
operator|.
name|getInputSplit
argument_list|()
decl_stmt|;
name|byte
index|[]
name|splitEndRow
init|=
name|split
operator|.
name|getEndRow
argument_list|()
decl_stmt|;
name|boolean
name|reachedEndOfTable
init|=
name|HashTable
operator|.
name|isTableEndRow
argument_list|(
name|splitEndRow
argument_list|)
decl_stmt|;
comment|// if there are more hash batches that begin before the end of this split move to them
while|while
condition|(
name|nextSourceKey
operator|!=
literal|null
operator|&&
operator|(
name|nextSourceKey
operator|.
name|compareTo
argument_list|(
name|splitEndRow
argument_list|)
operator|<
literal|0
operator|||
name|reachedEndOfTable
operator|)
condition|)
block|{
name|moveToNextBatch
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetHasher
operator|.
name|isBatchStarted
argument_list|()
condition|)
block|{
comment|// need to complete the final open hash batch
if|if
condition|(
operator|(
name|nextSourceKey
operator|!=
literal|null
operator|&&
name|nextSourceKey
operator|.
name|compareTo
argument_list|(
name|splitEndRow
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|nextSourceKey
operator|==
literal|null
operator|&&
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|splitEndRow
argument_list|,
name|sourceTableHash
operator|.
name|stopRow
argument_list|)
operator|)
condition|)
block|{
comment|// the open hash range continues past the end of this region
comment|// add a scan to complete the current hash range
name|Scan
name|scan
init|=
name|sourceTableHash
operator|.
name|initScan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|setStartRow
argument_list|(
name|splitEndRow
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextSourceKey
operator|==
literal|null
condition|)
block|{
name|scan
operator|.
name|setStopRow
argument_list|(
name|sourceTableHash
operator|.
name|stopRow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scan
operator|.
name|setStopRow
argument_list|(
name|nextSourceKey
operator|.
name|copyBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ResultScanner
name|targetScanner
init|=
name|targetTable
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
for|for
control|(
name|Result
name|row
range|:
name|targetScanner
control|)
block|{
name|targetHasher
operator|.
name|hashResult
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
block|}
comment|// else current batch ends exactly at split end row
name|finishBatchAndCompareHashes
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
specifier|final
name|int
name|NUM_ARGS
init|=
literal|3
decl_stmt|;
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|(
specifier|final
name|String
name|errorMsg
parameter_list|)
block|{
if|if
condition|(
name|errorMsg
operator|!=
literal|null
operator|&&
name|errorMsg
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"ERROR: "
operator|+
name|errorMsg
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: SyncTable [options]<sourcehashdir><sourcetable><targettable>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Options:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" sourcezkcluster  ZK cluster key of the source table"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"                  (defaults to cluster in classpath's config)"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" targetzkcluster  ZK cluster key of the target table"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"                  (defaults to cluster in classpath's config)"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" dryrun           if true, output counters but no writes"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"                  (defaults to false)"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Args:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" sourcehashdir    path to HashTable output dir for source table"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"                  if not specified, then all data will be scanned"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" sourcetable      Name of the source table to sync from"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" targettable      Name of the target table to sync to"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Examples:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" For a dry run SyncTable of tableA from a remote source cluster"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" to a local target cluster:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" $ bin/hbase "
operator|+
literal|"org.apache.hadoop.hbase.mapreduce.SyncTable --dryrun=true"
operator|+
literal|" --sourcezkcluster=zk1.example.com,zk2.example.com,zk3.example.com:2181:/hbase"
operator|+
literal|" hdfs://nn:9000/hashes/tableA tableA tableA"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|doCommandLine
parameter_list|(
specifier|final
name|String
index|[]
name|args
parameter_list|)
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|<
name|NUM_ARGS
condition|)
block|{
name|printUsage
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
try|try
block|{
name|sourceHashDir
operator|=
operator|new
name|Path
argument_list|(
name|args
index|[
name|args
operator|.
name|length
operator|-
literal|3
index|]
argument_list|)
expr_stmt|;
name|sourceTableName
operator|=
name|args
index|[
name|args
operator|.
name|length
operator|-
literal|2
index|]
expr_stmt|;
name|targetTableName
operator|=
name|args
index|[
name|args
operator|.
name|length
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
operator|-
name|NUM_ARGS
condition|;
name|i
operator|++
control|)
block|{
name|String
name|cmd
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"-h"
argument_list|)
operator|||
name|cmd
operator|.
name|startsWith
argument_list|(
literal|"--h"
argument_list|)
condition|)
block|{
name|printUsage
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|final
name|String
name|sourceZkClusterKey
init|=
literal|"--sourcezkcluster="
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|startsWith
argument_list|(
name|sourceZkClusterKey
argument_list|)
condition|)
block|{
name|sourceZkCluster
operator|=
name|cmd
operator|.
name|substring
argument_list|(
name|sourceZkClusterKey
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|final
name|String
name|targetZkClusterKey
init|=
literal|"--targetzkcluster="
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|startsWith
argument_list|(
name|targetZkClusterKey
argument_list|)
condition|)
block|{
name|targetZkCluster
operator|=
name|cmd
operator|.
name|substring
argument_list|(
name|targetZkClusterKey
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|final
name|String
name|dryRunKey
init|=
literal|"--dryrun="
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|startsWith
argument_list|(
name|dryRunKey
argument_list|)
condition|)
block|{
name|dryRun
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|cmd
operator|.
name|substring
argument_list|(
name|dryRunKey
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printUsage
argument_list|(
literal|"Invalid argument '"
operator|+
name|cmd
operator|+
literal|"'"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|printUsage
argument_list|(
literal|"Can't start because "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Main entry point.    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|ret
init|=
name|ToolRunner
operator|.
name|run
argument_list|(
operator|new
name|SyncTable
argument_list|(
name|HBaseConfiguration
operator|.
name|create
argument_list|()
argument_list|)
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|String
index|[]
name|otherArgs
init|=
operator|new
name|GenericOptionsParser
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|args
argument_list|)
operator|.
name|getRemainingArgs
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|doCommandLine
argument_list|(
name|otherArgs
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
name|Job
name|job
init|=
name|createSubmittableJob
argument_list|(
name|otherArgs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|job
operator|.
name|waitForCompletion
argument_list|(
literal|true
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Map-reduce job failed!"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|counters
operator|=
name|job
operator|.
name|getCounters
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_class

end_unit

