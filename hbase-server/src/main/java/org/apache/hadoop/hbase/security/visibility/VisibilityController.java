begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|visibility
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
operator|.
name|OperationStatusCode
operator|.
name|SANITY_CHECK_FAILURE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
operator|.
name|OperationStatusCode
operator|.
name|SUCCESS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|visibility
operator|.
name|VisibilityConstants
operator|.
name|LABELS_TABLE_FAMILY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|visibility
operator|.
name|VisibilityConstants
operator|.
name|LABELS_TABLE_NAME
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CoprocessorEnvironment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TagRewriteCell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Tag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaTableAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TagType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Append
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Increment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Mutation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|constraint
operator|.
name|ConstraintException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|BaseMasterAndRegionObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|BaseRegionServerObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|CoprocessorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|CoprocessorHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|CoprocessorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|MasterCoprocessorEnvironment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|ObserverContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|RegionCoprocessorEnvironment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|RegionServerCoprocessorEnvironment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|FailedSanityCheckException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|FilterBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|FilterList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RequestContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterServices
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ResponseConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|RegionActionResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|VisibilityLabelsProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|VisibilityLabelsProtos
operator|.
name|GetAuthsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|VisibilityLabelsProtos
operator|.
name|GetAuthsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|VisibilityLabelsProtos
operator|.
name|ListLabelsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|VisibilityLabelsProtos
operator|.
name|ListLabelsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|VisibilityLabelsProtos
operator|.
name|SetAuthsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|VisibilityLabelsProtos
operator|.
name|VisibilityLabel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|VisibilityLabelsProtos
operator|.
name|VisibilityLabelsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|VisibilityLabelsProtos
operator|.
name|VisibilityLabelsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|VisibilityLabelsProtos
operator|.
name|VisibilityLabelsService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|BloomType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|DeleteTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|DisabledRegionSplitPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|InternalScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|MiniBatchOperationInProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|OperationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationEndpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|access
operator|.
name|AccessControlLists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseInterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|access
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteStringer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapMaker
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcCallback
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcController
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Service
import|;
end_import

begin_comment
comment|/**  * Coprocessor that has both the MasterObserver and RegionObserver implemented that supports in  * visibility labels  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|CONFIG
argument_list|)
specifier|public
class|class
name|VisibilityController
extends|extends
name|BaseMasterAndRegionObserver
implements|implements
name|VisibilityLabelsService
operator|.
name|Interface
implements|,
name|CoprocessorService
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|VisibilityController
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// flags if we are running on a region of the 'labels' table
specifier|private
name|boolean
name|labelsRegion
init|=
literal|false
decl_stmt|;
comment|// Flag denoting whether AcessController is available or not.
specifier|private
name|boolean
name|acOn
init|=
literal|false
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|checkAuths
init|=
literal|false
decl_stmt|;
comment|/** Mapping of scanner instances to the user who created them */
specifier|private
name|Map
argument_list|<
name|InternalScanner
argument_list|,
name|String
argument_list|>
name|scannerOwners
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|weakKeys
argument_list|()
operator|.
name|makeMap
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|superUsers
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|superGroups
decl_stmt|;
specifier|private
name|VisibilityLabelService
name|visibilityLabelService
decl_stmt|;
comment|// Add to this list if there are any reserved tag types
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|Byte
argument_list|>
name|RESERVED_VIS_TAG_TYPES
init|=
operator|new
name|ArrayList
argument_list|<
name|Byte
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|RESERVED_VIS_TAG_TYPES
operator|.
name|add
argument_list|(
name|TagType
operator|.
name|VISIBILITY_TAG_TYPE
argument_list|)
expr_stmt|;
name|RESERVED_VIS_TAG_TYPES
operator|.
name|add
argument_list|(
name|TagType
operator|.
name|VISIBILITY_EXP_SERIALIZATION_FORMAT_TAG_TYPE
argument_list|)
expr_stmt|;
name|RESERVED_VIS_TAG_TYPES
operator|.
name|add
argument_list|(
name|TagType
operator|.
name|STRING_VIS_TAG_TYPE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|start
parameter_list|(
name|CoprocessorEnvironment
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|env
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
if|if
condition|(
name|HFile
operator|.
name|getFormatVersion
argument_list|(
name|conf
argument_list|)
operator|<
name|HFile
operator|.
name|MIN_FORMAT_VERSION_WITH_TAGS
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"A minimum HFile version of "
operator|+
name|HFile
operator|.
name|MIN_FORMAT_VERSION_WITH_TAGS
operator|+
literal|" is required to persist visibility labels. Consider setting "
operator|+
name|HFile
operator|.
name|FORMAT_VERSION_KEY
operator|+
literal|" accordingly."
argument_list|)
throw|;
block|}
if|if
condition|(
name|env
operator|instanceof
name|RegionServerCoprocessorEnvironment
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Visibility controller should not be configured as "
operator|+
literal|"'hbase.coprocessor.regionserver.classes'."
argument_list|)
throw|;
block|}
comment|// Do not create for master CPs
if|if
condition|(
operator|!
operator|(
name|env
operator|instanceof
name|MasterCoprocessorEnvironment
operator|)
condition|)
block|{
name|visibilityLabelService
operator|=
name|VisibilityLabelServiceManager
operator|.
name|getInstance
argument_list|()
operator|.
name|getVisibilityLabelService
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
name|Pair
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|superUsersAndGroups
init|=
name|VisibilityUtils
operator|.
name|getSystemAndSuperUsers
argument_list|(
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|superUsers
operator|=
name|superUsersAndGroups
operator|.
name|getFirst
argument_list|()
expr_stmt|;
name|this
operator|.
name|superGroups
operator|=
name|superUsersAndGroups
operator|.
name|getSecond
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
name|CoprocessorEnvironment
name|env
parameter_list|)
throws|throws
name|IOException
block|{    }
comment|/********************************* Master related hooks **********************************/
annotation|@
name|Override
specifier|public
name|void
name|postStartMaster
parameter_list|(
name|ObserverContext
argument_list|<
name|MasterCoprocessorEnvironment
argument_list|>
name|ctx
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Need to create the new system table for labels here
name|MasterServices
name|master
init|=
name|ctx
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getMasterServices
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|MetaTableAccessor
operator|.
name|tableExists
argument_list|(
name|master
operator|.
name|getConnection
argument_list|()
argument_list|,
name|LABELS_TABLE_NAME
argument_list|)
condition|)
block|{
name|HTableDescriptor
name|labelsTable
init|=
operator|new
name|HTableDescriptor
argument_list|(
name|LABELS_TABLE_NAME
argument_list|)
decl_stmt|;
name|HColumnDescriptor
name|labelsColumn
init|=
operator|new
name|HColumnDescriptor
argument_list|(
name|LABELS_TABLE_FAMILY
argument_list|)
decl_stmt|;
name|labelsColumn
operator|.
name|setBloomFilterType
argument_list|(
name|BloomType
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|labelsColumn
operator|.
name|setBlockCacheEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// We will cache all the labels. No need of normal
comment|// table block cache.
name|labelsTable
operator|.
name|addFamily
argument_list|(
name|labelsColumn
argument_list|)
expr_stmt|;
comment|// Let the "labels" table having only one region always. We are not expecting too many labels in
comment|// the system.
name|labelsTable
operator|.
name|setValue
argument_list|(
name|HTableDescriptor
operator|.
name|SPLIT_POLICY
argument_list|,
name|DisabledRegionSplitPolicy
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|labelsTable
operator|.
name|setValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|HConstants
operator|.
name|DISALLOW_WRITES_IN_RECOVERING
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|master
operator|.
name|createTable
argument_list|(
name|labelsTable
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|preModifyTable
parameter_list|(
name|ObserverContext
argument_list|<
name|MasterCoprocessorEnvironment
argument_list|>
name|ctx
parameter_list|,
name|TableName
name|tableName
parameter_list|,
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LABELS_TABLE_NAME
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ConstraintException
argument_list|(
literal|"Cannot alter "
operator|+
name|LABELS_TABLE_NAME
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|preAddColumn
parameter_list|(
name|ObserverContext
argument_list|<
name|MasterCoprocessorEnvironment
argument_list|>
name|ctx
parameter_list|,
name|TableName
name|tableName
parameter_list|,
name|HColumnDescriptor
name|column
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LABELS_TABLE_NAME
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ConstraintException
argument_list|(
literal|"Cannot alter "
operator|+
name|LABELS_TABLE_NAME
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|preModifyColumn
parameter_list|(
name|ObserverContext
argument_list|<
name|MasterCoprocessorEnvironment
argument_list|>
name|ctx
parameter_list|,
name|TableName
name|tableName
parameter_list|,
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LABELS_TABLE_NAME
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ConstraintException
argument_list|(
literal|"Cannot alter "
operator|+
name|LABELS_TABLE_NAME
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|preDeleteColumn
parameter_list|(
name|ObserverContext
argument_list|<
name|MasterCoprocessorEnvironment
argument_list|>
name|ctx
parameter_list|,
name|TableName
name|tableName
parameter_list|,
name|byte
index|[]
name|c
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LABELS_TABLE_NAME
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ConstraintException
argument_list|(
literal|"Cannot alter "
operator|+
name|LABELS_TABLE_NAME
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|preDisableTable
parameter_list|(
name|ObserverContext
argument_list|<
name|MasterCoprocessorEnvironment
argument_list|>
name|ctx
parameter_list|,
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LABELS_TABLE_NAME
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ConstraintException
argument_list|(
literal|"Cannot disable "
operator|+
name|LABELS_TABLE_NAME
argument_list|)
throw|;
block|}
block|}
comment|/****************************** Region related hooks ******************************/
annotation|@
name|Override
specifier|public
name|void
name|postOpen
parameter_list|(
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|e
parameter_list|)
block|{
comment|// Read the entire labels table and populate the zk
if|if
condition|(
name|e
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|LABELS_TABLE_NAME
argument_list|)
condition|)
block|{
name|this
operator|.
name|labelsRegion
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|acOn
operator|=
name|CoprocessorHost
operator|.
name|getLoadedCoprocessors
argument_list|()
operator|.
name|contains
argument_list|(
name|AccessController
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Defer the init of VisibilityLabelService on labels region until it is in recovering state.
if|if
condition|(
operator|!
name|e
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getRegion
argument_list|()
operator|.
name|isRecovering
argument_list|()
condition|)
block|{
name|initVisibilityLabelService
argument_list|(
name|e
operator|.
name|getEnvironment
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|checkAuths
operator|=
name|e
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|VisibilityConstants
operator|.
name|CHECK_AUTHS_FOR_MUTATION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|initVisibilityLabelService
argument_list|(
name|e
operator|.
name|getEnvironment
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|postLogReplay
parameter_list|(
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|e
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|labelsRegion
condition|)
block|{
name|initVisibilityLabelService
argument_list|(
name|e
operator|.
name|getEnvironment
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"post labels region log replay"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|initVisibilityLabelService
parameter_list|(
name|RegionCoprocessorEnvironment
name|env
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|visibilityLabelService
operator|.
name|init
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|this
operator|.
name|initialized
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while initializing VisibilityLabelService.."
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|preBatchMutate
parameter_list|(
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|c
parameter_list|,
name|MiniBatchOperationInProgress
argument_list|<
name|Mutation
argument_list|>
name|miniBatchOp
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|c
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getTable
argument_list|()
operator|.
name|isSystemTable
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// TODO this can be made as a global LRU cache at HRS level?
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Tag
argument_list|>
argument_list|>
name|labelCache
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Tag
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|miniBatchOp
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Mutation
name|m
init|=
name|miniBatchOp
operator|.
name|getOperation
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|CellVisibility
name|cellVisibility
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cellVisibility
operator|=
name|m
operator|.
name|getCellVisibility
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|de
parameter_list|)
block|{
name|miniBatchOp
operator|.
name|setOperationStatus
argument_list|(
name|i
argument_list|,
operator|new
name|OperationStatus
argument_list|(
name|SANITY_CHECK_FAILURE
argument_list|,
name|de
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|boolean
name|sanityFailure
init|=
literal|false
decl_stmt|;
name|boolean
name|modifiedTagFound
init|=
literal|false
decl_stmt|;
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Tag
argument_list|>
name|pair
init|=
operator|new
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Tag
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|CellScanner
name|cellScanner
init|=
name|m
operator|.
name|cellScanner
argument_list|()
init|;
name|cellScanner
operator|.
name|advance
argument_list|()
condition|;
control|)
block|{
name|pair
operator|=
name|checkForReservedVisibilityTagPresence
argument_list|(
name|cellScanner
operator|.
name|current
argument_list|()
argument_list|,
name|pair
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pair
operator|.
name|getFirst
argument_list|()
condition|)
block|{
name|miniBatchOp
operator|.
name|setOperationStatus
argument_list|(
name|i
argument_list|,
operator|new
name|OperationStatus
argument_list|(
name|SANITY_CHECK_FAILURE
argument_list|,
literal|"Mutation contains cell with reserved type tag"
argument_list|)
argument_list|)
expr_stmt|;
name|sanityFailure
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// Indicates that the cell has a the tag which was modified in the src replication cluster
name|Tag
name|tag
init|=
name|pair
operator|.
name|getSecond
argument_list|()
decl_stmt|;
if|if
condition|(
name|cellVisibility
operator|==
literal|null
operator|&&
name|tag
operator|!=
literal|null
condition|)
block|{
comment|// May need to store only the first one
name|cellVisibility
operator|=
operator|new
name|CellVisibility
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|tag
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|tag
operator|.
name|getTagOffset
argument_list|()
argument_list|,
name|tag
operator|.
name|getTagLength
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|modifiedTagFound
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|sanityFailure
condition|)
block|{
if|if
condition|(
name|cellVisibility
operator|!=
literal|null
condition|)
block|{
name|String
name|labelsExp
init|=
name|cellVisibility
operator|.
name|getExpression
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Tag
argument_list|>
name|visibilityTags
init|=
name|labelCache
operator|.
name|get
argument_list|(
name|labelsExp
argument_list|)
decl_stmt|;
if|if
condition|(
name|visibilityTags
operator|==
literal|null
condition|)
block|{
comment|// Don't check user auths for labels with Mutations when the user is super user
name|boolean
name|authCheck
init|=
name|this
operator|.
name|checkAuths
operator|&&
operator|!
operator|(
name|isSystemOrSuperUser
argument_list|()
operator|)
decl_stmt|;
try|try
block|{
name|visibilityTags
operator|=
name|this
operator|.
name|visibilityLabelService
operator|.
name|createVisibilityExpTags
argument_list|(
name|labelsExp
argument_list|,
literal|true
argument_list|,
name|authCheck
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidLabelException
name|e
parameter_list|)
block|{
name|miniBatchOp
operator|.
name|setOperationStatus
argument_list|(
name|i
argument_list|,
operator|new
name|OperationStatus
argument_list|(
name|SANITY_CHECK_FAILURE
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|visibilityTags
operator|!=
literal|null
condition|)
block|{
name|labelCache
operator|.
name|put
argument_list|(
name|labelsExp
argument_list|,
name|visibilityTags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|visibilityTags
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Cell
argument_list|>
name|updatedCells
init|=
operator|new
name|ArrayList
argument_list|<
name|Cell
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|CellScanner
name|cellScanner
init|=
name|m
operator|.
name|cellScanner
argument_list|()
init|;
name|cellScanner
operator|.
name|advance
argument_list|()
condition|;
control|)
block|{
name|Cell
name|cell
init|=
name|cellScanner
operator|.
name|current
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
init|=
name|Tag
operator|.
name|asList
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifiedTagFound
condition|)
block|{
comment|// Rewrite the tags by removing the modified tags.
name|removeReplicationVisibilityTag
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
name|tags
operator|.
name|addAll
argument_list|(
name|visibilityTags
argument_list|)
expr_stmt|;
name|Cell
name|updatedCell
init|=
operator|new
name|TagRewriteCell
argument_list|(
name|cell
argument_list|,
name|Tag
operator|.
name|fromList
argument_list|(
name|tags
argument_list|)
argument_list|)
decl_stmt|;
name|updatedCells
operator|.
name|add
argument_list|(
name|updatedCell
argument_list|)
expr_stmt|;
block|}
name|m
operator|.
name|getFamilyCellMap
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Clear and add new Cells to the Mutation.
for|for
control|(
name|Cell
name|cell
range|:
name|updatedCells
control|)
block|{
if|if
condition|(
name|m
operator|instanceof
name|Put
condition|)
block|{
name|Put
name|p
init|=
operator|(
name|Put
operator|)
name|m
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|instanceof
name|Delete
condition|)
block|{
name|Delete
name|d
init|=
operator|(
name|Delete
operator|)
name|m
decl_stmt|;
name|d
operator|.
name|addDeleteMarker
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|prePrepareTimeStampForDeleteVersion
parameter_list|(
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|ctx
parameter_list|,
name|Mutation
name|delete
parameter_list|,
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|byteNow
parameter_list|,
name|Get
name|get
parameter_list|)
throws|throws
name|IOException
block|{
name|CellVisibility
name|cellVisibility
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cellVisibility
operator|=
name|delete
operator|.
name|getCellVisibility
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|de
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid cell visibility specified "
operator|+
name|delete
argument_list|,
name|de
argument_list|)
throw|;
block|}
comment|// The check for checkForReservedVisibilityTagPresence happens in preBatchMutate happens.
comment|// It happens for every mutation and that would be enough.
name|List
argument_list|<
name|Tag
argument_list|>
name|visibilityTags
init|=
operator|new
name|ArrayList
argument_list|<
name|Tag
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cellVisibility
operator|!=
literal|null
condition|)
block|{
name|String
name|labelsExp
init|=
name|cellVisibility
operator|.
name|getExpression
argument_list|()
decl_stmt|;
try|try
block|{
name|visibilityTags
operator|=
name|this
operator|.
name|visibilityLabelService
operator|.
name|createVisibilityExpTags
argument_list|(
name|labelsExp
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidLabelException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid cell visibility specified "
operator|+
name|labelsExp
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|get
operator|.
name|setFilter
argument_list|(
operator|new
name|DeleteVersionVisibilityExpressionFilter
argument_list|(
name|visibilityTags
argument_list|,
name|VisibilityConstants
operator|.
name|SORTED_ORDINAL_SERIALIZATION_FORMAT
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Cell
argument_list|>
name|result
init|=
name|ctx
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getRegion
argument_list|()
operator|.
name|get
argument_list|(
name|get
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|size
argument_list|()
operator|<
name|get
operator|.
name|getMaxVersions
argument_list|()
condition|)
block|{
comment|// Nothing to delete
name|CellUtil
operator|.
name|updateLatestStamp
argument_list|(
name|cell
argument_list|,
name|Long
operator|.
name|MIN_VALUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|result
operator|.
name|size
argument_list|()
operator|>
name|get
operator|.
name|getMaxVersions
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected size: "
operator|+
name|result
operator|.
name|size
argument_list|()
operator|+
literal|". Results more than the max versions obtained."
argument_list|)
throw|;
block|}
name|Cell
name|getCell
init|=
name|result
operator|.
name|get
argument_list|(
name|get
operator|.
name|getMaxVersions
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|CellUtil
operator|.
name|setTimestamp
argument_list|(
name|cell
argument_list|,
name|getCell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
comment|// We are bypassing here because in the HRegion.updateDeleteLatestVersionTimeStamp we would
comment|// update with the current timestamp after again doing a get. As the hook as already determined
comment|// the needed timestamp we need to bypass here.
comment|// TODO : See if HRegion.updateDeleteLatestVersionTimeStamp() could be
comment|// called only if the hook is not called.
name|ctx
operator|.
name|bypass
argument_list|()
expr_stmt|;
block|}
comment|/**    * Checks whether cell contains any tag with type as VISIBILITY_TAG_TYPE. This    * tag type is reserved and should not be explicitly set by user.    *    * @param cell    *          - the cell under consideration    * @param pair - an optional pair of type<Boolean, Tag> which would be reused    *               if already set and new one will be created if null is passed    * @return a pair<Boolean, Tag> - if the boolean is false then it indicates    *         that the cell has a RESERVERD_VIS_TAG and with boolean as true, not    *         null tag indicates that a string modified tag was found.    */
specifier|private
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Tag
argument_list|>
name|checkForReservedVisibilityTagPresence
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Tag
argument_list|>
name|pair
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
name|pair
operator|=
operator|new
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Tag
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pair
operator|.
name|setFirst
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|pair
operator|.
name|setSecond
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Bypass this check when the operation is done by a system/super user.
comment|// This is done because, while Replication, the Cells coming to the peer cluster with reserved
comment|// typed tags and this is fine and should get added to the peer cluster table
if|if
condition|(
name|isSystemOrSuperUser
argument_list|()
condition|)
block|{
comment|// Does the cell contain special tag which indicates that the replicated
comment|// cell visiblilty tags
comment|// have been modified
name|Tag
name|modifiedTag
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cell
operator|.
name|getTagsLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Iterator
argument_list|<
name|Tag
argument_list|>
name|tagsIterator
init|=
name|CellUtil
operator|.
name|tagsIterator
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|tagsIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Tag
name|tag
init|=
name|tagsIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|.
name|getType
argument_list|()
operator|==
name|TagType
operator|.
name|STRING_VIS_TAG_TYPE
condition|)
block|{
name|modifiedTag
operator|=
name|tag
expr_stmt|;
break|break;
block|}
block|}
block|}
name|pair
operator|.
name|setFirst
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|pair
operator|.
name|setSecond
argument_list|(
name|modifiedTag
argument_list|)
expr_stmt|;
return|return
name|pair
return|;
block|}
if|if
condition|(
name|cell
operator|.
name|getTagsLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Iterator
argument_list|<
name|Tag
argument_list|>
name|tagsItr
init|=
name|CellUtil
operator|.
name|tagsIterator
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|tagsItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|RESERVED_VIS_TAG_TYPES
operator|.
name|contains
argument_list|(
name|tagsItr
operator|.
name|next
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|pair
return|;
block|}
block|}
block|}
name|pair
operator|.
name|setFirst
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|pair
return|;
block|}
comment|/**    * Checks whether cell contains any tag with type as VISIBILITY_TAG_TYPE. This    * tag type is reserved and should not be explicitly set by user. There are    * two versions of this method one that accepts pair and other without pair.    * In case of preAppend and preIncrement the additional operations are not    * needed like checking for STRING_VIS_TAG_TYPE and hence the API without pair    * could be used.    *    * @param cell    * @throws IOException    */
specifier|private
name|boolean
name|checkForReservedVisibilityTagPresence
parameter_list|(
name|Cell
name|cell
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Bypass this check when the operation is done by a system/super user.
comment|// This is done because, while Replication, the Cells coming to the peer
comment|// cluster with reserved
comment|// typed tags and this is fine and should get added to the peer cluster
comment|// table
if|if
condition|(
name|isSystemOrSuperUser
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|cell
operator|.
name|getTagsLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Iterator
argument_list|<
name|Tag
argument_list|>
name|tagsItr
init|=
name|CellUtil
operator|.
name|tagsIterator
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|tagsItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|RESERVED_VIS_TAG_TYPES
operator|.
name|contains
argument_list|(
name|tagsItr
operator|.
name|next
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|removeReplicationVisibilityTag
parameter_list|(
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
parameter_list|)
throws|throws
name|IOException
block|{
name|Iterator
argument_list|<
name|Tag
argument_list|>
name|iterator
init|=
name|tags
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Tag
name|tag
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|.
name|getType
argument_list|()
operator|==
name|TagType
operator|.
name|STRING_VIS_TAG_TYPE
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|RegionScanner
name|preScannerOpen
parameter_list|(
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|e
parameter_list|,
name|Scan
name|scan
parameter_list|,
name|RegionScanner
name|s
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
throw|throw
operator|new
name|VisibilityControllerNotReadyException
argument_list|(
literal|"VisibilityController not yet initialized!"
argument_list|)
throw|;
block|}
name|HRegion
name|region
init|=
name|e
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|Authorizations
name|authorizations
init|=
literal|null
decl_stmt|;
try|try
block|{
name|authorizations
operator|=
name|scan
operator|.
name|getAuthorizations
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|de
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|de
argument_list|)
throw|;
block|}
if|if
condition|(
name|authorizations
operator|==
literal|null
condition|)
block|{
comment|// No Authorizations present for this scan/Get!
comment|// In case of system tables other than "labels" just scan with out visibility check and
comment|// filtering. Checking visibility labels for META and NAMESPACE table is not needed.
name|TableName
name|table
init|=
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|table
operator|.
name|isSystemTable
argument_list|()
operator|&&
operator|!
name|table
operator|.
name|equals
argument_list|(
name|LABELS_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
name|Filter
name|visibilityLabelFilter
init|=
name|VisibilityUtils
operator|.
name|createVisibilityLabelFilter
argument_list|(
name|region
argument_list|,
name|authorizations
argument_list|)
decl_stmt|;
if|if
condition|(
name|visibilityLabelFilter
operator|!=
literal|null
condition|)
block|{
name|Filter
name|filter
init|=
name|scan
operator|.
name|getFilter
argument_list|()
decl_stmt|;
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
name|scan
operator|.
name|setFilter
argument_list|(
operator|new
name|FilterList
argument_list|(
name|filter
argument_list|,
name|visibilityLabelFilter
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scan
operator|.
name|setFilter
argument_list|(
name|visibilityLabelFilter
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
annotation|@
name|Override
specifier|public
name|DeleteTracker
name|postInstantiateDeleteTracker
parameter_list|(
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|ctx
parameter_list|,
name|DeleteTracker
name|delTracker
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|ctx
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|TableName
name|table
init|=
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|table
operator|.
name|isSystemTable
argument_list|()
condition|)
block|{
return|return
name|delTracker
return|;
block|}
comment|// We are creating a new type of delete tracker here which is able to track
comment|// the timestamps and also the
comment|// visibility tags per cell. The covering cells are determined not only
comment|// based on the delete type and ts
comment|// but also on the visibility expression matching.
return|return
operator|new
name|VisibilityScanDeleteTracker
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|RegionScanner
name|postScannerOpen
parameter_list|(
specifier|final
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|c
parameter_list|,
specifier|final
name|Scan
name|scan
parameter_list|,
specifier|final
name|RegionScanner
name|s
parameter_list|)
throws|throws
name|IOException
block|{
name|User
name|user
init|=
name|VisibilityUtils
operator|.
name|getActiveUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|user
operator|!=
literal|null
operator|&&
name|user
operator|.
name|getShortName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|scannerOwners
operator|.
name|put
argument_list|(
name|s
argument_list|,
name|user
operator|.
name|getShortName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|preScannerNext
parameter_list|(
specifier|final
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|c
parameter_list|,
specifier|final
name|InternalScanner
name|s
parameter_list|,
specifier|final
name|List
argument_list|<
name|Result
argument_list|>
name|result
parameter_list|,
specifier|final
name|int
name|limit
parameter_list|,
specifier|final
name|boolean
name|hasNext
parameter_list|)
throws|throws
name|IOException
block|{
name|requireScannerOwner
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|hasNext
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|preScannerClose
parameter_list|(
specifier|final
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|c
parameter_list|,
specifier|final
name|InternalScanner
name|s
parameter_list|)
throws|throws
name|IOException
block|{
name|requireScannerOwner
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|postScannerClose
parameter_list|(
specifier|final
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|c
parameter_list|,
specifier|final
name|InternalScanner
name|s
parameter_list|)
throws|throws
name|IOException
block|{
comment|// clean up any associated owner mapping
name|scannerOwners
operator|.
name|remove
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify, when servicing an RPC, that the caller is the scanner owner. If so, we assume that    * access control is correctly enforced based on the checks performed in preScannerOpen()    */
specifier|private
name|void
name|requireScannerOwner
parameter_list|(
name|InternalScanner
name|s
parameter_list|)
throws|throws
name|AccessDeniedException
block|{
if|if
condition|(
name|RequestContext
operator|.
name|isInRequestContext
argument_list|()
condition|)
block|{
name|String
name|requestUName
init|=
name|RequestContext
operator|.
name|getRequestUserName
argument_list|()
decl_stmt|;
name|String
name|owner
init|=
name|scannerOwners
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|owner
operator|!=
literal|null
operator|&&
operator|!
name|owner
operator|.
name|equals
argument_list|(
name|requestUName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"User '"
operator|+
name|requestUName
operator|+
literal|"' is not the scanner owner!"
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|preGetOp
parameter_list|(
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|e
parameter_list|,
name|Get
name|get
parameter_list|,
name|List
argument_list|<
name|Cell
argument_list|>
name|results
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
throw|throw
operator|new
name|VisibilityControllerNotReadyException
argument_list|(
literal|"VisibilityController not yet initialized!"
argument_list|)
throw|;
block|}
name|HRegion
name|region
init|=
name|e
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|Authorizations
name|authorizations
init|=
literal|null
decl_stmt|;
try|try
block|{
name|authorizations
operator|=
name|get
operator|.
name|getAuthorizations
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|de
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|de
argument_list|)
throw|;
block|}
if|if
condition|(
name|authorizations
operator|==
literal|null
condition|)
block|{
comment|// No Authorizations present for this scan/Get!
comment|// In case of system tables other than "labels" just scan with out visibility check and
comment|// filtering. Checking visibility labels for META and NAMESPACE table is not needed.
name|TableName
name|table
init|=
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|table
operator|.
name|isSystemTable
argument_list|()
operator|&&
operator|!
name|table
operator|.
name|equals
argument_list|(
name|LABELS_TABLE_NAME
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|Filter
name|visibilityLabelFilter
init|=
name|VisibilityUtils
operator|.
name|createVisibilityLabelFilter
argument_list|(
name|e
operator|.
name|getEnvironment
argument_list|()
operator|.
name|getRegion
argument_list|()
argument_list|,
name|authorizations
argument_list|)
decl_stmt|;
if|if
condition|(
name|visibilityLabelFilter
operator|!=
literal|null
condition|)
block|{
name|Filter
name|filter
init|=
name|get
operator|.
name|getFilter
argument_list|()
decl_stmt|;
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
name|get
operator|.
name|setFilter
argument_list|(
operator|new
name|FilterList
argument_list|(
name|filter
argument_list|,
name|visibilityLabelFilter
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get
operator|.
name|setFilter
argument_list|(
name|visibilityLabelFilter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|isSystemOrSuperUser
parameter_list|()
throws|throws
name|IOException
block|{
name|User
name|activeUser
init|=
name|VisibilityUtils
operator|.
name|getActiveUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|superUsers
operator|.
name|contains
argument_list|(
name|activeUser
operator|.
name|getShortName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|String
index|[]
name|groups
init|=
name|activeUser
operator|.
name|getGroupNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|groups
operator|!=
literal|null
operator|&&
name|groups
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|String
name|group
range|:
name|groups
control|)
block|{
if|if
condition|(
name|this
operator|.
name|superGroups
operator|.
name|contains
argument_list|(
name|group
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Result
name|preAppend
parameter_list|(
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|e
parameter_list|,
name|Append
name|append
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|CellScanner
name|cellScanner
init|=
name|append
operator|.
name|cellScanner
argument_list|()
init|;
name|cellScanner
operator|.
name|advance
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|checkForReservedVisibilityTagPresence
argument_list|(
name|cellScanner
operator|.
name|current
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FailedSanityCheckException
argument_list|(
literal|"Append contains cell with reserved type tag"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Result
name|preIncrement
parameter_list|(
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|e
parameter_list|,
name|Increment
name|increment
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|CellScanner
name|cellScanner
init|=
name|increment
operator|.
name|cellScanner
argument_list|()
init|;
name|cellScanner
operator|.
name|advance
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|checkForReservedVisibilityTagPresence
argument_list|(
name|cellScanner
operator|.
name|current
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FailedSanityCheckException
argument_list|(
literal|"Increment contains cell with reserved type tag"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|postMutationBeforeWAL
parameter_list|(
name|ObserverContext
argument_list|<
name|RegionCoprocessorEnvironment
argument_list|>
name|ctx
parameter_list|,
name|MutationType
name|opType
parameter_list|,
name|Mutation
name|mutation
parameter_list|,
name|Cell
name|oldCell
parameter_list|,
name|Cell
name|newCell
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|CellVisibility
name|cellVisibility
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cellVisibility
operator|=
name|mutation
operator|.
name|getCellVisibility
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|cellVisibility
operator|==
literal|null
condition|)
block|{
return|return
name|newCell
return|;
block|}
comment|// Prepend new visibility tags to a new list of tags for the cell
comment|// Don't check user auths for labels with Mutations when the user is super user
name|boolean
name|authCheck
init|=
name|this
operator|.
name|checkAuths
operator|&&
operator|!
operator|(
name|isSystemOrSuperUser
argument_list|()
operator|)
decl_stmt|;
name|tags
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|visibilityLabelService
operator|.
name|createVisibilityExpTags
argument_list|(
name|cellVisibility
operator|.
name|getExpression
argument_list|()
argument_list|,
literal|true
argument_list|,
name|authCheck
argument_list|)
argument_list|)
expr_stmt|;
comment|// Save an object allocation where we can
if|if
condition|(
name|newCell
operator|.
name|getTagsLength
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Carry forward all other tags
name|Iterator
argument_list|<
name|Tag
argument_list|>
name|tagsItr
init|=
name|CellUtil
operator|.
name|tagsIterator
argument_list|(
name|newCell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|newCell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|newCell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|tagsItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Tag
name|tag
init|=
name|tagsItr
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|.
name|getType
argument_list|()
operator|!=
name|TagType
operator|.
name|VISIBILITY_TAG_TYPE
operator|&&
name|tag
operator|.
name|getType
argument_list|()
operator|!=
name|TagType
operator|.
name|VISIBILITY_EXP_SERIALIZATION_FORMAT_TAG_TYPE
condition|)
block|{
name|tags
operator|.
name|add
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Cell
name|rewriteCell
init|=
operator|new
name|TagRewriteCell
argument_list|(
name|newCell
argument_list|,
name|Tag
operator|.
name|fromList
argument_list|(
name|tags
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|rewriteCell
return|;
block|}
annotation|@
name|Override
specifier|public
name|Service
name|getService
parameter_list|()
block|{
return|return
name|VisibilityLabelsProtos
operator|.
name|VisibilityLabelsService
operator|.
name|newReflectiveService
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/****************************** VisibilityEndpoint service related methods ******************************/
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|addLabels
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|VisibilityLabelsRequest
name|request
parameter_list|,
name|RpcCallback
argument_list|<
name|VisibilityLabelsResponse
argument_list|>
name|done
parameter_list|)
block|{
name|VisibilityLabelsResponse
operator|.
name|Builder
name|response
init|=
name|VisibilityLabelsResponse
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|VisibilityLabel
argument_list|>
name|visLabels
init|=
name|request
operator|.
name|getVisLabelList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|setExceptionResults
argument_list|(
name|visLabels
operator|.
name|size
argument_list|()
argument_list|,
operator|new
name|VisibilityControllerNotReadyException
argument_list|(
literal|"VisibilityController not yet initialized!"
argument_list|)
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|checkCallingUserAuth
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|labels
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|visLabels
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|RegionActionResult
name|successResult
init|=
name|RegionActionResult
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
for|for
control|(
name|VisibilityLabel
name|visLabel
range|:
name|visLabels
control|)
block|{
name|byte
index|[]
name|label
init|=
name|visLabel
operator|.
name|getLabel
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|labels
operator|.
name|add
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|response
operator|.
name|addResult
argument_list|(
name|successResult
argument_list|)
expr_stmt|;
comment|// Just mark as success. Later it will get reset
comment|// based on the result from
comment|// visibilityLabelService.addLabels ()
block|}
if|if
condition|(
operator|!
name|labels
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|OperationStatus
index|[]
name|opStatus
init|=
name|this
operator|.
name|visibilityLabelService
operator|.
name|addLabels
argument_list|(
name|labels
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|OperationStatus
name|status
range|:
name|opStatus
control|)
block|{
while|while
condition|(
name|response
operator|.
name|getResult
argument_list|(
name|i
argument_list|)
operator|!=
name|successResult
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|getOperationStatusCode
argument_list|()
operator|!=
name|SUCCESS
condition|)
block|{
name|RegionActionResult
operator|.
name|Builder
name|failureResultBuilder
init|=
name|RegionActionResult
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|failureResultBuilder
operator|.
name|setException
argument_list|(
name|ResponseConverter
operator|.
name|buildException
argument_list|(
operator|new
name|DoNotRetryIOException
argument_list|(
name|status
operator|.
name|getExceptionMsg
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|response
operator|.
name|setResult
argument_list|(
name|i
argument_list|,
name|failureResultBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|setExceptionResults
argument_list|(
name|visLabels
operator|.
name|size
argument_list|()
argument_list|,
name|e
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
block|}
name|done
operator|.
name|run
argument_list|(
name|response
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setExceptionResults
parameter_list|(
name|int
name|size
parameter_list|,
name|IOException
name|e
parameter_list|,
name|VisibilityLabelsResponse
operator|.
name|Builder
name|response
parameter_list|)
block|{
name|RegionActionResult
operator|.
name|Builder
name|failureResultBuilder
init|=
name|RegionActionResult
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|failureResultBuilder
operator|.
name|setException
argument_list|(
name|ResponseConverter
operator|.
name|buildException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|RegionActionResult
name|failureResult
init|=
name|failureResultBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|response
operator|.
name|addResult
argument_list|(
name|i
argument_list|,
name|failureResult
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|setAuths
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|SetAuthsRequest
name|request
parameter_list|,
name|RpcCallback
argument_list|<
name|VisibilityLabelsResponse
argument_list|>
name|done
parameter_list|)
block|{
name|VisibilityLabelsResponse
operator|.
name|Builder
name|response
init|=
name|VisibilityLabelsResponse
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ByteString
argument_list|>
name|auths
init|=
name|request
operator|.
name|getAuthList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|setExceptionResults
argument_list|(
name|auths
operator|.
name|size
argument_list|()
argument_list|,
operator|new
name|VisibilityControllerNotReadyException
argument_list|(
literal|"VisibilityController not yet initialized!"
argument_list|)
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|checkCallingUserAuth
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|labelAuths
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|auths
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|ByteString
name|authBS
range|:
name|auths
control|)
block|{
name|labelAuths
operator|.
name|add
argument_list|(
name|authBS
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|OperationStatus
index|[]
name|opStatus
init|=
name|this
operator|.
name|visibilityLabelService
operator|.
name|setAuths
argument_list|(
name|request
operator|.
name|getUser
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|labelAuths
argument_list|)
decl_stmt|;
name|RegionActionResult
name|successResult
init|=
name|RegionActionResult
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
for|for
control|(
name|OperationStatus
name|status
range|:
name|opStatus
control|)
block|{
if|if
condition|(
name|status
operator|.
name|getOperationStatusCode
argument_list|()
operator|==
name|SUCCESS
condition|)
block|{
name|response
operator|.
name|addResult
argument_list|(
name|successResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RegionActionResult
operator|.
name|Builder
name|failureResultBuilder
init|=
name|RegionActionResult
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|failureResultBuilder
operator|.
name|setException
argument_list|(
name|ResponseConverter
operator|.
name|buildException
argument_list|(
operator|new
name|DoNotRetryIOException
argument_list|(
name|status
operator|.
name|getExceptionMsg
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|response
operator|.
name|addResult
argument_list|(
name|failureResultBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|setExceptionResults
argument_list|(
name|auths
operator|.
name|size
argument_list|()
argument_list|,
name|e
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
block|}
name|done
operator|.
name|run
argument_list|(
name|response
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|getAuths
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|GetAuthsRequest
name|request
parameter_list|,
name|RpcCallback
argument_list|<
name|GetAuthsResponse
argument_list|>
name|done
parameter_list|)
block|{
name|GetAuthsResponse
operator|.
name|Builder
name|response
init|=
name|GetAuthsResponse
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|controller
operator|.
name|setFailed
argument_list|(
literal|"VisibilityController not yet initialized"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|user
init|=
name|request
operator|.
name|getUser
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|labels
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// We do ACL check here as we create scanner directly on region. It will not make calls to
comment|// AccessController CP methods.
if|if
condition|(
name|this
operator|.
name|acOn
operator|&&
operator|!
name|isSystemOrSuperUser
argument_list|()
condition|)
block|{
name|User
name|requestingUser
init|=
name|VisibilityUtils
operator|.
name|getActiveUser
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"User '"
operator|+
operator|(
name|requestingUser
operator|!=
literal|null
condition|?
name|requestingUser
operator|.
name|getShortName
argument_list|()
else|:
literal|"null"
operator|)
operator|+
literal|"' is not authorized to perform this action."
argument_list|)
throw|;
block|}
if|if
condition|(
name|AccessControlLists
operator|.
name|isGroupPrincipal
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|user
argument_list|)
argument_list|)
condition|)
block|{
name|String
name|group
init|=
name|AccessControlLists
operator|.
name|getGroupName
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|user
argument_list|)
argument_list|)
decl_stmt|;
name|labels
operator|=
name|this
operator|.
name|visibilityLabelService
operator|.
name|getGroupAuths
argument_list|(
operator|new
name|String
index|[]
block|{
name|group
block|}
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|labels
operator|=
name|this
operator|.
name|visibilityLabelService
operator|.
name|getUserAuths
argument_list|(
name|user
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|ResponseConverter
operator|.
name|setControllerException
argument_list|(
name|controller
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|response
operator|.
name|setUser
argument_list|(
name|request
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|labels
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|label
range|:
name|labels
control|)
block|{
name|response
operator|.
name|addAuth
argument_list|(
name|ByteStringer
operator|.
name|wrap
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|done
operator|.
name|run
argument_list|(
name|response
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|clearAuths
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|SetAuthsRequest
name|request
parameter_list|,
name|RpcCallback
argument_list|<
name|VisibilityLabelsResponse
argument_list|>
name|done
parameter_list|)
block|{
name|VisibilityLabelsResponse
operator|.
name|Builder
name|response
init|=
name|VisibilityLabelsResponse
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ByteString
argument_list|>
name|auths
init|=
name|request
operator|.
name|getAuthList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|setExceptionResults
argument_list|(
name|auths
operator|.
name|size
argument_list|()
argument_list|,
operator|new
name|CoprocessorException
argument_list|(
literal|"VisibilityController not yet initialized"
argument_list|)
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
comment|// When AC is ON, do AC based user auth check
if|if
condition|(
name|this
operator|.
name|acOn
operator|&&
operator|!
name|isSystemOrSuperUser
argument_list|()
condition|)
block|{
name|User
name|user
init|=
name|VisibilityUtils
operator|.
name|getActiveUser
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"User '"
operator|+
operator|(
name|user
operator|!=
literal|null
condition|?
name|user
operator|.
name|getShortName
argument_list|()
else|:
literal|"null"
operator|)
operator|+
literal|" is not authorized to perform this action."
argument_list|)
throw|;
block|}
name|checkCallingUserAuth
argument_list|()
expr_stmt|;
comment|// When AC is not in place the calling user should have SYSTEM_LABEL
comment|// auth to do this action.
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|labelAuths
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|auths
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|ByteString
name|authBS
range|:
name|auths
control|)
block|{
name|labelAuths
operator|.
name|add
argument_list|(
name|authBS
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|OperationStatus
index|[]
name|opStatus
init|=
name|this
operator|.
name|visibilityLabelService
operator|.
name|clearAuths
argument_list|(
name|request
operator|.
name|getUser
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|labelAuths
argument_list|)
decl_stmt|;
name|RegionActionResult
name|successResult
init|=
name|RegionActionResult
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
for|for
control|(
name|OperationStatus
name|status
range|:
name|opStatus
control|)
block|{
if|if
condition|(
name|status
operator|.
name|getOperationStatusCode
argument_list|()
operator|==
name|SUCCESS
condition|)
block|{
name|response
operator|.
name|addResult
argument_list|(
name|successResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RegionActionResult
operator|.
name|Builder
name|failureResultBuilder
init|=
name|RegionActionResult
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|failureResultBuilder
operator|.
name|setException
argument_list|(
name|ResponseConverter
operator|.
name|buildException
argument_list|(
operator|new
name|DoNotRetryIOException
argument_list|(
name|status
operator|.
name|getExceptionMsg
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|response
operator|.
name|addResult
argument_list|(
name|failureResultBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|setExceptionResults
argument_list|(
name|auths
operator|.
name|size
argument_list|()
argument_list|,
name|e
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
block|}
name|done
operator|.
name|run
argument_list|(
name|response
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|listLabels
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|ListLabelsRequest
name|request
parameter_list|,
name|RpcCallback
argument_list|<
name|ListLabelsResponse
argument_list|>
name|done
parameter_list|)
block|{
name|ListLabelsResponse
operator|.
name|Builder
name|response
init|=
name|ListLabelsResponse
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|controller
operator|.
name|setFailed
argument_list|(
literal|"VisibilityController not yet initialized"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|String
argument_list|>
name|labels
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// We do ACL check here as we create scanner directly on region. It will not make calls to
comment|// AccessController CP methods.
if|if
condition|(
name|this
operator|.
name|acOn
operator|&&
operator|!
name|isSystemOrSuperUser
argument_list|()
condition|)
block|{
name|User
name|requestingUser
init|=
name|VisibilityUtils
operator|.
name|getActiveUser
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"User '"
operator|+
operator|(
name|requestingUser
operator|!=
literal|null
condition|?
name|requestingUser
operator|.
name|getShortName
argument_list|()
else|:
literal|"null"
operator|)
operator|+
literal|"' is not authorized to perform this action."
argument_list|)
throw|;
block|}
name|String
name|regex
init|=
name|request
operator|.
name|hasRegex
argument_list|()
condition|?
name|request
operator|.
name|getRegex
argument_list|()
else|:
literal|null
decl_stmt|;
name|labels
operator|=
name|this
operator|.
name|visibilityLabelService
operator|.
name|listLabels
argument_list|(
name|regex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|ResponseConverter
operator|.
name|setControllerException
argument_list|(
name|controller
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|labels
operator|!=
literal|null
operator|&&
operator|!
name|labels
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|label
range|:
name|labels
control|)
block|{
name|response
operator|.
name|addLabel
argument_list|(
name|ByteStringer
operator|.
name|wrap
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|done
operator|.
name|run
argument_list|(
name|response
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkCallingUserAuth
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|acOn
condition|)
block|{
name|User
name|user
init|=
name|VisibilityUtils
operator|.
name|getActiveUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|user
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to retrieve calling user"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|this
operator|.
name|visibilityLabelService
operator|.
name|havingSystemAuth
argument_list|(
name|user
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"User '"
operator|+
name|user
operator|.
name|getShortName
argument_list|()
operator|+
literal|"' is not authorized to perform this action."
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|DeleteVersionVisibilityExpressionFilter
extends|extends
name|FilterBase
block|{
specifier|private
name|List
argument_list|<
name|Tag
argument_list|>
name|deleteCellVisTags
decl_stmt|;
specifier|private
name|Byte
name|deleteCellVisTagsFormat
decl_stmt|;
specifier|public
name|DeleteVersionVisibilityExpressionFilter
parameter_list|(
name|List
argument_list|<
name|Tag
argument_list|>
name|deleteCellVisTags
parameter_list|,
name|Byte
name|deleteCellVisTagsFormat
parameter_list|)
block|{
name|this
operator|.
name|deleteCellVisTags
operator|=
name|deleteCellVisTags
expr_stmt|;
name|this
operator|.
name|deleteCellVisTagsFormat
operator|=
name|deleteCellVisTagsFormat
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|ReturnCode
name|filterKeyValue
parameter_list|(
name|Cell
name|cell
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Tag
argument_list|>
name|putVisTags
init|=
operator|new
name|ArrayList
argument_list|<
name|Tag
argument_list|>
argument_list|()
decl_stmt|;
name|Byte
name|putCellVisTagsFormat
init|=
name|VisibilityUtils
operator|.
name|extractVisibilityTags
argument_list|(
name|cell
argument_list|,
name|putVisTags
argument_list|)
decl_stmt|;
name|boolean
name|matchFound
init|=
name|VisibilityLabelServiceManager
operator|.
name|getInstance
argument_list|()
operator|.
name|getVisibilityLabelService
argument_list|()
operator|.
name|matchVisibility
argument_list|(
name|putVisTags
argument_list|,
name|putCellVisTagsFormat
argument_list|,
name|deleteCellVisTags
argument_list|,
name|deleteCellVisTagsFormat
argument_list|)
decl_stmt|;
return|return
name|matchFound
condition|?
name|ReturnCode
operator|.
name|INCLUDE
else|:
name|ReturnCode
operator|.
name|SKIP
return|;
block|}
block|}
comment|/**    * A RegionServerObserver impl that provides the custom    * VisibilityReplicationEndpoint. This class should be configured as the    * 'hbase.coprocessor.regionserver.classes' for the visibility tags to be    * replicated as string.  The value for the configuration should be    * 'org.apache.hadoop.hbase.security.visibility.VisibilityController$VisibilityReplication'.    */
specifier|public
specifier|static
class|class
name|VisibilityReplication
extends|extends
name|BaseRegionServerObserver
block|{
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|VisibilityLabelService
name|visibilityLabelService
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|start
parameter_list|(
name|CoprocessorEnvironment
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|env
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
name|visibilityLabelService
operator|=
name|VisibilityLabelServiceManager
operator|.
name|getInstance
argument_list|()
operator|.
name|getVisibilityLabelService
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
name|CoprocessorEnvironment
name|env
parameter_list|)
throws|throws
name|IOException
block|{     }
annotation|@
name|Override
specifier|public
name|ReplicationEndpoint
name|postCreateReplicationEndPoint
parameter_list|(
name|ObserverContext
argument_list|<
name|RegionServerCoprocessorEnvironment
argument_list|>
name|ctx
parameter_list|,
name|ReplicationEndpoint
name|endpoint
parameter_list|)
block|{
return|return
operator|new
name|VisibilityReplicationEndpoint
argument_list|(
name|endpoint
argument_list|,
name|visibilityLabelService
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

