begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProcedureProtos
operator|.
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_CLOSED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProcedureProtos
operator|.
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_OPENED
import|;
end_import

begin_import
import|import
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionReplicaUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RetriesExhaustedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|UnexpectedStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|AbstractStateMachineRegionProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureEnv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|Procedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureStateSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureSuspendedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureYieldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProcedureProtos
operator|.
name|RegionStateTransitionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProcedureProtos
operator|.
name|RegionStateTransitionStateData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ProcedureProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionStateTransition
operator|.
name|TransitionCode
import|;
end_import

begin_comment
comment|/**  * The procedure to deal with the state transition of a region. A region with a TRSP in place is  * called RIT, i.e, RegionInTransition.  *<p/>  * It can be used to assign/unassign/reopen/move a region, and for  * {@link #unassign(MasterProcedureEnv, RegionInfo)} and  * {@link #reopen(MasterProcedureEnv, RegionInfo)}, you do not need to specify a target server, and  * for {@link #assign(MasterProcedureEnv, RegionInfo, ServerName)} and  * {@link #move(MasterProcedureEnv, RegionInfo, ServerName)}, if you want to you can provide a  * target server. And for {@link #move(MasterProcedureEnv, RegionInfo, ServerName)}, if you do not  * specify a targetServer, we will select one randomly.  *<p/>  *<p/>  * The typical state transition for assigning a region is:  *  *<pre>  * GET_ASSIGN_CANDIDATE ------> OPEN -----> CONFIRM_OPENED  *</pre>  *  * Notice that, if there are failures we may go back to the {@code GET_ASSIGN_CANDIDATE} state to  * try again.  *<p/>  * The typical state transition for unassigning a region is:  *  *<pre>  * CLOSE -----> CONFIRM_CLOSED  *</pre>  *  * Here things go a bit different, if there are failures, especially that if there is a server  * crash, we will go to the {@code GET_ASSIGN_CANDIDATE} state to bring the region online first, and  * then go through the normal way to unassign it.  *<p/>  * The typical state transition for reopening/moving a region is:  *  *<pre>  * CLOSE -----> CONFIRM_CLOSED -----> GET_ASSIGN_CANDIDATE ------> OPEN -----> CONFIRM_OPENED  *</pre>  *  * The retry logic is the same with the above assign/unassign.  *<p/>  * Notice that, although we allow specify a target server, it just acts as a candidate, we do not  * guarantee that the region will finally be on the target server. If this is important for you, you  * should check whether the region is on the target server after the procedure is finished.  *<p/>  * When you want to schedule a TRSP, please check whether there is still one for this region, and  * the check should be under the RegionStateNode lock. We will remove the TRSP from a  * RegionStateNode when we are done, see the code in {@code reportTransition} method below. There  * could be at most one TRSP for a give region.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|TransitRegionStateProcedure
extends|extends
name|AbstractStateMachineRegionProcedure
argument_list|<
name|RegionStateTransitionState
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TransitRegionStateProcedure
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|RegionStateTransitionState
name|initialState
decl_stmt|;
specifier|private
name|RegionStateTransitionState
name|lastState
decl_stmt|;
comment|// the candidate where we want to assign the region to.
specifier|private
name|ServerName
name|assignCandidate
decl_stmt|;
specifier|private
name|boolean
name|forceNewPlan
decl_stmt|;
specifier|private
name|int
name|attempt
decl_stmt|;
specifier|public
name|TransitRegionStateProcedure
parameter_list|()
block|{   }
annotation|@
name|VisibleForTesting
specifier|protected
name|TransitRegionStateProcedure
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionInfo
name|hri
parameter_list|,
name|ServerName
name|assignCandidate
parameter_list|,
name|boolean
name|forceNewPlan
parameter_list|,
name|RegionStateTransitionState
name|initialState
parameter_list|,
name|RegionStateTransitionState
name|lastState
parameter_list|)
block|{
name|super
argument_list|(
name|env
argument_list|,
name|hri
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignCandidate
operator|=
name|assignCandidate
expr_stmt|;
name|this
operator|.
name|forceNewPlan
operator|=
name|forceNewPlan
expr_stmt|;
name|this
operator|.
name|initialState
operator|=
name|initialState
expr_stmt|;
name|this
operator|.
name|lastState
operator|=
name|lastState
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|TableOperationType
name|getTableOperationType
parameter_list|()
block|{
comment|// TODO: maybe we should make another type here, REGION_TRANSITION?
return|return
name|TableOperationType
operator|.
name|REGION_EDIT
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|waitInitialized
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
if|if
condition|(
name|TableName
operator|.
name|isMetaTableName
argument_list|(
name|getTableName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// First we need meta to be loaded, and second, if meta is not online then we will likely to
comment|// fail when updating meta so we wait until it is assigned.
name|AssignmentManager
name|am
init|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
decl_stmt|;
return|return
name|am
operator|.
name|waitMetaLoaded
argument_list|(
name|this
argument_list|)
operator|||
name|am
operator|.
name|waitMetaAssigned
argument_list|(
name|this
argument_list|,
name|getRegion
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|void
name|queueAssign
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|ProcedureSuspendedException
block|{
comment|// Here the assumption is that, the region must be in CLOSED state, so the region location
comment|// will be null. And if we fail to open the region and retry here, the forceNewPlan will be
comment|// true, and also we will set the region location to null.
name|boolean
name|retain
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|forceNewPlan
condition|)
block|{
if|if
condition|(
name|assignCandidate
operator|!=
literal|null
condition|)
block|{
name|retain
operator|=
name|assignCandidate
operator|.
name|equals
argument_list|(
name|regionNode
operator|.
name|getLastHost
argument_list|()
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
name|assignCandidate
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regionNode
operator|.
name|getLastHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|retain
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting lastHost as the region location {}"
argument_list|,
name|regionNode
operator|.
name|getLastHost
argument_list|()
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
name|regionNode
operator|.
name|getLastHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting {}; {}; forceNewPlan={}, retain={}"
argument_list|,
name|this
argument_list|,
name|regionNode
operator|.
name|toShortString
argument_list|()
argument_list|,
name|forceNewPlan
argument_list|,
name|retain
argument_list|)
expr_stmt|;
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|queueAssign
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionNode
operator|.
name|getProcedureEvent
argument_list|()
operator|.
name|suspendIfNotReady
argument_list|(
name|this
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ProcedureSuspendedException
argument_list|()
throw|;
block|}
block|}
specifier|private
name|void
name|openRegion
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
name|ServerName
name|loc
init|=
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|loc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No location specified for {}, jump back to state {} to get one"
argument_list|,
name|getRegion
argument_list|()
argument_list|,
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_GET_ASSIGN_CANDIDATE
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_GET_ASSIGN_CANDIDATE
argument_list|)
expr_stmt|;
return|return;
block|}
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|regionOpening
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
name|addChildProcedure
argument_list|(
operator|new
name|OpenRegionProcedure
argument_list|(
name|getRegion
argument_list|()
argument_list|,
name|loc
argument_list|)
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_OPENED
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Flow
name|confirmOpened
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
comment|// notice that, for normal case, if we successfully opened a region, we will not arrive here, as
comment|// in reportTransition we will call unsetProcedure, and in executeFromState we will return
comment|// directly. But if the master is crashed before we finish the procedure, then next time we will
comment|// arrive here. So we still need to add code for normal cases.
if|if
condition|(
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|OPEN
argument_list|)
condition|)
block|{
name|attempt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lastState
operator|==
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_OPENED
condition|)
block|{
comment|// we are the last state, finish
name|regionNode
operator|.
name|unsetProcedure
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|NO_MORE_STATE
return|;
block|}
comment|// It is possible that we arrive here but confirm opened is not the last state, for example,
comment|// when merging or splitting a region, we unassign the region from a RS and the RS is crashed,
comment|// then there will be recovered edits for this region, we'd better make the region online
comment|// again and then unassign it, otherwise we have to fail the merge/split procedure as we may
comment|// loss data.
name|setNextState
argument_list|(
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CLOSE
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|HAS_MORE_STATE
return|;
block|}
if|if
condition|(
name|incrementAndCheckMaxAttempts
argument_list|(
name|env
argument_list|,
name|regionNode
argument_list|)
condition|)
block|{
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|regionFailedOpen
argument_list|(
name|regionNode
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|setFailure
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
operator|new
name|RetriesExhaustedException
argument_list|(
literal|"Max attempts "
operator|+
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getAssignMaxAttempts
argument_list|()
operator|+
literal|" exceeded"
argument_list|)
argument_list|)
expr_stmt|;
name|regionNode
operator|.
name|unsetProcedure
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|NO_MORE_STATE
return|;
block|}
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|regionFailedOpen
argument_list|(
name|regionNode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// we failed to assign the region, force a new plan
name|forceNewPlan
operator|=
literal|true
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_GET_ASSIGN_CANDIDATE
argument_list|)
expr_stmt|;
comment|// Here we do not throw exception because we want to the region to be online ASAP
return|return
name|Flow
operator|.
name|HAS_MORE_STATE
return|;
block|}
specifier|private
name|void
name|closeRegion
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|OPEN
argument_list|,
name|State
operator|.
name|CLOSING
argument_list|,
name|State
operator|.
name|MERGING
argument_list|,
name|State
operator|.
name|SPLITTING
argument_list|)
condition|)
block|{
comment|// this is the normal case
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|regionClosing
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
name|addChildProcedure
argument_list|(
operator|new
name|CloseRegionProcedure
argument_list|(
name|getRegion
argument_list|()
argument_list|,
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
argument_list|,
name|assignCandidate
argument_list|)
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_CLOSED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|forceNewPlan
operator|=
literal|true
expr_stmt|;
name|regionNode
operator|.
name|setRegionLocation
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_GET_ASSIGN_CANDIDATE
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Flow
name|confirmClosed
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateNode
name|regionNode
parameter_list|)
throws|throws
name|IOException
block|{
comment|// notice that, for normal case, if we successfully opened a region, we will not arrive here, as
comment|// in reportTransition we will call unsetProcedure, and in executeFromState we will return
comment|// directly. But if the master is crashed before we finish the procedure, then next time we will
comment|// arrive here. So we still need to add code for normal cases.
if|if
condition|(
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|CLOSED
argument_list|)
condition|)
block|{
name|attempt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lastState
operator|==
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_CLOSED
condition|)
block|{
comment|// we are the last state, finish
name|regionNode
operator|.
name|unsetProcedure
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|NO_MORE_STATE
return|;
block|}
comment|// This means we need to open the region again, should be a move or reopen
name|setNextState
argument_list|(
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_GET_ASSIGN_CANDIDATE
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|HAS_MORE_STATE
return|;
block|}
if|if
condition|(
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|CLOSING
argument_list|)
condition|)
block|{
comment|// This is possible, think the target RS crashes and restarts immediately, the close region
comment|// operation will return a NotServingRegionException soon, we can only recover after SCP takes
comment|// care of this RS. So here we throw an IOException to let upper layer to retry with backoff.
name|setNextState
argument_list|(
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CLOSE
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HBaseIOException
argument_list|(
literal|"Failed to close region"
argument_list|)
throw|;
block|}
comment|// abnormally closed, need to reopen it, no matter what is the last state, see the comment in
comment|// confirmOpened for more details that why we need to reopen the region first even if we just
comment|// want to close it.
comment|// The only exception is for non-default replica, where we do not need to deal with recovered
comment|// edits. Notice that the region will remain in ABNORMALLY_CLOSED state, the upper layer need to
comment|// deal with this state. For non-default replica, this is usually the same with CLOSED.
assert|assert
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|ABNORMALLY_CLOSED
argument_list|)
assert|;
if|if
condition|(
operator|!
name|RegionReplicaUtil
operator|.
name|isDefaultReplica
argument_list|(
name|getRegion
argument_list|()
argument_list|)
operator|&&
name|lastState
operator|==
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_CLOSED
condition|)
block|{
name|regionNode
operator|.
name|unsetProcedure
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|NO_MORE_STATE
return|;
block|}
name|attempt
operator|=
literal|0
expr_stmt|;
name|setNextState
argument_list|(
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_GET_ASSIGN_CANDIDATE
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|HAS_MORE_STATE
return|;
block|}
comment|// Override to lock RegionStateNode
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
annotation|@
name|Override
specifier|protected
name|Procedure
index|[]
name|execute
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|ProcedureSuspendedException
throws|,
name|ProcedureYieldException
throws|,
name|InterruptedException
block|{
name|RegionStateNode
name|regionNode
init|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|getRegion
argument_list|()
argument_list|)
decl_stmt|;
name|regionNode
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|execute
argument_list|(
name|env
argument_list|)
return|;
block|}
finally|finally
block|{
name|regionNode
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|RegionStateNode
name|getRegionStateNode
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
return|return
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|getRegion
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Flow
name|executeFromState
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateTransitionState
name|state
parameter_list|)
throws|throws
name|ProcedureSuspendedException
throws|,
name|ProcedureYieldException
throws|,
name|InterruptedException
block|{
name|RegionStateNode
name|regionNode
init|=
name|getRegionStateNode
argument_list|(
name|env
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionNode
operator|.
name|getProcedure
argument_list|()
operator|!=
name|this
condition|)
block|{
comment|// This is possible, and is the normal case, as we will call unsetProcedure in
comment|// reportTransition, this means we have already done
comment|// This is because that, when we mark the region as OPENED or CLOSED, then all the works
comment|// should have already been done, and logically we could have another TRSP scheduled for this
comment|// region immediately(think of a RS crash at the point...).
return|return
name|Flow
operator|.
name|NO_MORE_STATE
return|;
block|}
try|try
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|REGION_STATE_TRANSITION_GET_ASSIGN_CANDIDATE
case|:
name|queueAssign
argument_list|(
name|env
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|HAS_MORE_STATE
return|;
case|case
name|REGION_STATE_TRANSITION_OPEN
case|:
name|openRegion
argument_list|(
name|env
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|HAS_MORE_STATE
return|;
case|case
name|REGION_STATE_TRANSITION_CONFIRM_OPENED
case|:
return|return
name|confirmOpened
argument_list|(
name|env
argument_list|,
name|regionNode
argument_list|)
return|;
case|case
name|REGION_STATE_TRANSITION_CLOSE
case|:
name|closeRegion
argument_list|(
name|env
argument_list|,
name|regionNode
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|HAS_MORE_STATE
return|;
case|case
name|REGION_STATE_TRANSITION_CONFIRM_CLOSED
case|:
return|return
name|confirmClosed
argument_list|(
name|env
argument_list|,
name|regionNode
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"unhandled state="
operator|+
name|state
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|long
name|backoff
init|=
name|ProcedureUtil
operator|.
name|getBackoffTimeMs
argument_list|(
name|this
operator|.
name|attempt
operator|++
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed transition, suspend {}secs {}; {}; waiting on rectified condition fixed "
operator|+
literal|"by other Procedure or operator intervention"
argument_list|,
name|backoff
operator|/
literal|1000
argument_list|,
name|this
argument_list|,
name|regionNode
operator|.
name|toShortString
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setTimeout
argument_list|(
name|Math
operator|.
name|toIntExact
argument_list|(
name|backoff
argument_list|)
argument_list|)
expr_stmt|;
name|setState
argument_list|(
name|ProcedureProtos
operator|.
name|ProcedureState
operator|.
name|WAITING_TIMEOUT
argument_list|)
expr_stmt|;
name|skipPersistence
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ProcedureSuspendedException
argument_list|()
throw|;
block|}
block|}
comment|/**    * At end of timeout, wake ourselves up so we run again.    */
annotation|@
name|Override
specifier|protected
specifier|synchronized
name|boolean
name|setTimeoutFailure
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
name|setState
argument_list|(
name|ProcedureProtos
operator|.
name|ProcedureState
operator|.
name|RUNNABLE
argument_list|)
expr_stmt|;
name|env
operator|.
name|getProcedureScheduler
argument_list|()
operator|.
name|addFront
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// 'false' means that this procedure handled the timeout
block|}
specifier|private
name|boolean
name|isOpening
parameter_list|(
name|RegionStateNode
name|regionNode
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
name|TransitionCode
name|code
parameter_list|)
block|{
if|if
condition|(
operator|!
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|OPENING
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received report {} transition from {} for {}, pid={}, but the region is not in"
operator|+
literal|" OPENING state, should be a retry, ignore"
argument_list|,
name|code
argument_list|,
name|serverName
argument_list|,
name|regionNode
argument_list|,
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getCurrentState
argument_list|()
operator|!=
name|REGION_STATE_TRANSITION_CONFIRM_OPENED
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received report {} transition from {} for {}, pid={},"
operator|+
literal|" but the TRSP is not in {} state, should be a retry, ignore"
argument_list|,
name|code
argument_list|,
name|serverName
argument_list|,
name|regionNode
argument_list|,
name|getProcId
argument_list|()
argument_list|,
name|REGION_STATE_TRANSITION_CONFIRM_OPENED
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|reportTransitionOpen
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateNode
name|regionNode
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
name|long
name|openSeqNum
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isOpening
argument_list|(
name|regionNode
argument_list|,
name|serverName
argument_list|,
name|TransitionCode
operator|.
name|OPENED
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|openSeqNum
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
literal|"Received report unexpected "
operator|+
name|TransitionCode
operator|.
name|OPENED
operator|+
literal|" transition openSeqNum="
operator|+
name|openSeqNum
operator|+
literal|", "
operator|+
name|regionNode
operator|+
literal|", proc="
operator|+
name|this
argument_list|)
throw|;
block|}
if|if
condition|(
name|openSeqNum
operator|<
name|regionNode
operator|.
name|getOpenSeqNum
argument_list|()
condition|)
block|{
comment|// use the openSeqNum as a fence, if this is not a retry, then the openSeqNum should be
comment|// greater than or equal to the existing one.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received report {} transition from {} for {}, pid={} but the new openSeqNum {}"
operator|+
literal|" is less than the current one {}, should be a retry, ignore"
argument_list|,
name|TransitionCode
operator|.
name|OPENED
argument_list|,
name|serverName
argument_list|,
name|regionNode
argument_list|,
name|getProcId
argument_list|()
argument_list|,
name|openSeqNum
argument_list|,
name|regionNode
operator|.
name|getOpenSeqNum
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// notice that it is possible for a region to still have the same openSeqNum if it crashes and
comment|// we haven't written anything into it. That's why we can not just change the above condition
comment|// from '<' to '<='. So here we still need to check whether the serverName
comment|// matches, to determine whether this is a retry when the openSeqNum is not changed.
if|if
condition|(
operator|!
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received report {} transition from {} for {}, pid={} but the region is not on it,"
operator|+
literal|" should be a retry, ignore"
argument_list|,
name|TransitionCode
operator|.
name|OPENED
argument_list|,
name|serverName
argument_list|,
name|regionNode
argument_list|,
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|regionNode
operator|.
name|setOpenSeqNum
argument_list|(
name|openSeqNum
argument_list|)
expr_stmt|;
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|regionOpened
argument_list|(
name|regionNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastState
operator|==
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_OPENED
condition|)
block|{
comment|// we are done
name|regionNode
operator|.
name|unsetProcedure
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|regionNode
operator|.
name|getProcedureEvent
argument_list|()
operator|.
name|wake
argument_list|(
name|env
operator|.
name|getProcedureScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|reportTransitionFailedOpen
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateNode
name|regionNode
parameter_list|,
name|ServerName
name|serverName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isOpening
argument_list|(
name|regionNode
argument_list|,
name|serverName
argument_list|,
name|TransitionCode
operator|.
name|FAILED_OPEN
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// there is no openSeqNum for FAILED_OPEN, so we will check the target server instead
if|if
condition|(
operator|!
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received report {} transition from {} for {}, pid={},"
operator|+
literal|" but the region is not on it, should be a retry, ignore"
argument_list|,
name|TransitionCode
operator|.
name|FAILED_OPEN
argument_list|,
name|regionNode
argument_list|,
name|serverName
argument_list|,
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// just wake up the procedure and see if we can retry
comment|// Notice that, even if we arrive here, this call could still be a retry, as we may retry
comment|// opening on the same server again. And the assumption here is that, once the region state is
comment|// OPENING, and the TRSP state is REGION_STATE_TRANSITION_CONFIRM_OPENED, the TRSP must have
comment|// been suspended on the procedure event, so after the waking operation here, the TRSP will be
comment|// executed and try to schedule new OpenRegionProcedure again. Once there is a successful open
comment|// then we are done, so the TRSP will not be stuck.
comment|// TODO: maybe we could send the procedure id of the OpenRegionProcedure to the region server
comment|// and let the region server send it back when done, so it will be easy to detect whether this
comment|// is a retry.
name|regionNode
operator|.
name|getProcedureEvent
argument_list|()
operator|.
name|wake
argument_list|(
name|env
operator|.
name|getProcedureScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// we do not need seqId for closing a region
specifier|private
name|void
name|reportTransitionClosed
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateNode
name|regionNode
parameter_list|,
name|ServerName
name|serverName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|regionNode
operator|.
name|isInState
argument_list|(
name|State
operator|.
name|CLOSING
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received report {} transition from {} for {}, pid={}"
operator|+
literal|", but the region is not in CLOSING state, should be a retry, ignore"
argument_list|,
name|TransitionCode
operator|.
name|CLOSED
argument_list|,
name|serverName
argument_list|,
name|regionNode
argument_list|,
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getCurrentState
argument_list|()
operator|!=
name|REGION_STATE_TRANSITION_CONFIRM_CLOSED
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received report {} transition from {} for {}, pid={} but the proc is not in {}"
operator|+
literal|" state, should be a retry, ignore"
argument_list|,
name|TransitionCode
operator|.
name|CLOSED
argument_list|,
name|serverName
argument_list|,
name|regionNode
argument_list|,
name|getProcId
argument_list|()
argument_list|,
name|REGION_STATE_TRANSITION_CONFIRM_CLOSED
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|regionNode
operator|.
name|getRegionLocation
argument_list|()
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received report {} transition from {} for {}, pid={},"
operator|+
literal|" but the region is not on it, should be a retry, ignore"
argument_list|,
name|TransitionCode
operator|.
name|CLOSED
argument_list|,
name|serverName
argument_list|,
name|regionNode
argument_list|,
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|regionClosed
argument_list|(
name|regionNode
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastState
operator|==
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_CLOSED
condition|)
block|{
comment|// we are done
name|regionNode
operator|.
name|unsetProcedure
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|regionNode
operator|.
name|getProcedureEvent
argument_list|()
operator|.
name|wake
argument_list|(
name|env
operator|.
name|getProcedureScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Should be called with RegionStateNode locked
specifier|public
name|void
name|reportTransition
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateNode
name|regionNode
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
name|TransitionCode
name|code
parameter_list|,
name|long
name|seqId
parameter_list|)
throws|throws
name|IOException
block|{
comment|// It is possible that the previous reportRegionStateTransition call was succeeded at master
comment|// side, but before returning the result to region server, the rpc connection was broken, or the
comment|// master restarted. The region server will try calling reportRegionStateTransition again under
comment|// this scenario, so here we need to check whether this is a retry.
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|OPENED
case|:
name|reportTransitionOpen
argument_list|(
name|env
argument_list|,
name|regionNode
argument_list|,
name|serverName
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAILED_OPEN
case|:
name|reportTransitionFailedOpen
argument_list|(
name|env
argument_list|,
name|regionNode
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOSED
case|:
name|reportTransitionClosed
argument_list|(
name|env
argument_list|,
name|regionNode
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
literal|"Received report unexpected "
operator|+
name|code
operator|+
literal|" transition, "
operator|+
name|regionNode
operator|.
name|toShortString
argument_list|()
operator|+
literal|", "
operator|+
name|this
operator|+
literal|", expected OPENED or FAILED_OPEN or CLOSED."
argument_list|)
throw|;
block|}
block|}
comment|// Should be called with RegionStateNode locked
specifier|public
name|void
name|serverCrashed
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateNode
name|regionNode
parameter_list|,
name|ServerName
name|serverName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Notice that, in this method, we do not change the procedure state, instead, we update the
comment|// region state in hbase:meta. This is because that, the procedure state change will not be
comment|// persisted until the region is woken up and finish one step, if we crash before that then the
comment|// information will be lost. So here we will update the region state in hbase:meta, and when the
comment|// procedure is woken up, it will process the error and jump to the correct procedure state.
name|RegionStateTransitionState
name|currentState
init|=
name|getCurrentState
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|currentState
condition|)
block|{
case|case
name|REGION_STATE_TRANSITION_CLOSE
case|:
case|case
name|REGION_STATE_TRANSITION_CONFIRM_CLOSED
case|:
case|case
name|REGION_STATE_TRANSITION_CONFIRM_OPENED
case|:
comment|// for these 3 states, the region may still be online on the crashed server
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|regionClosed
argument_list|(
name|regionNode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentState
operator|!=
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CLOSE
condition|)
block|{
name|regionNode
operator|.
name|getProcedureEvent
argument_list|()
operator|.
name|wake
argument_list|(
name|env
operator|.
name|getProcedureScheduler
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// If the procedure is in other 2 states, then actually we should not arrive here, as we
comment|// know that the region is not online on any server, so we need to do nothing... But anyway
comment|// let's add a log here
name|LOG
operator|.
name|warn
argument_list|(
literal|"{} received unexpected server crash call for region {} from {}"
argument_list|,
name|this
argument_list|,
name|regionNode
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|incrementAndCheckMaxAttempts
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateNode
name|regionNode
parameter_list|)
block|{
name|int
name|retries
init|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getRegionStates
argument_list|()
operator|.
name|addToFailedOpen
argument_list|(
name|regionNode
argument_list|)
operator|.
name|incrementAndGetRetries
argument_list|()
decl_stmt|;
name|int
name|max
init|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getAssignMaxAttempts
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Retry={} of max={}; {}; {}"
argument_list|,
name|retries
argument_list|,
name|max
argument_list|,
name|this
argument_list|,
name|regionNode
operator|.
name|toShortString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|retries
operator|>=
name|max
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|rollbackState
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionStateTransitionState
name|state
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// no rollback
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|protected
name|RegionStateTransitionState
name|getState
parameter_list|(
name|int
name|stateId
parameter_list|)
block|{
return|return
name|RegionStateTransitionState
operator|.
name|forNumber
argument_list|(
name|stateId
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|getStateId
parameter_list|(
name|RegionStateTransitionState
name|state
parameter_list|)
block|{
return|return
name|state
operator|.
name|getNumber
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RegionStateTransitionState
name|getInitialState
parameter_list|()
block|{
return|return
name|initialState
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|serializeStateData
parameter_list|(
name|ProcedureStateSerializer
name|serializer
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|serializeStateData
argument_list|(
name|serializer
argument_list|)
expr_stmt|;
name|RegionStateTransitionStateData
operator|.
name|Builder
name|builder
init|=
name|RegionStateTransitionStateData
operator|.
name|newBuilder
argument_list|()
operator|.
name|setInitialState
argument_list|(
name|initialState
argument_list|)
operator|.
name|setLastState
argument_list|(
name|lastState
argument_list|)
operator|.
name|setForceNewPlan
argument_list|(
name|forceNewPlan
argument_list|)
decl_stmt|;
if|if
condition|(
name|assignCandidate
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setAssignCandidate
argument_list|(
name|ProtobufUtil
operator|.
name|toServerName
argument_list|(
name|assignCandidate
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|serializer
operator|.
name|serialize
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|deserializeStateData
parameter_list|(
name|ProcedureStateSerializer
name|serializer
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|deserializeStateData
argument_list|(
name|serializer
argument_list|)
expr_stmt|;
name|RegionStateTransitionStateData
name|data
init|=
name|serializer
operator|.
name|deserialize
argument_list|(
name|RegionStateTransitionStateData
operator|.
name|class
argument_list|)
decl_stmt|;
name|initialState
operator|=
name|data
operator|.
name|getInitialState
argument_list|()
expr_stmt|;
name|lastState
operator|=
name|data
operator|.
name|getLastState
argument_list|()
expr_stmt|;
name|forceNewPlan
operator|=
name|data
operator|.
name|getForceNewPlan
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|hasAssignCandidate
argument_list|()
condition|)
block|{
name|assignCandidate
operator|=
name|ProtobufUtil
operator|.
name|toServerName
argument_list|(
name|data
operator|.
name|getAssignCandidate
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|ProcedureMetrics
name|getProcedureMetrics
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
comment|// TODO: need to reimplement the metrics system for assign/unassign
if|if
condition|(
name|initialState
operator|==
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_GET_ASSIGN_CANDIDATE
condition|)
block|{
return|return
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getAssignmentManagerMetrics
argument_list|()
operator|.
name|getAssignProcMetrics
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getAssignmentManagerMetrics
argument_list|()
operator|.
name|getUnassignProcMetrics
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|toStringClassDetails
parameter_list|(
name|StringBuilder
name|sb
parameter_list|)
block|{
name|super
operator|.
name|toStringClassDetails
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialState
operator|==
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_GET_ASSIGN_CANDIDATE
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", ASSIGN"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastState
operator|==
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_CLOSED
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", UNASSIGN"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", REOPEN/MOVE"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|TransitRegionStateProcedure
name|setOwner
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|TransitRegionStateProcedure
name|proc
parameter_list|)
block|{
name|proc
operator|.
name|setOwner
argument_list|(
name|env
operator|.
name|getRequestUser
argument_list|()
operator|.
name|getShortName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|proc
return|;
block|}
comment|// Be careful that, when you call these 4 methods below, you need to manually attach the returned
comment|// procedure with the RegionStateNode, otherwise the procedure will quit immediately without doing
comment|// anything. See the comment in executeFromState to find out why we need this assumption.
specifier|public
specifier|static
name|TransitRegionStateProcedure
name|assign
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionInfo
name|region
parameter_list|,
annotation|@
name|Nullable
name|ServerName
name|targetServer
parameter_list|)
block|{
return|return
name|setOwner
argument_list|(
name|env
argument_list|,
operator|new
name|TransitRegionStateProcedure
argument_list|(
name|env
argument_list|,
name|region
argument_list|,
name|targetServer
argument_list|,
literal|false
argument_list|,
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_GET_ASSIGN_CANDIDATE
argument_list|,
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_OPENED
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|TransitRegionStateProcedure
name|unassign
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionInfo
name|region
parameter_list|)
block|{
return|return
name|setOwner
argument_list|(
name|env
argument_list|,
operator|new
name|TransitRegionStateProcedure
argument_list|(
name|env
argument_list|,
name|region
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CLOSE
argument_list|,
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_CLOSED
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|TransitRegionStateProcedure
name|reopen
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionInfo
name|region
parameter_list|)
block|{
return|return
name|setOwner
argument_list|(
name|env
argument_list|,
operator|new
name|TransitRegionStateProcedure
argument_list|(
name|env
argument_list|,
name|region
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CLOSE
argument_list|,
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_OPENED
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|TransitRegionStateProcedure
name|move
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
name|RegionInfo
name|region
parameter_list|,
annotation|@
name|Nullable
name|ServerName
name|targetServer
parameter_list|)
block|{
return|return
name|setOwner
argument_list|(
name|env
argument_list|,
operator|new
name|TransitRegionStateProcedure
argument_list|(
name|env
argument_list|,
name|region
argument_list|,
name|targetServer
argument_list|,
name|targetServer
operator|==
literal|null
argument_list|,
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CLOSE
argument_list|,
name|RegionStateTransitionState
operator|.
name|REGION_STATE_TRANSITION_CONFIRM_OPENED
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

end_unit

