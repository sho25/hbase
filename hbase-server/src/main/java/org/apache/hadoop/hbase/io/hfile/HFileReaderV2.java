begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|fs
operator|.
name|HFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|FSDataInputStreamWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|HFileBlockDecodingContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
operator|.
name|FileInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|IdLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cloudera
operator|.
name|htrace
operator|.
name|Trace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cloudera
operator|.
name|htrace
operator|.
name|TraceScope
import|;
end_import

begin_comment
comment|/**  * {@link HFile} reader for version 2.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|HFileReaderV2
extends|extends
name|AbstractHFileReader
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HFileReaderV2
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Minor versions in HFile V2 starting with this number have hbase checksums */
specifier|public
specifier|static
specifier|final
name|int
name|MINOR_VERSION_WITH_CHECKSUM
init|=
literal|1
decl_stmt|;
comment|/** In HFile V2 minor version that does not support checksums */
specifier|public
specifier|static
specifier|final
name|int
name|MINOR_VERSION_NO_CHECKSUM
init|=
literal|0
decl_stmt|;
comment|/** HFile minor version that introduced pbuf filetrailer */
specifier|public
specifier|static
specifier|final
name|int
name|PBUF_TRAILER_MINOR_VERSION
init|=
literal|2
decl_stmt|;
comment|/**    * The size of a (key length, value length) tuple that prefixes each entry in    * a data block.    */
specifier|public
specifier|final
specifier|static
name|int
name|KEY_VALUE_LEN_SIZE
init|=
literal|2
operator|*
name|Bytes
operator|.
name|SIZEOF_INT
decl_stmt|;
specifier|protected
name|boolean
name|includesMemstoreTS
init|=
literal|false
decl_stmt|;
specifier|protected
name|boolean
name|decodeMemstoreTS
init|=
literal|false
decl_stmt|;
specifier|protected
name|boolean
name|shouldIncludeMemstoreTS
parameter_list|()
block|{
return|return
name|includesMemstoreTS
return|;
block|}
comment|/** Filesystem-level block reader. */
specifier|protected
name|HFileBlock
operator|.
name|FSReader
name|fsBlockReader
decl_stmt|;
comment|/**    * A "sparse lock" implementation allowing to lock on a particular block    * identified by offset. The purpose of this is to avoid two clients loading    * the same block, and have all but one client wait to get the block from the    * cache.    */
specifier|private
name|IdLock
name|offsetLock
init|=
operator|new
name|IdLock
argument_list|()
decl_stmt|;
comment|/**    * Blocks read from the load-on-open section, excluding data root index, meta    * index, and file info.    */
specifier|private
name|List
argument_list|<
name|HFileBlock
argument_list|>
name|loadOnOpenBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|HFileBlock
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Minimum minor version supported by this HFile format */
specifier|static
specifier|final
name|int
name|MIN_MINOR_VERSION
init|=
literal|0
decl_stmt|;
comment|/** Maximum minor version supported by this HFile format */
comment|// We went to version 2 when we moved to pb'ing fileinfo and the trailer on
comment|// the file. This version can read Writables version 1.
specifier|static
specifier|final
name|int
name|MAX_MINOR_VERSION
init|=
literal|3
decl_stmt|;
comment|/** Minor versions starting with this number have faked index key */
specifier|static
specifier|final
name|int
name|MINOR_VERSION_WITH_FAKED_KEY
init|=
literal|3
decl_stmt|;
specifier|protected
name|HFileContext
name|hfileContext
decl_stmt|;
comment|/**    * Opens a HFile. You must load the index before you can use it by calling    * {@link #loadFileInfo()}.    *    * @param path Path to HFile.    * @param trailer File trailer.    * @param fsdis input stream.    * @param size Length of the stream.    * @param cacheConf Cache configuration.    * @param preferredEncodingInCache the encoding to use in cache in case we    *          have a choice. If the file is already encoded on disk, we will    *          still use its on-disk encoding in cache.    * @param hfs    */
specifier|public
name|HFileReaderV2
parameter_list|(
name|Path
name|path
parameter_list|,
name|FixedFileTrailer
name|trailer
parameter_list|,
specifier|final
name|FSDataInputStreamWrapper
name|fsdis
parameter_list|,
specifier|final
name|long
name|size
parameter_list|,
specifier|final
name|CacheConfig
name|cacheConf
parameter_list|,
name|DataBlockEncoding
name|preferredEncodingInCache
parameter_list|,
specifier|final
name|HFileSystem
name|hfs
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|path
argument_list|,
name|trailer
argument_list|,
name|size
argument_list|,
name|cacheConf
argument_list|,
name|hfs
argument_list|)
expr_stmt|;
name|trailer
operator|.
name|expectMajorVersion
argument_list|(
name|getMajorVersion
argument_list|()
argument_list|)
expr_stmt|;
name|validateMinorVersion
argument_list|(
name|path
argument_list|,
name|trailer
operator|.
name|getMinorVersion
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|hfileContext
operator|=
name|createHFileContext
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
comment|// Should we set the preferredEncodinginCache here for the context
name|HFileBlock
operator|.
name|FSReaderV2
name|fsBlockReaderV2
init|=
operator|new
name|HFileBlock
operator|.
name|FSReaderV2
argument_list|(
name|fsdis
argument_list|,
name|fileSize
argument_list|,
name|hfs
argument_list|,
name|path
argument_list|,
name|hfileContext
argument_list|)
decl_stmt|;
name|this
operator|.
name|fsBlockReader
operator|=
name|fsBlockReaderV2
expr_stmt|;
comment|// upcast
comment|// Comparator class name is stored in the trailer in version 2.
name|comparator
operator|=
name|trailer
operator|.
name|createComparator
argument_list|()
expr_stmt|;
name|dataBlockIndexReader
operator|=
operator|new
name|HFileBlockIndex
operator|.
name|BlockIndexReader
argument_list|(
name|comparator
argument_list|,
name|trailer
operator|.
name|getNumDataIndexLevels
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|metaBlockIndexReader
operator|=
operator|new
name|HFileBlockIndex
operator|.
name|BlockIndexReader
argument_list|(
name|KeyValue
operator|.
name|RAW_COMPARATOR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Parse load-on-open data.
name|HFileBlock
operator|.
name|BlockIterator
name|blockIter
init|=
name|fsBlockReaderV2
operator|.
name|blockRange
argument_list|(
name|trailer
operator|.
name|getLoadOnOpenDataOffset
argument_list|()
argument_list|,
name|fileSize
operator|-
name|trailer
operator|.
name|getTrailerSize
argument_list|()
argument_list|)
decl_stmt|;
comment|// Data index. We also read statistics about the block index written after
comment|// the root level.
name|dataBlockIndexReader
operator|.
name|readMultiLevelIndexRoot
argument_list|(
name|blockIter
operator|.
name|nextBlockWithBlockType
argument_list|(
name|BlockType
operator|.
name|ROOT_INDEX
argument_list|)
argument_list|,
name|trailer
operator|.
name|getDataIndexCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// Meta index.
name|metaBlockIndexReader
operator|.
name|readRootIndex
argument_list|(
name|blockIter
operator|.
name|nextBlockWithBlockType
argument_list|(
name|BlockType
operator|.
name|ROOT_INDEX
argument_list|)
argument_list|,
name|trailer
operator|.
name|getMetaIndexCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// File info
name|fileInfo
operator|=
operator|new
name|FileInfo
argument_list|()
expr_stmt|;
name|fileInfo
operator|.
name|read
argument_list|(
name|blockIter
operator|.
name|nextBlockWithBlockType
argument_list|(
name|BlockType
operator|.
name|FILE_INFO
argument_list|)
operator|.
name|getByteStream
argument_list|()
argument_list|)
expr_stmt|;
name|lastKey
operator|=
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|LASTKEY
argument_list|)
expr_stmt|;
name|avgKeyLen
operator|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|AVG_KEY_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|avgValueLen
operator|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|AVG_VALUE_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|keyValueFormatVersion
init|=
name|fileInfo
operator|.
name|get
argument_list|(
name|HFileWriterV2
operator|.
name|KEY_VALUE_VERSION
argument_list|)
decl_stmt|;
name|includesMemstoreTS
operator|=
name|keyValueFormatVersion
operator|!=
literal|null
operator|&&
name|Bytes
operator|.
name|toInt
argument_list|(
name|keyValueFormatVersion
argument_list|)
operator|==
name|HFileWriterV2
operator|.
name|KEY_VALUE_VER_WITH_MEMSTORE
expr_stmt|;
name|fsBlockReaderV2
operator|.
name|setIncludesMemstoreTS
argument_list|(
name|includesMemstoreTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|includesMemstoreTS
condition|)
block|{
name|decodeMemstoreTS
operator|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|fileInfo
operator|.
name|get
argument_list|(
name|HFileWriterV2
operator|.
name|MAX_MEMSTORE_TS_KEY
argument_list|)
argument_list|)
operator|>
literal|0
expr_stmt|;
block|}
comment|// Read data block encoding algorithm name from file info.
name|dataBlockEncoder
operator|=
name|HFileDataBlockEncoderImpl
operator|.
name|createFromFileInfo
argument_list|(
name|fileInfo
argument_list|,
name|preferredEncodingInCache
argument_list|)
expr_stmt|;
name|fsBlockReaderV2
operator|.
name|setDataBlockEncoder
argument_list|(
name|dataBlockEncoder
argument_list|)
expr_stmt|;
comment|// Store all other load-on-open blocks for further consumption.
name|HFileBlock
name|b
decl_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
name|blockIter
operator|.
name|nextBlock
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|loadOnOpenBlocks
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|HFileContext
name|createHFileContext
parameter_list|(
name|FixedFileTrailer
name|trailer
parameter_list|)
block|{
name|HFileContext
name|meta
init|=
operator|new
name|HFileContext
argument_list|()
decl_stmt|;
name|meta
operator|.
name|setIncludesMvcc
argument_list|(
name|this
operator|.
name|includesMemstoreTS
argument_list|)
expr_stmt|;
name|meta
operator|.
name|setUsesHBaseChecksum
argument_list|(
name|trailer
operator|.
name|getMinorVersion
argument_list|()
operator|>=
name|MINOR_VERSION_WITH_CHECKSUM
argument_list|)
expr_stmt|;
name|meta
operator|.
name|setCompressAlgo
argument_list|(
name|this
operator|.
name|compressAlgo
argument_list|)
expr_stmt|;
return|return
name|meta
return|;
block|}
comment|/**    * Create a Scanner on this file. No seeks or reads are done on creation. Call    * {@link HFileScanner#seekTo(byte[])} to position an start the read. There is    * nothing to clean up in a Scanner. Letting go of your references to the    * scanner is sufficient.    *    * @param cacheBlocks True if we should cache blocks read in by this scanner.    * @param pread Use positional read rather than seek+read if true (pread is    *          better for random reads, seek+read is better scanning).    * @param isCompaction is scanner being used for a compaction?    * @return Scanner on this file.    */
annotation|@
name|Override
specifier|public
name|HFileScanner
name|getScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
block|{
comment|// check if we want to use data block encoding in memory
if|if
condition|(
name|dataBlockEncoder
operator|.
name|useEncodedScanner
argument_list|(
name|isCompaction
argument_list|)
condition|)
block|{
return|return
operator|new
name|EncodedScannerV2
argument_list|(
name|this
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
name|hfileContext
argument_list|)
return|;
block|}
return|return
operator|new
name|ScannerV2
argument_list|(
name|this
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
return|;
block|}
comment|/**    * @param metaBlockName    * @param cacheBlock Add block to cache, if found    * @return block wrapped in a ByteBuffer, with header skipped    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getMetaBlock
parameter_list|(
name|String
name|metaBlockName
parameter_list|,
name|boolean
name|cacheBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|trailer
operator|.
name|getMetaIndexCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
comment|// there are no meta blocks
block|}
if|if
condition|(
name|metaBlockIndexReader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Meta index not loaded"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|mbname
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|metaBlockName
argument_list|)
decl_stmt|;
name|int
name|block
init|=
name|metaBlockIndexReader
operator|.
name|rootBlockContainingKey
argument_list|(
name|mbname
argument_list|,
literal|0
argument_list|,
name|mbname
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|==
operator|-
literal|1
condition|)
return|return
literal|null
return|;
name|long
name|blockSize
init|=
name|metaBlockIndexReader
operator|.
name|getRootBlockDataSize
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|long
name|startTimeNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
comment|// Per meta key from any given file, synchronize reads for said block. This
comment|// is OK to do for meta blocks because the meta block index is always
comment|// single-level.
synchronized|synchronized
init|(
name|metaBlockIndexReader
operator|.
name|getRootBlockKey
argument_list|(
name|block
argument_list|)
init|)
block|{
comment|// Check cache for block. If found return.
name|long
name|metaBlockOffset
init|=
name|metaBlockIndexReader
operator|.
name|getRootBlockOffset
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|BlockCacheKey
name|cacheKey
init|=
operator|new
name|BlockCacheKey
argument_list|(
name|name
argument_list|,
name|metaBlockOffset
argument_list|,
name|DataBlockEncoding
operator|.
name|NONE
argument_list|,
name|BlockType
operator|.
name|META
argument_list|)
decl_stmt|;
name|cacheBlock
operator|&=
name|cacheConf
operator|.
name|shouldCacheDataOnRead
argument_list|()
expr_stmt|;
if|if
condition|(
name|cacheConf
operator|.
name|isBlockCacheEnabled
argument_list|()
condition|)
block|{
name|HFileBlock
name|cachedBlock
init|=
operator|(
name|HFileBlock
operator|)
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|getBlock
argument_list|(
name|cacheKey
argument_list|,
name|cacheBlock
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBlock
operator|!=
literal|null
condition|)
block|{
comment|// Return a distinct 'shallow copy' of the block,
comment|// so pos does not get messed by the scanner
return|return
name|cachedBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
return|;
block|}
comment|// Cache Miss, please load.
block|}
name|HFileBlock
name|metaBlock
init|=
name|fsBlockReader
operator|.
name|readBlockData
argument_list|(
name|metaBlockOffset
argument_list|,
name|blockSize
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|long
name|delta
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNs
decl_stmt|;
name|HFile
operator|.
name|offerReadLatency
argument_list|(
name|delta
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Cache the block
if|if
condition|(
name|cacheBlock
condition|)
block|{
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|metaBlock
argument_list|,
name|cacheConf
operator|.
name|isInMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|metaBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
return|;
block|}
block|}
comment|/**    * Read in a file block.    * @param dataBlockOffset offset to read.    * @param onDiskBlockSize size of the block    * @param cacheBlock    * @param pread Use positional read instead of seek+read (positional is    *          better doing random reads whereas seek+read is better scanning).    * @param isCompaction is this block being read as part of a compaction    * @param expectedBlockType the block type we are expecting to read with this    *          read operation, or null to read whatever block type is available    *          and avoid checking (that might reduce caching efficiency of    *          encoded data blocks)    * @return Block wrapped in a ByteBuffer.    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|HFileBlock
name|readBlock
parameter_list|(
name|long
name|dataBlockOffset
parameter_list|,
name|long
name|onDiskBlockSize
parameter_list|,
specifier|final
name|boolean
name|cacheBlock
parameter_list|,
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|,
name|BlockType
name|expectedBlockType
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dataBlockIndexReader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block index not loaded"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dataBlockOffset
operator|<
literal|0
operator|||
name|dataBlockOffset
operator|>=
name|trailer
operator|.
name|getLoadOnOpenDataOffset
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Requested block is out of range: "
operator|+
name|dataBlockOffset
operator|+
literal|", lastDataBlockOffset: "
operator|+
name|trailer
operator|.
name|getLastDataBlockOffset
argument_list|()
argument_list|)
throw|;
block|}
comment|// For any given block from any given file, synchronize reads for said
comment|// block.
comment|// Without a cache, this synchronizing is needless overhead, but really
comment|// the other choice is to duplicate work (which the cache would prevent you
comment|// from doing).
name|BlockCacheKey
name|cacheKey
init|=
operator|new
name|BlockCacheKey
argument_list|(
name|name
argument_list|,
name|dataBlockOffset
argument_list|,
name|dataBlockEncoder
operator|.
name|getEffectiveEncodingInCache
argument_list|(
name|isCompaction
argument_list|)
argument_list|,
name|expectedBlockType
argument_list|)
decl_stmt|;
name|boolean
name|useLock
init|=
literal|false
decl_stmt|;
name|IdLock
operator|.
name|Entry
name|lockEntry
init|=
literal|null
decl_stmt|;
name|TraceScope
name|traceScope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"HFileReaderV2.readBlock"
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|useLock
condition|)
block|{
name|lockEntry
operator|=
name|offsetLock
operator|.
name|getLockEntry
argument_list|(
name|dataBlockOffset
argument_list|)
expr_stmt|;
block|}
comment|// Check cache for block. If found return.
if|if
condition|(
name|cacheConf
operator|.
name|isBlockCacheEnabled
argument_list|()
condition|)
block|{
comment|// Try and get the block from the block cache. If the useLock variable is true then this
comment|// is the second time through the loop and it should not be counted as a block cache miss.
name|HFileBlock
name|cachedBlock
init|=
operator|(
name|HFileBlock
operator|)
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|getBlock
argument_list|(
name|cacheKey
argument_list|,
name|cacheBlock
argument_list|,
name|useLock
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBlock
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cachedBlock
operator|.
name|getBlockType
argument_list|()
operator|==
name|BlockType
operator|.
name|DATA
condition|)
block|{
name|HFile
operator|.
name|dataBlockReadCnt
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
name|validateBlockType
argument_list|(
name|cachedBlock
argument_list|,
name|expectedBlockType
argument_list|)
expr_stmt|;
comment|// Validate encoding type for encoded blocks. We include encoding
comment|// type in the cache key, and we expect it to match on a cache hit.
if|if
condition|(
name|cachedBlock
operator|.
name|getBlockType
argument_list|()
operator|==
name|BlockType
operator|.
name|ENCODED_DATA
operator|&&
name|cachedBlock
operator|.
name|getDataBlockEncoding
argument_list|()
operator|!=
name|dataBlockEncoder
operator|.
name|getEncodingInCache
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cached block under key "
operator|+
name|cacheKey
operator|+
literal|" "
operator|+
literal|"has wrong encoding: "
operator|+
name|cachedBlock
operator|.
name|getDataBlockEncoding
argument_list|()
operator|+
literal|" (expected: "
operator|+
name|dataBlockEncoder
operator|.
name|getEncodingInCache
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
return|return
name|cachedBlock
return|;
block|}
comment|// Carry on, please load.
block|}
if|if
condition|(
operator|!
name|useLock
condition|)
block|{
comment|// check cache again with lock
name|useLock
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|Trace
operator|.
name|isTracing
argument_list|()
condition|)
block|{
name|traceScope
operator|.
name|getSpan
argument_list|()
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"blockCacheMiss"
argument_list|)
expr_stmt|;
block|}
comment|// Load block from filesystem.
name|long
name|startTimeNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|HFileBlock
name|hfileBlock
init|=
name|fsBlockReader
operator|.
name|readBlockData
argument_list|(
name|dataBlockOffset
argument_list|,
name|onDiskBlockSize
argument_list|,
operator|-
literal|1
argument_list|,
name|pread
argument_list|)
decl_stmt|;
name|hfileBlock
operator|=
name|diskToCacheFormat
argument_list|(
name|hfileBlock
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
name|validateBlockType
argument_list|(
name|hfileBlock
argument_list|,
name|expectedBlockType
argument_list|)
expr_stmt|;
specifier|final
name|long
name|delta
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNs
decl_stmt|;
name|HFile
operator|.
name|offerReadLatency
argument_list|(
name|delta
argument_list|,
name|pread
argument_list|)
expr_stmt|;
comment|// Cache the block if necessary
if|if
condition|(
name|cacheBlock
operator|&&
name|cacheConf
operator|.
name|shouldCacheBlockOnRead
argument_list|(
name|hfileBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|getCategory
argument_list|()
argument_list|)
condition|)
block|{
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|hfileBlock
argument_list|,
name|cacheConf
operator|.
name|isInMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hfileBlock
operator|.
name|getBlockType
argument_list|()
operator|==
name|BlockType
operator|.
name|DATA
condition|)
block|{
name|HFile
operator|.
name|dataBlockReadCnt
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
return|return
name|hfileBlock
return|;
block|}
block|}
finally|finally
block|{
name|traceScope
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|lockEntry
operator|!=
literal|null
condition|)
block|{
name|offsetLock
operator|.
name|releaseLockEntry
argument_list|(
name|lockEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|protected
name|HFileBlock
name|diskToCacheFormat
parameter_list|(
name|HFileBlock
name|hfileBlock
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
block|{
return|return
name|dataBlockEncoder
operator|.
name|diskToCacheFormat
argument_list|(
name|hfileBlock
argument_list|,
name|isCompaction
argument_list|)
return|;
block|}
comment|/**    * Compares the actual type of a block retrieved from cache or disk with its    * expected type and throws an exception in case of a mismatch. Expected    * block type of {@link BlockType#DATA} is considered to match the actual    * block type [@link {@link BlockType#ENCODED_DATA} as well.    * @param block a block retrieved from cache or disk    * @param expectedBlockType the expected block type, or null to skip the    *          check    */
specifier|private
name|void
name|validateBlockType
parameter_list|(
name|HFileBlock
name|block
parameter_list|,
name|BlockType
name|expectedBlockType
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|expectedBlockType
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|BlockType
name|actualBlockType
init|=
name|block
operator|.
name|getBlockType
argument_list|()
decl_stmt|;
if|if
condition|(
name|actualBlockType
operator|==
name|BlockType
operator|.
name|ENCODED_DATA
operator|&&
name|expectedBlockType
operator|==
name|BlockType
operator|.
name|DATA
condition|)
block|{
comment|// We consider DATA to match ENCODED_DATA for the purpose of this
comment|// verification.
return|return;
block|}
if|if
condition|(
name|actualBlockType
operator|!=
name|expectedBlockType
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected block type "
operator|+
name|expectedBlockType
operator|+
literal|", "
operator|+
literal|"but got "
operator|+
name|actualBlockType
operator|+
literal|": "
operator|+
name|block
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return Last key in the file. May be null if file has no entries. Note that    *         this is not the last row key, but rather the byte form of the last    *         KeyValue.    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getLastKey
parameter_list|()
block|{
return|return
name|dataBlockIndexReader
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|lastKey
return|;
block|}
comment|/**    * @return Midkey for this file. We work with block boundaries only so    *         returned midkey is an approximation only.    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|midkey
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dataBlockIndexReader
operator|.
name|midkey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|close
argument_list|(
name|cacheConf
operator|.
name|shouldEvictOnClose
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|evictOnClose
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|evictOnClose
operator|&&
name|cacheConf
operator|.
name|isBlockCacheEnabled
argument_list|()
condition|)
block|{
name|int
name|numEvicted
init|=
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|evictBlocksByHfileName
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"On close, file="
operator|+
name|name
operator|+
literal|" evicted="
operator|+
name|numEvicted
operator|+
literal|" block(s)"
argument_list|)
expr_stmt|;
block|}
block|}
name|fsBlockReader
operator|.
name|closeStreams
argument_list|()
expr_stmt|;
block|}
comment|/** For testing */
annotation|@
name|Override
name|HFileBlock
operator|.
name|FSReader
name|getUncachedBlockReader
parameter_list|()
block|{
return|return
name|fsBlockReader
return|;
block|}
specifier|protected
specifier|abstract
specifier|static
class|class
name|AbstractScannerV2
extends|extends
name|AbstractHFileReader
operator|.
name|Scanner
block|{
specifier|protected
name|HFileBlock
name|block
decl_stmt|;
comment|/**      * The next indexed key is to keep track of the indexed key of the next data block.      * If the nextIndexedKey is HConstants.NO_NEXT_INDEXED_KEY, it means that the      * current data block is the last data block.      *      * If the nextIndexedKey is null, it means the nextIndexedKey has not been loaded yet.      */
specifier|protected
name|byte
index|[]
name|nextIndexedKey
decl_stmt|;
specifier|public
name|AbstractScannerV2
parameter_list|(
name|HFileReaderV2
name|r
parameter_list|,
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
block|{
name|super
argument_list|(
name|r
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
block|}
comment|/**      * An internal API function. Seek to the given key, optionally rewinding to      * the first key of the block before doing the seek.      *      * @param key key byte array      * @param offset key offset in the key byte array      * @param length key length      * @param rewind whether to rewind to the first key of the block before      *        doing the seek. If this is false, we are assuming we never go      *        back, otherwise the result is undefined.      * @return -1 if the key is earlier than the first key of the file,      *         0 if we are at the given key, 1 if we are past the given key      *         -2 if the key is earlier than the first key of the file while      *         using a faked index key      * @throws IOException      */
specifier|protected
name|int
name|seekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|rewind
parameter_list|)
throws|throws
name|IOException
block|{
name|HFileBlockIndex
operator|.
name|BlockIndexReader
name|indexReader
init|=
name|reader
operator|.
name|getDataBlockIndexReader
argument_list|()
decl_stmt|;
name|BlockWithScanInfo
name|blockWithScanInfo
init|=
name|indexReader
operator|.
name|loadDataBlockWithScanInfo
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|block
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockWithScanInfo
operator|==
literal|null
operator|||
name|blockWithScanInfo
operator|.
name|getHFileBlock
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// This happens if the key e.g. falls before the beginning of the file.
return|return
operator|-
literal|1
return|;
block|}
return|return
name|loadBlockAndSeekToKey
argument_list|(
name|blockWithScanInfo
operator|.
name|getHFileBlock
argument_list|()
argument_list|,
name|blockWithScanInfo
operator|.
name|getNextIndexedKey
argument_list|()
argument_list|,
name|rewind
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|protected
specifier|abstract
name|ByteBuffer
name|getFirstKeyInBlock
parameter_list|(
name|HFileBlock
name|curBlock
parameter_list|)
function_decl|;
specifier|protected
specifier|abstract
name|int
name|loadBlockAndSeekToKey
parameter_list|(
name|HFileBlock
name|seekToBlock
parameter_list|,
name|byte
index|[]
name|nextIndexedKey
parameter_list|,
name|boolean
name|rewind
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
throws|throws
name|IOException
function_decl|;
annotation|@
name|Override
specifier|public
name|int
name|seekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Always rewind to the first key of the block, because the given key
comment|// might be before or after the current key.
return|return
name|seekTo
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|reseekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|compared
decl_stmt|;
if|if
condition|(
name|isSeeked
argument_list|()
condition|)
block|{
name|ByteBuffer
name|bb
init|=
name|getKey
argument_list|()
decl_stmt|;
name|compared
operator|=
name|reader
operator|.
name|getComparator
argument_list|()
operator|.
name|compareFlatKey
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|bb
operator|.
name|array
argument_list|()
argument_list|,
name|bb
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|bb
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|compared
operator|<
literal|1
condition|)
block|{
comment|// If the required key is less than or equal to current key, then
comment|// don't do anything.
return|return
name|compared
return|;
block|}
else|else
block|{
if|if
condition|(
name|this
operator|.
name|nextIndexedKey
operator|!=
literal|null
operator|&&
operator|(
name|this
operator|.
name|nextIndexedKey
operator|==
name|HConstants
operator|.
name|NO_NEXT_INDEXED_KEY
operator|||
name|reader
operator|.
name|getComparator
argument_list|()
operator|.
name|compareFlatKey
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|nextIndexedKey
argument_list|,
literal|0
argument_list|,
name|nextIndexedKey
operator|.
name|length
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
comment|// The reader shall continue to scan the current data block instead of querying the
comment|// block index as long as it knows the target key is strictly smaller than
comment|// the next indexed key or the current data block is the last data block.
return|return
name|loadBlockAndSeekToKey
argument_list|(
name|this
operator|.
name|block
argument_list|,
name|this
operator|.
name|nextIndexedKey
argument_list|,
literal|false
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
comment|// Don't rewind on a reseek operation, because reseek implies that we are
comment|// always going forward in the file.
return|return
name|seekTo
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|seekBefore
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|HFileBlock
name|seekToBlock
init|=
name|reader
operator|.
name|getDataBlockIndexReader
argument_list|()
operator|.
name|seekToDataBlock
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|block
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekToBlock
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ByteBuffer
name|firstKey
init|=
name|getFirstKeyInBlock
argument_list|(
name|seekToBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|reader
operator|.
name|getComparator
argument_list|()
operator|.
name|compareFlatKey
argument_list|(
name|firstKey
operator|.
name|array
argument_list|()
argument_list|,
name|firstKey
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|firstKey
operator|.
name|limit
argument_list|()
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|long
name|previousBlockOffset
init|=
name|seekToBlock
operator|.
name|getPrevBlockOffset
argument_list|()
decl_stmt|;
comment|// The key we are interested in
if|if
condition|(
name|previousBlockOffset
operator|==
operator|-
literal|1
condition|)
block|{
comment|// we have a 'problem', the key we want is the first of the file.
return|return
literal|false
return|;
block|}
comment|// It is important that we compute and pass onDiskSize to the block
comment|// reader so that it does not have to read the header separately to
comment|// figure out the size.
name|seekToBlock
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|previousBlockOffset
argument_list|,
name|seekToBlock
operator|.
name|getOffset
argument_list|()
operator|-
name|previousBlockOffset
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
name|BlockType
operator|.
name|DATA
argument_list|)
expr_stmt|;
comment|// TODO shortcut: seek forward in this block to the last key of the
comment|// block.
block|}
name|byte
index|[]
name|firstKeyInCurrentBlock
init|=
name|Bytes
operator|.
name|getBytes
argument_list|(
name|firstKey
argument_list|)
decl_stmt|;
name|loadBlockAndSeekToKey
argument_list|(
name|seekToBlock
argument_list|,
name|firstKeyInCurrentBlock
argument_list|,
literal|true
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Scans blocks in the "scanned" section of the {@link HFile} until the next      * data block is found.      *      * @return the next block, or null if there are no more data blocks      * @throws IOException      */
specifier|protected
name|HFileBlock
name|readNextDataBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|lastDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getLastDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|HFileBlock
name|curBlock
init|=
name|block
decl_stmt|;
do|do
block|{
if|if
condition|(
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|>=
name|lastDataBlockOffset
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid block file offset: "
operator|+
name|block
argument_list|)
throw|;
block|}
comment|// We are reading the next block without block type validation, because
comment|// it might turn out to be a non-data block.
name|curBlock
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
name|curBlock
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
argument_list|,
name|curBlock
operator|.
name|getNextBlockOnDiskSizeWithHeader
argument_list|()
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|curBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|equals
argument_list|(
name|BlockType
operator|.
name|DATA
argument_list|)
operator|||
name|curBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|equals
argument_list|(
name|BlockType
operator|.
name|ENCODED_DATA
argument_list|)
operator|)
condition|)
do|;
return|return
name|curBlock
return|;
block|}
block|}
comment|/**    * Implementation of {@link HFileScanner} interface.    */
specifier|protected
specifier|static
class|class
name|ScannerV2
extends|extends
name|AbstractScannerV2
block|{
specifier|private
name|HFileReaderV2
name|reader
decl_stmt|;
specifier|public
name|ScannerV2
parameter_list|(
name|HFileReaderV2
name|r
parameter_list|,
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
block|{
name|super
argument_list|(
name|r
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
name|this
operator|.
name|reader
operator|=
name|r
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|KeyValue
name|getKeyValue
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSeeked
argument_list|()
condition|)
return|return
literal|null
return|;
name|KeyValue
name|ret
init|=
operator|new
name|KeyValue
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
argument_list|,
name|getKvBufSize
argument_list|()
argument_list|,
name|currKeyLen
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|shouldIncludeMemstoreTS
argument_list|()
condition|)
block|{
name|ret
operator|.
name|setMvccVersion
argument_list|(
name|currMemstoreTS
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|protected
name|int
name|getKvBufSize
parameter_list|()
block|{
return|return
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
operator|+
name|currValueLen
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getKey
parameter_list|()
block|{
name|assertSeeked
argument_list|()
expr_stmt|;
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
argument_list|,
name|currKeyLen
argument_list|)
operator|.
name|slice
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getValue
parameter_list|()
block|{
name|assertSeeked
argument_list|()
expr_stmt|;
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
argument_list|,
name|currValueLen
argument_list|)
operator|.
name|slice
argument_list|()
return|;
block|}
specifier|protected
name|void
name|setNonSeekedState
parameter_list|()
block|{
name|block
operator|=
literal|null
expr_stmt|;
name|blockBuffer
operator|=
literal|null
expr_stmt|;
name|currKeyLen
operator|=
literal|0
expr_stmt|;
name|currValueLen
operator|=
literal|0
expr_stmt|;
name|currMemstoreTS
operator|=
literal|0
expr_stmt|;
name|currMemstoreTSLen
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Go to the next key/value in the block section. Loads the next block if      * necessary. If successful, {@link #getKey()} and {@link #getValue()} can      * be called.      *      * @return true if successfully navigated to the next key/value      */
annotation|@
name|Override
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
name|assertSeeked
argument_list|()
expr_stmt|;
try|try
block|{
name|blockBuffer
operator|.
name|position
argument_list|(
name|getNextKVStartPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Current pos = "
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|"; currKeyLen = "
operator|+
name|currKeyLen
operator|+
literal|"; currValLen = "
operator|+
name|currValueLen
operator|+
literal|"; block limit = "
operator|+
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|"; HFile name = "
operator|+
name|reader
operator|.
name|getName
argument_list|()
operator|+
literal|"; currBlock currBlockOffset = "
operator|+
name|block
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
name|blockBuffer
operator|.
name|remaining
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|long
name|lastDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getLastDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|getOffset
argument_list|()
operator|>=
name|lastDataBlockOffset
condition|)
block|{
name|setNonSeekedState
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// read the next block
name|HFileBlock
name|nextBlock
init|=
name|readNextDataBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextBlock
operator|==
literal|null
condition|)
block|{
name|setNonSeekedState
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|updateCurrBlock
argument_list|(
name|nextBlock
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// We are still in the same block.
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|protected
name|int
name|getNextKVStartPosition
parameter_list|()
block|{
return|return
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
operator|+
name|currValueLen
operator|+
name|currMemstoreTSLen
return|;
block|}
comment|/**      * Positions this scanner at the start of the file.      *      * @return false if empty file; i.e. a call to next would return false and      *         the current key and value are undefined.      * @throws IOException      */
annotation|@
name|Override
specifier|public
name|boolean
name|seekTo
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|reader
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getEntryCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// No data blocks.
return|return
literal|false
return|;
block|}
name|long
name|firstDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getFirstDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|!=
literal|null
operator|&&
name|block
operator|.
name|getOffset
argument_list|()
operator|==
name|firstDataBlockOffset
condition|)
block|{
name|blockBuffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|block
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|firstDataBlockOffset
argument_list|,
operator|-
literal|1
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
name|BlockType
operator|.
name|DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|.
name|getOffset
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid block offset: "
operator|+
name|block
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
name|updateCurrBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|loadBlockAndSeekToKey
parameter_list|(
name|HFileBlock
name|seekToBlock
parameter_list|,
name|byte
index|[]
name|nextIndexedKey
parameter_list|,
name|boolean
name|rewind
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|block
operator|==
literal|null
operator|||
name|block
operator|.
name|getOffset
argument_list|()
operator|!=
name|seekToBlock
operator|.
name|getOffset
argument_list|()
condition|)
block|{
name|updateCurrBlock
argument_list|(
name|seekToBlock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rewind
condition|)
block|{
name|blockBuffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
comment|// Update the nextIndexedKey
name|this
operator|.
name|nextIndexedKey
operator|=
name|nextIndexedKey
expr_stmt|;
return|return
name|blockSeek
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|seekBefore
argument_list|)
return|;
block|}
comment|/**      * Updates the current block to be the given {@link HFileBlock}. Seeks to      * the the first key/value pair.      *      * @param newBlock the block to make current      */
specifier|protected
name|void
name|updateCurrBlock
parameter_list|(
name|HFileBlock
name|newBlock
parameter_list|)
block|{
name|block
operator|=
name|newBlock
expr_stmt|;
comment|// sanity check
if|if
condition|(
name|block
operator|.
name|getBlockType
argument_list|()
operator|!=
name|BlockType
operator|.
name|DATA
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"ScannerV2 works only on data "
operator|+
literal|"blocks, got "
operator|+
name|block
operator|.
name|getBlockType
argument_list|()
operator|+
literal|"; "
operator|+
literal|"fileName="
operator|+
name|reader
operator|.
name|name
operator|+
literal|", "
operator|+
literal|"dataBlockEncoder="
operator|+
name|reader
operator|.
name|dataBlockEncoder
operator|+
literal|", "
operator|+
literal|"isCompaction="
operator|+
name|isCompaction
argument_list|)
throw|;
block|}
name|blockBuffer
operator|=
name|block
operator|.
name|getBufferWithoutHeader
argument_list|()
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
name|blockFetches
operator|++
expr_stmt|;
comment|// Reset the next indexed key
name|this
operator|.
name|nextIndexedKey
operator|=
literal|null
expr_stmt|;
block|}
specifier|protected
name|void
name|readKeyValueLen
parameter_list|()
block|{
name|blockBuffer
operator|.
name|mark
argument_list|()
expr_stmt|;
name|currKeyLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|ByteBufferUtils
operator|.
name|skip
argument_list|(
name|blockBuffer
argument_list|,
name|currKeyLen
operator|+
name|currValueLen
argument_list|)
expr_stmt|;
name|readMvccVersion
argument_list|()
expr_stmt|;
if|if
condition|(
name|currKeyLen
argument_list|<
literal|0
operator|||
name|currValueLen
argument_list|<
literal|0
operator|||
name|currKeyLen
argument_list|>
name|blockBuffer
operator|.
name|limit
operator|(
operator|)
operator|||
name|currValueLen
argument_list|>
name|blockBuffer
operator|.
name|limit
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid currKeyLen "
operator|+
name|currKeyLen
operator|+
literal|" or currValueLen "
operator|+
name|currValueLen
operator|+
literal|". Block offset: "
operator|+
name|block
operator|.
name|getOffset
argument_list|()
operator|+
literal|", block length: "
operator|+
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|", position: "
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|" (without header)."
argument_list|)
throw|;
block|}
name|blockBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|void
name|readMvccVersion
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|shouldIncludeMemstoreTS
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|decodeMemstoreTS
condition|)
block|{
try|try
block|{
name|currMemstoreTS
operator|=
name|Bytes
operator|.
name|readVLong
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
name|currMemstoreTSLen
operator|=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|currMemstoreTS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error reading memstore timestamp"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|currMemstoreTS
operator|=
literal|0
expr_stmt|;
name|currMemstoreTSLen
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Within a loaded block, seek looking for the last key that is smaller      * than (or equal to?) the key we are interested in.      *      * A note on the seekBefore: if you have seekBefore = true, AND the first      * key in the block = key, then you'll get thrown exceptions. The caller has      * to check for that case and load the previous block as appropriate.      *      * @param key the key to find      * @param seekBefore find the key before the given key in case of exact      *          match.      * @return 0 in case of an exact key match, 1 in case of an inexact match,      *         -2 in case of an inexact match and furthermore, the input key less      *         than the first key of current block(e.g. using a faked index key)      */
specifier|protected
name|int
name|blockSeek
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
block|{
name|int
name|klen
decl_stmt|,
name|vlen
decl_stmt|;
name|long
name|memstoreTS
init|=
literal|0
decl_stmt|;
name|int
name|memstoreTSLen
init|=
literal|0
decl_stmt|;
name|int
name|lastKeyValueSize
init|=
operator|-
literal|1
decl_stmt|;
do|do
block|{
name|blockBuffer
operator|.
name|mark
argument_list|()
expr_stmt|;
name|klen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|vlen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|blockBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|shouldIncludeMemstoreTS
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|decodeMemstoreTS
condition|)
block|{
try|try
block|{
name|int
name|memstoreTSOffset
init|=
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
operator|+
name|klen
operator|+
name|vlen
decl_stmt|;
name|memstoreTS
operator|=
name|Bytes
operator|.
name|readVLong
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|memstoreTSOffset
argument_list|)
expr_stmt|;
name|memstoreTSLen
operator|=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|memstoreTS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error reading memstore timestamp"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|memstoreTS
operator|=
literal|0
expr_stmt|;
name|memstoreTSLen
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|int
name|keyOffset
init|=
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
decl_stmt|;
name|int
name|comp
init|=
name|reader
operator|.
name|getComparator
argument_list|()
operator|.
name|compareFlatKey
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|keyOffset
argument_list|,
name|klen
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|seekBefore
condition|)
block|{
if|if
condition|(
name|lastKeyValueSize
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"blockSeek with seekBefore "
operator|+
literal|"at the first key of the block: key="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
operator|+
literal|", blockOffset="
operator|+
name|block
operator|.
name|getOffset
argument_list|()
operator|+
literal|", onDiskSize="
operator|+
name|block
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
argument_list|)
throw|;
block|}
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|-
name|lastKeyValueSize
argument_list|)
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// non exact match.
block|}
name|currKeyLen
operator|=
name|klen
expr_stmt|;
name|currValueLen
operator|=
name|vlen
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|shouldIncludeMemstoreTS
argument_list|()
condition|)
block|{
name|currMemstoreTS
operator|=
name|memstoreTS
expr_stmt|;
name|currMemstoreTSLen
operator|=
name|memstoreTSLen
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|// indicate exact match
block|}
elseif|else
if|if
condition|(
name|comp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|lastKeyValueSize
operator|>
literal|0
condition|)
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|-
name|lastKeyValueSize
argument_list|)
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastKeyValueSize
operator|==
operator|-
literal|1
operator|&&
name|blockBuffer
operator|.
name|position
argument_list|()
operator|==
literal|0
operator|&&
name|this
operator|.
name|reader
operator|.
name|trailer
operator|.
name|getMinorVersion
argument_list|()
operator|>=
name|MINOR_VERSION_WITH_FAKED_KEY
condition|)
block|{
return|return
name|HConstants
operator|.
name|INDEX_KEY_MAGIC
return|;
block|}
return|return
literal|1
return|;
block|}
comment|// The size of this key/value tuple, including key/value length fields.
name|lastKeyValueSize
operator|=
name|klen
operator|+
name|vlen
operator|+
name|memstoreTSLen
operator|+
name|KEY_VALUE_LEN_SIZE
expr_stmt|;
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|lastKeyValueSize
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|blockBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
do|;
comment|// Seek to the last key we successfully read. This will happen if this is
comment|// the last key/value pair in the file, in which case the following call
comment|// to next() has to return false.
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|-
name|lastKeyValueSize
argument_list|)
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// didn't exactly find it.
block|}
annotation|@
name|Override
specifier|protected
name|ByteBuffer
name|getFirstKeyInBlock
parameter_list|(
name|HFileBlock
name|curBlock
parameter_list|)
block|{
name|ByteBuffer
name|buffer
init|=
name|curBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
decl_stmt|;
comment|// It is safe to manipulate this buffer because we own the buffer object.
name|buffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|int
name|klen
init|=
name|buffer
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|ByteBuffer
name|keyBuff
init|=
name|buffer
operator|.
name|slice
argument_list|()
decl_stmt|;
name|keyBuff
operator|.
name|limit
argument_list|(
name|klen
argument_list|)
expr_stmt|;
name|keyBuff
operator|.
name|rewind
argument_list|()
expr_stmt|;
return|return
name|keyBuff
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getKeyString
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
argument_list|,
name|currKeyLen
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getValueString
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toString
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
argument_list|,
name|currValueLen
argument_list|)
return|;
block|}
block|}
comment|/**    * ScannerV2 that operates on encoded data blocks.    */
specifier|protected
specifier|static
class|class
name|EncodedScannerV2
extends|extends
name|AbstractScannerV2
block|{
specifier|private
name|DataBlockEncoder
operator|.
name|EncodedSeeker
name|seeker
init|=
literal|null
decl_stmt|;
specifier|protected
name|DataBlockEncoder
name|dataBlockEncoder
init|=
literal|null
decl_stmt|;
specifier|protected
specifier|final
name|HFileContext
name|meta
decl_stmt|;
specifier|protected
name|HFileBlockDecodingContext
name|decodingCtx
decl_stmt|;
specifier|public
name|EncodedScannerV2
parameter_list|(
name|HFileReaderV2
name|reader
parameter_list|,
name|boolean
name|cacheBlocks
parameter_list|,
name|boolean
name|pread
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|HFileContext
name|meta
parameter_list|)
block|{
name|super
argument_list|(
name|reader
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
name|this
operator|.
name|meta
operator|=
name|meta
expr_stmt|;
block|}
specifier|protected
name|void
name|setDataBlockEncoder
parameter_list|(
name|DataBlockEncoder
name|dataBlockEncoder
parameter_list|)
block|{
name|this
operator|.
name|dataBlockEncoder
operator|=
name|dataBlockEncoder
expr_stmt|;
name|decodingCtx
operator|=
name|this
operator|.
name|dataBlockEncoder
operator|.
name|newDataBlockDecodingContext
argument_list|(
name|this
operator|.
name|meta
argument_list|)
expr_stmt|;
name|seeker
operator|=
name|dataBlockEncoder
operator|.
name|createSeeker
argument_list|(
name|reader
operator|.
name|getComparator
argument_list|()
argument_list|,
name|decodingCtx
argument_list|)
expr_stmt|;
block|}
comment|/**      * Updates the current block to be the given {@link HFileBlock}. Seeks to      * the the first key/value pair.      *      * @param newBlock the block to make current      */
specifier|protected
name|void
name|updateCurrentBlock
parameter_list|(
name|HFileBlock
name|newBlock
parameter_list|)
block|{
name|block
operator|=
name|newBlock
expr_stmt|;
comment|// sanity checks
if|if
condition|(
name|block
operator|.
name|getBlockType
argument_list|()
operator|!=
name|BlockType
operator|.
name|ENCODED_DATA
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"EncodedScanner works only on encoded data blocks"
argument_list|)
throw|;
block|}
name|updateDataBlockEncoder
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|seeker
operator|.
name|setCurrentBuffer
argument_list|(
name|getEncodedBuffer
argument_list|(
name|newBlock
argument_list|)
argument_list|)
expr_stmt|;
name|blockFetches
operator|++
expr_stmt|;
block|}
specifier|private
name|void
name|updateDataBlockEncoder
parameter_list|(
name|HFileBlock
name|curBlock
parameter_list|)
block|{
name|short
name|dataBlockEncoderId
init|=
name|curBlock
operator|.
name|getDataBlockEncodingId
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataBlockEncoder
operator|==
literal|null
operator|||
operator|!
name|DataBlockEncoding
operator|.
name|isCorrectEncoder
argument_list|(
name|dataBlockEncoder
argument_list|,
name|dataBlockEncoderId
argument_list|)
condition|)
block|{
name|DataBlockEncoder
name|encoder
init|=
name|DataBlockEncoding
operator|.
name|getDataBlockEncoderById
argument_list|(
name|dataBlockEncoderId
argument_list|)
decl_stmt|;
name|setDataBlockEncoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|ByteBuffer
name|getEncodedBuffer
parameter_list|(
name|HFileBlock
name|newBlock
parameter_list|)
block|{
name|ByteBuffer
name|origBlock
init|=
name|newBlock
operator|.
name|getBufferReadOnly
argument_list|()
decl_stmt|;
name|ByteBuffer
name|encodedBlock
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|origBlock
operator|.
name|array
argument_list|()
argument_list|,
name|origBlock
operator|.
name|arrayOffset
argument_list|()
operator|+
name|newBlock
operator|.
name|headerSize
argument_list|()
operator|+
name|DataBlockEncoding
operator|.
name|ID_SIZE
argument_list|,
name|newBlock
operator|.
name|getUncompressedSizeWithoutHeader
argument_list|()
operator|-
name|DataBlockEncoding
operator|.
name|ID_SIZE
argument_list|)
operator|.
name|slice
argument_list|()
decl_stmt|;
return|return
name|encodedBlock
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|seekTo
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|reader
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getEntryCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// No data blocks.
return|return
literal|false
return|;
block|}
name|long
name|firstDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getFirstDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|!=
literal|null
operator|&&
name|block
operator|.
name|getOffset
argument_list|()
operator|==
name|firstDataBlockOffset
condition|)
block|{
name|seeker
operator|.
name|rewind
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|block
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|firstDataBlockOffset
argument_list|,
operator|-
literal|1
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
name|BlockType
operator|.
name|DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|.
name|getOffset
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid block offset: "
operator|+
name|block
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
name|updateCurrentBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|isValid
init|=
name|seeker
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isValid
condition|)
block|{
name|block
operator|=
name|readNextDataBlock
argument_list|()
expr_stmt|;
name|isValid
operator|=
name|block
operator|!=
literal|null
expr_stmt|;
if|if
condition|(
name|isValid
condition|)
block|{
name|updateCurrentBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|isValid
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getKey
parameter_list|()
block|{
name|assertValidSeek
argument_list|()
expr_stmt|;
return|return
name|seeker
operator|.
name|getKeyDeepCopy
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getValue
parameter_list|()
block|{
name|assertValidSeek
argument_list|()
expr_stmt|;
return|return
name|seeker
operator|.
name|getValueShallowCopy
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|KeyValue
name|getKeyValue
parameter_list|()
block|{
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|seeker
operator|.
name|getKeyValue
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getKeyString
parameter_list|()
block|{
name|ByteBuffer
name|keyBuffer
init|=
name|getKey
argument_list|()
decl_stmt|;
return|return
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|keyBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|keyBuffer
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|keyBuffer
operator|.
name|limit
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getValueString
parameter_list|()
block|{
name|ByteBuffer
name|valueBuffer
init|=
name|getValue
argument_list|()
decl_stmt|;
return|return
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|valueBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|valueBuffer
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|valueBuffer
operator|.
name|limit
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|void
name|assertValidSeek
parameter_list|()
block|{
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NotSeekedException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|ByteBuffer
name|getFirstKeyInBlock
parameter_list|(
name|HFileBlock
name|curBlock
parameter_list|)
block|{
name|updateDataBlockEncoder
argument_list|(
name|curBlock
argument_list|)
expr_stmt|;
return|return
name|dataBlockEncoder
operator|.
name|getFirstKeyInBlock
argument_list|(
name|getEncodedBuffer
argument_list|(
name|curBlock
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|loadBlockAndSeekToKey
parameter_list|(
name|HFileBlock
name|seekToBlock
parameter_list|,
name|byte
index|[]
name|nextIndexedKey
parameter_list|,
name|boolean
name|rewind
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|block
operator|==
literal|null
operator|||
name|block
operator|.
name|getOffset
argument_list|()
operator|!=
name|seekToBlock
operator|.
name|getOffset
argument_list|()
condition|)
block|{
name|updateCurrentBlock
argument_list|(
name|seekToBlock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rewind
condition|)
block|{
name|seeker
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|nextIndexedKey
operator|=
name|nextIndexedKey
expr_stmt|;
return|return
name|seeker
operator|.
name|seekToKeyInBlock
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|seekBefore
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a buffer with the Bloom filter metadata. The caller takes    * ownership of the buffer.    */
annotation|@
name|Override
specifier|public
name|DataInput
name|getGeneralBloomFilterMetadata
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|getBloomFilterMetadata
argument_list|(
name|BlockType
operator|.
name|GENERAL_BLOOM_META
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|DataInput
name|getDeleteBloomFilterMetadata
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|getBloomFilterMetadata
argument_list|(
name|BlockType
operator|.
name|DELETE_FAMILY_BLOOM_META
argument_list|)
return|;
block|}
specifier|private
name|DataInput
name|getBloomFilterMetadata
parameter_list|(
name|BlockType
name|blockType
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blockType
operator|!=
name|BlockType
operator|.
name|GENERAL_BLOOM_META
operator|&&
name|blockType
operator|!=
name|BlockType
operator|.
name|DELETE_FAMILY_BLOOM_META
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Block Type: "
operator|+
name|blockType
operator|.
name|toString
argument_list|()
operator|+
literal|" is not supported"
argument_list|)
throw|;
block|}
for|for
control|(
name|HFileBlock
name|b
range|:
name|loadOnOpenBlocks
control|)
if|if
condition|(
name|b
operator|.
name|getBlockType
argument_list|()
operator|==
name|blockType
condition|)
return|return
name|b
operator|.
name|getByteStream
argument_list|()
return|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isFileInfoLoaded
parameter_list|()
block|{
return|return
literal|true
return|;
comment|// We load file info in constructor in version 2.
block|}
comment|/**    * Validates that the minor version is within acceptable limits.    * Otherwise throws an Runtime exception    */
specifier|private
name|void
name|validateMinorVersion
parameter_list|(
name|Path
name|path
parameter_list|,
name|int
name|minorVersion
parameter_list|)
block|{
if|if
condition|(
name|minorVersion
argument_list|<
name|MIN_MINOR_VERSION
operator|||
name|minorVersion
argument_list|>
name|MAX_MINOR_VERSION
condition|)
block|{
name|String
name|msg
init|=
literal|"Minor version for path "
operator|+
name|path
operator|+
literal|" is expected to be between "
operator|+
name|MIN_MINOR_VERSION
operator|+
literal|" and "
operator|+
name|MAX_MINOR_VERSION
operator|+
literal|" but is found to be "
operator|+
name|minorVersion
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|getMajorVersion
parameter_list|()
block|{
return|return
literal|2
return|;
block|}
block|}
end_class

end_unit

