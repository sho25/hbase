begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|timeout
operator|.
name|IdleState
operator|.
name|READER_IDLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|timeout
operator|.
name|IdleState
operator|.
name|WRITER_IDLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|HEART_BEAT_SEQNO
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|READ_TIMEOUT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|completeFile
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|endFileLease
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|getStatus
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_SOCKET_TIMEOUT_KEY
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|buffer
operator|.
name|ByteBuf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|buffer
operator|.
name|ByteBufAllocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|Channel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|ChannelHandler
operator|.
name|Sharable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|ChannelHandlerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|EventLoop
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|SimpleChannelInboundHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|codec
operator|.
name|protobuf
operator|.
name|ProtobufDecoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|codec
operator|.
name|protobuf
operator|.
name|ProtobufVarint32FrameDecoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|timeout
operator|.
name|IdleStateEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|timeout
operator|.
name|IdleStateHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Promise
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|concurrent
operator|.
name|PromiseCombiner
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|Encryptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|CancelOnClose
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CancelableProgressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PacketHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PipelineAck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|PipelineAckProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * An asynchronous HDFS output stream implementation which fans out data to datanode and only  * supports writing file with only one block.  *<p>  * Use the createOutput method in {@link FanOutOneBlockAsyncDFSOutputHelper} to create. The mainly  * usage of this class is implementing WAL, so we only expose a little HDFS configurations in the  * method. And we place it here under util package because we want to make it independent of WAL  * implementation thus easier to move it to HDFS project finally.  *<p>  * Note that, all connections to datanode will run in the same {@link EventLoop} which means we only  * need one thread here. But be careful, we do some blocking operations in {@link #close()} and  * {@link #recoverAndClose(CancelableProgressable)} methods, so do not call them inside  * {@link EventLoop}. And for {@link #write(byte[])} {@link #write(byte[], int, int)},  * {@link #buffered()} and {@link #flush(boolean)}, if you call them outside {@link EventLoop},  * there will be an extra context-switch.  *<p>  * Advantages compare to DFSOutputStream:  *<ol>  *<li>The fan out mechanism. This will reduce the latency.</li>  *<li>The asynchronous WAL could also run in the same EventLoop, we could just call write and flush  * inside the EventLoop thread, so generally we only have one thread to do all the things.</li>  *<li>Fail-fast when connection to datanode error. The WAL implementation could open new writer  * ASAP.</li>  *<li>We could benefit from netty's ByteBuf management mechanism.</li>  *</ol>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|FanOutOneBlockAsyncDFSOutput
implements|implements
name|AsyncFSOutput
block|{
comment|// The MAX_PACKET_SIZE is 16MB but it include the header size and checksum size. So here we set a
comment|// smaller limit for data size.
specifier|private
specifier|static
specifier|final
name|int
name|MAX_DATA_LEN
init|=
literal|12
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|FSUtils
name|fsUtils
decl_stmt|;
specifier|private
specifier|final
name|DistributedFileSystem
name|dfs
decl_stmt|;
specifier|private
specifier|final
name|DFSClient
name|client
decl_stmt|;
specifier|private
specifier|final
name|ClientProtocol
name|namenode
decl_stmt|;
specifier|private
specifier|final
name|String
name|clientName
decl_stmt|;
specifier|private
specifier|final
name|String
name|src
decl_stmt|;
specifier|private
specifier|final
name|long
name|fileId
decl_stmt|;
specifier|private
specifier|final
name|LocatedBlock
name|locatedBlock
decl_stmt|;
specifier|private
specifier|final
name|Encryptor
name|encryptor
decl_stmt|;
specifier|private
specifier|final
name|EventLoop
name|eventLoop
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Channel
argument_list|>
name|datanodeList
decl_stmt|;
specifier|private
specifier|final
name|DataChecksum
name|summer
decl_stmt|;
specifier|private
specifier|final
name|int
name|maxDataLen
decl_stmt|;
specifier|private
specifier|final
name|ByteBufAllocator
name|alloc
decl_stmt|;
specifier|private
specifier|static
specifier|final
class|class
name|Callback
block|{
specifier|private
specifier|final
name|Promise
argument_list|<
name|Void
argument_list|>
name|promise
decl_stmt|;
specifier|private
specifier|final
name|long
name|ackedLength
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|Channel
argument_list|>
name|unfinishedReplicas
decl_stmt|;
specifier|public
name|Callback
parameter_list|(
name|Promise
argument_list|<
name|Void
argument_list|>
name|promise
parameter_list|,
name|long
name|ackedLength
parameter_list|,
name|Collection
argument_list|<
name|Channel
argument_list|>
name|replicas
parameter_list|)
block|{
name|this
operator|.
name|promise
operator|=
name|promise
expr_stmt|;
name|this
operator|.
name|ackedLength
operator|=
name|ackedLength
expr_stmt|;
if|if
condition|(
name|replicas
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|unfinishedReplicas
operator|=
name|Collections
operator|.
name|emptySet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|unfinishedReplicas
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|IdentityHashMap
argument_list|<
name|Channel
argument_list|,
name|Boolean
argument_list|>
argument_list|(
name|replicas
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|unfinishedReplicas
operator|.
name|addAll
argument_list|(
name|replicas
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|final
name|Deque
argument_list|<
name|Callback
argument_list|>
name|waitingAckQueue
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|// this could be different from acked block length because a packet can not start at the middle of
comment|// a chunk.
specifier|private
name|long
name|nextPacketOffsetInBlock
init|=
literal|0L
decl_stmt|;
specifier|private
name|long
name|nextPacketSeqno
init|=
literal|0L
decl_stmt|;
specifier|private
name|ByteBuf
name|buf
decl_stmt|;
comment|// buf's initial capacity - 4KB
specifier|private
name|int
name|capacity
init|=
literal|4
operator|*
literal|1024
decl_stmt|;
comment|// LIMIT is 128MB
specifier|private
specifier|static
specifier|final
name|int
name|LIMIT
init|=
literal|128
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
specifier|private
enum|enum
name|State
block|{
name|STREAMING
block|,
name|CLOSING
block|,
name|BROKEN
block|,
name|CLOSED
block|}
specifier|private
name|State
name|state
decl_stmt|;
specifier|private
name|void
name|completed
parameter_list|(
name|Channel
name|channel
parameter_list|)
block|{
if|if
condition|(
name|waitingAckQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Callback
name|c
range|:
name|waitingAckQueue
control|)
block|{
if|if
condition|(
name|c
operator|.
name|unfinishedReplicas
operator|.
name|remove
argument_list|(
name|channel
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|.
name|unfinishedReplicas
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|c
operator|.
name|promise
operator|.
name|trySuccess
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// since we will remove the Callback entry from waitingAckQueue if its unfinishedReplicas
comment|// is empty, so this could only happen at the head of waitingAckQueue, so we just call
comment|// removeFirst here.
name|waitingAckQueue
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
comment|// also wake up flush requests which have the same length.
for|for
control|(
name|Callback
name|cb
init|;
operator|(
name|cb
operator|=
name|waitingAckQueue
operator|.
name|peekFirst
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
if|if
condition|(
name|cb
operator|.
name|ackedLength
operator|==
name|c
operator|.
name|ackedLength
condition|)
block|{
name|cb
operator|.
name|promise
operator|.
name|trySuccess
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|waitingAckQueue
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
return|return;
block|}
block|}
block|}
specifier|private
name|void
name|failed
parameter_list|(
name|Channel
name|channel
parameter_list|,
name|Supplier
argument_list|<
name|Throwable
argument_list|>
name|errorSupplier
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|BROKEN
operator|||
name|state
operator|==
name|State
operator|.
name|CLOSED
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|CLOSING
condition|)
block|{
name|Callback
name|c
init|=
name|waitingAckQueue
operator|.
name|peekFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
operator|||
operator|!
name|c
operator|.
name|unfinishedReplicas
operator|.
name|contains
argument_list|(
name|channel
argument_list|)
condition|)
block|{
comment|// nothing, the endBlock request has already finished.
return|return;
block|}
block|}
comment|// disable further write, and fail all pending ack.
name|state
operator|=
name|State
operator|.
name|BROKEN
expr_stmt|;
name|Throwable
name|error
init|=
name|errorSupplier
operator|.
name|get
argument_list|()
decl_stmt|;
name|waitingAckQueue
operator|.
name|stream
argument_list|()
operator|.
name|forEach
argument_list|(
name|c
lambda|->
name|c
operator|.
name|promise
operator|.
name|tryFailure
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|waitingAckQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|datanodeList
operator|.
name|forEach
argument_list|(
name|ch
lambda|->
name|ch
operator|.
name|close
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Sharable
specifier|private
specifier|final
class|class
name|AckHandler
extends|extends
name|SimpleChannelInboundHandler
argument_list|<
name|PipelineAckProto
argument_list|>
block|{
specifier|private
specifier|final
name|int
name|timeoutMs
decl_stmt|;
specifier|public
name|AckHandler
parameter_list|(
name|int
name|timeoutMs
parameter_list|)
block|{
name|this
operator|.
name|timeoutMs
operator|=
name|timeoutMs
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|channelRead0
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|PipelineAckProto
name|ack
parameter_list|)
throws|throws
name|Exception
block|{
name|Status
name|reply
init|=
name|getStatus
argument_list|(
name|ack
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
operator|!=
name|Status
operator|.
name|SUCCESS
condition|)
block|{
name|failed
argument_list|(
name|ctx
operator|.
name|channel
argument_list|()
argument_list|,
parameter_list|()
lambda|->
operator|new
name|IOException
argument_list|(
literal|"Bad response "
operator|+
name|reply
operator|+
literal|" for block "
operator|+
name|locatedBlock
operator|.
name|getBlock
argument_list|()
operator|+
literal|" from datanode "
operator|+
name|ctx
operator|.
name|channel
argument_list|()
operator|.
name|remoteAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|PipelineAck
operator|.
name|isRestartOOBStatus
argument_list|(
name|reply
argument_list|)
condition|)
block|{
name|failed
argument_list|(
name|ctx
operator|.
name|channel
argument_list|()
argument_list|,
parameter_list|()
lambda|->
operator|new
name|IOException
argument_list|(
literal|"Restart response "
operator|+
name|reply
operator|+
literal|" for block "
operator|+
name|locatedBlock
operator|.
name|getBlock
argument_list|()
operator|+
literal|" from datanode "
operator|+
name|ctx
operator|.
name|channel
argument_list|()
operator|.
name|remoteAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ack
operator|.
name|getSeqno
argument_list|()
operator|==
name|HEART_BEAT_SEQNO
condition|)
block|{
return|return;
block|}
name|completed
argument_list|(
name|ctx
operator|.
name|channel
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|channelInactive
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|)
throws|throws
name|Exception
block|{
name|failed
argument_list|(
name|ctx
operator|.
name|channel
argument_list|()
argument_list|,
parameter_list|()
lambda|->
operator|new
name|IOException
argument_list|(
literal|"Connection to "
operator|+
name|ctx
operator|.
name|channel
argument_list|()
operator|.
name|remoteAddress
argument_list|()
operator|+
literal|" closed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|exceptionCaught
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|Throwable
name|cause
parameter_list|)
throws|throws
name|Exception
block|{
name|failed
argument_list|(
name|ctx
operator|.
name|channel
argument_list|()
argument_list|,
parameter_list|()
lambda|->
name|cause
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|userEventTriggered
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|Object
name|evt
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|evt
operator|instanceof
name|IdleStateEvent
condition|)
block|{
name|IdleStateEvent
name|e
init|=
operator|(
name|IdleStateEvent
operator|)
name|evt
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|state
argument_list|()
operator|==
name|READER_IDLE
condition|)
block|{
name|failed
argument_list|(
name|ctx
operator|.
name|channel
argument_list|()
argument_list|,
parameter_list|()
lambda|->
operator|new
name|IOException
argument_list|(
literal|"Timeout("
operator|+
name|timeoutMs
operator|+
literal|"ms) waiting for response"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|state
argument_list|()
operator|==
name|WRITER_IDLE
condition|)
block|{
name|PacketHeader
name|heartbeat
init|=
operator|new
name|PacketHeader
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
name|HEART_BEAT_SEQNO
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|heartbeat
operator|.
name|getSerializedSize
argument_list|()
decl_stmt|;
name|ByteBuf
name|buf
init|=
name|alloc
operator|.
name|buffer
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|heartbeat
operator|.
name|putInBuffer
argument_list|(
name|buf
operator|.
name|nioBuffer
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|writerIndex
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|channel
argument_list|()
operator|.
name|writeAndFlush
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|super
operator|.
name|userEventTriggered
argument_list|(
name|ctx
argument_list|,
name|evt
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setupReceiver
parameter_list|(
name|int
name|timeoutMs
parameter_list|)
block|{
name|AckHandler
name|ackHandler
init|=
operator|new
name|AckHandler
argument_list|(
name|timeoutMs
argument_list|)
decl_stmt|;
for|for
control|(
name|Channel
name|ch
range|:
name|datanodeList
control|)
block|{
name|ch
operator|.
name|pipeline
argument_list|()
operator|.
name|addLast
argument_list|(
operator|new
name|IdleStateHandler
argument_list|(
name|timeoutMs
argument_list|,
name|timeoutMs
operator|/
literal|2
argument_list|,
literal|0
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|,
operator|new
name|ProtobufVarint32FrameDecoder
argument_list|()
argument_list|,
operator|new
name|ProtobufDecoder
argument_list|(
name|PipelineAckProto
operator|.
name|getDefaultInstance
argument_list|()
argument_list|)
argument_list|,
name|ackHandler
argument_list|)
expr_stmt|;
name|ch
operator|.
name|config
argument_list|()
operator|.
name|setAutoRead
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|FanOutOneBlockAsyncDFSOutput
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSUtils
name|fsUtils
parameter_list|,
name|DistributedFileSystem
name|dfs
parameter_list|,
name|DFSClient
name|client
parameter_list|,
name|ClientProtocol
name|namenode
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|LocatedBlock
name|locatedBlock
parameter_list|,
name|Encryptor
name|encryptor
parameter_list|,
name|EventLoop
name|eventLoop
parameter_list|,
name|List
argument_list|<
name|Channel
argument_list|>
name|datanodeList
parameter_list|,
name|DataChecksum
name|summer
parameter_list|,
name|ByteBufAllocator
name|alloc
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|fsUtils
operator|=
name|fsUtils
expr_stmt|;
name|this
operator|.
name|dfs
operator|=
name|dfs
expr_stmt|;
name|this
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|this
operator|.
name|namenode
operator|=
name|namenode
expr_stmt|;
name|this
operator|.
name|fileId
operator|=
name|fileId
expr_stmt|;
name|this
operator|.
name|clientName
operator|=
name|clientName
expr_stmt|;
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|locatedBlock
operator|=
name|locatedBlock
expr_stmt|;
name|this
operator|.
name|encryptor
operator|=
name|encryptor
expr_stmt|;
name|this
operator|.
name|eventLoop
operator|=
name|eventLoop
expr_stmt|;
name|this
operator|.
name|datanodeList
operator|=
name|datanodeList
expr_stmt|;
name|this
operator|.
name|summer
operator|=
name|summer
expr_stmt|;
name|this
operator|.
name|maxDataLen
operator|=
name|MAX_DATA_LEN
operator|-
operator|(
name|MAX_DATA_LEN
operator|%
name|summer
operator|.
name|getBytesPerChecksum
argument_list|()
operator|)
expr_stmt|;
name|this
operator|.
name|alloc
operator|=
name|alloc
expr_stmt|;
name|this
operator|.
name|buf
operator|=
name|alloc
operator|.
name|directBuffer
argument_list|(
name|capacity
argument_list|)
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|State
operator|.
name|STREAMING
expr_stmt|;
name|setupReceiver
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_CLIENT_SOCKET_TIMEOUT_KEY
argument_list|,
name|READ_TIMEOUT
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|writeInt0
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|buf
operator|.
name|ensureWritable
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|.
name|writeInt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeInt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|eventLoop
operator|.
name|inEventLoop
argument_list|()
condition|)
block|{
name|writeInt0
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eventLoop
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
name|writeInt0
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|write0
parameter_list|(
name|ByteBuffer
name|bb
parameter_list|)
block|{
name|buf
operator|.
name|ensureWritable
argument_list|(
name|bb
operator|.
name|remaining
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|writeBytes
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|ByteBuffer
name|bb
parameter_list|)
block|{
if|if
condition|(
name|eventLoop
operator|.
name|inEventLoop
argument_list|()
condition|)
block|{
name|write0
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eventLoop
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
name|write0
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
block|{
name|write
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|write0
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|buf
operator|.
name|ensureWritable
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|buf
operator|.
name|writeBytes
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|eventLoop
operator|.
name|inEventLoop
argument_list|()
condition|)
block|{
name|write0
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eventLoop
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
name|write0
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
argument_list|)
operator|.
name|syncUninterruptibly
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|buffered
parameter_list|()
block|{
if|if
condition|(
name|eventLoop
operator|.
name|inEventLoop
argument_list|()
condition|)
block|{
return|return
name|buf
operator|.
name|readableBytes
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|eventLoop
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
name|buf
operator|.
name|readableBytes
argument_list|()
argument_list|)
operator|.
name|syncUninterruptibly
argument_list|()
operator|.
name|getNow
argument_list|()
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|DatanodeInfo
index|[]
name|getPipeline
parameter_list|()
block|{
return|return
name|locatedBlock
operator|.
name|getLocations
argument_list|()
return|;
block|}
specifier|private
name|Promise
argument_list|<
name|Void
argument_list|>
name|flushBuffer
parameter_list|(
name|ByteBuf
name|dataBuf
parameter_list|,
name|long
name|nextPacketOffsetInBlock
parameter_list|,
name|boolean
name|syncBlock
parameter_list|)
block|{
name|int
name|dataLen
init|=
name|dataBuf
operator|.
name|readableBytes
argument_list|()
decl_stmt|;
name|int
name|chunkLen
init|=
name|summer
operator|.
name|getBytesPerChecksum
argument_list|()
decl_stmt|;
name|int
name|trailingPartialChunkLen
init|=
name|dataLen
operator|%
name|chunkLen
decl_stmt|;
name|int
name|numChecks
init|=
name|dataLen
operator|/
name|chunkLen
operator|+
operator|(
name|trailingPartialChunkLen
operator|!=
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|checksumLen
init|=
name|numChecks
operator|*
name|summer
operator|.
name|getChecksumSize
argument_list|()
decl_stmt|;
name|ByteBuf
name|checksumBuf
init|=
name|alloc
operator|.
name|directBuffer
argument_list|(
name|checksumLen
argument_list|)
decl_stmt|;
name|summer
operator|.
name|calculateChunkedSums
argument_list|(
name|dataBuf
operator|.
name|nioBuffer
argument_list|()
argument_list|,
name|checksumBuf
operator|.
name|nioBuffer
argument_list|(
literal|0
argument_list|,
name|checksumLen
argument_list|)
argument_list|)
expr_stmt|;
name|checksumBuf
operator|.
name|writerIndex
argument_list|(
name|checksumLen
argument_list|)
expr_stmt|;
name|PacketHeader
name|header
init|=
operator|new
name|PacketHeader
argument_list|(
literal|4
operator|+
name|checksumLen
operator|+
name|dataLen
argument_list|,
name|nextPacketOffsetInBlock
argument_list|,
name|nextPacketSeqno
argument_list|,
literal|false
argument_list|,
name|dataLen
argument_list|,
name|syncBlock
argument_list|)
decl_stmt|;
name|int
name|headerLen
init|=
name|header
operator|.
name|getSerializedSize
argument_list|()
decl_stmt|;
name|ByteBuf
name|headerBuf
init|=
name|alloc
operator|.
name|buffer
argument_list|(
name|headerLen
argument_list|)
decl_stmt|;
name|header
operator|.
name|putInBuffer
argument_list|(
name|headerBuf
operator|.
name|nioBuffer
argument_list|(
literal|0
argument_list|,
name|headerLen
argument_list|)
argument_list|)
expr_stmt|;
name|headerBuf
operator|.
name|writerIndex
argument_list|(
name|headerLen
argument_list|)
expr_stmt|;
name|long
name|ackedLength
init|=
name|nextPacketOffsetInBlock
operator|+
name|dataLen
decl_stmt|;
name|Promise
argument_list|<
name|Void
argument_list|>
name|promise
init|=
name|eventLoop
operator|.
expr|<
name|Void
operator|>
name|newPromise
argument_list|()
operator|.
name|addListener
argument_list|(
name|future
lambda|->
block|{
if|if
condition|(
name|future
operator|.
name|isSuccess
argument_list|()
condition|)
block|{
name|locatedBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|setNumBytes
argument_list|(
name|ackedLength
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
decl_stmt|;
name|waitingAckQueue
operator|.
name|addLast
argument_list|(
operator|new
name|Callback
argument_list|(
name|promise
argument_list|,
name|ackedLength
argument_list|,
name|datanodeList
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Channel
name|ch
range|:
name|datanodeList
control|)
block|{
name|ch
operator|.
name|write
argument_list|(
name|headerBuf
operator|.
name|duplicate
argument_list|()
operator|.
name|retain
argument_list|()
argument_list|)
expr_stmt|;
name|ch
operator|.
name|write
argument_list|(
name|checksumBuf
operator|.
name|duplicate
argument_list|()
operator|.
name|retain
argument_list|()
argument_list|)
expr_stmt|;
name|ch
operator|.
name|writeAndFlush
argument_list|(
name|dataBuf
operator|.
name|duplicate
argument_list|()
operator|.
name|retain
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|checksumBuf
operator|.
name|release
argument_list|()
expr_stmt|;
name|headerBuf
operator|.
name|release
argument_list|()
expr_stmt|;
name|dataBuf
operator|.
name|release
argument_list|()
expr_stmt|;
name|nextPacketSeqno
operator|++
expr_stmt|;
return|return
name|promise
return|;
block|}
specifier|private
name|void
name|flush0
parameter_list|(
name|CompletableFuture
argument_list|<
name|Long
argument_list|>
name|future
parameter_list|,
name|boolean
name|syncBlock
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|STREAMING
condition|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"stream already broken"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|dataLen
init|=
name|buf
operator|.
name|readableBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|encryptor
operator|!=
literal|null
condition|)
block|{
name|ByteBuf
name|encryptBuf
init|=
name|alloc
operator|.
name|directBuffer
argument_list|(
name|dataLen
argument_list|)
decl_stmt|;
try|try
block|{
name|encryptor
operator|.
name|encrypt
argument_list|(
name|buf
operator|.
name|nioBuffer
argument_list|(
name|buf
operator|.
name|readerIndex
argument_list|()
argument_list|,
name|dataLen
argument_list|)
argument_list|,
name|encryptBuf
operator|.
name|nioBuffer
argument_list|(
literal|0
argument_list|,
name|dataLen
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|encryptBuf
operator|.
name|release
argument_list|()
expr_stmt|;
name|future
operator|.
name|completeExceptionally
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|encryptBuf
operator|.
name|writerIndex
argument_list|(
name|dataLen
argument_list|)
expr_stmt|;
name|buf
operator|.
name|release
argument_list|()
expr_stmt|;
name|buf
operator|=
name|encryptBuf
expr_stmt|;
block|}
name|long
name|lengthAfterFlush
init|=
name|nextPacketOffsetInBlock
operator|+
name|dataLen
decl_stmt|;
if|if
condition|(
name|lengthAfterFlush
operator|==
name|locatedBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
comment|// no new data, just return
name|future
operator|.
name|complete
argument_list|(
name|locatedBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|Callback
name|c
init|=
name|waitingAckQueue
operator|.
name|peekLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
operator|&&
name|lengthAfterFlush
operator|==
name|c
operator|.
name|ackedLength
condition|)
block|{
comment|// just append it to the tail of waiting ack queue,, do not issue new hflush request.
name|waitingAckQueue
operator|.
name|addLast
argument_list|(
operator|new
name|Callback
argument_list|(
name|eventLoop
operator|.
expr|<
name|Void
operator|>
name|newPromise
argument_list|()
operator|.
name|addListener
argument_list|(
name|f
lambda|->
block|{
if|if
condition|(
name|f
operator|.
name|isSuccess
argument_list|()
condition|)
block|{
name|future
operator|.
name|complete
argument_list|(
name|lengthAfterFlush
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
name|f
operator|.
name|cause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
argument_list|,
name|lengthAfterFlush
argument_list|,
name|Collections
operator|.
expr|<
name|Channel
operator|>
name|emptyList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|Promise
argument_list|<
name|Void
argument_list|>
name|promise
decl_stmt|;
if|if
condition|(
name|dataLen
operator|>
name|maxDataLen
condition|)
block|{
comment|// We need to write out the data by multiple packets as the max packet allowed is 16M.
name|PromiseCombiner
name|combiner
init|=
operator|new
name|PromiseCombiner
argument_list|()
decl_stmt|;
name|long
name|nextSubPacketOffsetInBlock
init|=
name|nextPacketOffsetInBlock
decl_stmt|;
for|for
control|(
name|int
name|remaining
init|=
name|dataLen
init|;
name|remaining
operator|>
literal|0
condition|;
control|)
block|{
name|int
name|toWriteDataLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|remaining
argument_list|,
name|maxDataLen
argument_list|)
decl_stmt|;
name|combiner
operator|.
name|add
argument_list|(
operator|(
name|Future
argument_list|<
name|Void
argument_list|>
operator|)
name|flushBuffer
argument_list|(
name|buf
operator|.
name|readRetainedSlice
argument_list|(
name|toWriteDataLen
argument_list|)
argument_list|,
name|nextSubPacketOffsetInBlock
argument_list|,
name|syncBlock
argument_list|)
argument_list|)
expr_stmt|;
name|nextSubPacketOffsetInBlock
operator|+=
name|toWriteDataLen
expr_stmt|;
name|remaining
operator|-=
name|toWriteDataLen
expr_stmt|;
block|}
name|promise
operator|=
name|eventLoop
operator|.
name|newPromise
argument_list|()
expr_stmt|;
name|combiner
operator|.
name|finish
argument_list|(
name|promise
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|promise
operator|=
name|flushBuffer
argument_list|(
name|buf
operator|.
name|retain
argument_list|()
argument_list|,
name|nextPacketOffsetInBlock
argument_list|,
name|syncBlock
argument_list|)
expr_stmt|;
block|}
name|promise
operator|.
name|addListener
argument_list|(
name|f
lambda|->
block|{
if|if
condition|(
name|f
operator|.
name|isSuccess
argument_list|()
condition|)
block|{
name|future
operator|.
name|complete
argument_list|(
name|lengthAfterFlush
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
name|f
operator|.
name|cause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|int
name|trailingPartialChunkLen
init|=
name|dataLen
operator|%
name|summer
operator|.
name|getBytesPerChecksum
argument_list|()
decl_stmt|;
name|ByteBuf
name|newBuf
init|=
name|alloc
operator|.
name|directBuffer
argument_list|(
name|guess
argument_list|(
name|dataLen
argument_list|)
argument_list|)
operator|.
name|ensureWritable
argument_list|(
name|trailingPartialChunkLen
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailingPartialChunkLen
operator|!=
literal|0
condition|)
block|{
name|buf
operator|.
name|readerIndex
argument_list|(
name|dataLen
operator|-
name|trailingPartialChunkLen
argument_list|)
operator|.
name|readBytes
argument_list|(
name|newBuf
argument_list|,
name|trailingPartialChunkLen
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|release
argument_list|()
expr_stmt|;
name|this
operator|.
name|buf
operator|=
name|newBuf
expr_stmt|;
name|nextPacketOffsetInBlock
operator|+=
name|dataLen
operator|-
name|trailingPartialChunkLen
expr_stmt|;
block|}
comment|/**    * Flush the buffer out to datanodes.    * @param syncBlock will call hsync if true, otherwise hflush.    * @return A CompletableFuture that hold the acked length after flushing.    */
specifier|public
name|CompletableFuture
argument_list|<
name|Long
argument_list|>
name|flush
parameter_list|(
name|boolean
name|syncBlock
parameter_list|)
block|{
name|CompletableFuture
argument_list|<
name|Long
argument_list|>
name|future
init|=
operator|new
name|CompletableFuture
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|eventLoop
operator|.
name|inEventLoop
argument_list|()
condition|)
block|{
name|flush0
argument_list|(
name|future
argument_list|,
name|syncBlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eventLoop
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
name|flush0
argument_list|(
name|future
argument_list|,
name|syncBlock
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|future
return|;
block|}
specifier|private
name|void
name|endBlock
parameter_list|(
name|Promise
argument_list|<
name|Void
argument_list|>
name|promise
parameter_list|,
name|long
name|size
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|STREAMING
condition|)
block|{
name|promise
operator|.
name|tryFailure
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"stream already broken"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|waitingAckQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|promise
operator|.
name|tryFailure
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"should call flush first before calling close"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|state
operator|=
name|State
operator|.
name|CLOSING
expr_stmt|;
name|PacketHeader
name|header
init|=
operator|new
name|PacketHeader
argument_list|(
literal|4
argument_list|,
name|size
argument_list|,
name|nextPacketSeqno
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|buf
operator|.
name|release
argument_list|()
expr_stmt|;
name|buf
operator|=
literal|null
expr_stmt|;
name|int
name|headerLen
init|=
name|header
operator|.
name|getSerializedSize
argument_list|()
decl_stmt|;
name|ByteBuf
name|headerBuf
init|=
name|alloc
operator|.
name|directBuffer
argument_list|(
name|headerLen
argument_list|)
decl_stmt|;
name|header
operator|.
name|putInBuffer
argument_list|(
name|headerBuf
operator|.
name|nioBuffer
argument_list|(
literal|0
argument_list|,
name|headerLen
argument_list|)
argument_list|)
expr_stmt|;
name|headerBuf
operator|.
name|writerIndex
argument_list|(
name|headerLen
argument_list|)
expr_stmt|;
name|waitingAckQueue
operator|.
name|add
argument_list|(
operator|new
name|Callback
argument_list|(
name|promise
argument_list|,
name|size
argument_list|,
name|datanodeList
argument_list|)
argument_list|)
expr_stmt|;
name|datanodeList
operator|.
name|forEach
argument_list|(
name|ch
lambda|->
name|ch
operator|.
name|writeAndFlush
argument_list|(
name|headerBuf
operator|.
name|duplicate
argument_list|()
operator|.
name|retain
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|headerBuf
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|/**    * The close method when error occurred. Now we just call recoverFileLease.    */
annotation|@
name|Override
specifier|public
name|void
name|recoverAndClose
parameter_list|(
name|CancelableProgressable
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eventLoop
operator|.
name|inEventLoop
argument_list|()
assert|;
name|datanodeList
operator|.
name|forEach
argument_list|(
name|ch
lambda|->
name|ch
operator|.
name|closeFuture
argument_list|()
operator|.
name|awaitUninterruptibly
argument_list|()
argument_list|)
expr_stmt|;
name|endFileLease
argument_list|(
name|client
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
name|fsUtils
operator|.
name|recoverFileLease
argument_list|(
name|dfs
argument_list|,
operator|new
name|Path
argument_list|(
name|src
argument_list|)
argument_list|,
name|conf
argument_list|,
name|reporter
operator|==
literal|null
condition|?
operator|new
name|CancelOnClose
argument_list|(
name|client
argument_list|)
else|:
name|reporter
argument_list|)
expr_stmt|;
block|}
comment|/**    * End the current block and complete file at namenode. You should call    * {@link #recoverAndClose(CancelableProgressable)} if this method throws an exception.    */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|eventLoop
operator|.
name|inEventLoop
argument_list|()
assert|;
name|Promise
argument_list|<
name|Void
argument_list|>
name|promise
init|=
name|eventLoop
operator|.
name|newPromise
argument_list|()
decl_stmt|;
name|eventLoop
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
name|endBlock
argument_list|(
name|promise
argument_list|,
name|nextPacketOffsetInBlock
operator|+
name|buf
operator|.
name|readableBytes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|promise
operator|.
name|addListener
argument_list|(
name|f
lambda|->
name|datanodeList
operator|.
name|forEach
argument_list|(
name|ch
lambda|->
name|ch
operator|.
name|close
argument_list|()
argument_list|)
argument_list|)
operator|.
name|syncUninterruptibly
argument_list|()
expr_stmt|;
name|datanodeList
operator|.
name|forEach
argument_list|(
name|ch
lambda|->
name|ch
operator|.
name|closeFuture
argument_list|()
operator|.
name|awaitUninterruptibly
argument_list|()
argument_list|)
expr_stmt|;
name|completeFile
argument_list|(
name|client
argument_list|,
name|namenode
argument_list|,
name|src
argument_list|,
name|clientName
argument_list|,
name|locatedBlock
operator|.
name|getBlock
argument_list|()
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
name|int
name|guess
parameter_list|(
name|int
name|bytesWritten
parameter_list|)
block|{
comment|// if the bytesWritten is greater than the current capacity
comment|// always increase the capacity in powers of 2.
if|if
condition|(
name|bytesWritten
operator|>
name|this
operator|.
name|capacity
condition|)
block|{
comment|// Ensure we don't cross the LIMIT
if|if
condition|(
operator|(
name|this
operator|.
name|capacity
operator|<<
literal|1
operator|)
operator|<=
name|LIMIT
condition|)
block|{
comment|// increase the capacity in the range of power of 2
name|this
operator|.
name|capacity
operator|=
name|this
operator|.
name|capacity
operator|<<
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// if we see that the bytesWritten is lesser we could again decrease
comment|// the capacity by dividing it by 2 if the bytesWritten is satisfied by
comment|// that reduction
if|if
condition|(
operator|(
name|this
operator|.
name|capacity
operator|>>
literal|1
operator|)
operator|>=
name|bytesWritten
condition|)
block|{
name|this
operator|.
name|capacity
operator|=
name|this
operator|.
name|capacity
operator|>>
literal|1
expr_stmt|;
block|}
block|}
return|return
name|this
operator|.
name|capacity
return|;
block|}
block|}
end_class

end_unit

