begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|HEART_BEAT_SEQNO
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|READ_TIMEOUT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|completeFile
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|endFileLease
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|getStatus
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_SOCKET_TIMEOUT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|timeout
operator|.
name|IdleState
operator|.
name|READER_IDLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|timeout
operator|.
name|IdleState
operator|.
name|WRITER_IDLE
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|Encryptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|CancelOnClose
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CancelableProgressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PacketHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PipelineAck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|PipelineAckProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Throwables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|buffer
operator|.
name|ByteBuf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|buffer
operator|.
name|ByteBufAllocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|Channel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|ChannelHandler
operator|.
name|Sharable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|ChannelHandlerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|ChannelId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|SimpleChannelInboundHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|codec
operator|.
name|protobuf
operator|.
name|ProtobufDecoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|codec
operator|.
name|protobuf
operator|.
name|ProtobufVarint32FrameDecoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|timeout
operator|.
name|IdleStateEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|timeout
operator|.
name|IdleStateHandler
import|;
end_import

begin_comment
comment|/**  * An asynchronous HDFS output stream implementation which fans out data to datanode and only  * supports writing file with only one block.  *<p>  * Use the createOutput method in {@link FanOutOneBlockAsyncDFSOutputHelper} to create. The mainly  * usage of this class is implementing WAL, so we only expose a little HDFS configurations in the  * method. And we place it here under io package because we want to make it independent of WAL  * implementation thus easier to move it to HDFS project finally.  *<p>  * Note that, although we support pipelined flush, i.e, write new data and then flush before the  * previous flush succeeds, the implementation is not thread safe, so you should not call its  * methods concurrently.  *<p>  * Advantages compare to DFSOutputStream:  *<ol>  *<li>The fan out mechanism. This will reduce the latency.</li>  *<li>Fail-fast when connection to datanode error. The WAL implementation could open new writer  * ASAP.</li>  *<li>We could benefit from netty's ByteBuf management mechanism.</li>  *</ol>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|FanOutOneBlockAsyncDFSOutput
implements|implements
name|AsyncFSOutput
block|{
comment|// The MAX_PACKET_SIZE is 16MB but it include the header size and checksum size. So here we set a
comment|// smaller limit for data size.
specifier|private
specifier|static
specifier|final
name|int
name|MAX_DATA_LEN
init|=
literal|12
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|FSUtils
name|fsUtils
decl_stmt|;
specifier|private
specifier|final
name|DistributedFileSystem
name|dfs
decl_stmt|;
specifier|private
specifier|final
name|DFSClient
name|client
decl_stmt|;
specifier|private
specifier|final
name|ClientProtocol
name|namenode
decl_stmt|;
specifier|private
specifier|final
name|String
name|clientName
decl_stmt|;
specifier|private
specifier|final
name|String
name|src
decl_stmt|;
specifier|private
specifier|final
name|long
name|fileId
decl_stmt|;
specifier|private
specifier|final
name|ExtendedBlock
name|block
decl_stmt|;
specifier|private
specifier|final
name|DatanodeInfo
index|[]
name|locations
decl_stmt|;
specifier|private
specifier|final
name|Encryptor
name|encryptor
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Channel
argument_list|>
name|datanodeList
decl_stmt|;
specifier|private
specifier|final
name|DataChecksum
name|summer
decl_stmt|;
specifier|private
specifier|final
name|int
name|maxDataLen
decl_stmt|;
specifier|private
specifier|final
name|ByteBufAllocator
name|alloc
decl_stmt|;
specifier|private
specifier|static
specifier|final
class|class
name|Callback
block|{
specifier|private
specifier|final
name|CompletableFuture
argument_list|<
name|Long
argument_list|>
name|future
decl_stmt|;
specifier|private
specifier|final
name|long
name|ackedLength
decl_stmt|;
comment|// should be backed by a thread safe collection
specifier|private
specifier|final
name|Set
argument_list|<
name|ChannelId
argument_list|>
name|unfinishedReplicas
decl_stmt|;
specifier|public
name|Callback
parameter_list|(
name|CompletableFuture
argument_list|<
name|Long
argument_list|>
name|future
parameter_list|,
name|long
name|ackedLength
parameter_list|,
name|Collection
argument_list|<
name|Channel
argument_list|>
name|replicas
parameter_list|)
block|{
name|this
operator|.
name|future
operator|=
name|future
expr_stmt|;
name|this
operator|.
name|ackedLength
operator|=
name|ackedLength
expr_stmt|;
if|if
condition|(
name|replicas
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|unfinishedReplicas
operator|=
name|Collections
operator|.
name|emptySet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|unfinishedReplicas
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|ChannelId
argument_list|,
name|Boolean
argument_list|>
argument_list|(
name|replicas
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|replicas
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|c
lambda|->
name|c
operator|.
name|id
argument_list|()
argument_list|)
operator|.
name|forEachOrdered
argument_list|(
name|unfinishedReplicas
operator|::
name|add
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|final
name|ConcurrentLinkedDeque
argument_list|<
name|Callback
argument_list|>
name|waitingAckQueue
init|=
operator|new
name|ConcurrentLinkedDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|volatile
name|long
name|ackedBlockLength
init|=
literal|0L
decl_stmt|;
comment|// this could be different from acked block length because a packet can not start at the middle of
comment|// a chunk.
specifier|private
name|long
name|nextPacketOffsetInBlock
init|=
literal|0L
decl_stmt|;
comment|// the length of the trailing partial chunk, this is because the packet start offset must be
comment|// aligned with the length of checksum chunk so we need to resend the same data.
specifier|private
name|int
name|trailingPartialChunkLength
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|nextPacketSeqno
init|=
literal|0L
decl_stmt|;
specifier|private
name|ByteBuf
name|buf
decl_stmt|;
specifier|private
specifier|final
name|SendBufSizePredictor
name|sendBufSizePRedictor
init|=
operator|new
name|SendBufSizePredictor
argument_list|()
decl_stmt|;
comment|// State for connections to DN
specifier|private
enum|enum
name|State
block|{
name|STREAMING
block|,
name|CLOSING
block|,
name|BROKEN
block|,
name|CLOSED
block|}
specifier|private
specifier|volatile
name|State
name|state
decl_stmt|;
comment|// all lock-free to make it run faster
specifier|private
name|void
name|completed
parameter_list|(
name|Channel
name|channel
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Callback
argument_list|>
name|iter
init|=
name|waitingAckQueue
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Callback
name|c
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// if the current unfinished replicas does not contain us then it means that we have already
comment|// acked this one, let's iterate to find the one we have not acked yet.
if|if
condition|(
name|c
operator|.
name|unfinishedReplicas
operator|.
name|remove
argument_list|(
name|channel
operator|.
name|id
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|.
name|unfinishedReplicas
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// we need to remove first before complete the future. It is possible that after we
comment|// complete the future the upper layer will call close immediately before we remove the
comment|// entry from waitingAckQueue and lead to an IllegalStateException. And also set the
comment|// ackedBlockLength first otherwise we may use a wrong length to commit the block. This
comment|// may lead to multiple remove and assign but is OK. The semantic of iter.remove is
comment|// removing the entry returned by calling previous next, so if the entry has already been
comment|// removed then it is a no-op, and for the assign, the values are the same so no problem.
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|ackedBlockLength
operator|=
name|c
operator|.
name|ackedLength
expr_stmt|;
comment|// the future.complete check is to confirm that we are the only one who grabbed the work,
comment|// otherwise just give up and return.
if|if
condition|(
name|c
operator|.
name|future
operator|.
name|complete
argument_list|(
name|c
operator|.
name|ackedLength
argument_list|)
condition|)
block|{
comment|// also wake up flush requests which have the same length.
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Callback
name|maybeDummyCb
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|maybeDummyCb
operator|.
name|ackedLength
operator|==
name|c
operator|.
name|ackedLength
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|maybeDummyCb
operator|.
name|future
operator|.
name|complete
argument_list|(
name|c
operator|.
name|ackedLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
block|}
return|return;
block|}
block|}
block|}
comment|// this usually does not happen which means it is not on the critical path so make it synchronized
comment|// so that the implementation will not burn up our brain as there are multiple state changes and
comment|// checks.
specifier|private
specifier|synchronized
name|void
name|failed
parameter_list|(
name|Channel
name|channel
parameter_list|,
name|Supplier
argument_list|<
name|Throwable
argument_list|>
name|errorSupplier
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|BROKEN
operator|||
name|state
operator|==
name|State
operator|.
name|CLOSED
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|CLOSING
condition|)
block|{
name|Callback
name|c
init|=
name|waitingAckQueue
operator|.
name|peekFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
operator|||
operator|!
name|c
operator|.
name|unfinishedReplicas
operator|.
name|contains
argument_list|(
name|channel
operator|.
name|id
argument_list|()
argument_list|)
condition|)
block|{
comment|// nothing, the endBlock request has already finished.
return|return;
block|}
block|}
comment|// disable further write, and fail all pending ack.
name|state
operator|=
name|State
operator|.
name|BROKEN
expr_stmt|;
name|Throwable
name|error
init|=
name|errorSupplier
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Callback
argument_list|>
name|iter
init|=
name|waitingAckQueue
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Callback
name|c
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// find the first sync request which we have not acked yet and fail all the request after it.
if|if
condition|(
operator|!
name|c
operator|.
name|unfinishedReplicas
operator|.
name|contains
argument_list|(
name|channel
operator|.
name|id
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|.
name|future
operator|.
name|completeExceptionally
argument_list|(
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
break|break;
block|}
name|c
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
name|datanodeList
operator|.
name|forEach
argument_list|(
name|ch
lambda|->
name|ch
operator|.
name|close
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Sharable
specifier|private
specifier|final
class|class
name|AckHandler
extends|extends
name|SimpleChannelInboundHandler
argument_list|<
name|PipelineAckProto
argument_list|>
block|{
specifier|private
specifier|final
name|int
name|timeoutMs
decl_stmt|;
specifier|public
name|AckHandler
parameter_list|(
name|int
name|timeoutMs
parameter_list|)
block|{
name|this
operator|.
name|timeoutMs
operator|=
name|timeoutMs
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|channelRead0
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|PipelineAckProto
name|ack
parameter_list|)
throws|throws
name|Exception
block|{
name|Status
name|reply
init|=
name|getStatus
argument_list|(
name|ack
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
operator|!=
name|Status
operator|.
name|SUCCESS
condition|)
block|{
name|failed
argument_list|(
name|ctx
operator|.
name|channel
argument_list|()
argument_list|,
parameter_list|()
lambda|->
operator|new
name|IOException
argument_list|(
literal|"Bad response "
operator|+
name|reply
operator|+
literal|" for block "
operator|+
name|block
operator|+
literal|" from datanode "
operator|+
name|ctx
operator|.
name|channel
argument_list|()
operator|.
name|remoteAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|PipelineAck
operator|.
name|isRestartOOBStatus
argument_list|(
name|reply
argument_list|)
condition|)
block|{
name|failed
argument_list|(
name|ctx
operator|.
name|channel
argument_list|()
argument_list|,
parameter_list|()
lambda|->
operator|new
name|IOException
argument_list|(
literal|"Restart response "
operator|+
name|reply
operator|+
literal|" for block "
operator|+
name|block
operator|+
literal|" from datanode "
operator|+
name|ctx
operator|.
name|channel
argument_list|()
operator|.
name|remoteAddress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ack
operator|.
name|getSeqno
argument_list|()
operator|==
name|HEART_BEAT_SEQNO
condition|)
block|{
return|return;
block|}
name|completed
argument_list|(
name|ctx
operator|.
name|channel
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|channelInactive
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|CLOSED
condition|)
block|{
return|return;
block|}
name|failed
argument_list|(
name|ctx
operator|.
name|channel
argument_list|()
argument_list|,
parameter_list|()
lambda|->
operator|new
name|IOException
argument_list|(
literal|"Connection to "
operator|+
name|ctx
operator|.
name|channel
argument_list|()
operator|.
name|remoteAddress
argument_list|()
operator|+
literal|" closed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|exceptionCaught
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|Throwable
name|cause
parameter_list|)
throws|throws
name|Exception
block|{
name|failed
argument_list|(
name|ctx
operator|.
name|channel
argument_list|()
argument_list|,
parameter_list|()
lambda|->
name|cause
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|userEventTriggered
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|Object
name|evt
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|evt
operator|instanceof
name|IdleStateEvent
condition|)
block|{
name|IdleStateEvent
name|e
init|=
operator|(
name|IdleStateEvent
operator|)
name|evt
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|state
argument_list|()
operator|==
name|READER_IDLE
condition|)
block|{
name|failed
argument_list|(
name|ctx
operator|.
name|channel
argument_list|()
argument_list|,
parameter_list|()
lambda|->
operator|new
name|IOException
argument_list|(
literal|"Timeout("
operator|+
name|timeoutMs
operator|+
literal|"ms) waiting for response"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|state
argument_list|()
operator|==
name|WRITER_IDLE
condition|)
block|{
name|PacketHeader
name|heartbeat
init|=
operator|new
name|PacketHeader
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
name|HEART_BEAT_SEQNO
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|heartbeat
operator|.
name|getSerializedSize
argument_list|()
decl_stmt|;
name|ByteBuf
name|buf
init|=
name|alloc
operator|.
name|buffer
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|heartbeat
operator|.
name|putInBuffer
argument_list|(
name|buf
operator|.
name|nioBuffer
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|writerIndex
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|channel
argument_list|()
operator|.
name|writeAndFlush
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|super
operator|.
name|userEventTriggered
argument_list|(
name|ctx
argument_list|,
name|evt
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setupReceiver
parameter_list|(
name|int
name|timeoutMs
parameter_list|)
block|{
name|AckHandler
name|ackHandler
init|=
operator|new
name|AckHandler
argument_list|(
name|timeoutMs
argument_list|)
decl_stmt|;
for|for
control|(
name|Channel
name|ch
range|:
name|datanodeList
control|)
block|{
name|ch
operator|.
name|pipeline
argument_list|()
operator|.
name|addLast
argument_list|(
operator|new
name|IdleStateHandler
argument_list|(
name|timeoutMs
argument_list|,
name|timeoutMs
operator|/
literal|2
argument_list|,
literal|0
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|,
operator|new
name|ProtobufVarint32FrameDecoder
argument_list|()
argument_list|,
operator|new
name|ProtobufDecoder
argument_list|(
name|PipelineAckProto
operator|.
name|getDefaultInstance
argument_list|()
argument_list|)
argument_list|,
name|ackHandler
argument_list|)
expr_stmt|;
name|ch
operator|.
name|config
argument_list|()
operator|.
name|setAutoRead
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|FanOutOneBlockAsyncDFSOutput
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSUtils
name|fsUtils
parameter_list|,
name|DistributedFileSystem
name|dfs
parameter_list|,
name|DFSClient
name|client
parameter_list|,
name|ClientProtocol
name|namenode
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|LocatedBlock
name|locatedBlock
parameter_list|,
name|Encryptor
name|encryptor
parameter_list|,
name|List
argument_list|<
name|Channel
argument_list|>
name|datanodeList
parameter_list|,
name|DataChecksum
name|summer
parameter_list|,
name|ByteBufAllocator
name|alloc
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|fsUtils
operator|=
name|fsUtils
expr_stmt|;
name|this
operator|.
name|dfs
operator|=
name|dfs
expr_stmt|;
name|this
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|this
operator|.
name|namenode
operator|=
name|namenode
expr_stmt|;
name|this
operator|.
name|fileId
operator|=
name|fileId
expr_stmt|;
name|this
operator|.
name|clientName
operator|=
name|clientName
expr_stmt|;
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|block
operator|=
name|locatedBlock
operator|.
name|getBlock
argument_list|()
expr_stmt|;
name|this
operator|.
name|locations
operator|=
name|locatedBlock
operator|.
name|getLocations
argument_list|()
expr_stmt|;
name|this
operator|.
name|encryptor
operator|=
name|encryptor
expr_stmt|;
name|this
operator|.
name|datanodeList
operator|=
name|datanodeList
expr_stmt|;
name|this
operator|.
name|summer
operator|=
name|summer
expr_stmt|;
name|this
operator|.
name|maxDataLen
operator|=
name|MAX_DATA_LEN
operator|-
operator|(
name|MAX_DATA_LEN
operator|%
name|summer
operator|.
name|getBytesPerChecksum
argument_list|()
operator|)
expr_stmt|;
name|this
operator|.
name|alloc
operator|=
name|alloc
expr_stmt|;
name|this
operator|.
name|buf
operator|=
name|alloc
operator|.
name|directBuffer
argument_list|(
name|sendBufSizePRedictor
operator|.
name|initialSize
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|State
operator|.
name|STREAMING
expr_stmt|;
name|setupReceiver
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_CLIENT_SOCKET_TIMEOUT_KEY
argument_list|,
name|READ_TIMEOUT
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeInt
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|buf
operator|.
name|ensureWritable
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|.
name|writeInt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|ByteBuffer
name|bb
parameter_list|)
block|{
name|buf
operator|.
name|ensureWritable
argument_list|(
name|bb
operator|.
name|remaining
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|writeBytes
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
block|{
name|write
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|buf
operator|.
name|ensureWritable
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|buf
operator|.
name|writeBytes
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|buffered
parameter_list|()
block|{
return|return
name|buf
operator|.
name|readableBytes
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|DatanodeInfo
index|[]
name|getPipeline
parameter_list|()
block|{
return|return
name|locations
return|;
block|}
specifier|private
name|void
name|flushBuffer
parameter_list|(
name|CompletableFuture
argument_list|<
name|Long
argument_list|>
name|future
parameter_list|,
name|ByteBuf
name|dataBuf
parameter_list|,
name|long
name|nextPacketOffsetInBlock
parameter_list|,
name|boolean
name|syncBlock
parameter_list|)
block|{
name|int
name|dataLen
init|=
name|dataBuf
operator|.
name|readableBytes
argument_list|()
decl_stmt|;
name|int
name|chunkLen
init|=
name|summer
operator|.
name|getBytesPerChecksum
argument_list|()
decl_stmt|;
name|int
name|trailingPartialChunkLen
init|=
name|dataLen
operator|%
name|chunkLen
decl_stmt|;
name|int
name|numChecks
init|=
name|dataLen
operator|/
name|chunkLen
operator|+
operator|(
name|trailingPartialChunkLen
operator|!=
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|checksumLen
init|=
name|numChecks
operator|*
name|summer
operator|.
name|getChecksumSize
argument_list|()
decl_stmt|;
name|ByteBuf
name|checksumBuf
init|=
name|alloc
operator|.
name|directBuffer
argument_list|(
name|checksumLen
argument_list|)
decl_stmt|;
name|summer
operator|.
name|calculateChunkedSums
argument_list|(
name|dataBuf
operator|.
name|nioBuffer
argument_list|()
argument_list|,
name|checksumBuf
operator|.
name|nioBuffer
argument_list|(
literal|0
argument_list|,
name|checksumLen
argument_list|)
argument_list|)
expr_stmt|;
name|checksumBuf
operator|.
name|writerIndex
argument_list|(
name|checksumLen
argument_list|)
expr_stmt|;
name|PacketHeader
name|header
init|=
operator|new
name|PacketHeader
argument_list|(
literal|4
operator|+
name|checksumLen
operator|+
name|dataLen
argument_list|,
name|nextPacketOffsetInBlock
argument_list|,
name|nextPacketSeqno
argument_list|,
literal|false
argument_list|,
name|dataLen
argument_list|,
name|syncBlock
argument_list|)
decl_stmt|;
name|int
name|headerLen
init|=
name|header
operator|.
name|getSerializedSize
argument_list|()
decl_stmt|;
name|ByteBuf
name|headerBuf
init|=
name|alloc
operator|.
name|buffer
argument_list|(
name|headerLen
argument_list|)
decl_stmt|;
name|header
operator|.
name|putInBuffer
argument_list|(
name|headerBuf
operator|.
name|nioBuffer
argument_list|(
literal|0
argument_list|,
name|headerLen
argument_list|)
argument_list|)
expr_stmt|;
name|headerBuf
operator|.
name|writerIndex
argument_list|(
name|headerLen
argument_list|)
expr_stmt|;
name|Callback
name|c
init|=
operator|new
name|Callback
argument_list|(
name|future
argument_list|,
name|nextPacketOffsetInBlock
operator|+
name|dataLen
argument_list|,
name|datanodeList
argument_list|)
decl_stmt|;
name|waitingAckQueue
operator|.
name|addLast
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// recheck again after we pushed the callback to queue
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|STREAMING
operator|&&
name|waitingAckQueue
operator|.
name|peekFirst
argument_list|()
operator|==
name|c
condition|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"stream already broken"
argument_list|)
argument_list|)
expr_stmt|;
comment|// it's the one we have just pushed or just a no-op
name|waitingAckQueue
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// TODO: we should perhaps measure time taken per DN here;
comment|//       we could collect statistics per DN, and/or exclude bad nodes in createOutput.
name|datanodeList
operator|.
name|forEach
argument_list|(
name|ch
lambda|->
block|{
name|ch
operator|.
name|write
argument_list|(
name|headerBuf
operator|.
name|retainedDuplicate
argument_list|()
argument_list|)
expr_stmt|;
name|ch
operator|.
name|write
argument_list|(
name|checksumBuf
operator|.
name|retainedDuplicate
argument_list|()
argument_list|)
expr_stmt|;
name|ch
operator|.
name|writeAndFlush
argument_list|(
name|dataBuf
operator|.
name|retainedDuplicate
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|checksumBuf
operator|.
name|release
argument_list|()
expr_stmt|;
name|headerBuf
operator|.
name|release
argument_list|()
expr_stmt|;
name|dataBuf
operator|.
name|release
argument_list|()
expr_stmt|;
name|nextPacketSeqno
operator|++
expr_stmt|;
block|}
specifier|private
name|void
name|flush0
parameter_list|(
name|CompletableFuture
argument_list|<
name|Long
argument_list|>
name|future
parameter_list|,
name|boolean
name|syncBlock
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|STREAMING
condition|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"stream already broken"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|dataLen
init|=
name|buf
operator|.
name|readableBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataLen
operator|==
name|trailingPartialChunkLength
condition|)
block|{
comment|// no new data
name|long
name|lengthAfterFlush
init|=
name|nextPacketOffsetInBlock
operator|+
name|dataLen
decl_stmt|;
name|Callback
name|lastFlush
init|=
name|waitingAckQueue
operator|.
name|peekLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastFlush
operator|!=
literal|null
condition|)
block|{
name|Callback
name|c
init|=
operator|new
name|Callback
argument_list|(
name|future
argument_list|,
name|lengthAfterFlush
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
decl_stmt|;
name|waitingAckQueue
operator|.
name|addLast
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// recheck here if we have already removed the previous callback from the queue
if|if
condition|(
name|waitingAckQueue
operator|.
name|peekFirst
argument_list|()
operator|==
name|c
condition|)
block|{
comment|// all previous callbacks have been removed
comment|// notice that this does mean we will always win here because the background thread may
comment|// have already started to mark the future here as completed in the completed or failed
comment|// methods but haven't removed it from the queue yet. That's also why the removeFirst
comment|// call below may be a no-op.
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|STREAMING
condition|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"stream already broken"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|future
operator|.
name|complete
argument_list|(
name|lengthAfterFlush
argument_list|)
expr_stmt|;
block|}
comment|// it's the one we have just pushed or just a no-op
name|waitingAckQueue
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// we must have acked all the data so the ackedBlockLength must be same with
comment|// lengthAfterFlush
name|future
operator|.
name|complete
argument_list|(
name|lengthAfterFlush
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|encryptor
operator|!=
literal|null
condition|)
block|{
name|ByteBuf
name|encryptBuf
init|=
name|alloc
operator|.
name|directBuffer
argument_list|(
name|dataLen
argument_list|)
decl_stmt|;
name|buf
operator|.
name|readBytes
argument_list|(
name|encryptBuf
argument_list|,
name|trailingPartialChunkLength
argument_list|)
expr_stmt|;
name|int
name|toEncryptLength
init|=
name|dataLen
operator|-
name|trailingPartialChunkLength
decl_stmt|;
try|try
block|{
name|encryptor
operator|.
name|encrypt
argument_list|(
name|buf
operator|.
name|nioBuffer
argument_list|(
name|trailingPartialChunkLength
argument_list|,
name|toEncryptLength
argument_list|)
argument_list|,
name|encryptBuf
operator|.
name|nioBuffer
argument_list|(
name|trailingPartialChunkLength
argument_list|,
name|toEncryptLength
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|encryptBuf
operator|.
name|release
argument_list|()
expr_stmt|;
name|future
operator|.
name|completeExceptionally
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|encryptBuf
operator|.
name|writerIndex
argument_list|(
name|dataLen
argument_list|)
expr_stmt|;
name|buf
operator|.
name|release
argument_list|()
expr_stmt|;
name|buf
operator|=
name|encryptBuf
expr_stmt|;
block|}
if|if
condition|(
name|dataLen
operator|>
name|maxDataLen
condition|)
block|{
comment|// We need to write out the data by multiple packets as the max packet allowed is 16M.
name|long
name|nextSubPacketOffsetInBlock
init|=
name|nextPacketOffsetInBlock
decl_stmt|;
for|for
control|(
name|int
name|remaining
init|=
name|dataLen
init|;
condition|;
control|)
block|{
if|if
condition|(
name|remaining
operator|<
name|maxDataLen
condition|)
block|{
name|flushBuffer
argument_list|(
name|future
argument_list|,
name|buf
operator|.
name|readRetainedSlice
argument_list|(
name|remaining
argument_list|)
argument_list|,
name|nextSubPacketOffsetInBlock
argument_list|,
name|syncBlock
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|flushBuffer
argument_list|(
operator|new
name|CompletableFuture
argument_list|<>
argument_list|()
argument_list|,
name|buf
operator|.
name|readRetainedSlice
argument_list|(
name|maxDataLen
argument_list|)
argument_list|,
name|nextSubPacketOffsetInBlock
argument_list|,
name|syncBlock
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|maxDataLen
expr_stmt|;
name|nextSubPacketOffsetInBlock
operator|+=
name|maxDataLen
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|flushBuffer
argument_list|(
name|future
argument_list|,
name|buf
operator|.
name|retain
argument_list|()
argument_list|,
name|nextPacketOffsetInBlock
argument_list|,
name|syncBlock
argument_list|)
expr_stmt|;
block|}
name|trailingPartialChunkLength
operator|=
name|dataLen
operator|%
name|summer
operator|.
name|getBytesPerChecksum
argument_list|()
expr_stmt|;
name|ByteBuf
name|newBuf
init|=
name|alloc
operator|.
name|directBuffer
argument_list|(
name|sendBufSizePRedictor
operator|.
name|guess
argument_list|(
name|dataLen
argument_list|)
argument_list|)
operator|.
name|ensureWritable
argument_list|(
name|trailingPartialChunkLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailingPartialChunkLength
operator|!=
literal|0
condition|)
block|{
name|buf
operator|.
name|readerIndex
argument_list|(
name|dataLen
operator|-
name|trailingPartialChunkLength
argument_list|)
operator|.
name|readBytes
argument_list|(
name|newBuf
argument_list|,
name|trailingPartialChunkLength
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|release
argument_list|()
expr_stmt|;
name|this
operator|.
name|buf
operator|=
name|newBuf
expr_stmt|;
name|nextPacketOffsetInBlock
operator|+=
name|dataLen
operator|-
name|trailingPartialChunkLength
expr_stmt|;
block|}
comment|/**    * Flush the buffer out to datanodes.    * @param syncBlock will call hsync if true, otherwise hflush.    * @return A CompletableFuture that hold the acked length after flushing.    */
annotation|@
name|Override
specifier|public
name|CompletableFuture
argument_list|<
name|Long
argument_list|>
name|flush
parameter_list|(
name|boolean
name|syncBlock
parameter_list|)
block|{
name|CompletableFuture
argument_list|<
name|Long
argument_list|>
name|future
init|=
operator|new
name|CompletableFuture
argument_list|<>
argument_list|()
decl_stmt|;
name|flush0
argument_list|(
name|future
argument_list|,
name|syncBlock
argument_list|)
expr_stmt|;
return|return
name|future
return|;
block|}
specifier|private
name|void
name|endBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|waitingAckQueue
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"should call flush first before calling close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|STREAMING
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"stream already broken"
argument_list|)
throw|;
block|}
name|state
operator|=
name|State
operator|.
name|CLOSING
expr_stmt|;
name|long
name|finalizedLength
init|=
name|ackedBlockLength
decl_stmt|;
name|PacketHeader
name|header
init|=
operator|new
name|PacketHeader
argument_list|(
literal|4
argument_list|,
name|finalizedLength
argument_list|,
name|nextPacketSeqno
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|buf
operator|.
name|release
argument_list|()
expr_stmt|;
name|buf
operator|=
literal|null
expr_stmt|;
name|int
name|headerLen
init|=
name|header
operator|.
name|getSerializedSize
argument_list|()
decl_stmt|;
name|ByteBuf
name|headerBuf
init|=
name|alloc
operator|.
name|directBuffer
argument_list|(
name|headerLen
argument_list|)
decl_stmt|;
name|header
operator|.
name|putInBuffer
argument_list|(
name|headerBuf
operator|.
name|nioBuffer
argument_list|(
literal|0
argument_list|,
name|headerLen
argument_list|)
argument_list|)
expr_stmt|;
name|headerBuf
operator|.
name|writerIndex
argument_list|(
name|headerLen
argument_list|)
expr_stmt|;
name|CompletableFuture
argument_list|<
name|Long
argument_list|>
name|future
init|=
operator|new
name|CompletableFuture
argument_list|<>
argument_list|()
decl_stmt|;
name|waitingAckQueue
operator|.
name|add
argument_list|(
operator|new
name|Callback
argument_list|(
name|future
argument_list|,
name|finalizedLength
argument_list|,
name|datanodeList
argument_list|)
argument_list|)
expr_stmt|;
name|datanodeList
operator|.
name|forEach
argument_list|(
name|ch
lambda|->
name|ch
operator|.
name|writeAndFlush
argument_list|(
name|headerBuf
operator|.
name|retainedDuplicate
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|headerBuf
operator|.
name|release
argument_list|()
expr_stmt|;
try|try
block|{
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|InterruptedIOException
argument_list|()
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|e
operator|.
name|getCause
argument_list|()
decl_stmt|;
name|Throwables
operator|.
name|propagateIfPossible
argument_list|(
name|cause
argument_list|,
name|IOException
operator|.
name|class
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|cause
argument_list|)
throw|;
block|}
block|}
comment|/**    * The close method when error occurred. Now we just call recoverFileLease.    */
annotation|@
name|Override
specifier|public
name|void
name|recoverAndClose
parameter_list|(
name|CancelableProgressable
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|buf
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|release
argument_list|()
expr_stmt|;
name|buf
operator|=
literal|null
expr_stmt|;
block|}
name|datanodeList
operator|.
name|forEach
argument_list|(
name|ch
lambda|->
name|ch
operator|.
name|close
argument_list|()
argument_list|)
expr_stmt|;
name|datanodeList
operator|.
name|forEach
argument_list|(
name|ch
lambda|->
name|ch
operator|.
name|closeFuture
argument_list|()
operator|.
name|awaitUninterruptibly
argument_list|()
argument_list|)
expr_stmt|;
name|endFileLease
argument_list|(
name|client
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
name|fsUtils
operator|.
name|recoverFileLease
argument_list|(
name|dfs
argument_list|,
operator|new
name|Path
argument_list|(
name|src
argument_list|)
argument_list|,
name|conf
argument_list|,
name|reporter
operator|==
literal|null
condition|?
operator|new
name|CancelOnClose
argument_list|(
name|client
argument_list|)
else|:
name|reporter
argument_list|)
expr_stmt|;
block|}
comment|/**    * End the current block and complete file at namenode. You should call    * {@link #recoverAndClose(CancelableProgressable)} if this method throws an exception.    */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|endBlock
argument_list|()
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|CLOSED
expr_stmt|;
name|datanodeList
operator|.
name|forEach
argument_list|(
name|ch
lambda|->
name|ch
operator|.
name|close
argument_list|()
argument_list|)
expr_stmt|;
name|datanodeList
operator|.
name|forEach
argument_list|(
name|ch
lambda|->
name|ch
operator|.
name|closeFuture
argument_list|()
operator|.
name|awaitUninterruptibly
argument_list|()
argument_list|)
expr_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|ackedBlockLength
argument_list|)
expr_stmt|;
name|completeFile
argument_list|(
name|client
argument_list|,
name|namenode
argument_list|,
name|src
argument_list|,
name|clientName
argument_list|,
name|block
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isBroken
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|BROKEN
return|;
block|}
block|}
end_class

end_unit

