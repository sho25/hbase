begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ByteBufferReadable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|ByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
class|class
name|BlockIOUtils
block|{
specifier|static
name|boolean
name|isByteBufferReadable
parameter_list|(
name|FSDataInputStream
name|is
parameter_list|)
block|{
name|InputStream
name|cur
init|=
name|is
operator|.
name|getWrappedStream
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|cur
operator|instanceof
name|FSDataInputStream
operator|)
condition|)
block|{
name|cur
operator|=
operator|(
operator|(
name|FSDataInputStream
operator|)
name|cur
operator|)
operator|.
name|getWrappedStream
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|cur
operator|instanceof
name|ByteBufferReadable
return|;
block|}
comment|/**    * Read length bytes into ByteBuffers directly.    * @param buf the destination {@link ByteBuff}    * @param dis the HDFS input stream which implement the ByteBufferReadable interface.    * @param length bytes to read.    * @throws IOException exception to throw if any error happen    */
specifier|static
name|void
name|readFully
parameter_list|(
name|ByteBuff
name|buf
parameter_list|,
name|FSDataInputStream
name|dis
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isByteBufferReadable
argument_list|(
name|dis
argument_list|)
condition|)
block|{
comment|// If InputStream does not support the ByteBuffer read, just read to heap and copy bytes to
comment|// the destination ByteBuff.
name|byte
index|[]
name|heapBuf
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|IOUtils
operator|.
name|readFully
argument_list|(
name|dis
argument_list|,
name|heapBuf
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|copyToByteBuff
argument_list|(
name|heapBuf
argument_list|,
literal|0
argument_list|,
name|length
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|ByteBuffer
index|[]
name|buffers
init|=
name|buf
operator|.
name|nioByteBuffers
argument_list|()
decl_stmt|;
name|int
name|remain
init|=
name|length
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|ByteBuffer
name|cur
init|=
name|buffers
index|[
name|idx
index|]
decl_stmt|;
while|while
condition|(
name|remain
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|!
name|cur
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
if|if
condition|(
operator|++
name|idx
operator|>=
name|buffers
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not enough ByteBuffers to read the reminding "
operator|+
name|remain
operator|+
literal|" "
operator|+
literal|"bytes"
argument_list|)
throw|;
block|}
name|cur
operator|=
name|buffers
index|[
name|idx
index|]
expr_stmt|;
block|}
name|cur
operator|.
name|limit
argument_list|(
name|cur
operator|.
name|position
argument_list|()
operator|+
name|Math
operator|.
name|min
argument_list|(
name|remain
argument_list|,
name|cur
operator|.
name|remaining
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|bytesRead
init|=
name|dis
operator|.
name|read
argument_list|(
name|cur
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesRead
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Premature EOF from inputStream, but still need "
operator|+
name|remain
operator|+
literal|" "
operator|+
literal|"bytes"
argument_list|)
throw|;
block|}
name|remain
operator|-=
name|bytesRead
expr_stmt|;
block|}
block|}
comment|/**    * Read from an input stream at least<code>necessaryLen</code> and if possible,    *<code>extraLen</code> also if available. Analogous to    * {@link IOUtils#readFully(InputStream, byte[], int, int)}, but specifies a number of "extra"    * bytes to also optionally read.    * @param in the input stream to read from    * @param buf the buffer to read into    * @param bufOffset the destination offset in the buffer    * @param necessaryLen the number of bytes that are absolutely necessary to read    * @param extraLen the number of extra bytes that would be nice to read    * @return true if succeeded reading the extra bytes    * @throws IOException if failed to read the necessary bytes    */
specifier|private
specifier|static
name|boolean
name|readWithExtraOnHeap
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|bufOffset
parameter_list|,
name|int
name|necessaryLen
parameter_list|,
name|int
name|extraLen
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|bytesRemaining
init|=
name|necessaryLen
operator|+
name|extraLen
decl_stmt|;
while|while
condition|(
name|bytesRemaining
operator|>
literal|0
condition|)
block|{
name|int
name|ret
init|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|bufOffset
argument_list|,
name|bytesRemaining
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bytesRemaining
operator|<=
name|extraLen
condition|)
block|{
comment|// We could not read the "extra data", but that is OK.
break|break;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Premature EOF from inputStream (read "
operator|+
literal|"returned "
operator|+
name|ret
operator|+
literal|", was trying to read "
operator|+
name|necessaryLen
operator|+
literal|" necessary bytes and "
operator|+
name|extraLen
operator|+
literal|" extra bytes, "
operator|+
literal|"successfully read "
operator|+
operator|(
name|necessaryLen
operator|+
name|extraLen
operator|-
name|bytesRemaining
operator|)
argument_list|)
throw|;
block|}
name|bufOffset
operator|+=
name|ret
expr_stmt|;
name|bytesRemaining
operator|-=
name|ret
expr_stmt|;
block|}
return|return
name|bytesRemaining
operator|<=
literal|0
return|;
block|}
comment|/**    * Read bytes into ByteBuffers directly, those buffers either contains the extraLen bytes or only    * contains necessaryLen bytes, which depends on how much bytes do the last time we read.    * @param buf the destination {@link ByteBuff}.    * @param dis input stream to read.    * @param necessaryLen bytes which we must read    * @param extraLen bytes which we may read    * @return if the returned flag is true, then we've finished to read the extraLen into our    *         ByteBuffers, otherwise we've not read the extraLen bytes yet.    * @throws IOException if failed to read the necessary bytes.    */
specifier|static
name|boolean
name|readWithExtra
parameter_list|(
name|ByteBuff
name|buf
parameter_list|,
name|FSDataInputStream
name|dis
parameter_list|,
name|int
name|necessaryLen
parameter_list|,
name|int
name|extraLen
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isByteBufferReadable
argument_list|(
name|dis
argument_list|)
condition|)
block|{
comment|// If InputStream does not support the ByteBuffer read, just read to heap and copy bytes to
comment|// the destination ByteBuff.
name|byte
index|[]
name|heapBuf
init|=
operator|new
name|byte
index|[
name|necessaryLen
operator|+
name|extraLen
index|]
decl_stmt|;
name|boolean
name|ret
init|=
name|readWithExtraOnHeap
argument_list|(
name|dis
argument_list|,
name|heapBuf
argument_list|,
literal|0
argument_list|,
name|necessaryLen
argument_list|,
name|extraLen
argument_list|)
decl_stmt|;
name|copyToByteBuff
argument_list|(
name|heapBuf
argument_list|,
literal|0
argument_list|,
name|heapBuf
operator|.
name|length
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ByteBuffer
index|[]
name|buffers
init|=
name|buf
operator|.
name|nioByteBuffers
argument_list|()
decl_stmt|;
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
name|int
name|remain
init|=
name|necessaryLen
operator|+
name|extraLen
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|ByteBuffer
name|cur
init|=
name|buffers
index|[
name|idx
index|]
decl_stmt|;
while|while
condition|(
name|bytesRead
operator|<
name|necessaryLen
condition|)
block|{
while|while
condition|(
operator|!
name|cur
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
if|if
condition|(
operator|++
name|idx
operator|>=
name|buffers
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not enough ByteBuffers to read the reminding "
operator|+
name|remain
operator|+
literal|"bytes"
argument_list|)
throw|;
block|}
name|cur
operator|=
name|buffers
index|[
name|idx
index|]
expr_stmt|;
block|}
name|cur
operator|.
name|limit
argument_list|(
name|cur
operator|.
name|position
argument_list|()
operator|+
name|Math
operator|.
name|min
argument_list|(
name|remain
argument_list|,
name|cur
operator|.
name|remaining
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|dis
operator|.
name|read
argument_list|(
name|cur
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Premature EOF from inputStream (read returned "
operator|+
name|ret
operator|+
literal|", was trying to read "
operator|+
name|necessaryLen
operator|+
literal|" necessary bytes and "
operator|+
name|extraLen
operator|+
literal|" extra bytes, successfully read "
operator|+
name|bytesRead
argument_list|)
throw|;
block|}
name|bytesRead
operator|+=
name|ret
expr_stmt|;
name|remain
operator|-=
name|ret
expr_stmt|;
block|}
return|return
operator|(
name|extraLen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bytesRead
operator|==
name|necessaryLen
operator|+
name|extraLen
operator|)
return|;
block|}
comment|/**    * Read from an input stream at least<code>necessaryLen</code> and if possible,    *<code>extraLen</code> also if available. Analogous to    * {@link IOUtils#readFully(InputStream, byte[], int, int)}, but uses positional read and    * specifies a number of "extra" bytes that would be desirable but not absolutely necessary to    * read.    * @param buff ByteBuff to read into.    * @param dis the input stream to read from    * @param position the position within the stream from which to start reading    * @param necessaryLen the number of bytes that are absolutely necessary to read    * @param extraLen the number of extra bytes that would be nice to read    * @return true if and only if extraLen is> 0 and reading those extra bytes was successful    * @throws IOException if failed to read the necessary bytes    */
specifier|static
name|boolean
name|preadWithExtra
parameter_list|(
name|ByteBuff
name|buff
parameter_list|,
name|FSDataInputStream
name|dis
parameter_list|,
name|long
name|position
parameter_list|,
name|int
name|necessaryLen
parameter_list|,
name|int
name|extraLen
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|remain
init|=
name|necessaryLen
operator|+
name|extraLen
decl_stmt|;
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|remain
index|]
decl_stmt|;
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bytesRead
operator|<
name|necessaryLen
condition|)
block|{
name|int
name|ret
init|=
name|dis
operator|.
name|read
argument_list|(
name|position
operator|+
name|bytesRead
argument_list|,
name|buf
argument_list|,
name|bytesRead
argument_list|,
name|remain
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Premature EOF from inputStream (positional read returned "
operator|+
name|ret
operator|+
literal|", was trying to read "
operator|+
name|necessaryLen
operator|+
literal|" necessary bytes and "
operator|+
name|extraLen
operator|+
literal|" extra bytes, successfully read "
operator|+
name|bytesRead
argument_list|)
throw|;
block|}
name|bytesRead
operator|+=
name|ret
expr_stmt|;
name|remain
operator|-=
name|ret
expr_stmt|;
block|}
comment|// Copy the bytes from on-heap bytes[] to ByteBuffer[] now, and after resolving HDFS-3246, we
comment|// will read the bytes to ByteBuffer[] directly without allocating any on-heap byte[].
comment|// TODO I keep the bytes copy here, because I want to abstract the ByteBuffer[]
comment|// preadWithExtra method for the upper layer, only need to refactor this method if the
comment|// ByteBuffer pread is OK.
name|copyToByteBuff
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|bytesRead
argument_list|,
name|buff
argument_list|)
expr_stmt|;
return|return
operator|(
name|extraLen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bytesRead
operator|==
name|necessaryLen
operator|+
name|extraLen
operator|)
return|;
block|}
specifier|private
specifier|static
name|int
name|copyToByteBuff
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|ByteBuff
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|len
argument_list|<
literal|0
operator|||
name|offset
operator|+
name|len
argument_list|>
name|buf
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid offset="
operator|+
name|offset
operator|+
literal|" and len="
operator|+
name|len
operator|+
literal|", cap="
operator|+
name|buf
operator|.
name|length
argument_list|)
throw|;
block|}
name|ByteBuffer
index|[]
name|buffers
init|=
name|out
operator|.
name|nioByteBuffers
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|,
name|remain
init|=
name|len
decl_stmt|,
name|copyLen
decl_stmt|;
name|ByteBuffer
name|cur
init|=
name|buffers
index|[
name|idx
index|]
decl_stmt|;
while|while
condition|(
name|remain
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|!
name|cur
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
if|if
condition|(
operator|++
name|idx
operator|>=
name|buffers
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not enough ByteBuffers to read the reminding "
operator|+
name|remain
operator|+
literal|"bytes"
argument_list|)
throw|;
block|}
name|cur
operator|=
name|buffers
index|[
name|idx
index|]
expr_stmt|;
block|}
name|copyLen
operator|=
name|Math
operator|.
name|min
argument_list|(
name|cur
operator|.
name|remaining
argument_list|()
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|cur
operator|.
name|put
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|copyLen
argument_list|)
expr_stmt|;
name|remain
operator|-=
name|copyLen
expr_stmt|;
name|offset
operator|+=
name|copyLen
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
block|}
end_class

end_unit

