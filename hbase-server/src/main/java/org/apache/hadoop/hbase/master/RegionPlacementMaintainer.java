begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DecimalFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Scanner
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|AsyncClusterConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|AsyncRegionServerAdmin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ClusterConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodeAssignmentHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|favored
operator|.
name|FavoredNodesPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FutureUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|MunkresAssignment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|Closeables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|GnuParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|HelpFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|RequestConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|UpdateFavoredNodesRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|UpdateFavoredNodesResponse
import|;
end_import

begin_comment
comment|/**  * A tool that is used for manipulating and viewing favored nodes information  * for regions. Run with -h to get a list of the options  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
comment|// TODO: Remove? Unused. Partially implemented only.
specifier|public
class|class
name|RegionPlacementMaintainer
implements|implements
name|Closeable
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RegionPlacementMaintainer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|//The cost of a placement that should never be assigned.
specifier|private
specifier|static
specifier|final
name|float
name|MAX_COST
init|=
name|Float
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
comment|// The cost of a placement that is undesirable but acceptable.
specifier|private
specifier|static
specifier|final
name|float
name|AVOID_COST
init|=
literal|100000f
decl_stmt|;
comment|// The amount by which the cost of a placement is increased if it is the
comment|// last slot of the server. This is done to more evenly distribute the slop
comment|// amongst servers.
specifier|private
specifier|static
specifier|final
name|float
name|LAST_SLOT_COST_PENALTY
init|=
literal|0.5f
decl_stmt|;
comment|// The amount by which the cost of a primary placement is penalized if it is
comment|// not the host currently serving the region. This is done to minimize moves.
specifier|private
specifier|static
specifier|final
name|float
name|NOT_CURRENT_HOST_PENALTY
init|=
literal|0.1f
decl_stmt|;
specifier|private
specifier|static
name|boolean
name|USE_MUNKRES_FOR_PLACING_SECONDARY_AND_TERTIARY
init|=
literal|false
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|enforceLocality
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|enforceMinAssignmentMove
decl_stmt|;
specifier|private
name|RackManager
name|rackManager
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|TableName
argument_list|>
name|targetTableSet
decl_stmt|;
specifier|private
name|AsyncClusterConnection
name|connection
decl_stmt|;
specifier|public
name|RegionPlacementMaintainer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RegionPlacementMaintainer
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|enforceLocality
parameter_list|,
name|boolean
name|enforceMinAssignmentMove
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|enforceLocality
operator|=
name|enforceLocality
expr_stmt|;
name|this
operator|.
name|enforceMinAssignmentMove
operator|=
name|enforceMinAssignmentMove
expr_stmt|;
name|this
operator|.
name|targetTableSet
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|rackManager
operator|=
operator|new
name|RackManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|printHelp
parameter_list|(
name|Options
name|opt
parameter_list|)
block|{
operator|new
name|HelpFormatter
argument_list|()
operator|.
name|printHelp
argument_list|(
literal|"RegionPlacement< -w | -u | -n | -v | -t | -h | -overwrite -r regionName -f favoredNodes "
operator|+
literal|"-diff>"
operator|+
literal|" [-l false] [-m false] [-d] [-tables t1,t2,...tn] [-zk zk1,zk2,zk3]"
operator|+
literal|" [-fs hdfs://a.b.c.d:9000] [-hbase_root /HBASE]"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
specifier|private
name|AsyncClusterConnection
name|getConnection
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
name|connection
operator|=
name|ClusterConnectionFactory
operator|.
name|createAsyncClusterConnection
argument_list|(
name|this
operator|.
name|conf
argument_list|,
literal|null
argument_list|,
name|User
operator|.
name|getCurrent
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|connection
return|;
block|}
specifier|public
name|void
name|setTargetTableName
parameter_list|(
name|String
index|[]
name|tableNames
parameter_list|)
block|{
if|if
condition|(
name|tableNames
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|table
range|:
name|tableNames
control|)
name|this
operator|.
name|targetTableSet
operator|.
name|add
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return the new RegionAssignmentSnapshot    */
specifier|public
name|SnapshotOfRegionAssignmentFromMeta
name|getRegionAssignmentSnapshot
parameter_list|()
throws|throws
name|IOException
block|{
name|SnapshotOfRegionAssignmentFromMeta
name|currentAssignmentShapshot
init|=
operator|new
name|SnapshotOfRegionAssignmentFromMeta
argument_list|(
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|currentAssignmentShapshot
operator|.
name|initialize
argument_list|()
expr_stmt|;
return|return
name|currentAssignmentShapshot
return|;
block|}
comment|/**    * Verify the region placement is consistent with the assignment plan    */
specifier|public
name|List
argument_list|<
name|AssignmentVerificationReport
argument_list|>
name|verifyRegionPlacement
parameter_list|(
name|boolean
name|isDetailMode
parameter_list|)
throws|throws
name|IOException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Start to verify the region assignment and "
operator|+
literal|"generate the verification report"
argument_list|)
expr_stmt|;
comment|// Get the region assignment snapshot
name|SnapshotOfRegionAssignmentFromMeta
name|snapshot
init|=
name|this
operator|.
name|getRegionAssignmentSnapshot
argument_list|()
decl_stmt|;
comment|// Get all the tables
name|Set
argument_list|<
name|TableName
argument_list|>
name|tables
init|=
name|snapshot
operator|.
name|getTableSet
argument_list|()
decl_stmt|;
comment|// Get the region locality map
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|>
name|regionLocalityMap
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|enforceLocality
operator|==
literal|true
condition|)
block|{
name|regionLocalityMap
operator|=
name|FSUtils
operator|.
name|getRegionDegreeLocalityMappingFromFS
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|AssignmentVerificationReport
argument_list|>
name|reports
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Iterate all the tables to fill up the verification report
for|for
control|(
name|TableName
name|table
range|:
name|tables
control|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|targetTableSet
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|this
operator|.
name|targetTableSet
operator|.
name|contains
argument_list|(
name|table
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|AssignmentVerificationReport
name|report
init|=
operator|new
name|AssignmentVerificationReport
argument_list|()
decl_stmt|;
name|report
operator|.
name|fillUp
argument_list|(
name|table
argument_list|,
name|snapshot
argument_list|,
name|regionLocalityMap
argument_list|)
expr_stmt|;
name|report
operator|.
name|print
argument_list|(
name|isDetailMode
argument_list|)
expr_stmt|;
name|reports
operator|.
name|add
argument_list|(
name|report
argument_list|)
expr_stmt|;
block|}
return|return
name|reports
return|;
block|}
comment|/**    * Generate the assignment plan for the existing table    *    * @param tableName    * @param assignmentSnapshot    * @param regionLocalityMap    * @param plan    * @param munkresForSecondaryAndTertiary if set on true the assignment plan    * for the tertiary and secondary will be generated with Munkres algorithm,    * otherwise will be generated using placeSecondaryAndTertiaryRS    * @throws IOException    */
specifier|private
name|void
name|genAssignmentPlan
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|SnapshotOfRegionAssignmentFromMeta
name|assignmentSnapshot
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|>
name|regionLocalityMap
parameter_list|,
name|FavoredNodesPlan
name|plan
parameter_list|,
name|boolean
name|munkresForSecondaryAndTertiary
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Get the all the regions for the current table
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|regions
init|=
name|assignmentSnapshot
operator|.
name|getTableToRegionMap
argument_list|()
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|int
name|numRegions
init|=
name|regions
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Get the current assignment map
name|Map
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
name|currentAssignmentMap
init|=
name|assignmentSnapshot
operator|.
name|getRegionToRegionServerMap
argument_list|()
decl_stmt|;
comment|// Get the all the region servers
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|servers
operator|.
name|addAll
argument_list|(
name|FutureUtils
operator|.
name|get
argument_list|(
name|getConnection
argument_list|()
operator|.
name|getAdmin
argument_list|()
operator|.
name|getRegionServers
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Start to generate assignment plan for "
operator|+
name|numRegions
operator|+
literal|" regions from table "
operator|+
name|tableName
operator|+
literal|" with "
operator|+
name|servers
operator|.
name|size
argument_list|()
operator|+
literal|" region servers"
argument_list|)
expr_stmt|;
name|int
name|slotsPerServer
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|float
operator|)
name|numRegions
operator|/
name|servers
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|regionSlots
init|=
name|slotsPerServer
operator|*
name|servers
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Compute the primary, secondary and tertiary costs for each region/server
comment|// pair. These costs are based only on node locality and rack locality, and
comment|// will be modified later.
name|float
index|[]
index|[]
name|primaryCost
init|=
operator|new
name|float
index|[
name|numRegions
index|]
index|[
name|regionSlots
index|]
decl_stmt|;
name|float
index|[]
index|[]
name|secondaryCost
init|=
operator|new
name|float
index|[
name|numRegions
index|]
index|[
name|regionSlots
index|]
decl_stmt|;
name|float
index|[]
index|[]
name|tertiaryCost
init|=
operator|new
name|float
index|[
name|numRegions
index|]
index|[
name|regionSlots
index|]
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|enforceLocality
operator|&&
name|regionLocalityMap
operator|!=
literal|null
condition|)
block|{
comment|// Transform the locality mapping into a 2D array, assuming that any
comment|// unspecified locality value is 0.
name|float
index|[]
index|[]
name|localityPerServer
init|=
operator|new
name|float
index|[
name|numRegions
index|]
index|[
name|regionSlots
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|serverLocalityMap
init|=
name|regionLocalityMap
operator|.
name|get
argument_list|(
name|regions
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverLocalityMap
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|servers
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|String
name|serverName
init|=
name|servers
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|getHostname
argument_list|()
decl_stmt|;
if|if
condition|(
name|serverName
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|Float
name|locality
init|=
name|serverLocalityMap
operator|.
name|get
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|locality
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|slotsPerServer
condition|;
name|k
operator|++
control|)
block|{
comment|// If we can't find the locality of a region to a server, which occurs
comment|// because locality is only reported for servers which have some
comment|// blocks of a region local, then the locality for that pair is 0.
name|localityPerServer
index|[
name|i
index|]
index|[
name|j
operator|*
name|slotsPerServer
operator|+
name|k
index|]
operator|=
name|locality
operator|.
name|floatValue
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Compute the total rack locality for each region in each rack. The total
comment|// rack locality is the sum of the localities of a region on all servers in
comment|// a rack.
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|RegionInfo
argument_list|,
name|Float
argument_list|>
argument_list|>
name|rackRegionLocality
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
name|RegionInfo
name|region
init|=
name|regions
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|regionSlots
condition|;
name|j
operator|+=
name|slotsPerServer
control|)
block|{
name|String
name|rack
init|=
name|rackManager
operator|.
name|getRack
argument_list|(
name|servers
operator|.
name|get
argument_list|(
name|j
operator|/
name|slotsPerServer
argument_list|)
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|RegionInfo
argument_list|,
name|Float
argument_list|>
name|rackLocality
init|=
name|rackRegionLocality
operator|.
name|get
argument_list|(
name|rack
argument_list|)
decl_stmt|;
if|if
condition|(
name|rackLocality
operator|==
literal|null
condition|)
block|{
name|rackLocality
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|rackRegionLocality
operator|.
name|put
argument_list|(
name|rack
argument_list|,
name|rackLocality
argument_list|)
expr_stmt|;
block|}
name|Float
name|localityObj
init|=
name|rackLocality
operator|.
name|get
argument_list|(
name|region
argument_list|)
decl_stmt|;
name|float
name|locality
init|=
name|localityObj
operator|==
literal|null
condition|?
literal|0
else|:
name|localityObj
operator|.
name|floatValue
argument_list|()
decl_stmt|;
name|locality
operator|+=
name|localityPerServer
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|rackLocality
operator|.
name|put
argument_list|(
name|region
argument_list|,
name|locality
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|regionSlots
condition|;
name|j
operator|++
control|)
block|{
name|String
name|rack
init|=
name|rackManager
operator|.
name|getRack
argument_list|(
name|servers
operator|.
name|get
argument_list|(
name|j
operator|/
name|slotsPerServer
argument_list|)
argument_list|)
decl_stmt|;
name|Float
name|totalRackLocalityObj
init|=
name|rackRegionLocality
operator|.
name|get
argument_list|(
name|rack
argument_list|)
operator|.
name|get
argument_list|(
name|regions
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|totalRackLocality
init|=
name|totalRackLocalityObj
operator|==
literal|null
condition|?
literal|0
else|:
name|totalRackLocalityObj
operator|.
name|floatValue
argument_list|()
decl_stmt|;
comment|// Primary cost aims to favor servers with high node locality and low
comment|// rack locality, so that secondaries and tertiaries can be chosen for
comment|// nodes with high rack locality. This might give primaries with
comment|// slightly less locality at first compared to a cost which only
comment|// considers the node locality, but should be better in the long run.
name|primaryCost
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|1
operator|-
operator|(
literal|2
operator|*
name|localityPerServer
index|[
name|i
index|]
index|[
name|j
index|]
operator|-
name|totalRackLocality
operator|)
expr_stmt|;
comment|// Secondary cost aims to favor servers with high node locality and high
comment|// rack locality since the tertiary will be chosen from the same rack as
comment|// the secondary. This could be negative, but that is okay.
name|secondaryCost
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|2
operator|-
operator|(
name|localityPerServer
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|totalRackLocality
operator|)
expr_stmt|;
comment|// Tertiary cost is only concerned with the node locality. It will later
comment|// be restricted to only hosts on the same rack as the secondary.
name|tertiaryCost
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|1
operator|-
name|localityPerServer
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|this
operator|.
name|enforceMinAssignmentMove
operator|&&
name|currentAssignmentMap
operator|!=
literal|null
condition|)
block|{
comment|// We want to minimize the number of regions which move as the result of a
comment|// new assignment. Therefore, slightly penalize any placement which is for
comment|// a host that is not currently serving the region.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|servers
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|ServerName
name|currentAddress
init|=
name|currentAssignmentMap
operator|.
name|get
argument_list|(
name|regions
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentAddress
operator|!=
literal|null
operator|&&
operator|!
name|currentAddress
operator|.
name|equals
argument_list|(
name|servers
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|slotsPerServer
condition|;
name|k
operator|++
control|)
block|{
name|primaryCost
index|[
name|i
index|]
index|[
name|j
operator|*
name|slotsPerServer
operator|+
name|k
index|]
operator|+=
name|NOT_CURRENT_HOST_PENALTY
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// Artificially increase cost of last slot of each server to evenly
comment|// distribute the slop, otherwise there will be a few servers with too few
comment|// regions and many servers with the max number of regions.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|regionSlots
condition|;
name|j
operator|+=
name|slotsPerServer
control|)
block|{
name|primaryCost
index|[
name|i
index|]
index|[
name|j
index|]
operator|+=
name|LAST_SLOT_COST_PENALTY
expr_stmt|;
name|secondaryCost
index|[
name|i
index|]
index|[
name|j
index|]
operator|+=
name|LAST_SLOT_COST_PENALTY
expr_stmt|;
name|tertiaryCost
index|[
name|i
index|]
index|[
name|j
index|]
operator|+=
name|LAST_SLOT_COST_PENALTY
expr_stmt|;
block|}
block|}
name|RandomizedMatrix
name|randomizedMatrix
init|=
operator|new
name|RandomizedMatrix
argument_list|(
name|numRegions
argument_list|,
name|regionSlots
argument_list|)
decl_stmt|;
name|primaryCost
operator|=
name|randomizedMatrix
operator|.
name|transform
argument_list|(
name|primaryCost
argument_list|)
expr_stmt|;
name|int
index|[]
name|primaryAssignment
init|=
operator|new
name|MunkresAssignment
argument_list|(
name|primaryCost
argument_list|)
operator|.
name|solve
argument_list|()
decl_stmt|;
name|primaryAssignment
operator|=
name|randomizedMatrix
operator|.
name|invertIndices
argument_list|(
name|primaryAssignment
argument_list|)
expr_stmt|;
comment|// Modify the secondary and tertiary costs for each region/server pair to
comment|// prevent a region from being assigned to the same rack for both primary
comment|// and either one of secondary or tertiary.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
name|int
name|slot
init|=
name|primaryAssignment
index|[
name|i
index|]
decl_stmt|;
name|String
name|rack
init|=
name|rackManager
operator|.
name|getRack
argument_list|(
name|servers
operator|.
name|get
argument_list|(
name|slot
operator|/
name|slotsPerServer
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|servers
operator|.
name|size
argument_list|()
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|rackManager
operator|.
name|getRack
argument_list|(
name|servers
operator|.
name|get
argument_list|(
name|k
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
name|rack
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|k
operator|==
name|slot
operator|/
name|slotsPerServer
condition|)
block|{
comment|// Same node, do not place secondary or tertiary here ever.
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
name|slotsPerServer
condition|;
name|m
operator|++
control|)
block|{
name|secondaryCost
index|[
name|i
index|]
index|[
name|k
operator|*
name|slotsPerServer
operator|+
name|m
index|]
operator|=
name|MAX_COST
expr_stmt|;
name|tertiaryCost
index|[
name|i
index|]
index|[
name|k
operator|*
name|slotsPerServer
operator|+
name|m
index|]
operator|=
name|MAX_COST
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Same rack, do not place secondary or tertiary here if possible.
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
name|slotsPerServer
condition|;
name|m
operator|++
control|)
block|{
name|secondaryCost
index|[
name|i
index|]
index|[
name|k
operator|*
name|slotsPerServer
operator|+
name|m
index|]
operator|=
name|AVOID_COST
expr_stmt|;
name|tertiaryCost
index|[
name|i
index|]
index|[
name|k
operator|*
name|slotsPerServer
operator|+
name|m
index|]
operator|=
name|AVOID_COST
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|munkresForSecondaryAndTertiary
condition|)
block|{
name|randomizedMatrix
operator|=
operator|new
name|RandomizedMatrix
argument_list|(
name|numRegions
argument_list|,
name|regionSlots
argument_list|)
expr_stmt|;
name|secondaryCost
operator|=
name|randomizedMatrix
operator|.
name|transform
argument_list|(
name|secondaryCost
argument_list|)
expr_stmt|;
name|int
index|[]
name|secondaryAssignment
init|=
operator|new
name|MunkresAssignment
argument_list|(
name|secondaryCost
argument_list|)
operator|.
name|solve
argument_list|()
decl_stmt|;
name|secondaryAssignment
operator|=
name|randomizedMatrix
operator|.
name|invertIndices
argument_list|(
name|secondaryAssignment
argument_list|)
expr_stmt|;
comment|// Modify the tertiary costs for each region/server pair to ensure that a
comment|// region is assigned to a tertiary server on the same rack as its secondary
comment|// server, but not the same server in that rack.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
name|int
name|slot
init|=
name|secondaryAssignment
index|[
name|i
index|]
decl_stmt|;
name|String
name|rack
init|=
name|rackManager
operator|.
name|getRack
argument_list|(
name|servers
operator|.
name|get
argument_list|(
name|slot
operator|/
name|slotsPerServer
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|servers
operator|.
name|size
argument_list|()
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|==
name|slot
operator|/
name|slotsPerServer
condition|)
block|{
comment|// Same node, do not place tertiary here ever.
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
name|slotsPerServer
condition|;
name|m
operator|++
control|)
block|{
name|tertiaryCost
index|[
name|i
index|]
index|[
name|k
operator|*
name|slotsPerServer
operator|+
name|m
index|]
operator|=
name|MAX_COST
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rackManager
operator|.
name|getRack
argument_list|(
name|servers
operator|.
name|get
argument_list|(
name|k
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
name|rack
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// Different rack, do not place tertiary here if possible.
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
name|slotsPerServer
condition|;
name|m
operator|++
control|)
block|{
name|tertiaryCost
index|[
name|i
index|]
index|[
name|k
operator|*
name|slotsPerServer
operator|+
name|m
index|]
operator|=
name|AVOID_COST
expr_stmt|;
block|}
block|}
block|}
block|}
name|randomizedMatrix
operator|=
operator|new
name|RandomizedMatrix
argument_list|(
name|numRegions
argument_list|,
name|regionSlots
argument_list|)
expr_stmt|;
name|tertiaryCost
operator|=
name|randomizedMatrix
operator|.
name|transform
argument_list|(
name|tertiaryCost
argument_list|)
expr_stmt|;
name|int
index|[]
name|tertiaryAssignment
init|=
operator|new
name|MunkresAssignment
argument_list|(
name|tertiaryCost
argument_list|)
operator|.
name|solve
argument_list|()
decl_stmt|;
name|tertiaryAssignment
operator|=
name|randomizedMatrix
operator|.
name|invertIndices
argument_list|(
name|tertiaryAssignment
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredServers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|FavoredNodeAssignmentHelper
operator|.
name|FAVORED_NODES_NUM
argument_list|)
decl_stmt|;
name|ServerName
name|s
init|=
name|servers
operator|.
name|get
argument_list|(
name|primaryAssignment
index|[
name|i
index|]
operator|/
name|slotsPerServer
argument_list|)
decl_stmt|;
name|favoredServers
operator|.
name|add
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|s
operator|.
name|getHostname
argument_list|()
argument_list|,
name|s
operator|.
name|getPort
argument_list|()
argument_list|,
name|ServerName
operator|.
name|NON_STARTCODE
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|servers
operator|.
name|get
argument_list|(
name|secondaryAssignment
index|[
name|i
index|]
operator|/
name|slotsPerServer
argument_list|)
expr_stmt|;
name|favoredServers
operator|.
name|add
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|s
operator|.
name|getHostname
argument_list|()
argument_list|,
name|s
operator|.
name|getPort
argument_list|()
argument_list|,
name|ServerName
operator|.
name|NON_STARTCODE
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|servers
operator|.
name|get
argument_list|(
name|tertiaryAssignment
index|[
name|i
index|]
operator|/
name|slotsPerServer
argument_list|)
expr_stmt|;
name|favoredServers
operator|.
name|add
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|s
operator|.
name|getHostname
argument_list|()
argument_list|,
name|s
operator|.
name|getPort
argument_list|()
argument_list|,
name|ServerName
operator|.
name|NON_STARTCODE
argument_list|)
argument_list|)
expr_stmt|;
comment|// Update the assignment plan
name|plan
operator|.
name|updateFavoredNodesMap
argument_list|(
name|regions
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|favoredServers
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Generated the assignment plan for "
operator|+
name|numRegions
operator|+
literal|" regions from table "
operator|+
name|tableName
operator|+
literal|" with "
operator|+
name|servers
operator|.
name|size
argument_list|()
operator|+
literal|" region servers"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Assignment plan for secondary and tertiary generated "
operator|+
literal|"using MunkresAssignment"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Map
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
name|primaryRSMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
name|primaryRSMap
operator|.
name|put
argument_list|(
name|regions
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|servers
operator|.
name|get
argument_list|(
name|primaryAssignment
index|[
name|i
index|]
operator|/
name|slotsPerServer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FavoredNodeAssignmentHelper
name|favoredNodeHelper
init|=
operator|new
name|FavoredNodeAssignmentHelper
argument_list|(
name|servers
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|favoredNodeHelper
operator|.
name|initialize
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
index|[]
argument_list|>
name|secondaryAndTertiaryMap
init|=
name|favoredNodeHelper
operator|.
name|placeSecondaryAndTertiaryWithRestrictions
argument_list|(
name|primaryRSMap
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredServers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|FavoredNodeAssignmentHelper
operator|.
name|FAVORED_NODES_NUM
argument_list|)
decl_stmt|;
name|RegionInfo
name|currentRegion
init|=
name|regions
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ServerName
name|s
init|=
name|primaryRSMap
operator|.
name|get
argument_list|(
name|currentRegion
argument_list|)
decl_stmt|;
name|favoredServers
operator|.
name|add
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|s
operator|.
name|getHostname
argument_list|()
argument_list|,
name|s
operator|.
name|getPort
argument_list|()
argument_list|,
name|ServerName
operator|.
name|NON_STARTCODE
argument_list|)
argument_list|)
expr_stmt|;
name|ServerName
index|[]
name|secondaryAndTertiary
init|=
name|secondaryAndTertiaryMap
operator|.
name|get
argument_list|(
name|currentRegion
argument_list|)
decl_stmt|;
name|s
operator|=
name|secondaryAndTertiary
index|[
literal|0
index|]
expr_stmt|;
name|favoredServers
operator|.
name|add
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|s
operator|.
name|getHostname
argument_list|()
argument_list|,
name|s
operator|.
name|getPort
argument_list|()
argument_list|,
name|ServerName
operator|.
name|NON_STARTCODE
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|secondaryAndTertiary
index|[
literal|1
index|]
expr_stmt|;
name|favoredServers
operator|.
name|add
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|s
operator|.
name|getHostname
argument_list|()
argument_list|,
name|s
operator|.
name|getPort
argument_list|()
argument_list|,
name|ServerName
operator|.
name|NON_STARTCODE
argument_list|)
argument_list|)
expr_stmt|;
comment|// Update the assignment plan
name|plan
operator|.
name|updateFavoredNodesMap
argument_list|(
name|regions
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|favoredServers
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Generated the assignment plan for "
operator|+
name|numRegions
operator|+
literal|" regions from table "
operator|+
name|tableName
operator|+
literal|" with "
operator|+
name|servers
operator|.
name|size
argument_list|()
operator|+
literal|" region servers"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Assignment plan for secondary and tertiary generated "
operator|+
literal|"using placeSecondaryAndTertiaryWithRestrictions method"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|FavoredNodesPlan
name|getNewAssignmentPlan
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Get the current region assignment snapshot by scanning from the META
name|SnapshotOfRegionAssignmentFromMeta
name|assignmentSnapshot
init|=
name|this
operator|.
name|getRegionAssignmentSnapshot
argument_list|()
decl_stmt|;
comment|// Get the region locality map
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|>
name|regionLocalityMap
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|enforceLocality
condition|)
block|{
name|regionLocalityMap
operator|=
name|FSUtils
operator|.
name|getRegionDegreeLocalityMappingFromFS
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// Initialize the assignment plan
name|FavoredNodesPlan
name|plan
init|=
operator|new
name|FavoredNodesPlan
argument_list|()
decl_stmt|;
comment|// Get the table to region mapping
name|Map
argument_list|<
name|TableName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|tableToRegionMap
init|=
name|assignmentSnapshot
operator|.
name|getTableToRegionMap
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Start to generate the new assignment plan for the "
operator|+
operator|+
name|tableToRegionMap
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" tables"
argument_list|)
expr_stmt|;
for|for
control|(
name|TableName
name|table
range|:
name|tableToRegionMap
operator|.
name|keySet
argument_list|()
control|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|targetTableSet
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|this
operator|.
name|targetTableSet
operator|.
name|contains
argument_list|(
name|table
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// TODO: maybe run the placement in parallel for each table
name|genAssignmentPlan
argument_list|(
name|table
argument_list|,
name|assignmentSnapshot
argument_list|,
name|regionLocalityMap
argument_list|,
name|plan
argument_list|,
name|USE_MUNKRES_FOR_PLACING_SECONDARY_AND_TERTIARY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Get some exceptions for placing primary region server"
operator|+
literal|"for table "
operator|+
name|table
operator|+
literal|" because "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Finish to generate the new assignment plan for the "
operator|+
operator|+
name|tableToRegionMap
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" tables"
argument_list|)
expr_stmt|;
return|return
name|plan
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|Closeables
operator|.
name|close
argument_list|(
name|connection
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Some algorithms for solving the assignment problem may traverse workers or    * jobs in linear order which may result in skewing the assignments of the    * first jobs in the matrix toward the last workers in the matrix if the    * costs are uniform. To avoid this kind of clumping, we can randomize the    * rows and columns of the cost matrix in a reversible way, such that the    * solution to the assignment problem can be interpreted in terms of the    * original untransformed cost matrix. Rows and columns are transformed    * independently such that the elements contained in any row of the input    * matrix are the same as the elements in the corresponding output matrix,    * and each row has its elements transformed in the same way. Similarly for    * columns.    */
specifier|protected
specifier|static
class|class
name|RandomizedMatrix
block|{
specifier|private
specifier|final
name|int
name|rows
decl_stmt|;
specifier|private
specifier|final
name|int
name|cols
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|rowTransform
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|rowInverse
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|colTransform
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|colInverse
decl_stmt|;
comment|/**      * Create a randomization scheme for a matrix of a given size.      * @param rows the number of rows in the matrix      * @param cols the number of columns in the matrix      */
specifier|public
name|RandomizedMatrix
parameter_list|(
name|int
name|rows
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
name|this
operator|.
name|rows
operator|=
name|rows
expr_stmt|;
name|this
operator|.
name|cols
operator|=
name|cols
expr_stmt|;
name|Random
name|random
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|rowTransform
operator|=
operator|new
name|int
index|[
name|rows
index|]
expr_stmt|;
name|rowInverse
operator|=
operator|new
name|int
index|[
name|rows
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
condition|;
name|i
operator|++
control|)
block|{
name|rowTransform
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|// Shuffle the row indices.
for|for
control|(
name|int
name|i
init|=
name|rows
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|r
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|temp
init|=
name|rowTransform
index|[
name|r
index|]
decl_stmt|;
name|rowTransform
index|[
name|r
index|]
operator|=
name|rowTransform
index|[
name|i
index|]
expr_stmt|;
name|rowTransform
index|[
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|// Generate the inverse row indices.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
condition|;
name|i
operator|++
control|)
block|{
name|rowInverse
index|[
name|rowTransform
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
block|}
name|colTransform
operator|=
operator|new
name|int
index|[
name|cols
index|]
expr_stmt|;
name|colInverse
operator|=
operator|new
name|int
index|[
name|cols
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cols
condition|;
name|i
operator|++
control|)
block|{
name|colTransform
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|// Shuffle the column indices.
for|for
control|(
name|int
name|i
init|=
name|cols
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|r
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|temp
init|=
name|colTransform
index|[
name|r
index|]
decl_stmt|;
name|colTransform
index|[
name|r
index|]
operator|=
name|colTransform
index|[
name|i
index|]
expr_stmt|;
name|colTransform
index|[
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|// Generate the inverse column indices.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cols
condition|;
name|i
operator|++
control|)
block|{
name|colInverse
index|[
name|colTransform
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/**      * Copy a given matrix into a new matrix, transforming each row index and      * each column index according to the randomization scheme that was created      * at construction time.      * @param matrix the cost matrix to transform      * @return a new matrix with row and column indices transformed      */
specifier|public
name|float
index|[]
index|[]
name|transform
parameter_list|(
name|float
index|[]
index|[]
name|matrix
parameter_list|)
block|{
name|float
index|[]
index|[]
name|result
init|=
operator|new
name|float
index|[
name|rows
index|]
index|[
name|cols
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|cols
condition|;
name|j
operator|++
control|)
block|{
name|result
index|[
name|rowTransform
index|[
name|i
index|]
index|]
index|[
name|colTransform
index|[
name|j
index|]
index|]
operator|=
name|matrix
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * Copy a given matrix into a new matrix, transforming each row index and      * each column index according to the inverse of the randomization scheme      * that was created at construction time.      * @param matrix the cost matrix to be inverted      * @return a new matrix with row and column indices inverted      */
specifier|public
name|float
index|[]
index|[]
name|invert
parameter_list|(
name|float
index|[]
index|[]
name|matrix
parameter_list|)
block|{
name|float
index|[]
index|[]
name|result
init|=
operator|new
name|float
index|[
name|rows
index|]
index|[
name|cols
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|cols
condition|;
name|j
operator|++
control|)
block|{
name|result
index|[
name|rowInverse
index|[
name|i
index|]
index|]
index|[
name|colInverse
index|[
name|j
index|]
index|]
operator|=
name|matrix
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * Given an array where each element {@code indices[i]} represents the      * randomized column index corresponding to randomized row index {@code i},      * create a new array with the corresponding inverted indices.      * @param indices an array of transformed indices to be inverted      * @return an array of inverted indices      */
specifier|public
name|int
index|[]
name|invertIndices
parameter_list|(
name|int
index|[]
name|indices
parameter_list|)
block|{
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
name|indices
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indices
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|rowInverse
index|[
name|i
index|]
index|]
operator|=
name|colInverse
index|[
name|indices
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
comment|/**    * Print the assignment plan to the system output stream    * @param plan    */
specifier|public
specifier|static
name|void
name|printAssignmentPlan
parameter_list|(
name|FavoredNodesPlan
name|plan
parameter_list|)
block|{
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
return|return;
name|LOG
operator|.
name|info
argument_list|(
literal|"========== Start to print the assignment plan ================"
argument_list|)
expr_stmt|;
comment|// sort the map based on region info
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
name|assignmentMap
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|plan
operator|.
name|getAssignmentMap
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
name|entry
range|:
name|assignmentMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|serverList
init|=
name|FavoredNodeAssignmentHelper
operator|.
name|getFavoredNodesAsString
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|regionName
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Region: "
operator|+
name|regionName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Its favored nodes: "
operator|+
name|serverList
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"========== Finish to print the assignment plan ================"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Update the assignment plan into hbase:meta    * @param plan the assignments plan to be updated into hbase:meta    * @throws IOException if cannot update assignment plan in hbase:meta    */
specifier|public
name|void
name|updateAssignmentPlanToMeta
parameter_list|(
name|FavoredNodesPlan
name|plan
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Start to update the hbase:meta with the new assignment plan"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
name|assignmentMap
init|=
name|plan
operator|.
name|getAssignmentMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|RegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
name|planToUpdate
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|assignmentMap
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|RegionInfo
argument_list|>
name|regionToRegionInfoMap
init|=
name|getRegionAssignmentSnapshot
argument_list|()
operator|.
name|getRegionNameToRegionInfoMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
name|entry
range|:
name|assignmentMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|planToUpdate
operator|.
name|put
argument_list|(
name|regionToRegionInfoMap
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FavoredNodeAssignmentHelper
operator|.
name|updateMetaWithFavoredNodesInfo
argument_list|(
name|planToUpdate
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Updated the hbase:meta with the new assignment plan"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to update hbase:meta with the new assignment"
operator|+
literal|"plan because "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Update the assignment plan to all the region servers    * @param plan    * @throws IOException    */
specifier|private
name|void
name|updateAssignmentPlanToRegionServers
parameter_list|(
name|FavoredNodesPlan
name|plan
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Start to update the region servers with the new assignment plan"
argument_list|)
expr_stmt|;
comment|// Get the region to region server map
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|currentAssignment
init|=
name|this
operator|.
name|getRegionAssignmentSnapshot
argument_list|()
operator|.
name|getRegionServerToRegionMap
argument_list|()
decl_stmt|;
comment|// track of the failed and succeeded updates
name|int
name|succeededNum
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|Exception
argument_list|>
name|failedUpdateMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|entry
range|:
name|currentAssignment
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|Pair
argument_list|<
name|RegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
argument_list|>
name|regionUpdateInfos
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Keep track of the favored updates for the current region server
name|FavoredNodesPlan
name|singleServerPlan
init|=
literal|null
decl_stmt|;
comment|// Find out all the updates for the current region server
for|for
control|(
name|RegionInfo
name|region
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredServerList
init|=
name|plan
operator|.
name|getFavoredNodes
argument_list|(
name|region
argument_list|)
decl_stmt|;
if|if
condition|(
name|favoredServerList
operator|!=
literal|null
operator|&&
name|favoredServerList
operator|.
name|size
argument_list|()
operator|==
name|FavoredNodeAssignmentHelper
operator|.
name|FAVORED_NODES_NUM
condition|)
block|{
comment|// Create the single server plan if necessary
if|if
condition|(
name|singleServerPlan
operator|==
literal|null
condition|)
block|{
name|singleServerPlan
operator|=
operator|new
name|FavoredNodesPlan
argument_list|()
expr_stmt|;
block|}
comment|// Update the single server update
name|singleServerPlan
operator|.
name|updateFavoredNodesMap
argument_list|(
name|region
argument_list|,
name|favoredServerList
argument_list|)
expr_stmt|;
name|regionUpdateInfos
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<>
argument_list|(
name|region
argument_list|,
name|favoredServerList
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|singleServerPlan
operator|!=
literal|null
condition|)
block|{
comment|// Update the current region server with its updated favored nodes
name|AsyncRegionServerAdmin
name|rsAdmin
init|=
name|getConnection
argument_list|()
operator|.
name|getRegionServerAdmin
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|UpdateFavoredNodesRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildUpdateFavoredNodesRequest
argument_list|(
name|regionUpdateInfos
argument_list|)
decl_stmt|;
name|UpdateFavoredNodesResponse
name|updateFavoredNodesResponse
init|=
name|FutureUtils
operator|.
name|get
argument_list|(
name|rsAdmin
operator|.
name|updateFavoredNodes
argument_list|(
name|request
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Region server "
operator|+
name|FutureUtils
operator|.
name|get
argument_list|(
name|rsAdmin
operator|.
name|getServerInfo
argument_list|(
name|RequestConverter
operator|.
name|buildGetServerInfoRequest
argument_list|()
argument_list|)
argument_list|)
operator|.
name|getServerInfo
argument_list|()
operator|+
literal|" has updated "
operator|+
name|updateFavoredNodesResponse
operator|.
name|getResponse
argument_list|()
operator|+
literal|" / "
operator|+
name|singleServerPlan
operator|.
name|getAssignmentMap
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" regions with the assignment plan"
argument_list|)
expr_stmt|;
name|succeededNum
operator|++
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|failedUpdateMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// log the succeeded updates
name|LOG
operator|.
name|info
argument_list|(
literal|"Updated "
operator|+
name|succeededNum
operator|+
literal|" region servers with "
operator|+
literal|"the new assignment plan"
argument_list|)
expr_stmt|;
comment|// log the failed updates
name|int
name|failedNum
init|=
name|failedUpdateMap
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|failedNum
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to update the following + "
operator|+
name|failedNum
operator|+
literal|" region servers with its corresponding favored nodes"
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|Exception
argument_list|>
name|entry
range|:
name|failedUpdateMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to update "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getAddress
argument_list|()
operator|+
literal|" because of "
operator|+
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|updateAssignmentPlan
parameter_list|(
name|FavoredNodesPlan
name|plan
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Start to update the new assignment plan for the hbase:meta table and"
operator|+
literal|" the region servers"
argument_list|)
expr_stmt|;
comment|// Update the new assignment plan to META
name|updateAssignmentPlanToMeta
argument_list|(
name|plan
argument_list|)
expr_stmt|;
comment|// Update the new assignment plan to Region Servers
name|updateAssignmentPlanToRegionServers
argument_list|(
name|plan
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finish to update the new assignment plan for the hbase:meta table and"
operator|+
literal|" the region servers"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return how many regions will move per table since their primary RS will    * change    *    * @param newPlan - new AssignmentPlan    * @return how many primaries will move per table    */
specifier|public
name|Map
argument_list|<
name|TableName
argument_list|,
name|Integer
argument_list|>
name|getRegionsMovement
parameter_list|(
name|FavoredNodesPlan
name|newPlan
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|TableName
argument_list|,
name|Integer
argument_list|>
name|movesPerTable
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|SnapshotOfRegionAssignmentFromMeta
name|snapshot
init|=
name|this
operator|.
name|getRegionAssignmentSnapshot
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|TableName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|tableToRegions
init|=
name|snapshot
operator|.
name|getTableToRegionMap
argument_list|()
decl_stmt|;
name|FavoredNodesPlan
name|oldPlan
init|=
name|snapshot
operator|.
name|getExistingAssignmentPlan
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|TableName
argument_list|>
name|tables
init|=
name|snapshot
operator|.
name|getTableSet
argument_list|()
decl_stmt|;
for|for
control|(
name|TableName
name|table
range|:
name|tables
control|)
block|{
name|int
name|movedPrimaries
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|targetTableSet
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|this
operator|.
name|targetTableSet
operator|.
name|contains
argument_list|(
name|table
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|regions
init|=
name|tableToRegions
operator|.
name|get
argument_list|(
name|table
argument_list|)
decl_stmt|;
for|for
control|(
name|RegionInfo
name|region
range|:
name|regions
control|)
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|oldServers
init|=
name|oldPlan
operator|.
name|getFavoredNodes
argument_list|(
name|region
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|newServers
init|=
name|newPlan
operator|.
name|getFavoredNodes
argument_list|(
name|region
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldServers
operator|!=
literal|null
operator|&&
name|newServers
operator|!=
literal|null
condition|)
block|{
name|ServerName
name|oldPrimary
init|=
name|oldServers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ServerName
name|newPrimary
init|=
name|newServers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldPrimary
operator|.
name|compareTo
argument_list|(
name|newPrimary
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|movedPrimaries
operator|++
expr_stmt|;
block|}
block|}
block|}
name|movesPerTable
operator|.
name|put
argument_list|(
name|table
argument_list|,
name|movedPrimaries
argument_list|)
expr_stmt|;
block|}
return|return
name|movesPerTable
return|;
block|}
comment|/**    * Compares two plans and check whether the locality dropped or increased    * (prints the information as a string) also prints the baseline locality    *    * @param movesPerTable - how many primary regions will move per table    * @param regionLocalityMap - locality map from FS    * @param newPlan - new assignment plan    * @throws IOException    */
specifier|public
name|void
name|checkDifferencesWithOldPlan
parameter_list|(
name|Map
argument_list|<
name|TableName
argument_list|,
name|Integer
argument_list|>
name|movesPerTable
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|>
name|regionLocalityMap
parameter_list|,
name|FavoredNodesPlan
name|newPlan
parameter_list|)
throws|throws
name|IOException
block|{
comment|// localities for primary, secondary and tertiary
name|SnapshotOfRegionAssignmentFromMeta
name|snapshot
init|=
name|this
operator|.
name|getRegionAssignmentSnapshot
argument_list|()
decl_stmt|;
name|FavoredNodesPlan
name|oldPlan
init|=
name|snapshot
operator|.
name|getExistingAssignmentPlan
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|TableName
argument_list|>
name|tables
init|=
name|snapshot
operator|.
name|getTableSet
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|TableName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|tableToRegionsMap
init|=
name|snapshot
operator|.
name|getTableToRegionMap
argument_list|()
decl_stmt|;
for|for
control|(
name|TableName
name|table
range|:
name|tables
control|)
block|{
name|float
index|[]
name|deltaLocality
init|=
operator|new
name|float
index|[
literal|3
index|]
decl_stmt|;
name|float
index|[]
name|locality
init|=
operator|new
name|float
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|targetTableSet
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|this
operator|.
name|targetTableSet
operator|.
name|contains
argument_list|(
name|table
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|regions
init|=
name|tableToRegionsMap
operator|.
name|get
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"=================================================="
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Assignment Plan Projection Report For Table: "
operator|+
name|table
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\t Total regions: "
operator|+
name|regions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\t"
operator|+
name|movesPerTable
operator|.
name|get
argument_list|(
name|table
argument_list|)
operator|+
literal|" primaries will move due to their primary has changed"
argument_list|)
expr_stmt|;
for|for
control|(
name|RegionInfo
name|currentRegion
range|:
name|regions
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|regionLocality
init|=
name|regionLocalityMap
operator|.
name|get
argument_list|(
name|currentRegion
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionLocality
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|ServerName
argument_list|>
name|oldServers
init|=
name|oldPlan
operator|.
name|getFavoredNodes
argument_list|(
name|currentRegion
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|newServers
init|=
name|newPlan
operator|.
name|getFavoredNodes
argument_list|(
name|currentRegion
argument_list|)
decl_stmt|;
if|if
condition|(
name|newServers
operator|!=
literal|null
operator|&&
name|oldServers
operator|!=
literal|null
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FavoredNodesPlan
operator|.
name|Position
name|p
range|:
name|FavoredNodesPlan
operator|.
name|Position
operator|.
name|values
argument_list|()
control|)
block|{
name|ServerName
name|newServer
init|=
name|newServers
operator|.
name|get
argument_list|(
name|p
operator|.
name|ordinal
argument_list|()
argument_list|)
decl_stmt|;
name|ServerName
name|oldServer
init|=
name|oldServers
operator|.
name|get
argument_list|(
name|p
operator|.
name|ordinal
argument_list|()
argument_list|)
decl_stmt|;
name|Float
name|oldLocality
init|=
literal|0f
decl_stmt|;
if|if
condition|(
name|oldServers
operator|!=
literal|null
condition|)
block|{
name|oldLocality
operator|=
name|regionLocality
operator|.
name|get
argument_list|(
name|oldServer
operator|.
name|getHostname
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldLocality
operator|==
literal|null
condition|)
block|{
name|oldLocality
operator|=
literal|0f
expr_stmt|;
block|}
name|locality
index|[
name|i
index|]
operator|+=
name|oldLocality
expr_stmt|;
block|}
name|Float
name|newLocality
init|=
name|regionLocality
operator|.
name|get
argument_list|(
name|newServer
operator|.
name|getHostname
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newLocality
operator|==
literal|null
condition|)
block|{
name|newLocality
operator|=
literal|0f
expr_stmt|;
block|}
name|deltaLocality
index|[
name|i
index|]
operator|+=
name|newLocality
operator|-
name|oldLocality
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
name|DecimalFormat
name|df
init|=
operator|new
name|java
operator|.
name|text
operator|.
name|DecimalFormat
argument_list|(
literal|"#.##"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deltaLocality
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"\t\t Baseline locality for "
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"primary "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"secondary "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"tertiary "
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|df
operator|.
name|format
argument_list|(
literal|100
operator|*
name|locality
index|[
name|i
index|]
operator|/
name|regions
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|"%"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"\t\t Locality will change with the new plan: "
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|df
operator|.
name|format
argument_list|(
literal|100
operator|*
name|deltaLocality
index|[
name|i
index|]
operator|/
name|regions
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|"%"
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\t Baseline dispersion"
argument_list|)
expr_stmt|;
name|printDispersionScores
argument_list|(
name|table
argument_list|,
name|snapshot
argument_list|,
name|regions
operator|.
name|size
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\t Projected dispersion"
argument_list|)
expr_stmt|;
name|printDispersionScores
argument_list|(
name|table
argument_list|,
name|snapshot
argument_list|,
name|regions
operator|.
name|size
argument_list|()
argument_list|,
name|newPlan
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|printDispersionScores
parameter_list|(
name|TableName
name|table
parameter_list|,
name|SnapshotOfRegionAssignmentFromMeta
name|snapshot
parameter_list|,
name|int
name|numRegions
parameter_list|,
name|FavoredNodesPlan
name|newPlan
parameter_list|,
name|boolean
name|simplePrint
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|targetTableSet
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|this
operator|.
name|targetTableSet
operator|.
name|contains
argument_list|(
name|table
argument_list|)
condition|)
block|{
return|return;
block|}
name|AssignmentVerificationReport
name|report
init|=
operator|new
name|AssignmentVerificationReport
argument_list|()
decl_stmt|;
name|report
operator|.
name|fillUpDispersion
argument_list|(
name|table
argument_list|,
name|snapshot
argument_list|,
name|newPlan
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Float
argument_list|>
name|dispersion
init|=
name|report
operator|.
name|getDispersionInformation
argument_list|()
decl_stmt|;
if|if
condition|(
name|simplePrint
condition|)
block|{
name|DecimalFormat
name|df
init|=
operator|new
name|java
operator|.
name|text
operator|.
name|DecimalFormat
argument_list|(
literal|"#.##"
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"\tAvg dispersion score: "
operator|+
name|df
operator|.
name|format
argument_list|(
name|dispersion
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
literal|" hosts;\tMax dispersion score: "
operator|+
name|df
operator|.
name|format
argument_list|(
name|dispersion
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|+
literal|" hosts;\tMin dispersion score: "
operator|+
name|df
operator|.
name|format
argument_list|(
name|dispersion
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|+
literal|" hosts;"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"For Table: "
operator|+
name|table
operator|+
literal|" ; #Total Regions: "
operator|+
name|numRegions
operator|+
literal|" ; The average dispersion score is "
operator|+
name|dispersion
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|printLocalityAndDispersionForCurrentPlan
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|>
name|regionLocalityMap
parameter_list|)
throws|throws
name|IOException
block|{
name|SnapshotOfRegionAssignmentFromMeta
name|snapshot
init|=
name|this
operator|.
name|getRegionAssignmentSnapshot
argument_list|()
decl_stmt|;
name|FavoredNodesPlan
name|assignmentPlan
init|=
name|snapshot
operator|.
name|getExistingAssignmentPlan
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|TableName
argument_list|>
name|tables
init|=
name|snapshot
operator|.
name|getTableSet
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|TableName
argument_list|,
name|List
argument_list|<
name|RegionInfo
argument_list|>
argument_list|>
name|tableToRegionsMap
init|=
name|snapshot
operator|.
name|getTableToRegionMap
argument_list|()
decl_stmt|;
for|for
control|(
name|TableName
name|table
range|:
name|tables
control|)
block|{
name|float
index|[]
name|locality
init|=
operator|new
name|float
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|targetTableSet
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|this
operator|.
name|targetTableSet
operator|.
name|contains
argument_list|(
name|table
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|regions
init|=
name|tableToRegionsMap
operator|.
name|get
argument_list|(
name|table
argument_list|)
decl_stmt|;
for|for
control|(
name|RegionInfo
name|currentRegion
range|:
name|regions
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|regionLocality
init|=
name|regionLocalityMap
operator|.
name|get
argument_list|(
name|currentRegion
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionLocality
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
init|=
name|assignmentPlan
operator|.
name|getFavoredNodes
argument_list|(
name|currentRegion
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|!=
literal|null
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FavoredNodesPlan
operator|.
name|Position
name|p
range|:
name|FavoredNodesPlan
operator|.
name|Position
operator|.
name|values
argument_list|()
control|)
block|{
name|ServerName
name|server
init|=
name|servers
operator|.
name|get
argument_list|(
name|p
operator|.
name|ordinal
argument_list|()
argument_list|)
decl_stmt|;
name|Float
name|currentLocality
init|=
literal|0f
decl_stmt|;
if|if
condition|(
name|servers
operator|!=
literal|null
condition|)
block|{
name|currentLocality
operator|=
name|regionLocality
operator|.
name|get
argument_list|(
name|server
operator|.
name|getHostname
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentLocality
operator|==
literal|null
condition|)
block|{
name|currentLocality
operator|=
literal|0f
expr_stmt|;
block|}
name|locality
index|[
name|i
index|]
operator|+=
name|currentLocality
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locality
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|copy
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|copy
operator|=
literal|"primary"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|copy
operator|=
literal|"secondary"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|copy
operator|=
literal|"tertiary"
expr_stmt|;
block|}
name|float
name|avgLocality
init|=
literal|100
operator|*
name|locality
index|[
name|i
index|]
operator|/
name|regions
operator|.
name|size
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"For Table: "
operator|+
name|table
operator|+
literal|" ; #Total Regions: "
operator|+
name|regions
operator|.
name|size
argument_list|()
operator|+
literal|" ; The average locality for "
operator|+
name|copy
operator|+
literal|" is "
operator|+
name|avgLocality
operator|+
literal|" %"
argument_list|)
expr_stmt|;
block|}
name|printDispersionScores
argument_list|(
name|table
argument_list|,
name|snapshot
argument_list|,
name|regions
operator|.
name|size
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @param favoredNodesStr The String of favored nodes    * @return the list of ServerName for the byte array of favored nodes.    */
specifier|public
specifier|static
name|List
argument_list|<
name|ServerName
argument_list|>
name|getFavoredNodeList
parameter_list|(
name|String
name|favoredNodesStr
parameter_list|)
block|{
name|String
index|[]
name|favoredNodesArray
init|=
name|StringUtils
operator|.
name|split
argument_list|(
name|favoredNodesStr
argument_list|,
literal|","
argument_list|)
decl_stmt|;
if|if
condition|(
name|favoredNodesArray
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|serverList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|hostNameAndPort
range|:
name|favoredNodesArray
control|)
block|{
name|serverList
operator|.
name|add
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|hostNameAndPort
argument_list|,
name|ServerName
operator|.
name|NON_STARTCODE
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|serverList
return|;
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
name|args
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
name|Options
name|opt
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"w"
argument_list|,
literal|"write"
argument_list|,
literal|false
argument_list|,
literal|"write the assignments to hbase:meta only"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"u"
argument_list|,
literal|"update"
argument_list|,
literal|false
argument_list|,
literal|"update the assignments to hbase:meta and RegionServers together"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"n"
argument_list|,
literal|"dry-run"
argument_list|,
literal|false
argument_list|,
literal|"do not write assignments to META"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"v"
argument_list|,
literal|"verify"
argument_list|,
literal|false
argument_list|,
literal|"verify current assignments against META"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"p"
argument_list|,
literal|"print"
argument_list|,
literal|false
argument_list|,
literal|"print the current assignment plan in META"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"h"
argument_list|,
literal|"help"
argument_list|,
literal|false
argument_list|,
literal|"print usage"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"d"
argument_list|,
literal|"verification-details"
argument_list|,
literal|false
argument_list|,
literal|"print the details of verification report"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"zk"
argument_list|,
literal|true
argument_list|,
literal|"to set the zookeeper quorum"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"fs"
argument_list|,
literal|true
argument_list|,
literal|"to set HDFS"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"hbase_root"
argument_list|,
literal|true
argument_list|,
literal|"to set hbase_root directory"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"overwrite"
argument_list|,
literal|false
argument_list|,
literal|"overwrite the favored nodes for a single region,"
operator|+
literal|"for example: -update -r regionName -f server1:port,server2:port,server3:port"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"r"
argument_list|,
literal|true
argument_list|,
literal|"The region name that needs to be updated"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"f"
argument_list|,
literal|true
argument_list|,
literal|"The new favored nodes"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"tables"
argument_list|,
literal|true
argument_list|,
literal|"The list of table names splitted by ',' ;"
operator|+
literal|"For example: -tables: t1,t2,...,tn"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"l"
argument_list|,
literal|"locality"
argument_list|,
literal|true
argument_list|,
literal|"enforce the maximum locality"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"m"
argument_list|,
literal|"min-move"
argument_list|,
literal|true
argument_list|,
literal|"enforce minimum assignment move"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"diff"
argument_list|,
literal|false
argument_list|,
literal|"calculate difference between assignment plans"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"munkres"
argument_list|,
literal|false
argument_list|,
literal|"use munkres to place secondaries and tertiaries"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|addOption
argument_list|(
literal|"ld"
argument_list|,
literal|"locality-dispersion"
argument_list|,
literal|false
argument_list|,
literal|"print locality and dispersion "
operator|+
literal|"information for current plan"
argument_list|)
expr_stmt|;
try|try
block|{
name|CommandLine
name|cmd
init|=
operator|new
name|GnuParser
argument_list|()
operator|.
name|parse
argument_list|(
name|opt
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
name|boolean
name|enforceMinAssignmentMove
init|=
literal|true
decl_stmt|;
name|boolean
name|enforceLocality
init|=
literal|true
decl_stmt|;
name|boolean
name|verificationDetails
init|=
literal|false
decl_stmt|;
comment|// Read all the options
if|if
condition|(
operator|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"l"
argument_list|)
operator|&&
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"l"
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"false"
argument_list|)
operator|)
operator|||
operator|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"locality"
argument_list|)
operator|&&
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"locality"
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"false"
argument_list|)
operator|)
condition|)
block|{
name|enforceLocality
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"m"
argument_list|)
operator|&&
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"m"
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"false"
argument_list|)
operator|)
operator|||
operator|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"min-move"
argument_list|)
operator|&&
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"min-move"
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"false"
argument_list|)
operator|)
condition|)
block|{
name|enforceMinAssignmentMove
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"zk"
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|HConstants
operator|.
name|ZOOKEEPER_QUORUM
argument_list|,
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"zk"
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting the zk quorum: "
operator|+
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|ZOOKEEPER_QUORUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"fs"
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|FileSystem
operator|.
name|FS_DEFAULT_NAME_KEY
argument_list|,
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"fs"
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting the HDFS: "
operator|+
name|conf
operator|.
name|get
argument_list|(
name|FileSystem
operator|.
name|FS_DEFAULT_NAME_KEY
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"hbase_root"
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|,
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"hbase_root"
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting the hbase root directory: "
operator|+
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create the region placement obj
try|try
init|(
name|RegionPlacementMaintainer
name|rp
init|=
operator|new
name|RegionPlacementMaintainer
argument_list|(
name|conf
argument_list|,
name|enforceLocality
argument_list|,
name|enforceMinAssignmentMove
argument_list|)
init|)
block|{
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"d"
argument_list|)
operator|||
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"verification-details"
argument_list|)
condition|)
block|{
name|verificationDetails
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"tables"
argument_list|)
condition|)
block|{
name|String
name|tableNameListStr
init|=
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"tables"
argument_list|)
decl_stmt|;
name|String
index|[]
name|tableNames
init|=
name|StringUtils
operator|.
name|split
argument_list|(
name|tableNameListStr
argument_list|,
literal|","
argument_list|)
decl_stmt|;
name|rp
operator|.
name|setTargetTableName
argument_list|(
name|tableNames
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"munkres"
argument_list|)
condition|)
block|{
name|USE_MUNKRES_FOR_PLACING_SECONDARY_AND_TERTIARY
operator|=
literal|true
expr_stmt|;
block|}
comment|// Read all the modes
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"v"
argument_list|)
operator|||
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"verify"
argument_list|)
condition|)
block|{
comment|// Verify the region placement.
name|rp
operator|.
name|verifyRegionPlacement
argument_list|(
name|verificationDetails
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"n"
argument_list|)
operator|||
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"dry-run"
argument_list|)
condition|)
block|{
comment|// Generate the assignment plan only without updating the hbase:meta and RS
name|FavoredNodesPlan
name|plan
init|=
name|rp
operator|.
name|getNewAssignmentPlan
argument_list|()
decl_stmt|;
name|printAssignmentPlan
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"w"
argument_list|)
operator|||
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"write"
argument_list|)
condition|)
block|{
comment|// Generate the new assignment plan
name|FavoredNodesPlan
name|plan
init|=
name|rp
operator|.
name|getNewAssignmentPlan
argument_list|()
decl_stmt|;
comment|// Print the new assignment plan
name|printAssignmentPlan
argument_list|(
name|plan
argument_list|)
expr_stmt|;
comment|// Write the new assignment plan to META
name|rp
operator|.
name|updateAssignmentPlanToMeta
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"u"
argument_list|)
operator|||
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"update"
argument_list|)
condition|)
block|{
comment|// Generate the new assignment plan
name|FavoredNodesPlan
name|plan
init|=
name|rp
operator|.
name|getNewAssignmentPlan
argument_list|()
decl_stmt|;
comment|// Print the new assignment plan
name|printAssignmentPlan
argument_list|(
name|plan
argument_list|)
expr_stmt|;
comment|// Update the assignment to hbase:meta and Region Servers
name|rp
operator|.
name|updateAssignmentPlan
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"diff"
argument_list|)
condition|)
block|{
name|FavoredNodesPlan
name|newPlan
init|=
name|rp
operator|.
name|getNewAssignmentPlan
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|>
name|locality
init|=
name|FSUtils
operator|.
name|getRegionDegreeLocalityMappingFromFS
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|TableName
argument_list|,
name|Integer
argument_list|>
name|movesPerTable
init|=
name|rp
operator|.
name|getRegionsMovement
argument_list|(
name|newPlan
argument_list|)
decl_stmt|;
name|rp
operator|.
name|checkDifferencesWithOldPlan
argument_list|(
name|movesPerTable
argument_list|,
name|locality
argument_list|,
name|newPlan
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Do you want to update the assignment plan? [y/n]"
argument_list|)
expr_stmt|;
name|Scanner
name|s
init|=
operator|new
name|Scanner
argument_list|(
name|System
operator|.
name|in
argument_list|)
decl_stmt|;
name|String
name|input
init|=
name|s
operator|.
name|nextLine
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|input
operator|.
name|equals
argument_list|(
literal|"y"
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Updating assignment plan..."
argument_list|)
expr_stmt|;
name|rp
operator|.
name|updateAssignmentPlan
argument_list|(
name|newPlan
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"ld"
argument_list|)
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|>
name|locality
init|=
name|FSUtils
operator|.
name|getRegionDegreeLocalityMappingFromFS
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|rp
operator|.
name|printLocalityAndDispersionForCurrentPlan
argument_list|(
name|locality
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"p"
argument_list|)
operator|||
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"print"
argument_list|)
condition|)
block|{
name|FavoredNodesPlan
name|plan
init|=
name|rp
operator|.
name|getRegionAssignmentSnapshot
argument_list|()
operator|.
name|getExistingAssignmentPlan
argument_list|()
decl_stmt|;
name|printAssignmentPlan
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"overwrite"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"f"
argument_list|)
operator|||
operator|!
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"r"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Please specify: "
operator|+
literal|" -update -r regionName -f server1:port,server2:port,server3:port"
argument_list|)
throw|;
block|}
name|String
name|regionName
init|=
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"r"
argument_list|)
decl_stmt|;
name|String
name|favoredNodesStr
init|=
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"f"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Going to update the region "
operator|+
name|regionName
operator|+
literal|" with the new favored nodes "
operator|+
name|favoredNodesStr
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
init|=
literal|null
decl_stmt|;
name|RegionInfo
name|regionInfo
init|=
name|rp
operator|.
name|getRegionAssignmentSnapshot
argument_list|()
operator|.
name|getRegionNameToRegionInfoMap
argument_list|()
operator|.
name|get
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionInfo
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot find the region "
operator|+
name|regionName
operator|+
literal|" from the META"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|favoredNodes
operator|=
name|getFavoredNodeList
argument_list|(
name|favoredNodesStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot parse the invalid favored nodes because "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
name|FavoredNodesPlan
name|newPlan
init|=
operator|new
name|FavoredNodesPlan
argument_list|()
decl_stmt|;
name|newPlan
operator|.
name|updateFavoredNodesMap
argument_list|(
name|regionInfo
argument_list|,
name|favoredNodes
argument_list|)
expr_stmt|;
name|rp
operator|.
name|updateAssignmentPlan
argument_list|(
name|newPlan
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printHelp
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
name|printHelp
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

