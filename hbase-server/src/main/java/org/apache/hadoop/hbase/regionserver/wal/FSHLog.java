begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLEncoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Syncable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|DrainBarrier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HasThread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cloudera
operator|.
name|htrace
operator|.
name|Trace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cloudera
operator|.
name|htrace
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * HLog stores all the edits to the HStore.  Its the hbase write-ahead-log  * implementation.  *  * It performs logfile-rolling, so external callers are not aware that the  * underlying file is being rolled.  *  *<p>  * There is one HLog per RegionServer.  All edits for all Regions carried by  * a particular RegionServer are entered first in the HLog.  *  *<p>  * Each HRegion is identified by a unique long<code>int</code>. HRegions do  * not need to declare themselves before using the HLog; they simply include  * their HRegion-id in the<code>append</code> or  *<code>completeCacheFlush</code> calls.  *  *<p>  * An HLog consists of multiple on-disk files, which have a chronological order.  * As data is flushed to other (better) on-disk structures, the log becomes  * obsolete. We can destroy all the log messages for a given HRegion-id up to  * the most-recent CACHEFLUSH message from that HRegion.  *  *<p>  * It's only practical to delete entire files. Thus, we delete an entire on-disk  * file F when all of the messages in F have a log-sequence-id that's older  * (smaller) than the most-recent CACHEFLUSH message for every HRegion that has  * a message in F.  *  *<p>  * Synchronized methods can never execute in parallel. However, between the  * start of a cache flush and the completion point, appends are allowed but log  * rolling is not. To prevent log rolling taking place during this period, a  * separate reentrant lock is used.  *  *<p>To read an HLog, call {@link HLogFactory#createReader(org.apache.hadoop.fs.FileSystem,  * org.apache.hadoop.fs.Path, org.apache.hadoop.conf.Configuration)}.  *  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
class|class
name|FSHLog
implements|implements
name|HLog
implements|,
name|Syncable
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSHLog
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|FileSystem
name|fs
decl_stmt|;
specifier|private
specifier|final
name|Path
name|rootDir
decl_stmt|;
specifier|private
specifier|final
name|Path
name|dir
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|// Listeners that are called on WAL events.
specifier|private
name|List
argument_list|<
name|WALActionsListener
argument_list|>
name|listeners
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|WALActionsListener
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|long
name|blocksize
decl_stmt|;
specifier|private
specifier|final
name|String
name|prefix
decl_stmt|;
specifier|private
specifier|final
name|AtomicLong
name|unflushedEntries
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicLong
name|syncedTillHere
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
name|long
name|lastDeferredTxid
decl_stmt|;
specifier|private
specifier|final
name|Path
name|oldLogDir
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|logRollRunning
decl_stmt|;
comment|// all writes pending on AsyncWriter/AsyncSyncer thread with
comment|// txid<= failedTxid will fail by throwing asyncIOE
specifier|private
specifier|final
name|AtomicLong
name|failedTxid
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|IOException
name|asyncIOE
init|=
literal|null
decl_stmt|;
specifier|private
name|WALCoprocessorHost
name|coprocessorHost
decl_stmt|;
specifier|private
name|FSDataOutputStream
name|hdfs_out
decl_stmt|;
comment|// FSDataOutputStream associated with the current SequenceFile.writer
comment|// Minimum tolerable replicas, if the actual value is lower than it,
comment|// rollWriter will be triggered
specifier|private
name|int
name|minTolerableReplication
decl_stmt|;
specifier|private
name|Method
name|getNumCurrentReplicas
decl_stmt|;
comment|// refers to DFSOutputStream.getNumCurrentReplicas
specifier|final
specifier|static
name|Object
index|[]
name|NO_ARGS
init|=
operator|new
name|Object
index|[]
block|{}
decl_stmt|;
comment|/** The barrier used to ensure that close() waits for all log rolls and flushes to finish. */
specifier|private
name|DrainBarrier
name|closeBarrier
init|=
operator|new
name|DrainBarrier
argument_list|()
decl_stmt|;
comment|/**    * Current log file.    */
name|Writer
name|writer
decl_stmt|;
comment|/**    * This lock synchronizes all operations on oldestUnflushedSeqNums and oldestFlushingSeqNums,    * with the exception of append's putIfAbsent into oldestUnflushedSeqNums.    * We only use these to find out the low bound seqNum, or to find regions with old seqNums to    * force flush them, so we don't care about these numbers messing with anything. */
specifier|private
specifier|final
name|Object
name|oldestSeqNumsLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|/**    * This lock makes sure only one log roll runs at the same time. Should not be taken while    * any other lock is held. We don't just use synchronized because that results in bogus and    * tedious findbugs warning when it thinks synchronized controls writer thread safety */
specifier|private
specifier|final
name|Object
name|rollWriterLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|/**    * Map of encoded region names to their most recent sequence/edit id in their memstore.    */
specifier|private
specifier|final
name|ConcurrentSkipListMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|oldestUnflushedSeqNums
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
comment|/**    * Map of encoded region names to their most recent sequence/edit id in their memstore;    * contains the regions that are currently flushing. That way we can store two numbers for    * flushing and non-flushing (oldestUnflushedSeqNums) memstore for the same region.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|oldestFlushingSeqNums
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|forMeta
init|=
literal|false
decl_stmt|;
comment|// The timestamp (in ms) when the log file was created.
specifier|private
specifier|volatile
name|long
name|filenum
init|=
operator|-
literal|1
decl_stmt|;
comment|//number of transactions in the current Hlog.
specifier|private
specifier|final
name|AtomicInteger
name|numEntries
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// If live datanode count is lower than the default replicas value,
comment|// RollWriter will be triggered in each sync(So the RollWriter will be
comment|// triggered one by one in a short time). Using it as a workaround to slow
comment|// down the roll frequency triggered by checkLowReplication().
specifier|private
name|AtomicInteger
name|consecutiveLogRolls
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|int
name|lowReplicationRollLimit
decl_stmt|;
comment|// If consecutiveLogRolls is larger than lowReplicationRollLimit,
comment|// then disable the rolling in checkLowReplication().
comment|// Enable it if the replications recover.
specifier|private
specifier|volatile
name|boolean
name|lowReplicationRollEnabled
init|=
literal|true
decl_stmt|;
comment|// If> than this size, roll the log. This is typically 0.95 times the size
comment|// of the default Hdfs block size.
specifier|private
specifier|final
name|long
name|logrollsize
decl_stmt|;
comment|/** size of current log */
specifier|private
name|long
name|curLogSize
init|=
literal|0
decl_stmt|;
comment|/**    * The total size of hlog    */
specifier|private
name|AtomicLong
name|totalLogSize
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// We synchronize on updateLock to prevent updates and to prevent a log roll
comment|// during an update
comment|// locked during appends
specifier|private
specifier|final
name|Object
name|updateLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Object
name|pendingWritesLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|enabled
decl_stmt|;
comment|/*    * If more than this many logs, force flush of oldest region to oldest edit    * goes to disk.  If too many and we crash, then will take forever replaying.    * Keep the number of logs tidy.    */
specifier|private
specifier|final
name|int
name|maxLogs
decl_stmt|;
comment|// List of pending writes to the HLog. There corresponds to transactions
comment|// that have not yet returned to the client. We keep them cached here
comment|// instead of writing them to HDFS piecemeal. The goal is to increase
comment|// the batchsize for writing-to-hdfs as well as sync-to-hdfs, so that
comment|// we can get better system throughput.
specifier|private
name|List
argument_list|<
name|Entry
argument_list|>
name|pendingWrites
init|=
operator|new
name|LinkedList
argument_list|<
name|Entry
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|AsyncWriter
name|asyncWriter
decl_stmt|;
comment|// since AsyncSyncer takes much longer than other phase(add WALEdits to local
comment|// buffer, write local buffer to HDFS, notify pending write handler threads),
comment|// when a sync is ongoing, all other phase pend, we use multiple parallel
comment|// AsyncSyncer threads to improve overall throughput.
specifier|private
specifier|final
name|AsyncSyncer
index|[]
name|asyncSyncers
decl_stmt|;
specifier|private
specifier|final
name|AsyncNotifier
name|asyncNotifier
decl_stmt|;
comment|/** Number of log close errors tolerated before we abort */
specifier|private
specifier|final
name|int
name|closeErrorsTolerated
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|closeErrorCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|MetricsWAL
name|metrics
decl_stmt|;
comment|/**  * Map of region encoded names to the latest sequence num obtained from them while appending  * WALEdits to the wal. We create one map for each WAL file at the time it is rolled.  *<p>  * When deciding whether to archive a WAL file, we compare the sequence IDs in this map to  * {@link #oldestFlushingSeqNums} and {@link #oldestUnflushedSeqNums}.  * See {@link FSHLog#areAllRegionsFlushed(Map, Map, Map)} for more info.  *<p>  * This map uses byte[] as the key, and uses reference equality. It works in our use case as we  * use {@link HRegionInfo#getEncodedNameAsBytes()} as keys. For a given region, it always returns  * the same array.  */
specifier|private
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|latestSequenceNums
init|=
operator|new
name|HashMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * WAL Comparator; it compares the timestamp (log filenum), present in the log file name.    */
specifier|public
specifier|final
name|Comparator
argument_list|<
name|Path
argument_list|>
name|LOG_NAME_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|Path
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Path
name|o1
parameter_list|,
name|Path
name|o2
parameter_list|)
block|{
name|long
name|t1
init|=
name|getFileNumFromFileName
argument_list|(
name|o1
argument_list|)
decl_stmt|;
name|long
name|t2
init|=
name|getFileNumFromFileName
argument_list|(
name|o2
argument_list|)
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|t1
operator|>
name|t2
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Map of log file to the latest sequence nums of all regions it has entries of.    * The map is sorted by the log file creation timestamp (contained in the log file name).    */
specifier|private
name|NavigableMap
argument_list|<
name|Path
argument_list|,
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
argument_list|>
name|hlogSequenceNums
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|Path
argument_list|,
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|(
name|LOG_NAME_COMPARATOR
argument_list|)
decl_stmt|;
comment|/**    * Constructor.    *    * @param fs filesystem handle    * @param root path for stored and archived hlogs    * @param logDir dir where hlogs are stored    * @param conf configuration to use    * @throws IOException    */
specifier|public
name|FSHLog
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|root
parameter_list|,
specifier|final
name|String
name|logDir
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|root
argument_list|,
name|logDir
argument_list|,
name|HConstants
operator|.
name|HREGION_OLDLOGDIR_NAME
argument_list|,
name|conf
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor.    *    * @param fs filesystem handle    * @param root path for stored and archived hlogs    * @param logDir dir where hlogs are stored    * @param oldLogDir dir where hlogs are archived    * @param conf configuration to use    * @throws IOException    */
specifier|public
name|FSHLog
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|root
parameter_list|,
specifier|final
name|String
name|logDir
parameter_list|,
specifier|final
name|String
name|oldLogDir
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|root
argument_list|,
name|logDir
argument_list|,
name|oldLogDir
argument_list|,
name|conf
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create an edit log at the given<code>dir</code> location.    *    * You should never have to load an existing log. If there is a log at    * startup, it should have already been processed and deleted by the time the    * HLog object is started up.    *    * @param fs filesystem handle    * @param root path for stored and archived hlogs    * @param logDir dir where hlogs are stored    * @param conf configuration to use    * @param listeners Listeners on WAL events. Listeners passed here will    * be registered before we do anything else; e.g. the    * Constructor {@link #rollWriter()}.    * @param prefix should always be hostname and port in distributed env and    *        it will be URL encoded before being used.    *        If prefix is null, "hlog" will be used    * @throws IOException    */
specifier|public
name|FSHLog
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|root
parameter_list|,
specifier|final
name|String
name|logDir
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|List
argument_list|<
name|WALActionsListener
argument_list|>
name|listeners
parameter_list|,
specifier|final
name|String
name|prefix
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|root
argument_list|,
name|logDir
argument_list|,
name|HConstants
operator|.
name|HREGION_OLDLOGDIR_NAME
argument_list|,
name|conf
argument_list|,
name|listeners
argument_list|,
literal|true
argument_list|,
name|prefix
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create an edit log at the given<code>dir</code> location.    *    * You should never have to load an existing log. If there is a log at    * startup, it should have already been processed and deleted by the time the    * HLog object is started up.    *    * @param fs filesystem handle    * @param root path to where logs and oldlogs    * @param logDir dir where hlogs are stored    * @param oldLogDir dir where hlogs are archived    * @param conf configuration to use    * @param listeners Listeners on WAL events. Listeners passed here will    * be registered before we do anything else; e.g. the    * Constructor {@link #rollWriter()}.    * @param failIfLogDirExists If true IOException will be thrown if dir already exists.    * @param prefix should always be hostname and port in distributed env and    *        it will be URL encoded before being used.    *        If prefix is null, "hlog" will be used    * @param forMeta if this hlog is meant for meta updates    * @throws IOException    */
specifier|public
name|FSHLog
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|root
parameter_list|,
specifier|final
name|String
name|logDir
parameter_list|,
specifier|final
name|String
name|oldLogDir
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|List
argument_list|<
name|WALActionsListener
argument_list|>
name|listeners
parameter_list|,
specifier|final
name|boolean
name|failIfLogDirExists
parameter_list|,
specifier|final
name|String
name|prefix
parameter_list|,
name|boolean
name|forMeta
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|rootDir
operator|=
name|root
expr_stmt|;
name|this
operator|.
name|dir
operator|=
operator|new
name|Path
argument_list|(
name|this
operator|.
name|rootDir
argument_list|,
name|logDir
argument_list|)
expr_stmt|;
name|this
operator|.
name|oldLogDir
operator|=
operator|new
name|Path
argument_list|(
name|this
operator|.
name|rootDir
argument_list|,
name|oldLogDir
argument_list|)
expr_stmt|;
name|this
operator|.
name|forMeta
operator|=
name|forMeta
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
if|if
condition|(
name|listeners
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|WALActionsListener
name|i
range|:
name|listeners
control|)
block|{
name|registerWALActionsListener
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|blocksize
operator|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.hlog.blocksize"
argument_list|,
name|FSUtils
operator|.
name|getDefaultBlockSize
argument_list|(
name|this
operator|.
name|fs
argument_list|,
name|this
operator|.
name|dir
argument_list|)
argument_list|)
expr_stmt|;
comment|// Roll at 95% of block size.
name|float
name|multi
init|=
name|conf
operator|.
name|getFloat
argument_list|(
literal|"hbase.regionserver.logroll.multiplier"
argument_list|,
literal|0.95f
argument_list|)
decl_stmt|;
name|this
operator|.
name|logrollsize
operator|=
call|(
name|long
call|)
argument_list|(
name|this
operator|.
name|blocksize
operator|*
name|multi
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxLogs
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.maxlogs"
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|this
operator|.
name|minTolerableReplication
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.hlog.tolerable.lowreplication"
argument_list|,
name|FSUtils
operator|.
name|getDefaultReplication
argument_list|(
name|fs
argument_list|,
name|this
operator|.
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|lowReplicationRollLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.hlog.lowreplication.rolllimit"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|this
operator|.
name|enabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.regionserver.hlog.enabled"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|closeErrorsTolerated
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.logroll.errors.tolerated"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"WAL/HLog configuration: blocksize="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|this
operator|.
name|blocksize
argument_list|)
operator|+
literal|", rollsize="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|this
operator|.
name|logrollsize
argument_list|)
operator|+
literal|", enabled="
operator|+
name|this
operator|.
name|enabled
argument_list|)
expr_stmt|;
comment|// If prefix is null||empty then just name it hlog
name|this
operator|.
name|prefix
operator|=
name|prefix
operator|==
literal|null
operator|||
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"hlog"
else|:
name|URLEncoder
operator|.
name|encode
argument_list|(
name|prefix
argument_list|,
literal|"UTF8"
argument_list|)
expr_stmt|;
name|boolean
name|dirExists
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|failIfLogDirExists
operator|&&
operator|(
name|dirExists
operator|=
name|this
operator|.
name|fs
operator|.
name|exists
argument_list|(
name|dir
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Target HLog directory already exists: "
operator|+
name|dir
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|dirExists
operator|&&
operator|!
name|fs
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to mkdir "
operator|+
name|dir
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|this
operator|.
name|oldLogDir
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fs
operator|.
name|mkdirs
argument_list|(
name|this
operator|.
name|oldLogDir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to mkdir "
operator|+
name|this
operator|.
name|oldLogDir
argument_list|)
throw|;
block|}
block|}
comment|// rollWriter sets this.hdfs_out if it can.
name|rollWriter
argument_list|()
expr_stmt|;
comment|// handle the reflection necessary to call getNumCurrentReplicas()
name|this
operator|.
name|getNumCurrentReplicas
operator|=
name|getGetNumCurrentReplicas
argument_list|(
name|this
operator|.
name|hdfs_out
argument_list|)
expr_stmt|;
specifier|final
name|String
name|n
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|asyncWriter
operator|=
operator|new
name|AsyncWriter
argument_list|(
name|n
operator|+
literal|"-WAL.AsyncWriter"
argument_list|)
expr_stmt|;
name|asyncWriter
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|syncerNums
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.hlog.asyncer.number"
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|asyncSyncers
operator|=
operator|new
name|AsyncSyncer
index|[
name|syncerNums
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|asyncSyncers
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|asyncSyncers
index|[
name|i
index|]
operator|=
operator|new
name|AsyncSyncer
argument_list|(
name|n
operator|+
literal|"-WAL.AsyncSyncer"
operator|+
name|i
argument_list|)
expr_stmt|;
name|asyncSyncers
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|asyncNotifier
operator|=
operator|new
name|AsyncNotifier
argument_list|(
name|n
operator|+
literal|"-WAL.AsyncNotifier"
argument_list|)
expr_stmt|;
name|asyncNotifier
operator|.
name|start
argument_list|()
expr_stmt|;
name|coprocessorHost
operator|=
operator|new
name|WALCoprocessorHost
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
operator|new
name|MetricsWAL
argument_list|()
expr_stmt|;
block|}
comment|/**    * Find the 'getNumCurrentReplicas' on the passed<code>os</code> stream.    * @return Method or null.    */
specifier|private
name|Method
name|getGetNumCurrentReplicas
parameter_list|(
specifier|final
name|FSDataOutputStream
name|os
parameter_list|)
block|{
name|Method
name|m
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|os
operator|!=
literal|null
condition|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|OutputStream
argument_list|>
name|wrappedStreamClass
init|=
name|os
operator|.
name|getWrappedStream
argument_list|()
operator|.
name|getClass
argument_list|()
decl_stmt|;
try|try
block|{
name|m
operator|=
name|wrappedStreamClass
operator|.
name|getDeclaredMethod
argument_list|(
literal|"getNumCurrentReplicas"
argument_list|,
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{}
block|)
empty_stmt|;
name|m
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"FileSystem's output stream doesn't support"
operator|+
literal|" getNumCurrentReplicas; --HDFS-826 not available; fsOut="
operator|+
name|wrappedStreamClass
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Doesn't have access to getNumCurrentReplicas on "
operator|+
literal|"FileSystems's output stream --HDFS-826 not available; fsOut="
operator|+
name|wrappedStreamClass
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|m
operator|=
literal|null
expr_stmt|;
comment|// could happen on setAccessible()
block|}
block|}
if|if
condition|(
name|m
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"Using getNumCurrentReplicas--HDFS-826"
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_class

begin_function
annotation|@
name|Override
specifier|public
name|void
name|registerWALActionsListener
parameter_list|(
specifier|final
name|WALActionsListener
name|listener
parameter_list|)
block|{
name|this
operator|.
name|listeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|unregisterWALActionsListener
parameter_list|(
specifier|final
name|WALActionsListener
name|listener
parameter_list|)
block|{
return|return
name|this
operator|.
name|listeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|long
name|getFilenum
parameter_list|()
block|{
return|return
name|this
operator|.
name|filenum
return|;
block|}
end_function

begin_comment
comment|/**    * Method used internal to this class and for tests only.    * @return The wrapped stream our writer is using; its not the    * writer's 'out' FSDatoOutputStream but the stream that this 'out' wraps    * (In hdfs its an instance of DFSDataOutputStream).    *    * usage: see TestLogRolling.java    */
end_comment

begin_function
name|OutputStream
name|getOutputStream
parameter_list|()
block|{
return|return
name|this
operator|.
name|hdfs_out
operator|.
name|getWrappedStream
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|byte
index|[]
index|[]
name|rollWriter
parameter_list|()
throws|throws
name|FailedLogCloseException
throws|,
name|IOException
block|{
return|return
name|rollWriter
argument_list|(
literal|false
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|byte
index|[]
index|[]
name|rollWriter
parameter_list|(
name|boolean
name|force
parameter_list|)
throws|throws
name|FailedLogCloseException
throws|,
name|IOException
block|{
synchronized|synchronized
init|(
name|rollWriterLock
init|)
block|{
comment|// Return if nothing to flush.
if|if
condition|(
operator|!
name|force
operator|&&
name|this
operator|.
name|writer
operator|!=
literal|null
operator|&&
name|this
operator|.
name|numEntries
operator|.
name|get
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|byte
index|[]
index|[]
name|regionsToFlush
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|closed
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"HLog closed. Skipping rolling of writer"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
try|try
block|{
name|this
operator|.
name|logRollRunning
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|closeBarrier
operator|.
name|beginOp
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"HLog closing. Skipping rolling of writer"
argument_list|)
expr_stmt|;
return|return
name|regionsToFlush
return|;
block|}
comment|// Do all the preparation outside of the updateLock to block
comment|// as less as possible the incoming writes
name|long
name|currentFilenum
init|=
name|this
operator|.
name|filenum
decl_stmt|;
name|Path
name|oldPath
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|currentFilenum
operator|>
literal|0
condition|)
block|{
comment|//computeFilename  will take care of meta hlog filename
name|oldPath
operator|=
name|computeFilename
argument_list|(
name|currentFilenum
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|filenum
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|Path
name|newPath
init|=
name|computeFilename
argument_list|()
decl_stmt|;
while|while
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|newPath
argument_list|)
condition|)
block|{
name|this
operator|.
name|filenum
operator|++
expr_stmt|;
name|newPath
operator|=
name|computeFilename
argument_list|()
expr_stmt|;
block|}
comment|// Tell our listeners that a new log is about to be created
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|WALActionsListener
name|i
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|i
operator|.
name|preLogRoll
argument_list|(
name|oldPath
argument_list|,
name|newPath
argument_list|)
expr_stmt|;
block|}
block|}
name|FSHLog
operator|.
name|Writer
name|nextWriter
init|=
name|this
operator|.
name|createWriterInstance
argument_list|(
name|fs
argument_list|,
name|newPath
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// Can we get at the dfsclient outputstream?
name|FSDataOutputStream
name|nextHdfsOut
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nextWriter
operator|instanceof
name|ProtobufLogWriter
condition|)
block|{
name|nextHdfsOut
operator|=
operator|(
operator|(
name|ProtobufLogWriter
operator|)
name|nextWriter
operator|)
operator|.
name|getStream
argument_list|()
expr_stmt|;
comment|// perform the costly sync before we get the lock to roll writers.
try|try
block|{
name|nextWriter
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// optimization failed, no need to abort here.
name|LOG
operator|.
name|warn
argument_list|(
literal|"pre-sync failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|Path
name|oldFile
init|=
literal|null
decl_stmt|;
name|int
name|oldNumEntries
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|updateLock
init|)
block|{
comment|// Clean up current writer.
name|oldNumEntries
operator|=
name|this
operator|.
name|numEntries
operator|.
name|get
argument_list|()
expr_stmt|;
name|oldFile
operator|=
name|cleanupCurrentWriter
argument_list|(
name|currentFilenum
argument_list|)
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|nextWriter
expr_stmt|;
name|this
operator|.
name|hdfs_out
operator|=
name|nextHdfsOut
expr_stmt|;
name|this
operator|.
name|numEntries
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldFile
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|hlogSequenceNums
operator|.
name|put
argument_list|(
name|oldFile
argument_list|,
name|this
operator|.
name|latestSequenceNums
argument_list|)
expr_stmt|;
name|this
operator|.
name|latestSequenceNums
operator|=
operator|new
name|HashMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldFile
operator|==
literal|null
condition|)
name|LOG
operator|.
name|info
argument_list|(
literal|"New WAL "
operator|+
name|FSUtils
operator|.
name|getPath
argument_list|(
name|newPath
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|long
name|oldFileLen
init|=
name|this
operator|.
name|fs
operator|.
name|getFileStatus
argument_list|(
name|oldFile
argument_list|)
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|this
operator|.
name|totalLogSize
operator|.
name|addAndGet
argument_list|(
name|oldFileLen
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Rolled WAL "
operator|+
name|FSUtils
operator|.
name|getPath
argument_list|(
name|oldFile
argument_list|)
operator|+
literal|" with entries="
operator|+
name|oldNumEntries
operator|+
literal|", filesize="
operator|+
name|StringUtils
operator|.
name|humanReadableInt
argument_list|(
name|oldFileLen
argument_list|)
operator|+
literal|"; new WAL "
operator|+
name|FSUtils
operator|.
name|getPath
argument_list|(
name|newPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Tell our listeners that a new log was created
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|WALActionsListener
name|i
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|i
operator|.
name|postLogRoll
argument_list|(
name|oldPath
argument_list|,
name|newPath
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Can we delete any of the old log files?
if|if
condition|(
name|getNumRolledLogFiles
argument_list|()
operator|>
literal|0
condition|)
block|{
name|cleanOldLogs
argument_list|()
expr_stmt|;
name|regionsToFlush
operator|=
name|findRegionsToForceFlush
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|logRollRunning
operator|=
literal|false
expr_stmt|;
name|closeBarrier
operator|.
name|endOp
argument_list|()
expr_stmt|;
block|}
return|return
name|regionsToFlush
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * This method allows subclasses to inject different writers without having to    * extend other methods like rollWriter().    *    * @param fs    * @param path    * @param conf    * @return Writer instance    * @throws IOException    */
end_comment

begin_function
specifier|protected
name|Writer
name|createWriterInstance
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|forMeta
condition|)
block|{
comment|//TODO: set a higher replication for the hlog files (HBASE-6773)
block|}
return|return
name|HLogFactory
operator|.
name|createWALWriter
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|conf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Archive old logs that could be archived: a log is eligible for archiving if all its WALEdits    * are already flushed by the corresponding regions.    *<p>    * For each log file, it compares its region to sequenceId map    * (@link {@link FSHLog#latestSequenceNums} with corresponding region entries in    * {@link FSHLog#oldestFlushingSeqNums} and {@link FSHLog#oldestUnflushedSeqNums}.    * If all the regions in the map are flushed past of their value, then the wal is eligible for    * archiving.    * @throws IOException    */
end_comment

begin_function
specifier|private
name|void
name|cleanOldLogs
parameter_list|()
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|oldestFlushingSeqNumsLocal
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|oldestUnflushedSeqNumsLocal
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|logsToArchive
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
comment|// make a local copy so as to avoid locking when we iterate over these maps.
synchronized|synchronized
init|(
name|oldestSeqNumsLock
init|)
block|{
name|oldestFlushingSeqNumsLocal
operator|=
operator|new
name|HashMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
argument_list|(
name|this
operator|.
name|oldestFlushingSeqNums
argument_list|)
expr_stmt|;
name|oldestUnflushedSeqNumsLocal
operator|=
operator|new
name|HashMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
argument_list|(
name|this
operator|.
name|oldestUnflushedSeqNums
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
argument_list|>
name|e
range|:
name|hlogSequenceNums
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// iterate over the log file.
name|Path
name|log
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|sequenceNums
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// iterate over the map for this log file, and tell whether it should be archive or not.
if|if
condition|(
name|areAllRegionsFlushed
argument_list|(
name|sequenceNums
argument_list|,
name|oldestFlushingSeqNumsLocal
argument_list|,
name|oldestUnflushedSeqNumsLocal
argument_list|)
condition|)
block|{
name|logsToArchive
operator|.
name|add
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"log file is ready for archiving "
operator|+
name|log
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Path
name|p
range|:
name|logsToArchive
control|)
block|{
name|this
operator|.
name|totalLogSize
operator|.
name|addAndGet
argument_list|(
operator|-
name|this
operator|.
name|fs
operator|.
name|getFileStatus
argument_list|(
name|p
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|archiveLogFile
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|this
operator|.
name|hlogSequenceNums
operator|.
name|remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Takes a region:sequenceId map for a WAL file, and checks whether the file can be archived.    * It compares the region entries present in the passed sequenceNums map with the local copy of    * {@link #oldestUnflushedSeqNums} and {@link #oldestFlushingSeqNums}. If, for all regions,    * the value is lesser than the minimum of values present in the oldestFlushing/UnflushedSeqNums,    * then the wal file is eligible for archiving.    * @param sequenceNums for a HLog, at the time when it was rolled.    * @param oldestFlushingMap    * @param oldestUnflushedMap    * @return true if wal is eligible for archiving, false otherwise.    */
end_comment

begin_function
specifier|static
name|boolean
name|areAllRegionsFlushed
parameter_list|(
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|sequenceNums
parameter_list|,
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|oldestFlushingMap
parameter_list|,
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|oldestUnflushedMap
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|regionSeqIdEntry
range|:
name|sequenceNums
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// find region entries in the flushing/unflushed map. If there is no entry, it means
comment|// a region doesn't have any unflushed entry.
name|long
name|oldestFlushing
init|=
name|oldestFlushingMap
operator|.
name|containsKey
argument_list|(
name|regionSeqIdEntry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|?
name|oldestFlushingMap
operator|.
name|get
argument_list|(
name|regionSeqIdEntry
operator|.
name|getKey
argument_list|()
argument_list|)
else|:
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|long
name|oldestUnFlushed
init|=
name|oldestUnflushedMap
operator|.
name|containsKey
argument_list|(
name|regionSeqIdEntry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|?
name|oldestUnflushedMap
operator|.
name|get
argument_list|(
name|regionSeqIdEntry
operator|.
name|getKey
argument_list|()
argument_list|)
else|:
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
comment|// do a minimum to be sure to contain oldest sequence Id
name|long
name|minSeqNum
init|=
name|Math
operator|.
name|min
argument_list|(
name|oldestFlushing
argument_list|,
name|oldestUnFlushed
argument_list|)
decl_stmt|;
if|if
condition|(
name|minSeqNum
operator|<=
name|regionSeqIdEntry
operator|.
name|getValue
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// can't archive
block|}
return|return
literal|true
return|;
block|}
end_function

begin_comment
comment|/**    * Iterates over the given map of regions, and compares their sequence numbers with corresponding    * entries in {@link #oldestUnflushedSeqNums}. If the sequence number is greater or equal, the    * region is eligible to flush, otherwise, there is no benefit to flush (from the perspective of    * passed regionsSequenceNums map), because the region has already flushed the entries present    * in the WAL file for which this method is called for (typically, the oldest wal file).    * @param regionsSequenceNums    * @return regions which should be flushed (whose sequence numbers are larger than their    * corresponding un-flushed entries.    */
end_comment

begin_function
specifier|private
name|byte
index|[]
index|[]
name|findEligibleMemstoresToFlush
parameter_list|(
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|regionsSequenceNums
parameter_list|)
block|{
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|regionsToFlush
init|=
literal|null
decl_stmt|;
comment|// Keeping the old behavior of iterating unflushedSeqNums under oldestSeqNumsLock.
synchronized|synchronized
init|(
name|oldestSeqNumsLock
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|e
range|:
name|regionsSequenceNums
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Long
name|unFlushedVal
init|=
name|this
operator|.
name|oldestUnflushedSeqNums
operator|.
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|unFlushedVal
operator|!=
literal|null
operator|&&
name|unFlushedVal
operator|<=
name|e
operator|.
name|getValue
argument_list|()
condition|)
block|{
if|if
condition|(
name|regionsToFlush
operator|==
literal|null
condition|)
name|regionsToFlush
operator|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
expr_stmt|;
name|regionsToFlush
operator|.
name|add
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|regionsToFlush
operator|==
literal|null
condition|?
literal|null
else|:
name|regionsToFlush
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[]
index|[]
block|{
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
block|}
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * If the number of un-archived WAL files is greater than maximum allowed, it checks    * the first (oldest) WAL file, and returns the regions which should be flushed so that it could    * be archived.    * @return regions to flush in order to archive oldest wal file.    * @throws IOException    */
end_comment

begin_function
name|byte
index|[]
index|[]
name|findRegionsToForceFlush
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
index|[]
name|regions
init|=
literal|null
decl_stmt|;
name|int
name|logCount
init|=
name|getNumRolledLogFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|logCount
operator|>
name|this
operator|.
name|maxLogs
operator|&&
name|logCount
operator|>
literal|0
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
argument_list|>
name|firstWALEntry
init|=
name|this
operator|.
name|hlogSequenceNums
operator|.
name|firstEntry
argument_list|()
decl_stmt|;
name|regions
operator|=
name|findEligibleMemstoresToFlush
argument_list|(
name|firstWALEntry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regions
operator|!=
literal|null
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regions
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Too many hlogs: logs="
operator|+
name|logCount
operator|+
literal|", maxlogs="
operator|+
name|this
operator|.
name|maxLogs
operator|+
literal|"; forcing flush of "
operator|+
name|regions
operator|.
name|length
operator|+
literal|" regions(s): "
operator|+
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|regions
return|;
block|}
end_function

begin_comment
comment|/*    * Cleans up current writer closing.    * Presumes we're operating inside an updateLock scope.    * @return Path to current writer or null if none.    * @throws IOException    */
end_comment

begin_function
name|Path
name|cleanupCurrentWriter
parameter_list|(
specifier|final
name|long
name|currentfilenum
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|oldFile
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|writer
operator|!=
literal|null
condition|)
block|{
comment|// Close the current writer, get a new one.
try|try
block|{
comment|// Wait till all current transactions are written to the hlog.
comment|// No new transactions can occur because we have the updatelock.
if|if
condition|(
name|this
operator|.
name|unflushedEntries
operator|.
name|get
argument_list|()
operator|!=
name|this
operator|.
name|syncedTillHere
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"cleanupCurrentWriter "
operator|+
literal|" waiting for transactions to get synced "
operator|+
literal|" total "
operator|+
name|this
operator|.
name|unflushedEntries
operator|.
name|get
argument_list|()
operator|+
literal|" synced till here "
operator|+
name|this
operator|.
name|syncedTillHere
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|writer
operator|=
literal|null
expr_stmt|;
name|closeErrorCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed close of HLog writer"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|int
name|errors
init|=
name|closeErrorCount
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|errors
operator|<=
name|closeErrorsTolerated
operator|&&
operator|!
name|hasDeferredEntries
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Riding over HLog close failure! error count="
operator|+
name|errors
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hasDeferredEntries
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Aborting due to unflushed edits in HLog"
argument_list|)
expr_stmt|;
block|}
comment|// Failed close of log file.  Means we're losing edits.  For now,
comment|// shut ourselves down to minimize loss.  Alternative is to try and
comment|// keep going.  See HBASE-930.
name|FailedLogCloseException
name|flce
init|=
operator|new
name|FailedLogCloseException
argument_list|(
literal|"#"
operator|+
name|currentfilenum
argument_list|)
decl_stmt|;
name|flce
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|flce
throw|;
block|}
block|}
if|if
condition|(
name|currentfilenum
operator|>=
literal|0
condition|)
block|{
name|oldFile
operator|=
name|computeFilename
argument_list|(
name|currentfilenum
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|oldFile
return|;
block|}
end_function

begin_function
specifier|private
name|void
name|archiveLogFile
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|newPath
init|=
name|getHLogArchivePath
argument_list|(
name|this
operator|.
name|oldLogDir
argument_list|,
name|p
argument_list|)
decl_stmt|;
comment|// Tell our listeners that a log is going to be archived.
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|WALActionsListener
name|i
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|i
operator|.
name|preLogArchive
argument_list|(
name|p
argument_list|,
name|newPath
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|FSUtils
operator|.
name|renameAndSetModifyTime
argument_list|(
name|this
operator|.
name|fs
argument_list|,
name|p
argument_list|,
name|newPath
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to rename "
operator|+
name|p
operator|+
literal|" to "
operator|+
name|newPath
argument_list|)
throw|;
block|}
comment|// Tell our listeners that a log has been archived.
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|WALActionsListener
name|i
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|i
operator|.
name|postLogArchive
argument_list|(
name|p
argument_list|,
name|newPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**    * This is a convenience method that computes a new filename with a given    * using the current HLog file-number    * @return Path    */
end_comment

begin_function
specifier|protected
name|Path
name|computeFilename
parameter_list|()
block|{
return|return
name|computeFilename
argument_list|(
name|this
operator|.
name|filenum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * This is a convenience method that computes a new filename with a given    * file-number.    * @param filenum to use    * @return Path    */
end_comment

begin_function
specifier|protected
name|Path
name|computeFilename
parameter_list|(
name|long
name|filenum
parameter_list|)
block|{
if|if
condition|(
name|filenum
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"hlog file number can't be< 0"
argument_list|)
throw|;
block|}
name|String
name|child
init|=
name|prefix
operator|+
literal|"."
operator|+
name|filenum
decl_stmt|;
if|if
condition|(
name|forMeta
condition|)
block|{
name|child
operator|+=
name|HLog
operator|.
name|META_HLOG_FILE_EXTN
expr_stmt|;
block|}
return|return
operator|new
name|Path
argument_list|(
name|dir
argument_list|,
name|child
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * A log file has a creation timestamp (in ms) in its file name ({@link #filenum}.  * This helper method returns the creation timestamp from a given log file.  * It extracts the timestamp assuming the filename is created with the  * {@link #computeFilename(long filenum)} method.  * @param fileName  * @return timestamp, as in the log file name.  */
end_comment

begin_function
specifier|protected
name|long
name|getFileNumFromFileName
parameter_list|(
name|Path
name|fileName
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"file name can't be null"
argument_list|)
throw|;
comment|// The path should start with dir/<prefix>.
name|String
name|prefixPathStr
init|=
operator|new
name|Path
argument_list|(
name|dir
argument_list|,
name|prefix
operator|+
literal|"."
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fileName
operator|.
name|toString
argument_list|()
operator|.
name|startsWith
argument_list|(
name|prefixPathStr
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The log file "
operator|+
name|fileName
operator|+
literal|" doesn't belong to"
operator|+
literal|" this regionserver "
operator|+
name|prefixPathStr
argument_list|)
throw|;
block|}
name|String
name|chompedPath
init|=
name|fileName
operator|.
name|toString
argument_list|()
operator|.
name|substring
argument_list|(
name|prefixPathStr
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|forMeta
condition|)
name|chompedPath
operator|=
name|chompedPath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|chompedPath
operator|.
name|indexOf
argument_list|(
name|META_HLOG_FILE_EXTN
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|chompedPath
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|closeAndDelete
parameter_list|()
throws|throws
name|IOException
block|{
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|this
operator|.
name|dir
argument_list|)
condition|)
return|return;
name|FileStatus
index|[]
name|files
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|this
operator|.
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FileStatus
name|file
range|:
name|files
control|)
block|{
name|Path
name|p
init|=
name|getHLogArchivePath
argument_list|(
name|this
operator|.
name|oldLogDir
argument_list|,
name|file
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
comment|// Tell our listeners that a log is going to be archived.
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|WALActionsListener
name|i
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|i
operator|.
name|preLogArchive
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|FSUtils
operator|.
name|renameAndSetModifyTime
argument_list|(
name|fs
argument_list|,
name|file
operator|.
name|getPath
argument_list|()
argument_list|,
name|p
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to rename "
operator|+
name|file
operator|.
name|getPath
argument_list|()
operator|+
literal|" to "
operator|+
name|p
argument_list|)
throw|;
block|}
comment|// Tell our listeners that a log was archived.
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|WALActionsListener
name|i
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|i
operator|.
name|postLogArchive
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Moved "
operator|+
name|files
operator|.
name|length
operator|+
literal|" WAL file(s) to "
operator|+
name|FSUtils
operator|.
name|getPath
argument_list|(
name|this
operator|.
name|oldLogDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fs
operator|.
name|delete
argument_list|(
name|dir
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unable to delete "
operator|+
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
block|{
return|return;
block|}
try|try
block|{
name|asyncNotifier
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|asyncNotifier
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while waiting for "
operator|+
name|asyncNotifier
operator|.
name|getName
argument_list|()
operator|+
literal|" threads to die"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|asyncSyncers
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
try|try
block|{
name|asyncSyncers
index|[
name|i
index|]
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|asyncSyncers
index|[
name|i
index|]
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while waiting for "
operator|+
name|asyncSyncers
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
operator|+
literal|" threads to die"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|asyncWriter
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|asyncWriter
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while waiting for "
operator|+
name|asyncWriter
operator|.
name|getName
argument_list|()
operator|+
literal|" thread to die"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|// Prevent all further flushing and rolling.
name|closeBarrier
operator|.
name|stopAndDrainOps
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while waiting for cache flushes and log rolls"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|// Tell our listeners that the log is closing
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|WALActionsListener
name|i
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|i
operator|.
name|logCloseRequested
argument_list|()
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|updateLock
init|)
block|{
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closing WAL writer in "
operator|+
name|this
operator|.
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|writer
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|writer
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**    * @param now    * @param encodedRegionName Encoded name of the region as returned by    *<code>HRegionInfo#getEncodedNameAsBytes()</code>.    * @param tableName    * @param clusterIds that have consumed the change    * @return New log key.    */
end_comment

begin_function
specifier|protected
name|HLogKey
name|makeKey
parameter_list|(
name|byte
index|[]
name|encodedRegionName
parameter_list|,
name|TableName
name|tableName
parameter_list|,
name|long
name|seqnum
parameter_list|,
name|long
name|now
parameter_list|,
name|List
argument_list|<
name|UUID
argument_list|>
name|clusterIds
parameter_list|,
name|long
name|nonceGroup
parameter_list|,
name|long
name|nonce
parameter_list|)
block|{
return|return
operator|new
name|HLogKey
argument_list|(
name|encodedRegionName
argument_list|,
name|tableName
argument_list|,
name|seqnum
argument_list|,
name|now
argument_list|,
name|clusterIds
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|append
parameter_list|(
name|HRegionInfo
name|info
parameter_list|,
name|TableName
name|tableName
parameter_list|,
name|WALEdit
name|edits
parameter_list|,
specifier|final
name|long
name|now
parameter_list|,
name|HTableDescriptor
name|htd
parameter_list|,
name|AtomicLong
name|sequenceId
parameter_list|)
throws|throws
name|IOException
block|{
name|append
argument_list|(
name|info
argument_list|,
name|tableName
argument_list|,
name|edits
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|UUID
argument_list|>
argument_list|()
argument_list|,
name|now
argument_list|,
name|htd
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|sequenceId
argument_list|,
name|HConstants
operator|.
name|NO_NONCE
argument_list|,
name|HConstants
operator|.
name|NO_NONCE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Append a set of edits to the log. Log edits are keyed by (encoded)    * regionName, rowname, and log-sequence-id.    *    * Later, if we sort by these keys, we obtain all the relevant edits for a    * given key-range of the HRegion (TODO). Any edits that do not have a    * matching COMPLETE_CACHEFLUSH message can be discarded.    *    *<p>    * Logs cannot be restarted once closed, or once the HLog process dies. Each    * time the HLog starts, it must create a new log. This means that other    * systems should process the log appropriately upon each startup (and prior    * to initializing HLog).    *    * synchronized prevents appends during the completion of a cache flush or for    * the duration of a log roll.    *    * @param info    * @param tableName    * @param edits    * @param clusterIds that have consumed the change (for replication)    * @param now    * @param doSync shall we sync?    * @param sequenceId of the region.    * @return txid of this transaction    * @throws IOException    */
end_comment

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|private
name|long
name|append
parameter_list|(
name|HRegionInfo
name|info
parameter_list|,
name|TableName
name|tableName
parameter_list|,
name|WALEdit
name|edits
parameter_list|,
name|List
argument_list|<
name|UUID
argument_list|>
name|clusterIds
parameter_list|,
specifier|final
name|long
name|now
parameter_list|,
name|HTableDescriptor
name|htd
parameter_list|,
name|boolean
name|doSync
parameter_list|,
name|boolean
name|isInMemstore
parameter_list|,
name|AtomicLong
name|sequenceId
parameter_list|,
name|long
name|nonceGroup
parameter_list|,
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|edits
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|this
operator|.
name|unflushedEntries
operator|.
name|get
argument_list|()
return|;
if|if
condition|(
name|this
operator|.
name|closed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot append; log is closed"
argument_list|)
throw|;
block|}
name|TraceScope
name|traceScope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"FSHlog.append"
argument_list|)
decl_stmt|;
try|try
block|{
name|long
name|txid
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|updateLock
init|)
block|{
comment|// get the sequence number from the passed Long. In normal flow, it is coming from the
comment|// region.
name|long
name|seqNum
init|=
name|sequenceId
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
comment|// The 'lastSeqWritten' map holds the sequence number of the oldest
comment|// write for each region (i.e. the first edit added to the particular
comment|// memstore). . When the cache is flushed, the entry for the
comment|// region being flushed is removed if the sequence number of the flush
comment|// is greater than or equal to the value in lastSeqWritten.
comment|// Use encoded name.  Its shorter, guaranteed unique and a subset of
comment|// actual  name.
name|byte
index|[]
name|encodedRegionName
init|=
name|info
operator|.
name|getEncodedNameAsBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|isInMemstore
condition|)
name|this
operator|.
name|oldestUnflushedSeqNums
operator|.
name|putIfAbsent
argument_list|(
name|encodedRegionName
argument_list|,
name|seqNum
argument_list|)
expr_stmt|;
name|HLogKey
name|logKey
init|=
name|makeKey
argument_list|(
name|encodedRegionName
argument_list|,
name|tableName
argument_list|,
name|seqNum
argument_list|,
name|now
argument_list|,
name|clusterIds
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|pendingWritesLock
init|)
block|{
name|doWrite
argument_list|(
name|info
argument_list|,
name|logKey
argument_list|,
name|edits
argument_list|,
name|htd
argument_list|)
expr_stmt|;
name|txid
operator|=
name|this
operator|.
name|unflushedEntries
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|numEntries
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|this
operator|.
name|asyncWriter
operator|.
name|setPendingTxid
argument_list|(
name|txid
argument_list|)
expr_stmt|;
if|if
condition|(
name|htd
operator|.
name|isDeferredLogFlush
argument_list|()
condition|)
block|{
name|lastDeferredTxid
operator|=
name|txid
expr_stmt|;
block|}
name|this
operator|.
name|latestSequenceNums
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|seqNum
argument_list|)
expr_stmt|;
block|}
comment|// TODO: note that only tests currently call append w/sync.
comment|//       Therefore, this code here is not actually used by anything.
comment|// Sync if catalog region, and if not then check if that table supports
comment|// deferred log flushing
if|if
condition|(
name|doSync
operator|&&
operator|(
name|info
operator|.
name|isMetaRegion
argument_list|()
operator|||
operator|!
name|htd
operator|.
name|isDeferredLogFlush
argument_list|()
operator|)
condition|)
block|{
comment|// sync txn to file system
name|this
operator|.
name|sync
argument_list|(
name|txid
argument_list|)
expr_stmt|;
block|}
return|return
name|txid
return|;
block|}
finally|finally
block|{
name|traceScope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|long
name|appendNoSync
parameter_list|(
name|HRegionInfo
name|info
parameter_list|,
name|TableName
name|tableName
parameter_list|,
name|WALEdit
name|edits
parameter_list|,
name|List
argument_list|<
name|UUID
argument_list|>
name|clusterIds
parameter_list|,
specifier|final
name|long
name|now
parameter_list|,
name|HTableDescriptor
name|htd
parameter_list|,
name|AtomicLong
name|sequenceId
parameter_list|,
name|boolean
name|isInMemstore
parameter_list|,
name|long
name|nonceGroup
parameter_list|,
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|append
argument_list|(
name|info
argument_list|,
name|tableName
argument_list|,
name|edits
argument_list|,
name|clusterIds
argument_list|,
name|now
argument_list|,
name|htd
argument_list|,
literal|false
argument_list|,
name|isInMemstore
argument_list|,
name|sequenceId
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The work of current write process of HLog goes as below:    * 1). All write handler threads append edits to HLog's local pending buffer;    *     (it notifies AsyncWriter thread that there is new edits in local buffer)    * 2). All write handler threads wait in HLog.syncer() function for underlying threads to    *     finish the sync that contains its txid;    * 3). An AsyncWriter thread is responsible for retrieving all edits in HLog's    *     local pending buffer and writing to the hdfs (hlog.writer.append);    *     (it notifies AsyncSyncer threads that there is new writes to hdfs which needs a sync)    * 4). AsyncSyncer threads are responsible for issuing sync request to hdfs to persist the    *     writes by AsyncWriter; (they notify the AsyncNotifier thread that sync is done)    * 5). An AsyncNotifier thread is responsible for notifying all pending write handler    *     threads which are waiting in the HLog.syncer() function    * 6). No LogSyncer thread any more (since there is always AsyncWriter/AsyncFlusher threads    *     do the same job it does)    * note: more than one AsyncSyncer threads are needed here to guarantee good enough performance    *       when less concurrent write handler threads. since sync is the most time-consuming    *       operation in the whole write process, multiple AsyncSyncer threads can provide better    *       parallelism of sync to get better overall throughput    */
end_comment

begin_comment
comment|// thread to write locally buffered writes to HDFS
end_comment

begin_class
specifier|private
class|class
name|AsyncWriter
extends|extends
name|HasThread
block|{
specifier|private
name|long
name|pendingTxid
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|txidToWrite
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|lastWrittenTxid
init|=
literal|0
decl_stmt|;
specifier|private
name|Object
name|writeLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|public
name|AsyncWriter
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|// wake up (called by (write) handler thread) AsyncWriter thread
comment|// to write buffered writes to HDFS
specifier|public
name|void
name|setPendingTxid
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|writeLock
init|)
block|{
if|if
condition|(
name|txid
operator|<=
name|this
operator|.
name|pendingTxid
condition|)
return|return;
name|this
operator|.
name|pendingTxid
operator|=
name|txid
expr_stmt|;
name|this
operator|.
name|writeLock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
operator|!
name|this
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
comment|// 1. wait until there is new writes in local buffer
synchronized|synchronized
init|(
name|this
operator|.
name|writeLock
init|)
block|{
while|while
condition|(
name|this
operator|.
name|pendingTxid
operator|<=
name|this
operator|.
name|lastWrittenTxid
condition|)
block|{
name|this
operator|.
name|writeLock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
comment|// 2. get all buffered writes and update 'real' pendingTxid
comment|//    since maybe newer writes enter buffer as AsyncWriter wakes
comment|//    up and holds the lock
comment|// NOTE! can't hold 'updateLock' here since rollWriter will pend
comment|// on 'sync()' with 'updateLock', but 'sync()' will wait for
comment|// AsyncWriter/AsyncSyncer/AsyncNotifier series. without updateLock
comment|// can leads to pendWrites more than pendingTxid, but not problem
name|List
argument_list|<
name|Entry
argument_list|>
name|pendWrites
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|pendingWritesLock
init|)
block|{
name|this
operator|.
name|txidToWrite
operator|=
name|unflushedEntries
operator|.
name|get
argument_list|()
expr_stmt|;
name|pendWrites
operator|=
name|pendingWrites
expr_stmt|;
name|pendingWrites
operator|=
operator|new
name|LinkedList
argument_list|<
name|Entry
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|// 3. write all buffered writes to HDFS(append, without sync)
try|try
block|{
for|for
control|(
name|Entry
name|e
range|:
name|pendWrites
control|)
block|{
name|writer
operator|.
name|append
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while AsyncWriter write, request close of hlog "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|requestLogRoll
argument_list|()
expr_stmt|;
name|asyncIOE
operator|=
name|e
expr_stmt|;
name|failedTxid
operator|.
name|set
argument_list|(
name|this
operator|.
name|txidToWrite
argument_list|)
expr_stmt|;
block|}
comment|// 4. update 'lastWrittenTxid' and notify AsyncSyncer to do 'sync'
name|this
operator|.
name|lastWrittenTxid
operator|=
name|this
operator|.
name|txidToWrite
expr_stmt|;
name|boolean
name|hasIdleSyncer
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|asyncSyncers
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|asyncSyncers
index|[
name|i
index|]
operator|.
name|isSyncing
argument_list|()
condition|)
block|{
name|hasIdleSyncer
operator|=
literal|true
expr_stmt|;
name|asyncSyncers
index|[
name|i
index|]
operator|.
name|setWrittenTxid
argument_list|(
name|this
operator|.
name|lastWrittenTxid
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|hasIdleSyncer
condition|)
block|{
name|int
name|idx
init|=
operator|(
name|int
operator|)
name|this
operator|.
name|lastWrittenTxid
operator|%
name|asyncSyncers
operator|.
name|length
decl_stmt|;
name|asyncSyncers
index|[
name|idx
index|]
operator|.
name|setWrittenTxid
argument_list|(
name|this
operator|.
name|lastWrittenTxid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|" interrupted while waiting for "
operator|+
literal|"newer writes added to local buffer"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"UNEXPECTED"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|" exiting"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// thread to request HDFS to sync the WALEdits written by AsyncWriter
end_comment

begin_comment
comment|// to make those WALEdits durable on HDFS side
end_comment

begin_class
specifier|private
class|class
name|AsyncSyncer
extends|extends
name|HasThread
block|{
specifier|private
name|long
name|writtenTxid
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|txidToSync
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|lastSyncedTxid
init|=
literal|0
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|isSyncing
init|=
literal|false
decl_stmt|;
specifier|private
name|Object
name|syncLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|public
name|AsyncSyncer
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isSyncing
parameter_list|()
block|{
return|return
name|this
operator|.
name|isSyncing
return|;
block|}
comment|// wake up (called by AsyncWriter thread) AsyncSyncer thread
comment|// to sync(flush) writes written by AsyncWriter in HDFS
specifier|public
name|void
name|setWrittenTxid
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|syncLock
init|)
block|{
if|if
condition|(
name|txid
operator|<=
name|this
operator|.
name|writtenTxid
condition|)
return|return;
name|this
operator|.
name|writtenTxid
operator|=
name|txid
expr_stmt|;
name|this
operator|.
name|syncLock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
operator|!
name|this
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
comment|// 1. wait until AsyncWriter has written data to HDFS and
comment|//    called setWrittenTxid to wake up us
synchronized|synchronized
init|(
name|this
operator|.
name|syncLock
init|)
block|{
while|while
condition|(
name|this
operator|.
name|writtenTxid
operator|<=
name|this
operator|.
name|lastSyncedTxid
condition|)
block|{
name|this
operator|.
name|syncLock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|txidToSync
operator|=
name|this
operator|.
name|writtenTxid
expr_stmt|;
block|}
comment|// 2. do 'sync' to HDFS to provide durability
name|long
name|now
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|this
operator|.
name|isSyncing
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
name|writer
operator|.
name|sync
argument_list|()
expr_stmt|;
name|this
operator|.
name|isSyncing
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Error while AsyncSyncer sync, request close of hlog "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|requestLogRoll
argument_list|()
expr_stmt|;
name|asyncIOE
operator|=
name|e
expr_stmt|;
name|failedTxid
operator|.
name|set
argument_list|(
name|this
operator|.
name|txidToSync
argument_list|)
expr_stmt|;
block|}
name|metrics
operator|.
name|finishSync
argument_list|(
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|now
argument_list|)
expr_stmt|;
comment|// 3. wake up AsyncNotifier to notify(wake-up) all pending 'put'
comment|// handler threads on 'sync()'
name|this
operator|.
name|lastSyncedTxid
operator|=
name|this
operator|.
name|txidToSync
expr_stmt|;
name|asyncNotifier
operator|.
name|setFlushedTxid
argument_list|(
name|this
operator|.
name|lastSyncedTxid
argument_list|)
expr_stmt|;
comment|// 4. check and do logRoll if needed
if|if
condition|(
operator|!
name|logRollRunning
condition|)
block|{
name|checkLowReplication
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
operator|&&
name|writer
operator|.
name|getLength
argument_list|()
operator|>
name|logrollsize
condition|)
block|{
name|requestLogRoll
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"writer.getLength() failed,this failure won't block here"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|" interrupted while waiting for "
operator|+
literal|"notification from AsyncWriter thread"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"UNEXPECTED"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|" exiting"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// thread to notify all write handler threads which are pending on
end_comment

begin_comment
comment|// their written WALEdits' durability(sync)
end_comment

begin_comment
comment|// why an extra 'notifier' thread is needed rather than letting
end_comment

begin_comment
comment|// AsyncSyncer thread itself notifies when sync is done is to let
end_comment

begin_comment
comment|// AsyncSyncer thread do next sync as soon as possible since 'notify'
end_comment

begin_comment
comment|// has heavy synchronization with all pending write handler threads
end_comment

begin_class
specifier|private
class|class
name|AsyncNotifier
extends|extends
name|HasThread
block|{
specifier|private
name|long
name|flushedTxid
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|lastNotifiedTxid
init|=
literal|0
decl_stmt|;
specifier|private
name|Object
name|notifyLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|public
name|AsyncNotifier
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setFlushedTxid
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|notifyLock
init|)
block|{
if|if
condition|(
name|txid
operator|<=
name|this
operator|.
name|flushedTxid
condition|)
block|{
return|return;
block|}
name|this
operator|.
name|flushedTxid
operator|=
name|txid
expr_stmt|;
name|this
operator|.
name|notifyLock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
operator|!
name|this
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|notifyLock
init|)
block|{
while|while
condition|(
name|this
operator|.
name|flushedTxid
operator|<=
name|this
operator|.
name|lastNotifiedTxid
condition|)
block|{
name|this
operator|.
name|notifyLock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|lastNotifiedTxid
operator|=
name|this
operator|.
name|flushedTxid
expr_stmt|;
block|}
comment|// notify(wake-up) all pending (write) handler thread
comment|// (or logroller thread which also may pend on sync())
synchronized|synchronized
init|(
name|syncedTillHere
init|)
block|{
name|syncedTillHere
operator|.
name|set
argument_list|(
name|this
operator|.
name|lastNotifiedTxid
argument_list|)
expr_stmt|;
name|syncedTillHere
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|" interrupted while waiting for "
operator|+
literal|" notification from AsyncSyncer thread"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"UNEXPECTED"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|" exiting"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// sync all known transactions
end_comment

begin_function
specifier|private
name|void
name|syncer
parameter_list|()
throws|throws
name|IOException
block|{
name|syncer
argument_list|(
name|this
operator|.
name|unflushedEntries
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
comment|// sync all pending items
block|}
end_function

begin_comment
comment|// sync all transactions upto the specified txid
end_comment

begin_function
specifier|private
name|void
name|syncer
parameter_list|(
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|syncedTillHere
init|)
block|{
while|while
condition|(
name|this
operator|.
name|syncedTillHere
operator|.
name|get
argument_list|()
operator|<
name|txid
condition|)
block|{
try|try
block|{
name|this
operator|.
name|syncedTillHere
operator|.
name|wait
argument_list|()
expr_stmt|;
if|if
condition|(
name|txid
operator|<=
name|this
operator|.
name|failedTxid
operator|.
name|get
argument_list|()
condition|)
block|{
assert|assert
name|asyncIOE
operator|!=
literal|null
operator|:
literal|"current txid is among(under) failed txids, but asyncIOE is null!"
assert|;
throw|throw
name|asyncIOE
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"interrupted while waiting for notification from AsyncNotifier"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|postSync
parameter_list|()
block|{}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|postAppend
parameter_list|(
name|List
argument_list|<
name|Entry
argument_list|>
name|entries
parameter_list|)
block|{}
end_function

begin_function
specifier|private
name|void
name|checkLowReplication
parameter_list|()
block|{
comment|// if the number of replicas in HDFS has fallen below the configured
comment|// value, then roll logs.
try|try
block|{
name|int
name|numCurrentReplicas
init|=
name|getLogReplication
argument_list|()
decl_stmt|;
if|if
condition|(
name|numCurrentReplicas
operator|!=
literal|0
operator|&&
name|numCurrentReplicas
operator|<
name|this
operator|.
name|minTolerableReplication
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|lowReplicationRollEnabled
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|consecutiveLogRolls
operator|.
name|get
argument_list|()
operator|<
name|this
operator|.
name|lowReplicationRollLimit
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"HDFS pipeline error detected. "
operator|+
literal|"Found "
operator|+
name|numCurrentReplicas
operator|+
literal|" replicas but expecting no less than "
operator|+
name|this
operator|.
name|minTolerableReplication
operator|+
literal|" replicas. "
operator|+
literal|" Requesting close of hlog."
argument_list|)
expr_stmt|;
name|requestLogRoll
argument_list|()
expr_stmt|;
comment|// If rollWriter is requested, increase consecutiveLogRolls. Once it
comment|// is larger than lowReplicationRollLimit, disable the
comment|// LowReplication-Roller
name|this
operator|.
name|consecutiveLogRolls
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Too many consecutive RollWriter requests, it's a sign of "
operator|+
literal|"the total number of live datanodes is lower than the tolerable replicas."
argument_list|)
expr_stmt|;
name|this
operator|.
name|consecutiveLogRolls
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|lowReplicationRollEnabled
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|numCurrentReplicas
operator|>=
name|this
operator|.
name|minTolerableReplication
condition|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|lowReplicationRollEnabled
condition|)
block|{
comment|// The new writer's log replicas is always the default value.
comment|// So we should not enable LowReplication-Roller. If numEntries
comment|// is lower than or equals 1, we consider it as a new writer.
if|if
condition|(
name|this
operator|.
name|numEntries
operator|.
name|get
argument_list|()
operator|<=
literal|1
condition|)
block|{
return|return;
block|}
comment|// Once the live datanode number and the replicas return to normal,
comment|// enable the LowReplication-Roller.
name|this
operator|.
name|lowReplicationRollEnabled
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"LowReplication-Roller was enabled."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to invoke DFSOutputStream.getNumCurrentReplicas"
operator|+
name|e
operator|+
literal|" still proceeding ahead..."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * This method gets the datanode replication count for the current HLog.    *    * If the pipeline isn't started yet or is empty, you will get the default    * replication factor.  Therefore, if this function returns 0, it means you    * are not properly running with the HDFS-826 patch.    * @throws InvocationTargetException    * @throws IllegalAccessException    * @throws IllegalArgumentException    *    * @throws Exception    */
end_comment

begin_function
name|int
name|getLogReplication
parameter_list|()
throws|throws
name|IllegalArgumentException
throws|,
name|IllegalAccessException
throws|,
name|InvocationTargetException
block|{
if|if
condition|(
name|this
operator|.
name|getNumCurrentReplicas
operator|!=
literal|null
operator|&&
name|this
operator|.
name|hdfs_out
operator|!=
literal|null
condition|)
block|{
name|Object
name|repl
init|=
name|this
operator|.
name|getNumCurrentReplicas
operator|.
name|invoke
argument_list|(
name|getOutputStream
argument_list|()
argument_list|,
name|NO_ARGS
argument_list|)
decl_stmt|;
if|if
condition|(
name|repl
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
operator|(
name|Integer
operator|)
name|repl
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|boolean
name|canGetCurReplicas
parameter_list|()
block|{
return|return
name|this
operator|.
name|getNumCurrentReplicas
operator|!=
literal|null
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|hsync
parameter_list|()
throws|throws
name|IOException
block|{
name|syncer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|hflush
parameter_list|()
throws|throws
name|IOException
block|{
name|syncer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
name|syncer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|(
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
name|syncer
argument_list|(
name|txid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|requestLogRoll
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|WALActionsListener
name|i
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|i
operator|.
name|logRollRequested
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|// TODO: Remove info.  Unused.
end_comment

begin_function
specifier|protected
name|void
name|doWrite
parameter_list|(
name|HRegionInfo
name|info
parameter_list|,
name|HLogKey
name|logKey
parameter_list|,
name|WALEdit
name|logEdit
parameter_list|,
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|enabled
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|WALActionsListener
name|i
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|i
operator|.
name|visitLogEntryBeforeWrite
argument_list|(
name|htd
argument_list|,
name|logKey
argument_list|,
name|logEdit
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|long
name|now
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// coprocessor hook:
if|if
condition|(
operator|!
name|coprocessorHost
operator|.
name|preWALWrite
argument_list|(
name|info
argument_list|,
name|logKey
argument_list|,
name|logEdit
argument_list|)
condition|)
block|{
if|if
condition|(
name|logEdit
operator|.
name|isReplay
argument_list|()
condition|)
block|{
comment|// set replication scope null so that this won't be replicated
name|logKey
operator|.
name|setScopes
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// write to our buffer for the Hlog file.
name|this
operator|.
name|pendingWrites
operator|.
name|add
argument_list|(
operator|new
name|HLog
operator|.
name|Entry
argument_list|(
name|logKey
argument_list|,
name|logEdit
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|took
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|now
decl_stmt|;
name|coprocessorHost
operator|.
name|postWALWrite
argument_list|(
name|info
argument_list|,
name|logKey
argument_list|,
name|logEdit
argument_list|)
expr_stmt|;
name|long
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|KeyValue
name|kv
range|:
name|logEdit
operator|.
name|getKeyValues
argument_list|()
control|)
block|{
name|len
operator|+=
name|kv
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|metrics
operator|.
name|finishAppend
argument_list|(
name|took
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Could not append. Requesting close of hlog"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|requestLogRoll
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
end_function

begin_comment
comment|/** @return How many items have been added to the log */
end_comment

begin_function
name|int
name|getNumEntries
parameter_list|()
block|{
return|return
name|numEntries
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/** @return the number of rolled log files */
end_comment

begin_function
specifier|public
name|int
name|getNumRolledLogFiles
parameter_list|()
block|{
return|return
name|hlogSequenceNums
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/** @return the number of log files in use */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|int
name|getNumLogFiles
parameter_list|()
block|{
comment|// +1 for current use log
return|return
name|getNumRolledLogFiles
argument_list|()
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/** @return the size of log files in use */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|long
name|getLogFileSize
parameter_list|()
block|{
return|return
name|totalLogSize
operator|.
name|get
argument_list|()
operator|+
name|curLogSize
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|startCacheFlush
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|)
block|{
name|Long
name|oldRegionSeqNum
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|closeBarrier
operator|.
name|beginOp
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Flush will not be started for "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
operator|+
literal|" - because the server is closing."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
synchronized|synchronized
init|(
name|oldestSeqNumsLock
init|)
block|{
name|oldRegionSeqNum
operator|=
name|this
operator|.
name|oldestUnflushedSeqNums
operator|.
name|remove
argument_list|(
name|encodedRegionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldRegionSeqNum
operator|!=
literal|null
condition|)
block|{
name|Long
name|oldValue
init|=
name|this
operator|.
name|oldestFlushingSeqNums
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|oldRegionSeqNum
argument_list|)
decl_stmt|;
assert|assert
name|oldValue
operator|==
literal|null
operator|:
literal|"Flushing map not cleaned up for "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
assert|;
block|}
block|}
if|if
condition|(
name|oldRegionSeqNum
operator|==
literal|null
condition|)
block|{
comment|// TODO: if we have no oldRegionSeqNum, and WAL is not disabled, presumably either
comment|//       the region is already flushing (which would make this call invalid), or there
comment|//       were no appends after last flush, so why are we starting flush? Maybe we should
comment|//       assert not null, and switch to "long" everywhere. Less rigorous, but safer,
comment|//       alternative is telling the caller to stop. For now preserve old logic.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't find oldest seqNum for the region we are about to flush: ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|completeCacheFlush
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|oldestSeqNumsLock
init|)
block|{
name|this
operator|.
name|oldestFlushingSeqNums
operator|.
name|remove
argument_list|(
name|encodedRegionName
argument_list|)
expr_stmt|;
block|}
name|closeBarrier
operator|.
name|endOp
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|abortCacheFlush
parameter_list|(
name|byte
index|[]
name|encodedRegionName
parameter_list|)
block|{
name|Long
name|currentSeqNum
init|=
literal|null
decl_stmt|,
name|seqNumBeforeFlushStarts
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|oldestSeqNumsLock
init|)
block|{
name|seqNumBeforeFlushStarts
operator|=
name|this
operator|.
name|oldestFlushingSeqNums
operator|.
name|remove
argument_list|(
name|encodedRegionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|seqNumBeforeFlushStarts
operator|!=
literal|null
condition|)
block|{
name|currentSeqNum
operator|=
name|this
operator|.
name|oldestUnflushedSeqNums
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|seqNumBeforeFlushStarts
argument_list|)
expr_stmt|;
block|}
block|}
name|closeBarrier
operator|.
name|endOp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|currentSeqNum
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|currentSeqNum
operator|.
name|longValue
argument_list|()
operator|<=
name|seqNumBeforeFlushStarts
operator|.
name|longValue
argument_list|()
operator|)
condition|)
block|{
name|String
name|errorStr
init|=
literal|"Region "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
operator|+
literal|"acquired edits out of order current memstore seq="
operator|+
name|currentSeqNum
operator|+
literal|", previous oldest unflushed id="
operator|+
name|seqNumBeforeFlushStarts
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorStr
argument_list|)
expr_stmt|;
assert|assert
literal|false
operator|:
name|errorStr
assert|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|halt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|isLowReplicationRollEnabled
parameter_list|()
block|{
return|return
name|lowReplicationRollEnabled
return|;
block|}
end_function

begin_comment
comment|/**    * Get the directory we are making logs in.    *    * @return dir    */
end_comment

begin_function
specifier|protected
name|Path
name|getDir
parameter_list|()
block|{
return|return
name|dir
return|;
block|}
end_function

begin_function
specifier|static
name|Path
name|getHLogArchivePath
parameter_list|(
name|Path
name|oldLogDir
parameter_list|,
name|Path
name|p
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|oldLogDir
argument_list|,
name|p
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|String
name|formatRecoveredEditsFileName
parameter_list|(
specifier|final
name|long
name|seqid
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%019d"
argument_list|,
name|seqid
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|public
specifier|static
specifier|final
name|long
name|FIXED_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|OBJECT
operator|+
operator|(
literal|5
operator|*
name|ClassSize
operator|.
name|REFERENCE
operator|)
operator|+
name|ClassSize
operator|.
name|ATOMIC_INTEGER
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
operator|+
operator|(
literal|3
operator|*
name|Bytes
operator|.
name|SIZEOF_LONG
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|private
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: HLog<ARGS>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Arguments:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" --dump  Dump textual representation of passed one or more files"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"         For example: HLog --dump hdfs://example.com:9000/hbase/.logs/MACHINE/LOGFILE"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" --split Split the passed directory of WAL logs"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"         For example: HLog --split hdfs://example.com:9000/hbase/.logs/DIR"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|void
name|split
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|p
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|p
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|fs
operator|.
name|getFileStatus
argument_list|(
name|p
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|p
operator|+
literal|" is not a directory"
argument_list|)
throw|;
block|}
specifier|final
name|Path
name|baseDir
init|=
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|oldLogDir
init|=
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|HConstants
operator|.
name|HREGION_OLDLOGDIR_NAME
argument_list|)
decl_stmt|;
name|HLogSplitter
operator|.
name|split
argument_list|(
name|baseDir
argument_list|,
name|p
argument_list|,
name|oldLogDir
argument_list|,
name|fs
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|WALCoprocessorHost
name|getCoprocessorHost
parameter_list|()
block|{
return|return
name|coprocessorHost
return|;
block|}
end_function

begin_comment
comment|/** Provide access to currently deferred sequence num for tests */
end_comment

begin_function
name|boolean
name|hasDeferredEntries
parameter_list|()
block|{
return|return
name|this
operator|.
name|lastDeferredTxid
operator|>
name|this
operator|.
name|syncedTillHere
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|long
name|getEarliestMemstoreSeqNum
parameter_list|(
name|byte
index|[]
name|encodedRegionName
parameter_list|)
block|{
name|Long
name|result
init|=
name|oldestUnflushedSeqNums
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
return|return
name|result
operator|==
literal|null
condition|?
name|HConstants
operator|.
name|NO_SEQNUM
else|:
name|result
operator|.
name|longValue
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Pass one or more log file names and it will either dump out a text version    * on<code>stdout</code> or split the specified log files.    *    * @param args    * @throws IOException    */
end_comment

begin_function
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|2
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// either dump using the HLogPrettyPrinter or split, depending on args
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|compareTo
argument_list|(
literal|"--dump"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|HLogPrettyPrinter
operator|.
name|run
argument_list|(
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|args
argument_list|,
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|compareTo
argument_list|(
literal|"--split"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|Path
name|logPath
init|=
operator|new
name|Path
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|FSUtils
operator|.
name|setFsDefault
argument_list|(
name|conf
argument_list|,
name|logPath
argument_list|)
expr_stmt|;
name|split
argument_list|(
name|conf
argument_list|,
name|logPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|t
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

unit|}
end_unit

