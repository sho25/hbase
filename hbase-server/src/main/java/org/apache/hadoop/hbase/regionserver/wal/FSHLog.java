begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
package|;
end_package

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|BlockingWaitStrategy
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|EventHandler
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|ExceptionHandler
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|LifecycleAware
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|dsl
operator|.
name|Disruptor
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|dsl
operator|.
name|ProducerType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|trace
operator|.
name|TraceUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HasThread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|FSHLogProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALEdit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALKeyImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALProvider
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * The default implementation of FSWAL.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|FSHLog
extends|extends
name|AbstractFSWAL
argument_list|<
name|Writer
argument_list|>
block|{
comment|// IMPLEMENTATION NOTES:
comment|//
comment|// At the core is a ring buffer. Our ring buffer is the LMAX Disruptor. It tries to
comment|// minimize synchronizations and volatile writes when multiple contending threads as is the case
comment|// here appending and syncing on a single WAL. The Disruptor is configured to handle multiple
comment|// producers but it has one consumer only (the producers in HBase are IPC Handlers calling append
comment|// and then sync). The single consumer/writer pulls the appends and syncs off the ring buffer.
comment|// When a handler calls sync, it is given back a future. The producer 'blocks' on the future so
comment|// it does not return until the sync completes. The future is passed over the ring buffer from
comment|// the producer/handler to the consumer thread where it does its best to batch up the producer
comment|// syncs so one WAL sync actually spans multiple producer sync invocations. How well the
comment|// batching works depends on the write rate; i.e. we tend to batch more in times of
comment|// high writes/syncs.
comment|//
comment|// Calls to append now also wait until the append has been done on the consumer side of the
comment|// disruptor. We used to not wait but it makes the implementation easier to grok if we have
comment|// the region edit/sequence id after the append returns.
comment|//
comment|// TODO: Handlers need to coordinate appending AND syncing. Can we have the threads contend
comment|// once only? Probably hard given syncs take way longer than an append.
comment|//
comment|// The consumer threads pass the syncs off to multiple syncing threads in a round robin fashion
comment|// to ensure we keep up back-to-back FS sync calls (FS sync calls are the long poll writing the
comment|// WAL). The consumer thread passes the futures to the sync threads for it to complete
comment|// the futures when done.
comment|//
comment|// The 'sequence' in the below is the sequence of the append/sync on the ringbuffer. It
comment|// acts as a sort-of transaction id. It is always incrementing.
comment|//
comment|// The RingBufferEventHandler class hosts the ring buffer consuming code. The threads that
comment|// do the actual FS sync are implementations of SyncRunner. SafePointZigZagLatch is a
comment|// synchronization class used to halt the consumer at a safe point -- just after all outstanding
comment|// syncs and appends have completed -- so the log roller can swap the WAL out under it.
comment|//
comment|// We use ring buffer sequence as txid of FSWALEntry and SyncFuture.
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FSHLog
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * The nexus at which all incoming handlers meet. Does appends and sync with an ordering. Appends    * and syncs are each put on the ring which means handlers need to smash up against the ring twice    * (can we make it once only? ... maybe not since time to append is so different from time to sync    * and sometimes we don't want to sync or we want to async the sync). The ring is where we make    * sure of our ordering and it is also where we do batching up of handler sync calls.    */
specifier|private
specifier|final
name|Disruptor
argument_list|<
name|RingBufferTruck
argument_list|>
name|disruptor
decl_stmt|;
comment|/**    * This fellow is run by the above appendExecutor service but it is all about batching up appends    * and syncs; it may shutdown without cleaning out the last few appends or syncs. To guard against    * this, keep a reference to this handler and do explicit close on way out to make sure all    * flushed out before we exit.    */
specifier|private
specifier|final
name|RingBufferEventHandler
name|ringBufferEventHandler
decl_stmt|;
comment|/**    * FSDataOutputStream associated with the current SequenceFile.writer    */
specifier|private
name|FSDataOutputStream
name|hdfs_out
decl_stmt|;
comment|// All about log rolling if not enough replicas outstanding.
comment|// Minimum tolerable replicas, if the actual value is lower than it, rollWriter will be triggered
specifier|private
specifier|final
name|int
name|minTolerableReplication
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|useHsync
decl_stmt|;
comment|// If live datanode count is lower than the default replicas value,
comment|// RollWriter will be triggered in each sync(So the RollWriter will be
comment|// triggered one by one in a short time). Using it as a workaround to slow
comment|// down the roll frequency triggered by checkLowReplication().
specifier|private
specifier|final
name|AtomicInteger
name|consecutiveLogRolls
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|int
name|lowReplicationRollLimit
decl_stmt|;
comment|// If consecutiveLogRolls is larger than lowReplicationRollLimit,
comment|// then disable the rolling in checkLowReplication().
comment|// Enable it if the replications recover.
specifier|private
specifier|volatile
name|boolean
name|lowReplicationRollEnabled
init|=
literal|true
decl_stmt|;
comment|/** Number of log close errors tolerated before we abort */
specifier|private
specifier|final
name|int
name|closeErrorsTolerated
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|closeErrorCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|/**    * Exception handler to pass the disruptor ringbuffer. Same as native implementation only it logs    * using our logger instead of java native logger.    */
specifier|static
class|class
name|RingBufferExceptionHandler
implements|implements
name|ExceptionHandler
argument_list|<
name|RingBufferTruck
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|void
name|handleEventException
parameter_list|(
name|Throwable
name|ex
parameter_list|,
name|long
name|sequence
parameter_list|,
name|RingBufferTruck
name|event
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Sequence="
operator|+
name|sequence
operator|+
literal|", event="
operator|+
name|event
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleOnStartException
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ex
operator|.
name|toString
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleOnShutdownException
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ex
operator|.
name|toString
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**    * Constructor.    * @param fs filesystem handle    * @param root path for stored and archived wals    * @param logDir dir where wals are stored    * @param conf configuration to use    */
specifier|public
name|FSHLog
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|root
parameter_list|,
specifier|final
name|String
name|logDir
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|root
argument_list|,
name|logDir
argument_list|,
name|HConstants
operator|.
name|HREGION_OLDLOGDIR_NAME
argument_list|,
name|conf
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create an edit log at the given<code>dir</code> location. You should never have to load an    * existing log. If there is a log at startup, it should have already been processed and deleted    * by the time the WAL object is started up.    * @param fs filesystem handle    * @param rootDir path to where logs and oldlogs    * @param logDir dir where wals are stored    * @param archiveDir dir where wals are archived    * @param conf configuration to use    * @param listeners Listeners on WAL events. Listeners passed here will be registered before we do    *          anything else; e.g. the Constructor {@link #rollWriter()}.    * @param failIfWALExists If true IOException will be thrown if files related to this wal already    *          exist.    * @param prefix should always be hostname and port in distributed env and it will be URL encoded    *          before being used. If prefix is null, "wal" will be used    * @param suffix will be url encoded. null is treated as empty. non-empty must start with    *          {@link org.apache.hadoop.hbase.wal.AbstractFSWALProvider#WAL_FILE_NAME_DELIMITER}    */
specifier|public
name|FSHLog
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|rootDir
parameter_list|,
specifier|final
name|String
name|logDir
parameter_list|,
specifier|final
name|String
name|archiveDir
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|List
argument_list|<
name|WALActionsListener
argument_list|>
name|listeners
parameter_list|,
specifier|final
name|boolean
name|failIfWALExists
parameter_list|,
specifier|final
name|String
name|prefix
parameter_list|,
specifier|final
name|String
name|suffix
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|fs
argument_list|,
name|rootDir
argument_list|,
name|logDir
argument_list|,
name|archiveDir
argument_list|,
name|conf
argument_list|,
name|listeners
argument_list|,
name|failIfWALExists
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|this
operator|.
name|minTolerableReplication
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.hlog.tolerable.lowreplication"
argument_list|,
name|FSUtils
operator|.
name|getDefaultReplication
argument_list|(
name|fs
argument_list|,
name|this
operator|.
name|walDir
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|lowReplicationRollLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.hlog.lowreplication.rolllimit"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|this
operator|.
name|closeErrorsTolerated
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.logroll.errors.tolerated"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|this
operator|.
name|useHsync
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HRegion
operator|.
name|WAL_HSYNC_CONF_KEY
argument_list|,
name|HRegion
operator|.
name|DEFAULT_WAL_HSYNC
argument_list|)
expr_stmt|;
comment|// rollWriter sets this.hdfs_out if it can.
name|rollWriter
argument_list|()
expr_stmt|;
comment|// This is the 'writer' -- a single threaded executor. This single thread 'consumes' what is
comment|// put on the ring buffer.
name|String
name|hostingThreadName
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// Using BlockingWaitStrategy. Stuff that is going on here takes so long it makes no sense
comment|// spinning as other strategies do.
name|this
operator|.
name|disruptor
operator|=
operator|new
name|Disruptor
argument_list|<>
argument_list|(
name|RingBufferTruck
operator|::
operator|new
argument_list|,
name|getPreallocatedEventCount
argument_list|()
argument_list|,
name|Threads
operator|.
name|getNamedThreadFactory
argument_list|(
name|hostingThreadName
operator|+
literal|".append"
argument_list|)
argument_list|,
name|ProducerType
operator|.
name|MULTI
argument_list|,
operator|new
name|BlockingWaitStrategy
argument_list|()
argument_list|)
expr_stmt|;
comment|// Advance the ring buffer sequence so that it starts from 1 instead of 0,
comment|// because SyncFuture.NOT_DONE = 0.
name|this
operator|.
name|disruptor
operator|.
name|getRingBuffer
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
name|int
name|maxHandlersCount
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|REGION_SERVER_HANDLER_COUNT
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|this
operator|.
name|ringBufferEventHandler
operator|=
operator|new
name|RingBufferEventHandler
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.hlog.syncer.count"
argument_list|,
literal|5
argument_list|)
argument_list|,
name|maxHandlersCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|disruptor
operator|.
name|setDefaultExceptionHandler
argument_list|(
operator|new
name|RingBufferExceptionHandler
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|disruptor
operator|.
name|handleEventsWith
argument_list|(
operator|new
name|RingBufferEventHandler
index|[]
block|{
name|this
operator|.
name|ringBufferEventHandler
block|}
argument_list|)
expr_stmt|;
comment|// Starting up threads in constructor is a no no; Interface should have an init call.
name|this
operator|.
name|disruptor
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**    * Currently, we need to expose the writer's OutputStream to tests so that they can manipulate the    * default behavior (such as setting the maxRecoveryErrorCount value for example (see    * {@see org.apache.hadoop.hbase.regionserver.wal.AbstractTestWALReplay#testReplayEditsWrittenIntoWAL()}). This is    * done using reflection on the underlying HDFS OutputStream. NOTE: This could be removed once Hadoop1 support is    * removed.    * @return null if underlying stream is not ready.    */
annotation|@
name|VisibleForTesting
name|OutputStream
name|getOutputStream
parameter_list|()
block|{
name|FSDataOutputStream
name|fsdos
init|=
name|this
operator|.
name|hdfs_out
decl_stmt|;
return|return
name|fsdos
operator|!=
literal|null
condition|?
name|fsdos
operator|.
name|getWrappedStream
argument_list|()
else|:
literal|null
return|;
block|}
comment|/**    * Run a sync after opening to set up the pipeline.    */
specifier|private
name|void
name|preemptiveSync
parameter_list|(
specifier|final
name|ProtobufLogWriter
name|nextWriter
parameter_list|)
block|{
name|long
name|startTimeNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
name|nextWriter
operator|.
name|sync
argument_list|(
name|useHsync
argument_list|)
expr_stmt|;
name|postSync
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNanos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// optimization failed, no need to abort here.
name|LOG
operator|.
name|warn
argument_list|(
literal|"pre-sync failed but an optimization so keep going"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This method allows subclasses to inject different writers without having to extend other    * methods like rollWriter().    * @return Writer instance    */
annotation|@
name|Override
specifier|protected
name|Writer
name|createWriterInstance
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Writer
name|writer
init|=
name|FSHLogProvider
operator|.
name|createWriter
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|path
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|writer
operator|instanceof
name|ProtobufLogWriter
condition|)
block|{
name|preemptiveSync
argument_list|(
operator|(
name|ProtobufLogWriter
operator|)
name|writer
argument_list|)
expr_stmt|;
block|}
return|return
name|writer
return|;
block|}
comment|/**    * Used to manufacture race condition reliably. For testing only.    * @see #beforeWaitOnSafePoint()    */
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|afterCreatingZigZagLatch
parameter_list|()
block|{   }
comment|/**    * @see #afterCreatingZigZagLatch()    */
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|beforeWaitOnSafePoint
parameter_list|()
block|{   }
annotation|@
name|Override
specifier|protected
name|void
name|doAppend
parameter_list|(
name|Writer
name|writer
parameter_list|,
name|FSWALEntry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
name|writer
operator|.
name|append
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doReplaceWriter
parameter_list|(
name|Path
name|oldPath
parameter_list|,
name|Path
name|newPath
parameter_list|,
name|Writer
name|nextWriter
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Ask the ring buffer writer to pause at a safe point. Once we do this, the writer
comment|// thread will eventually pause. An error hereafter needs to release the writer thread
comment|// regardless -- hence the finally block below. Note, this method is called from the FSHLog
comment|// constructor BEFORE the ring buffer is set running so it is null on first time through
comment|// here; allow for that.
name|SyncFuture
name|syncFuture
init|=
literal|null
decl_stmt|;
name|SafePointZigZagLatch
name|zigzagLatch
init|=
literal|null
decl_stmt|;
name|long
name|sequence
init|=
operator|-
literal|1L
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|ringBufferEventHandler
operator|!=
literal|null
condition|)
block|{
comment|// Get sequence first to avoid dead lock when ring buffer is full
comment|// Considering below sequence
comment|// 1. replaceWriter is called and zigzagLatch is initialized
comment|// 2. ringBufferEventHandler#onEvent is called and arrives at #attainSafePoint(long) then wait
comment|// on safePointReleasedLatch
comment|// 3. Since ring buffer is full, if we get sequence when publish sync, the replaceWriter
comment|// thread will wait for the ring buffer to be consumed, but the only consumer is waiting
comment|// replaceWriter thread to release safePointReleasedLatch, which causes a deadlock
name|sequence
operator|=
name|getSequenceOnRingBuffer
argument_list|()
expr_stmt|;
name|zigzagLatch
operator|=
name|this
operator|.
name|ringBufferEventHandler
operator|.
name|attainSafePoint
argument_list|()
expr_stmt|;
block|}
name|afterCreatingZigZagLatch
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Wait on the safe point to be achieved. Send in a sync in case nothing has hit the
comment|// ring buffer between the above notification of writer that we want it to go to
comment|// 'safe point' and then here where we are waiting on it to attain safe point. Use
comment|// 'sendSync' instead of 'sync' because we do not want this thread to block waiting on it
comment|// to come back. Cleanup this syncFuture down below after we are ready to run again.
try|try
block|{
if|if
condition|(
name|zigzagLatch
operator|!=
literal|null
condition|)
block|{
comment|// use assert to make sure no change breaks the logic that
comment|// sequence and zigzagLatch will be set together
assert|assert
name|sequence
operator|>
literal|0L
operator|:
literal|"Failed to get sequence from ring buffer"
assert|;
name|TraceUtil
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"awaiting safepoint"
argument_list|)
expr_stmt|;
name|syncFuture
operator|=
name|zigzagLatch
operator|.
name|waitSafePoint
argument_list|(
name|publishSyncOnRingBuffer
argument_list|(
name|sequence
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FailedSyncBeforeLogCloseException
name|e
parameter_list|)
block|{
comment|// If unflushed/unsynced entries on close, it is reason to abort.
if|if
condition|(
name|isUnflushedEntries
argument_list|()
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed sync-before-close but no outstanding appends; closing WAL"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|oldFileLen
init|=
literal|0L
decl_stmt|;
comment|// It is at the safe point. Swap out writer from under the blocked writer thread.
comment|// TODO: This is close is inline with critical section. Should happen in background?
if|if
condition|(
name|this
operator|.
name|writer
operator|!=
literal|null
condition|)
block|{
name|oldFileLen
operator|=
name|this
operator|.
name|writer
operator|.
name|getLength
argument_list|()
expr_stmt|;
try|try
block|{
name|TraceUtil
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"closing writer"
argument_list|)
expr_stmt|;
name|this
operator|.
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|TraceUtil
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"writer closed"
argument_list|)
expr_stmt|;
name|this
operator|.
name|closeErrorCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|int
name|errors
init|=
name|closeErrorCount
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isUnflushedEntries
argument_list|()
operator|&&
operator|(
name|errors
operator|<=
name|this
operator|.
name|closeErrorsTolerated
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Riding over failed WAL close of "
operator|+
name|oldPath
operator|+
literal|", cause=\""
operator|+
name|ioe
operator|.
name|getMessage
argument_list|()
operator|+
literal|"\", errors="
operator|+
name|errors
operator|+
literal|"; THIS FILE WAS NOT CLOSED BUT ALL EDITS SYNCED SO SHOULD BE OK"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|ioe
throw|;
block|}
block|}
block|}
name|logRollAndSetupWalProps
argument_list|(
name|oldPath
argument_list|,
name|newPath
argument_list|,
name|oldFileLen
argument_list|)
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|nextWriter
expr_stmt|;
if|if
condition|(
name|nextWriter
operator|!=
literal|null
operator|&&
name|nextWriter
operator|instanceof
name|ProtobufLogWriter
condition|)
block|{
name|this
operator|.
name|hdfs_out
operator|=
operator|(
operator|(
name|ProtobufLogWriter
operator|)
name|nextWriter
operator|)
operator|.
name|getStream
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|hdfs_out
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// Perpetuate the interrupt
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|long
name|count
init|=
name|getUnflushedEntriesCount
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed close of WAL writer "
operator|+
name|oldPath
operator|+
literal|", unflushedEntries="
operator|+
name|count
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FailedLogCloseException
argument_list|(
name|oldPath
operator|+
literal|", unflushedEntries="
operator|+
name|count
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// Let the writer thread go regardless, whether error or not.
if|if
condition|(
name|zigzagLatch
operator|!=
literal|null
condition|)
block|{
name|zigzagLatch
operator|.
name|releaseSafePoint
argument_list|()
expr_stmt|;
comment|// syncFuture will be null if we failed our wait on safe point above. Otherwise, if
comment|// latch was obtained successfully, the sync we threw in either trigger the latch or it
comment|// got stamped with an exception because the WAL was damaged and we could not sync. Now
comment|// the write pipeline has been opened up again by releasing the safe point, process the
comment|// syncFuture we got above. This is probably a noop but it may be stale exception from
comment|// when old WAL was in place. Catch it if so.
if|if
condition|(
name|syncFuture
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|blockOnSync
argument_list|(
name|syncFuture
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Stale sync exception"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doShutdown
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Shutdown the disruptor. Will stop after all entries have been processed. Make sure we
comment|// have stopped incoming appends before calling this else it will not shutdown. We are
comment|// conservative below waiting a long time and if not elapsed, then halting.
if|if
condition|(
name|this
operator|.
name|disruptor
operator|!=
literal|null
condition|)
block|{
name|long
name|timeoutms
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.wal.disruptor.shutdown.timeout.ms"
argument_list|,
literal|60000
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|disruptor
operator|.
name|shutdown
argument_list|(
name|timeoutms
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Timed out bringing down disruptor after "
operator|+
name|timeoutms
operator|+
literal|"ms; forcing halt "
operator|+
literal|"(It is a problem if this is NOT an ABORT! -- DATALOSS!!!!)"
argument_list|)
expr_stmt|;
name|this
operator|.
name|disruptor
operator|.
name|halt
argument_list|()
expr_stmt|;
name|this
operator|.
name|disruptor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closing WAL writer in "
operator|+
name|FSUtils
operator|.
name|getPath
argument_list|(
name|walDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|writer
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|writer
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"NP_NULL_ON_SOME_PATH_EXCEPTION"
argument_list|,
name|justification
operator|=
literal|"Will never be null"
argument_list|)
annotation|@
name|Override
specifier|public
name|long
name|append
parameter_list|(
specifier|final
name|RegionInfo
name|hri
parameter_list|,
specifier|final
name|WALKeyImpl
name|key
parameter_list|,
specifier|final
name|WALEdit
name|edits
parameter_list|,
specifier|final
name|boolean
name|inMemstore
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|stampSequenceIdAndPublishToRingBuffer
argument_list|(
name|hri
argument_list|,
name|key
argument_list|,
name|edits
argument_list|,
name|inMemstore
argument_list|,
name|disruptor
operator|.
name|getRingBuffer
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Thread to runs the hdfs sync call. This call takes a while to complete. This is the longest    * pole adding edits to the WAL and this must complete to be sure all edits persisted. We run    * multiple threads sync'ng rather than one that just syncs in series so we have better latencies;    * otherwise, an edit that arrived just after a sync started, might have to wait almost the length    * of two sync invocations before it is marked done.    *<p>    * When the sync completes, it marks all the passed in futures done. On the other end of the sync    * future is a blocked thread, usually a regionserver Handler. There may be more than one future    * passed in the case where a few threads arrive at about the same time and all invoke 'sync'. In    * this case we'll batch up the invocations and run one filesystem sync only for a batch of    * Handler sync invocations. Do not confuse these Handler SyncFutures with the futures an    * ExecutorService returns when you call submit. We have no use for these in this model. These    * SyncFutures are 'artificial', something to hold the Handler until the filesystem sync    * completes.    */
specifier|private
class|class
name|SyncRunner
extends|extends
name|HasThread
block|{
specifier|private
specifier|volatile
name|long
name|sequence
decl_stmt|;
comment|// Keep around last exception thrown. Clear on successful sync.
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|SyncFuture
argument_list|>
name|syncFutures
decl_stmt|;
specifier|private
specifier|volatile
name|SyncFuture
name|takeSyncFuture
init|=
literal|null
decl_stmt|;
name|SyncRunner
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|int
name|maxHandlersCount
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// LinkedBlockingQueue because of
comment|// http://www.javacodegeeks.com/2010/09/java-best-practices-queue-battle-and.html
comment|// Could use other blockingqueues here or concurrent queues.
comment|//
comment|// We could let the capacity be 'open' but bound it so we get alerted in pathological case
comment|// where we cannot sync and we have a bunch of threads all backed up waiting on their syncs
comment|// to come in. LinkedBlockingQueue actually shrinks when you remove elements so Q should
comment|// stay neat and tidy in usual case. Let the max size be three times the maximum handlers.
comment|// The passed in maxHandlerCount is the user-level handlers which is what we put up most of
comment|// but HBase has other handlers running too -- opening region handlers which want to write
comment|// the meta table when succesful (i.e. sync), closing handlers -- etc. These are usually
comment|// much fewer in number than the user-space handlers so Q-size should be user handlers plus
comment|// some space for these other handlers. Lets multiply by 3 for good-measure.
name|this
operator|.
name|syncFutures
operator|=
operator|new
name|LinkedBlockingQueue
argument_list|<>
argument_list|(
name|maxHandlersCount
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
name|void
name|offer
parameter_list|(
specifier|final
name|long
name|sequence
parameter_list|,
specifier|final
name|SyncFuture
index|[]
name|syncFutures
parameter_list|,
specifier|final
name|int
name|syncFutureCount
parameter_list|)
block|{
comment|// Set sequence first because the add to the queue will wake the thread if sleeping.
name|this
operator|.
name|sequence
operator|=
name|sequence
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|syncFutureCount
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|syncFutures
operator|.
name|add
argument_list|(
name|syncFutures
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Release the passed<code>syncFuture</code>      * @return Returns 1.      */
specifier|private
name|int
name|releaseSyncFuture
parameter_list|(
specifier|final
name|SyncFuture
name|syncFuture
parameter_list|,
specifier|final
name|long
name|currentSequence
parameter_list|,
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|syncFuture
operator|.
name|done
argument_list|(
name|currentSequence
argument_list|,
name|t
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
comment|// This function releases one sync future only.
return|return
literal|1
return|;
block|}
comment|/**      * Release all SyncFutures whose sequence is<=<code>currentSequence</code>.      * @param t May be non-null if we are processing SyncFutures because an exception was thrown.      * @return Count of SyncFutures we let go.      */
specifier|private
name|int
name|releaseSyncFutures
parameter_list|(
specifier|final
name|long
name|currentSequence
parameter_list|,
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
name|int
name|syncCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SyncFuture
name|syncFuture
init|;
operator|(
name|syncFuture
operator|=
name|this
operator|.
name|syncFutures
operator|.
name|peek
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
if|if
condition|(
name|syncFuture
operator|.
name|getTxid
argument_list|()
operator|>
name|currentSequence
condition|)
block|{
break|break;
block|}
name|releaseSyncFuture
argument_list|(
name|syncFuture
argument_list|,
name|currentSequence
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|syncFutures
operator|.
name|remove
argument_list|(
name|syncFuture
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|syncFuture
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|syncCount
operator|++
expr_stmt|;
block|}
return|return
name|syncCount
return|;
block|}
comment|/**      * @param sequence The sequence we ran the filesystem sync against.      * @return Current highest synced sequence.      */
specifier|private
name|long
name|updateHighestSyncedSequence
parameter_list|(
name|long
name|sequence
parameter_list|)
block|{
name|long
name|currentHighestSyncedSequence
decl_stmt|;
comment|// Set the highestSyncedSequence IFF our current sequence id is the 'highest'.
do|do
block|{
name|currentHighestSyncedSequence
operator|=
name|highestSyncedTxid
operator|.
name|get
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentHighestSyncedSequence
operator|>=
name|sequence
condition|)
block|{
comment|// Set the sync number to current highwater mark; might be able to let go more
comment|// queued sync futures
name|sequence
operator|=
name|currentHighestSyncedSequence
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|highestSyncedTxid
operator|.
name|compareAndSet
argument_list|(
name|currentHighestSyncedSequence
argument_list|,
name|sequence
argument_list|)
condition|)
do|;
return|return
name|sequence
return|;
block|}
name|boolean
name|areSyncFuturesReleased
parameter_list|()
block|{
comment|// check whether there is no sync futures offered, and no in-flight sync futures that is being
comment|// processed.
return|return
name|syncFutures
operator|.
name|size
argument_list|()
operator|<=
literal|0
operator|&&
name|takeSyncFuture
operator|==
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|long
name|currentSequence
decl_stmt|;
while|while
condition|(
operator|!
name|isInterrupted
argument_list|()
condition|)
block|{
name|int
name|syncCount
init|=
literal|0
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|takeSyncFuture
operator|=
literal|null
expr_stmt|;
comment|// We have to process what we 'take' from the queue
name|takeSyncFuture
operator|=
name|this
operator|.
name|syncFutures
operator|.
name|take
argument_list|()
expr_stmt|;
name|currentSequence
operator|=
name|this
operator|.
name|sequence
expr_stmt|;
name|long
name|syncFutureSequence
init|=
name|takeSyncFuture
operator|.
name|getTxid
argument_list|()
decl_stmt|;
if|if
condition|(
name|syncFutureSequence
operator|>
name|currentSequence
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"currentSequence="
operator|+
name|currentSequence
operator|+
literal|", syncFutureSequence="
operator|+
name|syncFutureSequence
argument_list|)
throw|;
block|}
comment|// See if we can process any syncfutures BEFORE we go sync.
name|long
name|currentHighestSyncedSequence
init|=
name|highestSyncedTxid
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentSequence
operator|<
name|currentHighestSyncedSequence
condition|)
block|{
name|syncCount
operator|+=
name|releaseSyncFuture
argument_list|(
name|takeSyncFuture
argument_list|,
name|currentHighestSyncedSequence
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Done with the 'take'. Go around again and do a new 'take'.
continue|continue;
block|}
break|break;
block|}
comment|// I got something. Lets run. Save off current sequence number in case it changes
comment|// while we run.
comment|//TODO handle htrace API change, see HBASE-18895
comment|//TraceScope scope = Trace.continueSpan(takeSyncFuture.getSpan());
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|Throwable
name|lastException
init|=
literal|null
decl_stmt|;
try|try
block|{
name|TraceUtil
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"syncing writer"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|sync
argument_list|(
name|useHsync
argument_list|)
expr_stmt|;
name|TraceUtil
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"writer synced"
argument_list|)
expr_stmt|;
name|currentSequence
operator|=
name|updateHighestSyncedSequence
argument_list|(
name|currentSequence
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error syncing, request close of WAL"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|lastException
operator|=
name|e
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"UNEXPECTED"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|lastException
operator|=
name|e
expr_stmt|;
block|}
finally|finally
block|{
comment|// reattach the span to the future before releasing.
comment|//TODO handle htrace API change, see HBASE-18895
comment|// takeSyncFuture.setSpan(scope.getSpan());
comment|// First release what we 'took' from the queue.
name|syncCount
operator|+=
name|releaseSyncFuture
argument_list|(
name|takeSyncFuture
argument_list|,
name|currentSequence
argument_list|,
name|lastException
argument_list|)
expr_stmt|;
comment|// Can we release other syncs?
name|syncCount
operator|+=
name|releaseSyncFutures
argument_list|(
name|currentSequence
argument_list|,
name|lastException
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastException
operator|!=
literal|null
condition|)
block|{
name|requestLogRoll
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|checkLogRoll
argument_list|()
expr_stmt|;
block|}
block|}
name|postSync
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
argument_list|,
name|syncCount
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Presume legit interrupt.
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"UNEXPECTED, continuing"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Schedule a log roll if needed.    */
specifier|private
name|void
name|checkLogRoll
parameter_list|()
block|{
comment|// Will return immediately if we are in the middle of a WAL log roll currently.
if|if
condition|(
operator|!
name|rollWriterLock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
return|return;
block|}
name|boolean
name|lowReplication
decl_stmt|;
try|try
block|{
name|lowReplication
operator|=
name|doCheckLogLowReplication
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|rollWriterLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lowReplication
operator|||
operator|(
name|writer
operator|!=
literal|null
operator|&&
name|writer
operator|.
name|getLength
argument_list|()
operator|>
name|logrollsize
operator|)
condition|)
block|{
name|requestLogRoll
argument_list|(
name|lowReplication
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return true if number of replicas for the WAL is lower than threshold    */
annotation|@
name|Override
specifier|protected
name|boolean
name|doCheckLogLowReplication
parameter_list|()
block|{
name|boolean
name|logRollNeeded
init|=
literal|false
decl_stmt|;
comment|// if the number of replicas in HDFS has fallen below the configured
comment|// value, then roll logs.
try|try
block|{
name|int
name|numCurrentReplicas
init|=
name|getLogReplication
argument_list|()
decl_stmt|;
if|if
condition|(
name|numCurrentReplicas
operator|!=
literal|0
operator|&&
name|numCurrentReplicas
operator|<
name|this
operator|.
name|minTolerableReplication
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|lowReplicationRollEnabled
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|consecutiveLogRolls
operator|.
name|get
argument_list|()
operator|<
name|this
operator|.
name|lowReplicationRollLimit
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"HDFS pipeline error detected. "
operator|+
literal|"Found "
operator|+
name|numCurrentReplicas
operator|+
literal|" replicas but expecting no less than "
operator|+
name|this
operator|.
name|minTolerableReplication
operator|+
literal|" replicas. "
operator|+
literal|" Requesting close of WAL. current pipeline: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|getPipeline
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|logRollNeeded
operator|=
literal|true
expr_stmt|;
comment|// If rollWriter is requested, increase consecutiveLogRolls. Once it
comment|// is larger than lowReplicationRollLimit, disable the
comment|// LowReplication-Roller
name|this
operator|.
name|consecutiveLogRolls
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Too many consecutive RollWriter requests, it's a sign of "
operator|+
literal|"the total number of live datanodes is lower than the tolerable replicas."
argument_list|)
expr_stmt|;
name|this
operator|.
name|consecutiveLogRolls
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|lowReplicationRollEnabled
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|numCurrentReplicas
operator|>=
name|this
operator|.
name|minTolerableReplication
condition|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|lowReplicationRollEnabled
condition|)
block|{
comment|// The new writer's log replicas is always the default value.
comment|// So we should not enable LowReplication-Roller. If numEntries
comment|// is lower than or equals 1, we consider it as a new writer.
if|if
condition|(
name|this
operator|.
name|numEntries
operator|.
name|get
argument_list|()
operator|<=
literal|1
condition|)
block|{
return|return
name|logRollNeeded
return|;
block|}
comment|// Once the live datanode number and the replicas return to normal,
comment|// enable the LowReplication-Roller.
name|this
operator|.
name|lowReplicationRollEnabled
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"LowReplication-Roller was enabled."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DFSOutputStream.getNumCurrentReplicas failed because of "
operator|+
name|e
operator|+
literal|", continuing..."
argument_list|)
expr_stmt|;
block|}
return|return
name|logRollNeeded
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|long
name|getSequenceOnRingBuffer
parameter_list|()
block|{
return|return
name|this
operator|.
name|disruptor
operator|.
name|getRingBuffer
argument_list|()
operator|.
name|next
argument_list|()
return|;
block|}
specifier|private
name|SyncFuture
name|publishSyncOnRingBuffer
parameter_list|(
name|boolean
name|forceSync
parameter_list|)
block|{
name|long
name|sequence
init|=
name|getSequenceOnRingBuffer
argument_list|()
decl_stmt|;
return|return
name|publishSyncOnRingBuffer
argument_list|(
name|sequence
argument_list|,
name|forceSync
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|SyncFuture
name|publishSyncOnRingBuffer
parameter_list|(
name|long
name|sequence
parameter_list|,
name|boolean
name|forceSync
parameter_list|)
block|{
comment|// here we use ring buffer sequence as transaction id
name|SyncFuture
name|syncFuture
init|=
name|getSyncFuture
argument_list|(
name|sequence
argument_list|)
operator|.
name|setForceSync
argument_list|(
name|forceSync
argument_list|)
decl_stmt|;
try|try
block|{
name|RingBufferTruck
name|truck
init|=
name|this
operator|.
name|disruptor
operator|.
name|getRingBuffer
argument_list|()
operator|.
name|get
argument_list|(
name|sequence
argument_list|)
decl_stmt|;
name|truck
operator|.
name|load
argument_list|(
name|syncFuture
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|disruptor
operator|.
name|getRingBuffer
argument_list|()
operator|.
name|publish
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
block|}
return|return
name|syncFuture
return|;
block|}
comment|// Sync all known transactions
specifier|private
name|void
name|publishSyncThenBlockOnCompletion
parameter_list|(
name|TraceScope
name|scope
parameter_list|,
name|boolean
name|forceSync
parameter_list|)
throws|throws
name|IOException
block|{
name|SyncFuture
name|syncFuture
init|=
name|publishSyncOnRingBuffer
argument_list|(
name|forceSync
argument_list|)
decl_stmt|;
name|blockOnSync
argument_list|(
name|syncFuture
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    *<p>    * If the pipeline isn't started yet or is empty, you will get the default replication factor.    * Therefore, if this function returns 0, it means you are not properly running with the HDFS-826    * patch.    */
annotation|@
name|Override
annotation|@
name|VisibleForTesting
name|int
name|getLogReplication
parameter_list|()
block|{
try|try
block|{
comment|// in standalone mode, it will return 0
if|if
condition|(
name|this
operator|.
name|hdfs_out
operator|instanceof
name|HdfsDataOutputStream
condition|)
block|{
return|return
operator|(
operator|(
name|HdfsDataOutputStream
operator|)
name|this
operator|.
name|hdfs_out
operator|)
operator|.
name|getCurrentBlockReplication
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
name|sync
argument_list|(
name|useHsync
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|(
name|boolean
name|forceSync
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"FSHLog.sync"
argument_list|)
init|)
block|{
name|publishSyncThenBlockOnCompletion
argument_list|(
name|scope
argument_list|,
name|forceSync
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|(
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
name|sync
argument_list|(
name|txid
argument_list|,
name|useHsync
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|(
name|long
name|txid
parameter_list|,
name|boolean
name|forceSync
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|highestSyncedTxid
operator|.
name|get
argument_list|()
operator|>=
name|txid
condition|)
block|{
comment|// Already sync'd.
return|return;
block|}
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"FSHLog.sync"
argument_list|)
init|)
block|{
name|publishSyncThenBlockOnCompletion
argument_list|(
name|scope
argument_list|,
name|forceSync
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
name|boolean
name|isLowReplicationRollEnabled
parameter_list|()
block|{
return|return
name|lowReplicationRollEnabled
return|;
block|}
specifier|public
specifier|static
specifier|final
name|long
name|FIXED_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|OBJECT
operator|+
operator|(
literal|5
operator|*
name|ClassSize
operator|.
name|REFERENCE
operator|)
operator|+
name|ClassSize
operator|.
name|ATOMIC_INTEGER
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
operator|+
operator|(
literal|3
operator|*
name|Bytes
operator|.
name|SIZEOF_LONG
operator|)
argument_list|)
decl_stmt|;
comment|/**    * This class is used coordinating two threads holding one thread at a 'safe point' while the    * orchestrating thread does some work that requires the first thread paused: e.g. holding the WAL    * writer while its WAL is swapped out from under it by another thread.    *<p>    * Thread A signals Thread B to hold when it gets to a 'safe point'. Thread A wait until Thread B    * gets there. When the 'safe point' has been attained, Thread B signals Thread A. Thread B then    * holds at the 'safe point'. Thread A on notification that Thread B is paused, goes ahead and    * does the work it needs to do while Thread B is holding. When Thread A is done, it flags B and    * then Thread A and Thread B continue along on their merry way. Pause and signalling 'zigzags'    * between the two participating threads. We use two latches -- one the inverse of the other --    * pausing and signaling when states are achieved.    *<p>    * To start up the drama, Thread A creates an instance of this class each time it would do this    * zigzag dance and passes it to Thread B (these classes use Latches so it is one shot only).    * Thread B notices the new instance (via reading a volatile reference or how ever) and it starts    * to work toward the 'safe point'. Thread A calls {@link #waitSafePoint(SyncFuture)} when it cannot proceed    * until the Thread B 'safe point' is attained. Thread A will be held inside in    * {@link #waitSafePoint(SyncFuture)} until Thread B reaches the 'safe point'. Once there, Thread B frees    * Thread A by calling {@link #safePointAttained()}. Thread A now knows Thread B is at the 'safe    * point' and that it is holding there (When Thread B calls {@link #safePointAttained()} it blocks    * here until Thread A calls {@link #releaseSafePoint()}). Thread A proceeds to do what it needs    * to do while Thread B is paused. When finished, it lets Thread B lose by calling    * {@link #releaseSafePoint()} and away go both Threads again.    */
specifier|static
class|class
name|SafePointZigZagLatch
block|{
comment|/**      * Count down this latch when safe point attained.      */
specifier|private
specifier|volatile
name|CountDownLatch
name|safePointAttainedLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**      * Latch to wait on. Will be released when we can proceed.      */
specifier|private
specifier|volatile
name|CountDownLatch
name|safePointReleasedLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|private
name|void
name|checkIfSyncFailed
parameter_list|(
name|SyncFuture
name|syncFuture
parameter_list|)
throws|throws
name|FailedSyncBeforeLogCloseException
block|{
if|if
condition|(
name|syncFuture
operator|.
name|isThrowable
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FailedSyncBeforeLogCloseException
argument_list|(
name|syncFuture
operator|.
name|getThrowable
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * For Thread A to call when it is ready to wait on the 'safe point' to be attained. Thread A      * will be held in here until Thread B calls {@link #safePointAttained()}      * @param syncFuture We need this as barometer on outstanding syncs. If it comes home with an      *          exception, then something is up w/ our syncing.      * @return The passed<code>syncFuture</code>      */
name|SyncFuture
name|waitSafePoint
parameter_list|(
name|SyncFuture
name|syncFuture
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|FailedSyncBeforeLogCloseException
block|{
while|while
condition|(
operator|!
name|this
operator|.
name|safePointAttainedLatch
operator|.
name|await
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
condition|)
block|{
name|checkIfSyncFailed
argument_list|(
name|syncFuture
argument_list|)
expr_stmt|;
block|}
name|checkIfSyncFailed
argument_list|(
name|syncFuture
argument_list|)
expr_stmt|;
return|return
name|syncFuture
return|;
block|}
comment|/**      * Called by Thread B when it attains the 'safe point'. In this method, Thread B signals Thread      * A it can proceed. Thread B will be held in here until {@link #releaseSafePoint()} is called      * by Thread A.      */
name|void
name|safePointAttained
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|this
operator|.
name|safePointAttainedLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|this
operator|.
name|safePointReleasedLatch
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
comment|/**      * Called by Thread A when it is done with the work it needs to do while Thread B is halted.      * This will release the Thread B held in a call to {@link #safePointAttained()}      */
name|void
name|releaseSafePoint
parameter_list|()
block|{
name|this
operator|.
name|safePointReleasedLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
comment|/**      * @return True is this is a 'cocked', fresh instance, and not one that has already fired.      */
name|boolean
name|isCocked
parameter_list|()
block|{
return|return
name|this
operator|.
name|safePointAttainedLatch
operator|.
name|getCount
argument_list|()
operator|>
literal|0
operator|&&
name|this
operator|.
name|safePointReleasedLatch
operator|.
name|getCount
argument_list|()
operator|>
literal|0
return|;
block|}
block|}
comment|/**    * Handler that is run by the disruptor ringbuffer consumer. Consumer is a SINGLE    * 'writer/appender' thread. Appends edits and starts up sync runs. Tries its best to batch up    * syncs. There is no discernible benefit batching appends so we just append as they come in    * because it simplifies the below implementation. See metrics for batching effectiveness (In    * measurement, at 100 concurrent handlers writing 1k, we are batching> 10 appends and 10 handler    * sync invocations for every actual dfsclient sync call; at 10 concurrent handlers, YMMV).    *<p>    * Herein, we have an array into which we store the sync futures as they come in. When we have a    * 'batch', we'll then pass what we have collected to a SyncRunner thread to do the filesystem    * sync. When it completes, it will then call {@link SyncFuture#done(long, Throwable)} on each of    * SyncFutures in the batch to release blocked Handler threads.    *<p>    * I've tried various effects to try and make latencies low while keeping throughput high. I've    * tried keeping a single Queue of SyncFutures in this class appending to its tail as the syncs    * coming and having sync runner threads poll off the head to 'finish' completed SyncFutures. I've    * tried linkedlist, and various from concurrent utils whether LinkedBlockingQueue or    * ArrayBlockingQueue, etc. The more points of synchronization, the more 'work' (according to    * 'perf stats') that has to be done; small increases in stall percentages seem to have a big    * impact on throughput/latencies. The below model where we have an array into which we stash the    * syncs and then hand them off to the sync thread seemed like a decent compromise. See HBASE-8755    * for more detail.    */
class|class
name|RingBufferEventHandler
implements|implements
name|EventHandler
argument_list|<
name|RingBufferTruck
argument_list|>
implements|,
name|LifecycleAware
block|{
specifier|private
specifier|final
name|SyncRunner
index|[]
name|syncRunners
decl_stmt|;
specifier|private
specifier|final
name|SyncFuture
index|[]
name|syncFutures
decl_stmt|;
comment|// Had 'interesting' issues when this was non-volatile. On occasion, we'd not pass all
comment|// syncFutures to the next sync'ing thread.
specifier|private
name|AtomicInteger
name|syncFuturesCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
specifier|private
specifier|volatile
name|SafePointZigZagLatch
name|zigzagLatch
decl_stmt|;
comment|/**      * Set if we get an exception appending or syncing so that all subsequence appends and syncs on      * this WAL fail until WAL is replaced.      */
specifier|private
name|Exception
name|exception
init|=
literal|null
decl_stmt|;
comment|/**      * Object to block on while waiting on safe point.      */
specifier|private
specifier|final
name|Object
name|safePointWaiter
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|shutdown
init|=
literal|false
decl_stmt|;
comment|/**      * Which syncrunner to use next.      */
specifier|private
name|int
name|syncRunnerIndex
decl_stmt|;
name|RingBufferEventHandler
parameter_list|(
specifier|final
name|int
name|syncRunnerCount
parameter_list|,
specifier|final
name|int
name|maxHandlersCount
parameter_list|)
block|{
name|this
operator|.
name|syncFutures
operator|=
operator|new
name|SyncFuture
index|[
name|maxHandlersCount
index|]
expr_stmt|;
name|this
operator|.
name|syncRunners
operator|=
operator|new
name|SyncRunner
index|[
name|syncRunnerCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|syncRunnerCount
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|.
name|syncRunners
index|[
name|i
index|]
operator|=
operator|new
name|SyncRunner
argument_list|(
literal|"sync."
operator|+
name|i
argument_list|,
name|maxHandlersCount
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|cleanupOutstandingSyncsOnException
parameter_list|(
specifier|final
name|long
name|sequence
parameter_list|,
specifier|final
name|Exception
name|e
parameter_list|)
block|{
comment|// There could be handler-count syncFutures outstanding.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|syncFuturesCount
operator|.
name|get
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|.
name|syncFutures
index|[
name|i
index|]
operator|.
name|done
argument_list|(
name|sequence
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|syncFuturesCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * @return True if outstanding sync futures still      */
specifier|private
name|boolean
name|isOutstandingSyncs
parameter_list|()
block|{
comment|// Look at SyncFutures in the EventHandler
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|syncFuturesCount
operator|.
name|get
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|syncFutures
index|[
name|i
index|]
operator|.
name|isDone
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|isOutstandingSyncsFromRunners
parameter_list|()
block|{
comment|// Look at SyncFutures in the SyncRunners
for|for
control|(
name|SyncRunner
name|syncRunner
range|:
name|syncRunners
control|)
block|{
if|if
condition|(
name|syncRunner
operator|.
name|isAlive
argument_list|()
operator|&&
operator|!
name|syncRunner
operator|.
name|areSyncFuturesReleased
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
comment|// We can set endOfBatch in the below method if at end of our this.syncFutures array
specifier|public
name|void
name|onEvent
parameter_list|(
specifier|final
name|RingBufferTruck
name|truck
parameter_list|,
specifier|final
name|long
name|sequence
parameter_list|,
name|boolean
name|endOfBatch
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Appends and syncs are coming in order off the ringbuffer. We depend on this fact. We'll
comment|// add appends to dfsclient as they come in. Batching appends doesn't give any significant
comment|// benefit on measurement. Handler sync calls we will batch up. If we get an exception
comment|// appending an edit, we fail all subsequent appends and syncs with the same exception until
comment|// the WAL is reset. It is important that we not short-circuit and exit early this method.
comment|// It is important that we always go through the attainSafePoint on the end. Another thread,
comment|// the log roller may be waiting on a signal from us here and will just hang without it.
try|try
block|{
if|if
condition|(
name|truck
operator|.
name|type
argument_list|()
operator|==
name|RingBufferTruck
operator|.
name|Type
operator|.
name|SYNC
condition|)
block|{
name|this
operator|.
name|syncFutures
index|[
name|this
operator|.
name|syncFuturesCount
operator|.
name|getAndIncrement
argument_list|()
index|]
operator|=
name|truck
operator|.
name|unloadSync
argument_list|()
expr_stmt|;
comment|// Force flush of syncs if we are carrying a full complement of syncFutures.
if|if
condition|(
name|this
operator|.
name|syncFuturesCount
operator|.
name|get
argument_list|()
operator|==
name|this
operator|.
name|syncFutures
operator|.
name|length
condition|)
block|{
name|endOfBatch
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|truck
operator|.
name|type
argument_list|()
operator|==
name|RingBufferTruck
operator|.
name|Type
operator|.
name|APPEND
condition|)
block|{
name|FSWALEntry
name|entry
init|=
name|truck
operator|.
name|unloadAppend
argument_list|()
decl_stmt|;
comment|//TODO handle htrace API change, see HBASE-18895
comment|//TraceScope scope = Trace.continueSpan(entry.detachSpan());
try|try
block|{
if|if
condition|(
name|this
operator|.
name|exception
operator|!=
literal|null
condition|)
block|{
comment|// Return to keep processing events coming off the ringbuffer
return|return;
block|}
name|append
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Failed append. Record the exception.
name|this
operator|.
name|exception
operator|=
name|e
expr_stmt|;
comment|// invoking cleanupOutstandingSyncsOnException when append failed with exception,
comment|// it will cleanup existing sync requests recorded in syncFutures but not offered to SyncRunner yet,
comment|// so there won't be any sync future left over if no further truck published to disruptor.
name|cleanupOutstandingSyncsOnException
argument_list|(
name|sequence
argument_list|,
name|this
operator|.
name|exception
operator|instanceof
name|DamagedWALException
condition|?
name|this
operator|.
name|exception
else|:
operator|new
name|DamagedWALException
argument_list|(
literal|"On sync"
argument_list|,
name|this
operator|.
name|exception
argument_list|)
argument_list|)
expr_stmt|;
comment|// Return to keep processing events coming off the ringbuffer
return|return;
block|}
block|}
else|else
block|{
comment|// What is this if not an append or sync. Fail all up to this!!!
name|cleanupOutstandingSyncsOnException
argument_list|(
name|sequence
argument_list|,
operator|new
name|IllegalStateException
argument_list|(
literal|"Neither append nor sync"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Return to keep processing.
return|return;
block|}
comment|// TODO: Check size and if big go ahead and call a sync if we have enough data.
comment|// This is a sync. If existing exception, fall through. Else look to see if batch.
if|if
condition|(
name|this
operator|.
name|exception
operator|==
literal|null
condition|)
block|{
comment|// If not a batch, return to consume more events from the ring buffer before proceeding;
comment|// we want to get up a batch of syncs and appends before we go do a filesystem sync.
if|if
condition|(
operator|!
name|endOfBatch
operator|||
name|this
operator|.
name|syncFuturesCount
operator|.
name|get
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
comment|// syncRunnerIndex is bound to the range [0, Integer.MAX_INT - 1] as follows:
comment|//   * The maximum value possible for syncRunners.length is Integer.MAX_INT
comment|//   * syncRunnerIndex starts at 0 and is incremented only here
comment|//   * after the increment, the value is bounded by the '%' operator to
comment|//     [0, syncRunners.length), presuming the value was positive prior to
comment|//     the '%' operator.
comment|//   * after being bound to [0, Integer.MAX_INT - 1], the new value is stored in
comment|//     syncRunnerIndex ensuring that it can't grow without bound and overflow.
comment|//   * note that the value after the increment must be positive, because the most it
comment|//     could have been prior was Integer.MAX_INT - 1 and we only increment by 1.
name|this
operator|.
name|syncRunnerIndex
operator|=
operator|(
name|this
operator|.
name|syncRunnerIndex
operator|+
literal|1
operator|)
operator|%
name|this
operator|.
name|syncRunners
operator|.
name|length
expr_stmt|;
try|try
block|{
comment|// Below expects that the offer 'transfers' responsibility for the outstanding syncs to
comment|// the syncRunner. We should never get an exception in here.
name|this
operator|.
name|syncRunners
index|[
name|this
operator|.
name|syncRunnerIndex
index|]
operator|.
name|offer
argument_list|(
name|sequence
argument_list|,
name|this
operator|.
name|syncFutures
argument_list|,
name|this
operator|.
name|syncFuturesCount
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Should NEVER get here.
name|requestLogRoll
argument_list|()
expr_stmt|;
name|this
operator|.
name|exception
operator|=
operator|new
name|DamagedWALException
argument_list|(
literal|"Failed offering sync"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// We may have picked up an exception above trying to offer sync
if|if
condition|(
name|this
operator|.
name|exception
operator|!=
literal|null
condition|)
block|{
name|cleanupOutstandingSyncsOnException
argument_list|(
name|sequence
argument_list|,
name|this
operator|.
name|exception
operator|instanceof
name|DamagedWALException
condition|?
name|this
operator|.
name|exception
else|:
operator|new
name|DamagedWALException
argument_list|(
literal|"On sync"
argument_list|,
name|this
operator|.
name|exception
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|attainSafePoint
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
name|this
operator|.
name|syncFuturesCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"UNEXPECTED!!! syncFutures.length="
operator|+
name|this
operator|.
name|syncFutures
operator|.
name|length
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|SafePointZigZagLatch
name|attainSafePoint
parameter_list|()
block|{
name|this
operator|.
name|zigzagLatch
operator|=
operator|new
name|SafePointZigZagLatch
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|zigzagLatch
return|;
block|}
comment|/**      * Check if we should attain safe point. If so, go there and then wait till signalled before we      * proceeding.      */
specifier|private
name|void
name|attainSafePoint
parameter_list|(
specifier|final
name|long
name|currentSequence
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|zigzagLatch
operator|==
literal|null
operator|||
operator|!
name|this
operator|.
name|zigzagLatch
operator|.
name|isCocked
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// If here, another thread is waiting on us to get to safe point. Don't leave it hanging.
name|beforeWaitOnSafePoint
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Wait on outstanding syncers; wait for them to finish syncing (unless we've been
comment|// shutdown or unless our latch has been thrown because we have been aborted or unless
comment|// this WAL is broken and we can't get a sync/append to complete).
while|while
condition|(
operator|(
operator|!
name|this
operator|.
name|shutdown
operator|&&
name|this
operator|.
name|zigzagLatch
operator|.
name|isCocked
argument_list|()
operator|&&
name|highestSyncedTxid
operator|.
name|get
argument_list|()
operator|<
name|currentSequence
operator|&&
comment|// We could be in here and all syncs are failing or failed. Check for this. Otherwise
comment|// we'll just be stuck here for ever. In other words, ensure there syncs running.
name|isOutstandingSyncs
argument_list|()
operator|)
comment|// Wait for all SyncRunners to finish their work so that we can replace the writer
operator|||
name|isOutstandingSyncsFromRunners
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|safePointWaiter
init|)
block|{
name|this
operator|.
name|safePointWaiter
operator|.
name|wait
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Tell waiting thread we've attained safe point. Can clear this.throwable if set here
comment|// because we know that next event through the ringbuffer will be going to a new WAL
comment|// after we do the zigzaglatch dance.
name|this
operator|.
name|exception
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|zigzagLatch
operator|.
name|safePointAttained
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Append to the WAL. Does all CP and WAL listener calls.      */
name|void
name|append
parameter_list|(
specifier|final
name|FSWALEntry
name|entry
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|FSHLog
operator|.
name|this
operator|.
name|append
argument_list|(
name|writer
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Append sequenceId="
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getSequenceId
argument_list|()
operator|+
literal|", requesting roll of WAL"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|requestLogRoll
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|DamagedWALException
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onStart
parameter_list|()
block|{
for|for
control|(
name|SyncRunner
name|syncRunner
range|:
name|this
operator|.
name|syncRunners
control|)
block|{
name|syncRunner
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onShutdown
parameter_list|()
block|{
for|for
control|(
name|SyncRunner
name|syncRunner
range|:
name|this
operator|.
name|syncRunners
control|)
block|{
name|syncRunner
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * This method gets the pipeline for the current WAL.    */
annotation|@
name|Override
name|DatanodeInfo
index|[]
name|getPipeline
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|hdfs_out
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|hdfs_out
operator|.
name|getWrappedStream
argument_list|()
operator|instanceof
name|DFSOutputStream
condition|)
block|{
return|return
operator|(
operator|(
name|DFSOutputStream
operator|)
name|this
operator|.
name|hdfs_out
operator|.
name|getWrappedStream
argument_list|()
operator|)
operator|.
name|getPipeline
argument_list|()
return|;
block|}
block|}
return|return
operator|new
name|DatanodeInfo
index|[
literal|0
index|]
return|;
block|}
block|}
end_class

end_unit

