begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUTKey WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|TableProcedureInterface
operator|.
name|TableOperationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|AbstractProcedureScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|Procedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureEventQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlKeyComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlIterableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlLinkedNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlTreeIterator
import|;
end_import

begin_comment
comment|/**  * ProcedureScheduler for the Master Procedures.  * This ProcedureScheduler tries to provide to the ProcedureExecutor procedures  * that can be executed without having to wait on a lock.  * Most of the master operations can be executed concurrently, if they  * are operating on different tables (e.g. two create table can be performed  * at the same, time assuming table A and table B) or against two different servers; say  * two servers that crashed at about the same time.  *  *<p>Each procedure should implement an interface providing information for this queue.  * for example table related procedures should implement TableProcedureInterface.  * each procedure will be pushed in its own queue, and based on the operation type  * we may take smarter decision. e.g. we can abort all the operations preceding  * a delete table, or similar.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|MasterProcedureScheduler
extends|extends
name|AbstractProcedureScheduler
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|MasterProcedureScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|NamespaceQueueKeyComparator
name|NAMESPACE_QUEUE_KEY_COMPARATOR
init|=
operator|new
name|NamespaceQueueKeyComparator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|ServerQueueKeyComparator
name|SERVER_QUEUE_KEY_COMPARATOR
init|=
operator|new
name|ServerQueueKeyComparator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|TableQueueKeyComparator
name|TABLE_QUEUE_KEY_COMPARATOR
init|=
operator|new
name|TableQueueKeyComparator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|FairQueue
argument_list|<
name|ServerName
argument_list|>
name|serverRunQueue
init|=
operator|new
name|FairQueue
argument_list|<
name|ServerName
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|FairQueue
argument_list|<
name|TableName
argument_list|>
name|tableRunQueue
init|=
operator|new
name|FairQueue
argument_list|<
name|TableName
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ServerQueue
index|[]
name|serverBuckets
init|=
operator|new
name|ServerQueue
index|[
literal|128
index|]
decl_stmt|;
specifier|private
name|NamespaceQueue
name|namespaceMap
init|=
literal|null
decl_stmt|;
specifier|private
name|TableQueue
name|tableMap
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|int
name|metaTablePriority
decl_stmt|;
specifier|private
specifier|final
name|int
name|userTablePriority
decl_stmt|;
specifier|private
specifier|final
name|int
name|sysTablePriority
decl_stmt|;
specifier|public
name|MasterProcedureScheduler
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
comment|// TODO: should this be part of the HTD?
name|metaTablePriority
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.procedure.queue.meta.table.priority"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sysTablePriority
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.procedure.queue.system.table.priority"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|userTablePriority
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.procedure.queue.user.table.priority"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|yield
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
name|push
argument_list|(
name|proc
argument_list|,
name|isTableProcedure
argument_list|(
name|proc
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|enqueue
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|,
specifier|final
name|boolean
name|addFront
parameter_list|)
block|{
if|if
condition|(
name|isTableProcedure
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|doAdd
argument_list|(
name|tableRunQueue
argument_list|,
name|getTableQueue
argument_list|(
name|getTableName
argument_list|(
name|proc
argument_list|)
argument_list|)
argument_list|,
name|proc
argument_list|,
name|addFront
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isServerProcedure
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|doAdd
argument_list|(
name|serverRunQueue
argument_list|,
name|getServerQueue
argument_list|(
name|getServerName
argument_list|(
name|proc
argument_list|)
argument_list|)
argument_list|,
name|proc
argument_list|,
name|addFront
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: at the moment we only have Table and Server procedures
comment|// if you are implementing a non-table/non-server procedure, you have two options: create
comment|// a group for all the non-table/non-server procedures or try to find a key for your
comment|// non-table/non-server procedures and implement something similar to the TableRunQueue.
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"RQs for non-table/non-server procedures are not implemented yet: "
operator|+
name|proc
argument_list|)
throw|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|doAdd
parameter_list|(
specifier|final
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|,
specifier|final
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|,
specifier|final
name|Procedure
name|proc
parameter_list|,
specifier|final
name|boolean
name|addFront
parameter_list|)
block|{
if|if
condition|(
name|proc
operator|.
name|isSuspended
argument_list|()
condition|)
return|return;
name|queue
operator|.
name|add
argument_list|(
name|proc
argument_list|,
name|addFront
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|queue
operator|.
name|hasExclusiveLock
argument_list|()
operator|||
name|queue
operator|.
name|isLockOwner
argument_list|(
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
condition|)
block|{
comment|// if the queue was not remove for an xlock execution
comment|// or the proc is the lock owner, put the queue back into execution
name|addToRunQueue
argument_list|(
name|fairq
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|queue
operator|.
name|hasParentLock
argument_list|(
name|proc
argument_list|)
condition|)
block|{
assert|assert
name|addFront
operator|:
literal|"expected to add a child in the front"
assert|;
assert|assert
operator|!
name|queue
operator|.
name|isSuspended
argument_list|()
operator|:
literal|"unexpected suspended state for the queue"
assert|;
comment|// our (proc) parent has the xlock,
comment|// so the queue is not in the fairq (run-queue)
comment|// add it back to let the child run (inherit the lock)
name|addToRunQueue
argument_list|(
name|fairq
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|queueHasRunnables
parameter_list|()
block|{
return|return
name|tableRunQueue
operator|.
name|hasRunnables
argument_list|()
operator|||
name|serverRunQueue
operator|.
name|hasRunnables
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Procedure
name|dequeue
parameter_list|()
block|{
comment|// For now, let server handling have precedence over table handling; presumption is that it
comment|// is more important handling crashed servers than it is running the
comment|// enabling/disabling tables, etc.
name|Procedure
name|pollResult
init|=
name|doPoll
argument_list|(
name|serverRunQueue
argument_list|)
decl_stmt|;
if|if
condition|(
name|pollResult
operator|==
literal|null
condition|)
block|{
name|pollResult
operator|=
name|doPoll
argument_list|(
name|tableRunQueue
argument_list|)
expr_stmt|;
block|}
return|return
name|pollResult
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|>
name|Procedure
name|doPoll
parameter_list|(
specifier|final
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|)
block|{
specifier|final
name|Queue
argument_list|<
name|T
argument_list|>
name|rq
init|=
name|fairq
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|rq
operator|==
literal|null
operator|||
operator|!
name|rq
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
assert|assert
operator|!
name|rq
operator|.
name|isSuspended
argument_list|()
operator|:
literal|"rq="
operator|+
name|rq
operator|+
literal|" is suspended"
assert|;
specifier|final
name|Procedure
name|pollResult
init|=
name|rq
operator|.
name|peek
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|xlockReq
init|=
name|rq
operator|.
name|requireExclusiveLock
argument_list|(
name|pollResult
argument_list|)
decl_stmt|;
if|if
condition|(
name|xlockReq
operator|&&
name|rq
operator|.
name|isLocked
argument_list|()
operator|&&
operator|!
name|rq
operator|.
name|hasLockAccess
argument_list|(
name|pollResult
argument_list|)
condition|)
block|{
comment|// someone is already holding the lock (e.g. shared lock). avoid a yield
return|return
literal|null
return|;
block|}
name|rq
operator|.
name|poll
argument_list|()
expr_stmt|;
if|if
condition|(
name|rq
operator|.
name|isEmpty
argument_list|()
operator|||
name|xlockReq
condition|)
block|{
name|removeFromRunQueue
argument_list|(
name|fairq
argument_list|,
name|rq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|.
name|hasParentLock
argument_list|(
name|pollResult
argument_list|)
condition|)
block|{
comment|// if the rq is in the fairq because of runnable child
comment|// check if the next procedure is still a child.
comment|// if not, remove the rq from the fairq and go back to the xlock state
name|Procedure
name|nextProc
init|=
name|rq
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextProc
operator|!=
literal|null
operator|&&
operator|!
name|Procedure
operator|.
name|haveSameParent
argument_list|(
name|nextProc
argument_list|,
name|pollResult
argument_list|)
condition|)
block|{
name|removeFromRunQueue
argument_list|(
name|fairq
argument_list|,
name|rq
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pollResult
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearQueue
parameter_list|()
block|{
comment|// Remove Servers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|serverBuckets
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|clear
argument_list|(
name|serverBuckets
index|[
name|i
index|]
argument_list|,
name|serverRunQueue
argument_list|,
name|SERVER_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
name|serverBuckets
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
comment|// Remove Namespaces
name|clear
argument_list|(
name|namespaceMap
argument_list|,
literal|null
argument_list|,
name|NAMESPACE_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
name|namespaceMap
operator|=
literal|null
expr_stmt|;
comment|// Remove Tables
name|clear
argument_list|(
name|tableMap
argument_list|,
name|tableRunQueue
argument_list|,
name|TABLE_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
name|tableMap
operator|=
literal|null
expr_stmt|;
assert|assert
name|size
argument_list|()
operator|==
literal|0
operator|:
literal|"expected queue size to be 0, got "
operator|+
name|size
argument_list|()
assert|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|,
name|TNode
extends|extends
name|Queue
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|clear
parameter_list|(
name|TNode
name|treeMap
parameter_list|,
specifier|final
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|,
specifier|final
name|AvlKeyComparator
argument_list|<
name|TNode
argument_list|>
name|comparator
parameter_list|)
block|{
while|while
condition|(
name|treeMap
operator|!=
literal|null
condition|)
block|{
name|Queue
argument_list|<
name|T
argument_list|>
name|node
init|=
name|AvlTree
operator|.
name|getFirst
argument_list|(
name|treeMap
argument_list|)
decl_stmt|;
assert|assert
operator|!
name|node
operator|.
name|isSuspended
argument_list|()
operator|:
literal|"can't clear suspended "
operator|+
name|node
operator|.
name|getKey
argument_list|()
assert|;
name|treeMap
operator|=
name|AvlTree
operator|.
name|remove
argument_list|(
name|treeMap
argument_list|,
name|node
operator|.
name|getKey
argument_list|()
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|fairq
operator|!=
literal|null
condition|)
name|removeFromRunQueue
argument_list|(
name|fairq
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|int
name|queueSize
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|// Server queues
specifier|final
name|AvlTreeIterator
argument_list|<
name|ServerQueue
argument_list|>
name|serverIter
init|=
operator|new
name|AvlTreeIterator
argument_list|<
name|ServerQueue
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|serverBuckets
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|serverIter
operator|.
name|seekFirst
argument_list|(
name|serverBuckets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|serverIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|count
operator|+=
name|serverIter
operator|.
name|next
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Table queues
specifier|final
name|AvlTreeIterator
argument_list|<
name|TableQueue
argument_list|>
name|tableIter
init|=
operator|new
name|AvlTreeIterator
argument_list|<
name|TableQueue
argument_list|>
argument_list|(
name|tableMap
argument_list|)
decl_stmt|;
while|while
condition|(
name|tableIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|count
operator|+=
name|tableIter
operator|.
name|next
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|completionCleanup
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
if|if
condition|(
name|proc
operator|instanceof
name|TableProcedureInterface
condition|)
block|{
name|TableProcedureInterface
name|iProcTable
init|=
operator|(
name|TableProcedureInterface
operator|)
name|proc
decl_stmt|;
name|boolean
name|tableDeleted
decl_stmt|;
if|if
condition|(
name|proc
operator|.
name|hasException
argument_list|()
condition|)
block|{
name|Exception
name|procEx
init|=
name|proc
operator|.
name|getException
argument_list|()
operator|.
name|unwrapRemoteException
argument_list|()
decl_stmt|;
if|if
condition|(
name|iProcTable
operator|.
name|getTableOperationType
argument_list|()
operator|==
name|TableOperationType
operator|.
name|CREATE
condition|)
block|{
comment|// create failed because the table already exist
name|tableDeleted
operator|=
operator|!
operator|(
name|procEx
operator|instanceof
name|TableExistsException
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// the operation failed because the table does not exist
name|tableDeleted
operator|=
operator|(
name|procEx
operator|instanceof
name|TableNotFoundException
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// the table was deleted
name|tableDeleted
operator|=
operator|(
name|iProcTable
operator|.
name|getTableOperationType
argument_list|()
operator|==
name|TableOperationType
operator|.
name|DELETE
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tableDeleted
condition|)
block|{
name|markTableAsDeleted
argument_list|(
name|iProcTable
operator|.
name|getTableName
argument_list|()
argument_list|,
name|proc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// No cleanup for ServerProcedureInterface types, yet.
return|return;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|addToRunQueue
parameter_list|(
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|,
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
if|if
condition|(
operator|!
name|AvlIterableList
operator|.
name|isLinked
argument_list|(
name|queue
argument_list|)
operator|&&
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|queue
operator|.
name|isSuspended
argument_list|()
condition|)
block|{
name|fairq
operator|.
name|add
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|removeFromRunQueue
parameter_list|(
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|,
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
if|if
condition|(
name|AvlIterableList
operator|.
name|isLinked
argument_list|(
name|queue
argument_list|)
condition|)
block|{
name|fairq
operator|.
name|remove
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ============================================================================
comment|//  Table Queue Lookup Helpers
comment|// ============================================================================
specifier|private
name|TableQueue
name|getTableQueueWithLock
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getTableQueue
argument_list|(
name|tableName
argument_list|)
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|TableQueue
name|getTableQueue
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
name|TableQueue
name|node
init|=
name|AvlTree
operator|.
name|get
argument_list|(
name|tableMap
argument_list|,
name|tableName
argument_list|,
name|TABLE_QUEUE_KEY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
return|return
name|node
return|;
name|NamespaceQueue
name|nsQueue
init|=
name|getNamespaceQueue
argument_list|(
name|tableName
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|=
operator|new
name|TableQueue
argument_list|(
name|tableName
argument_list|,
name|nsQueue
argument_list|,
name|getTablePriority
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|tableMap
operator|=
name|AvlTree
operator|.
name|insert
argument_list|(
name|tableMap
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|private
name|void
name|removeTableQueue
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
name|tableMap
operator|=
name|AvlTree
operator|.
name|remove
argument_list|(
name|tableMap
argument_list|,
name|tableName
argument_list|,
name|TABLE_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|getTablePriority
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
name|metaTablePriority
return|;
block|}
elseif|else
if|if
condition|(
name|tableName
operator|.
name|isSystemTable
argument_list|()
condition|)
block|{
return|return
name|sysTablePriority
return|;
block|}
return|return
name|userTablePriority
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isTableProcedure
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
return|return
name|proc
operator|instanceof
name|TableProcedureInterface
return|;
block|}
specifier|private
specifier|static
name|TableName
name|getTableName
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|TableProcedureInterface
operator|)
name|proc
operator|)
operator|.
name|getTableName
argument_list|()
return|;
block|}
comment|// ============================================================================
comment|//  Namespace Queue Lookup Helpers
comment|// ============================================================================
specifier|private
name|NamespaceQueue
name|getNamespaceQueue
parameter_list|(
name|String
name|namespace
parameter_list|)
block|{
name|NamespaceQueue
name|node
init|=
name|AvlTree
operator|.
name|get
argument_list|(
name|namespaceMap
argument_list|,
name|namespace
argument_list|,
name|NAMESPACE_QUEUE_KEY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
return|return
operator|(
name|NamespaceQueue
operator|)
name|node
return|;
name|node
operator|=
operator|new
name|NamespaceQueue
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
name|namespaceMap
operator|=
name|AvlTree
operator|.
name|insert
argument_list|(
name|namespaceMap
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
comment|// ============================================================================
comment|//  Server Queue Lookup Helpers
comment|// ============================================================================
specifier|private
name|ServerQueue
name|getServerQueueWithLock
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getServerQueue
argument_list|(
name|serverName
argument_list|)
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|ServerQueue
name|getServerQueue
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|getBucketIndex
argument_list|(
name|serverBuckets
argument_list|,
name|serverName
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|ServerQueue
name|node
init|=
name|AvlTree
operator|.
name|get
argument_list|(
name|serverBuckets
index|[
name|index
index|]
argument_list|,
name|serverName
argument_list|,
name|SERVER_QUEUE_KEY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
return|return
name|node
return|;
name|node
operator|=
operator|new
name|ServerQueue
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|serverBuckets
index|[
name|index
index|]
operator|=
name|AvlTree
operator|.
name|insert
argument_list|(
name|serverBuckets
index|[
name|index
index|]
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|ServerQueue
operator|)
name|node
return|;
block|}
specifier|private
name|void
name|removeServerQueue
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|getBucketIndex
argument_list|(
name|serverBuckets
argument_list|,
name|serverName
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ServerQueue
name|root
init|=
name|serverBuckets
index|[
name|index
index|]
decl_stmt|;
name|serverBuckets
index|[
name|index
index|]
operator|=
name|AvlTree
operator|.
name|remove
argument_list|(
name|root
argument_list|,
name|serverName
argument_list|,
name|SERVER_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|int
name|getBucketIndex
parameter_list|(
name|Object
index|[]
name|buckets
parameter_list|,
name|int
name|hashCode
parameter_list|)
block|{
return|return
name|Math
operator|.
name|abs
argument_list|(
name|hashCode
argument_list|)
operator|%
name|buckets
operator|.
name|length
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isServerProcedure
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
return|return
name|proc
operator|instanceof
name|ServerProcedureInterface
return|;
block|}
specifier|private
specifier|static
name|ServerName
name|getServerName
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ServerProcedureInterface
operator|)
name|proc
operator|)
operator|.
name|getServerName
argument_list|()
return|;
block|}
comment|// ============================================================================
comment|//  Table and Server Queue Implementation
comment|// ============================================================================
specifier|private
specifier|static
class|class
name|ServerQueueKeyComparator
implements|implements
name|AvlKeyComparator
argument_list|<
name|ServerQueue
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compareKey
parameter_list|(
name|ServerQueue
name|node
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
return|return
name|node
operator|.
name|compareKey
argument_list|(
operator|(
name|ServerName
operator|)
name|key
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|ServerQueue
extends|extends
name|QueueImpl
argument_list|<
name|ServerName
argument_list|>
block|{
specifier|public
name|ServerQueue
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
name|super
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|requireExclusiveLock
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
name|ServerProcedureInterface
name|spi
init|=
operator|(
name|ServerProcedureInterface
operator|)
name|proc
decl_stmt|;
switch|switch
condition|(
name|spi
operator|.
name|getServerOperationType
argument_list|()
condition|)
block|{
case|case
name|CRASH_HANDLER
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"unexpected type "
operator|+
name|spi
operator|.
name|getServerOperationType
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
class|class
name|RegionEvent
extends|extends
name|ProcedureEventQueue
block|{
specifier|private
specifier|final
name|HRegionInfo
name|regionInfo
decl_stmt|;
specifier|private
name|long
name|exclusiveLockProcIdOwner
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
specifier|public
name|RegionEvent
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|this
operator|.
name|regionInfo
operator|=
name|regionInfo
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasExclusiveLock
parameter_list|()
block|{
return|return
name|exclusiveLockProcIdOwner
operator|!=
name|Long
operator|.
name|MIN_VALUE
return|;
block|}
specifier|public
name|boolean
name|isLockOwner
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
return|return
name|exclusiveLockProcIdOwner
operator|==
name|procId
return|;
block|}
specifier|public
name|boolean
name|hasParentLock
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
return|return
name|proc
operator|.
name|hasParent
argument_list|()
operator|&&
operator|(
name|isLockOwner
argument_list|(
name|proc
operator|.
name|getParentProcId
argument_list|()
argument_list|)
operator|||
name|isLockOwner
argument_list|(
name|proc
operator|.
name|getRootProcId
argument_list|()
argument_list|)
operator|)
return|;
block|}
specifier|public
name|boolean
name|hasLockAccess
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
return|return
name|isLockOwner
argument_list|(
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
operator|||
name|hasParentLock
argument_list|(
name|proc
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|tryExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
if|if
condition|(
name|hasExclusiveLock
argument_list|()
condition|)
return|return
name|hasLockAccess
argument_list|(
name|proc
argument_list|)
return|;
name|exclusiveLockProcIdOwner
operator|=
name|proc
operator|.
name|getProcId
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|releaseExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
if|if
condition|(
name|isLockOwner
argument_list|(
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
condition|)
block|{
name|exclusiveLockProcIdOwner
operator|=
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|HRegionInfo
name|getRegionInfo
parameter_list|()
block|{
return|return
name|regionInfo
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"RegionEvent("
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|")"
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|TableQueueKeyComparator
implements|implements
name|AvlKeyComparator
argument_list|<
name|TableQueue
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compareKey
parameter_list|(
name|TableQueue
name|node
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
return|return
name|node
operator|.
name|compareKey
argument_list|(
operator|(
name|TableName
operator|)
name|key
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|TableQueue
extends|extends
name|QueueImpl
argument_list|<
name|TableName
argument_list|>
block|{
specifier|private
specifier|final
name|NamespaceQueue
name|namespaceQueue
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|RegionEvent
argument_list|>
name|regionEventMap
decl_stmt|;
specifier|public
name|TableQueue
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|NamespaceQueue
name|namespaceQueue
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|super
argument_list|(
name|tableName
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|this
operator|.
name|namespaceQueue
operator|=
name|namespaceQueue
expr_stmt|;
block|}
specifier|public
name|NamespaceQueue
name|getNamespaceQueue
parameter_list|()
block|{
return|return
name|namespaceQueue
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|isAvailable
parameter_list|()
block|{
comment|// if there are no items in the queue, or the namespace is locked.
comment|// we can't execute operation on this table
if|if
condition|(
name|isEmpty
argument_list|()
operator|||
name|namespaceQueue
operator|.
name|hasExclusiveLock
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|hasExclusiveLock
argument_list|()
condition|)
block|{
comment|// if we have an exclusive lock already taken
comment|// only child of the lock owner can be executed
specifier|final
name|Procedure
name|nextProc
init|=
name|peek
argument_list|()
decl_stmt|;
return|return
name|nextProc
operator|!=
literal|null
operator|&&
name|hasLockAccess
argument_list|(
name|nextProc
argument_list|)
return|;
block|}
comment|// no xlock
return|return
literal|true
return|;
block|}
specifier|public
specifier|synchronized
name|RegionEvent
name|getRegionEvent
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
if|if
condition|(
name|regionEventMap
operator|==
literal|null
condition|)
block|{
name|regionEventMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RegionEvent
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|RegionEvent
name|event
init|=
name|regionEventMap
operator|.
name|get
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|event
operator|==
literal|null
condition|)
block|{
name|event
operator|=
operator|new
name|RegionEvent
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|regionEventMap
operator|.
name|put
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
return|return
name|event
return|;
block|}
specifier|public
specifier|synchronized
name|void
name|removeRegionEvent
parameter_list|(
specifier|final
name|RegionEvent
name|event
parameter_list|)
block|{
name|regionEventMap
operator|.
name|remove
argument_list|(
name|event
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionEventMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|regionEventMap
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// TODO: We can abort pending/in-progress operation if the new call is
comment|//       something like drop table. We can Override addBack(),
comment|//       check the type and abort all the in-flight procedurs.
specifier|private
name|boolean
name|canAbortPendingOperations
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
name|TableProcedureInterface
name|tpi
init|=
operator|(
name|TableProcedureInterface
operator|)
name|proc
decl_stmt|;
switch|switch
condition|(
name|tpi
operator|.
name|getTableOperationType
argument_list|()
condition|)
block|{
case|case
name|DELETE
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
specifier|public
name|boolean
name|requireExclusiveLock
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
name|TableProcedureInterface
name|tpi
init|=
operator|(
name|TableProcedureInterface
operator|)
name|proc
decl_stmt|;
switch|switch
condition|(
name|tpi
operator|.
name|getTableOperationType
argument_list|()
condition|)
block|{
case|case
name|CREATE
case|:
case|case
name|DELETE
case|:
case|case
name|DISABLE
case|:
case|case
name|ENABLE
case|:
return|return
literal|true
return|;
case|case
name|EDIT
case|:
comment|// we allow concurrent edit on the NS table
return|return
operator|!
name|tpi
operator|.
name|getTableName
argument_list|()
operator|.
name|equals
argument_list|(
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
argument_list|)
return|;
case|case
name|READ
case|:
return|return
literal|false
return|;
comment|// region operations are using the shared-lock on the table
comment|// and then they will grab an xlock on the region.
case|case
name|SPLIT
case|:
case|case
name|MERGE
case|:
case|case
name|ASSIGN
case|:
case|case
name|UNASSIGN
case|:
case|case
name|REGION_EDIT
case|:
return|return
literal|false
return|;
default|default:
break|break;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"unexpected type "
operator|+
name|tpi
operator|.
name|getTableOperationType
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
class|class
name|NamespaceQueueKeyComparator
implements|implements
name|AvlKeyComparator
argument_list|<
name|NamespaceQueue
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compareKey
parameter_list|(
name|NamespaceQueue
name|node
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
return|return
name|node
operator|.
name|compareKey
argument_list|(
operator|(
name|String
operator|)
name|key
argument_list|)
return|;
block|}
block|}
comment|/**    * the namespace is currently used just as a rwlock, not as a queue.    * because ns operation are not frequent enough. so we want to avoid    * having to move table queues around for suspend/resume.    */
specifier|private
specifier|static
class|class
name|NamespaceQueue
extends|extends
name|Queue
argument_list|<
name|String
argument_list|>
block|{
specifier|public
name|NamespaceQueue
parameter_list|(
name|String
name|namespace
parameter_list|)
block|{
name|super
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|requireExclusiveLock
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|add
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|,
specifier|final
name|boolean
name|addToFront
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Procedure
name|peek
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Procedure
name|poll
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
comment|// ============================================================================
comment|//  Table Locking Helpers
comment|// ============================================================================
comment|/**    * Try to acquire the exclusive lock on the specified table.    * other operations in the table-queue will be executed after the lock is released.    * @param procedure the procedure trying to acquire the lock    * @param table Table to lock    * @return true if we were able to acquire the lock on the table, otherwise false.    */
specifier|public
name|boolean
name|tryAcquireTableExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|TableQueue
name|queue
init|=
name|getTableQueue
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|queue
operator|.
name|getNamespaceQueue
argument_list|()
operator|.
name|trySharedLock
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|queue
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|queue
operator|.
name|getNamespaceQueue
argument_list|()
operator|.
name|releaseSharedLock
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|removeFromRunQueue
argument_list|(
name|tableRunQueue
argument_list|,
name|queue
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Release the exclusive lock taken with tryAcquireTableWrite()    * @param procedure the procedure releasing the lock    * @param table the name of the table that has the exclusive lock    */
specifier|public
name|void
name|releaseTableExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|TableQueue
name|queue
init|=
name|getTableQueue
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|queue
operator|.
name|hasParentLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|queue
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
block|}
name|queue
operator|.
name|getNamespaceQueue
argument_list|()
operator|.
name|releaseSharedLock
argument_list|()
expr_stmt|;
name|addToRunQueue
argument_list|(
name|tableRunQueue
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Try to acquire the shared lock on the specified table.    * other "read" operations in the table-queue may be executed concurrently,    * @param procedure the procedure trying to acquire the lock    * @param table Table to lock    * @return true if we were able to acquire the lock on the table, otherwise false.    */
specifier|public
name|boolean
name|tryAcquireTableSharedLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
return|return
name|tryAcquireTableQueueSharedLock
argument_list|(
name|procedure
argument_list|,
name|table
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|private
name|TableQueue
name|tryAcquireTableQueueSharedLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|TableQueue
name|queue
init|=
name|getTableQueue
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|queue
operator|.
name|getNamespaceQueue
argument_list|()
operator|.
name|trySharedLock
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|queue
operator|.
name|trySharedLock
argument_list|()
condition|)
block|{
name|queue
operator|.
name|getNamespaceQueue
argument_list|()
operator|.
name|releaseSharedLock
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|queue
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Release the shared lock taken with tryAcquireTableRead()    * @param procedure the procedure releasing the lock    * @param table the name of the table that has the shared lock    */
specifier|public
name|void
name|releaseTableSharedLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|TableQueue
name|queue
init|=
name|getTableQueue
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|.
name|releaseSharedLock
argument_list|()
condition|)
block|{
name|addToRunQueue
argument_list|(
name|tableRunQueue
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
name|queue
operator|.
name|getNamespaceQueue
argument_list|()
operator|.
name|releaseSharedLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Tries to remove the queue and the table-lock of the specified table.    * If there are new operations pending (e.g. a new create),    * the remove will not be performed.    * @param table the name of the table that should be marked as deleted    * @param procedure the procedure that is removing the table    * @return true if deletion succeeded, false otherwise meaning that there are    *     other new operations pending for that table (e.g. a new create).    */
annotation|@
name|VisibleForTesting
specifier|protected
name|boolean
name|markTableAsDeleted
parameter_list|(
specifier|final
name|TableName
name|table
parameter_list|,
specifier|final
name|Procedure
name|procedure
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
name|TableQueue
name|queue
init|=
name|getTableQueue
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|queue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|queue
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
comment|// remove the table from the run-queue and the map
if|if
condition|(
name|AvlIterableList
operator|.
name|isLinked
argument_list|(
name|queue
argument_list|)
condition|)
block|{
name|tableRunQueue
operator|.
name|remove
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
name|removeTableQueue
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: If there are no create, we can drop all the other ops
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// ============================================================================
comment|//  Region Locking Helpers
comment|// ============================================================================
comment|/**    * Suspend the procedure if the specified region is already locked.    * @param procedure the procedure trying to acquire the lock on the region    * @param regionInfo the region we are trying to lock    * @return true if the procedure has to wait for the regions to be available    */
specifier|public
name|boolean
name|waitRegion
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
return|return
name|waitRegions
argument_list|(
name|procedure
argument_list|,
name|regionInfo
operator|.
name|getTable
argument_list|()
argument_list|,
name|regionInfo
argument_list|)
return|;
block|}
comment|/**    * Suspend the procedure if the specified set of regions are already locked.    * @param procedure the procedure trying to acquire the lock on the regions    * @param table the table name of the regions we are trying to lock    * @param regionInfo the list of regions we are trying to lock    * @return true if the procedure has to wait for the regions to be available    */
specifier|public
name|boolean
name|waitRegions
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|,
specifier|final
name|HRegionInfo
modifier|...
name|regionInfo
parameter_list|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
specifier|final
name|TableQueue
name|queue
decl_stmt|;
if|if
condition|(
name|procedure
operator|.
name|hasParent
argument_list|()
condition|)
block|{
comment|// the assumption is that the parent procedure have already the table xlock
name|queue
operator|=
name|getTableQueueWithLock
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// acquire the table shared-lock
name|queue
operator|=
name|tryAcquireTableQueueSharedLock
argument_list|(
name|procedure
argument_list|,
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
return|return
literal|true
return|;
block|}
comment|// acquire region xlocks or wait
name|boolean
name|hasLock
init|=
literal|true
decl_stmt|;
specifier|final
name|RegionEvent
index|[]
name|event
init|=
operator|new
name|RegionEvent
index|[
name|regionInfo
operator|.
name|length
index|]
decl_stmt|;
synchronized|synchronized
init|(
name|queue
init|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionInfo
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
assert|assert
name|regionInfo
index|[
name|i
index|]
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|table
argument_list|)
assert|;
assert|assert
name|i
operator|==
literal|0
operator|||
name|regionInfo
index|[
name|i
index|]
operator|!=
name|regionInfo
index|[
name|i
operator|-
literal|1
index|]
operator|:
literal|"duplicate region: "
operator|+
name|regionInfo
index|[
name|i
index|]
assert|;
name|event
index|[
name|i
index|]
operator|=
name|queue
operator|.
name|getRegionEvent
argument_list|(
name|regionInfo
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event
index|[
name|i
index|]
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|suspendProcedure
argument_list|(
name|event
index|[
name|i
index|]
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|hasLock
operator|=
literal|false
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|event
index|[
name|i
index|]
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|hasLock
operator|&&
operator|!
name|procedure
operator|.
name|hasParent
argument_list|()
condition|)
block|{
name|releaseTableSharedLock
argument_list|(
name|procedure
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|hasLock
return|;
block|}
comment|/**    * Wake the procedures waiting for the specified region    * @param procedure the procedure that was holding the region    * @param regionInfo the region the procedure was holding    */
specifier|public
name|void
name|wakeRegion
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|wakeRegions
argument_list|(
name|procedure
argument_list|,
name|regionInfo
operator|.
name|getTable
argument_list|()
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wake the procedures waiting for the specified regions    * @param procedure the procedure that was holding the regions    * @param regionInfo the list of regions the procedure was holding    */
specifier|public
name|void
name|wakeRegions
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|,
specifier|final
name|HRegionInfo
modifier|...
name|regionInfo
parameter_list|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
specifier|final
name|TableQueue
name|queue
init|=
name|getTableQueueWithLock
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|int
name|numProcs
init|=
literal|0
decl_stmt|;
specifier|final
name|Procedure
index|[]
name|nextProcs
init|=
operator|new
name|Procedure
index|[
name|regionInfo
operator|.
name|length
index|]
decl_stmt|;
synchronized|synchronized
init|(
name|queue
init|)
block|{
name|HRegionInfo
name|prevRegion
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionInfo
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
assert|assert
name|regionInfo
index|[
name|i
index|]
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|table
argument_list|)
assert|;
assert|assert
name|i
operator|==
literal|0
operator|||
name|regionInfo
index|[
name|i
index|]
operator|!=
name|regionInfo
index|[
name|i
operator|-
literal|1
index|]
operator|:
literal|"duplicate region: "
operator|+
name|regionInfo
index|[
name|i
index|]
assert|;
name|RegionEvent
name|event
init|=
name|queue
operator|.
name|getRegionEvent
argument_list|(
name|regionInfo
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|event
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
if|if
condition|(
name|event
operator|.
name|hasWaitingProcedures
argument_list|()
condition|)
block|{
comment|// release one procedure at the time since regions has an xlock
name|nextProcs
index|[
name|numProcs
operator|++
index|]
operator|=
name|event
operator|.
name|popWaitingProcedure
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queue
operator|.
name|removeRegionEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// awake procedures if any
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
name|numProcs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|wakeProcedure
argument_list|(
name|nextProcs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|wakePollIfNeeded
argument_list|(
name|numProcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|procedure
operator|.
name|hasParent
argument_list|()
condition|)
block|{
comment|// release the table shared-lock.
comment|// (if we have a parent, it is holding an xlock so we didn't take the shared-lock)
name|releaseTableSharedLock
argument_list|(
name|procedure
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ============================================================================
comment|//  Namespace Locking Helpers
comment|// ============================================================================
comment|/**    * Try to acquire the exclusive lock on the specified namespace.    * @see #releaseNamespaceExclusiveLock(Procedure,String)    * @param procedure the procedure trying to acquire the lock    * @param nsName Namespace to lock    * @return true if we were able to acquire the lock on the namespace, otherwise false.    */
specifier|public
name|boolean
name|tryAcquireNamespaceExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|String
name|nsName
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
name|TableQueue
name|tableQueue
init|=
name|getTableQueue
argument_list|(
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tableQueue
operator|.
name|trySharedLock
argument_list|()
condition|)
return|return
literal|false
return|;
name|NamespaceQueue
name|nsQueue
init|=
name|getNamespaceQueue
argument_list|(
name|nsName
argument_list|)
decl_stmt|;
name|boolean
name|hasLock
init|=
name|nsQueue
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasLock
condition|)
block|{
name|tableQueue
operator|.
name|releaseSharedLock
argument_list|()
expr_stmt|;
block|}
return|return
name|hasLock
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Release the exclusive lock    * @see #tryAcquireNamespaceExclusiveLock(Procedure,String)    * @param procedure the procedure releasing the lock    * @param nsName the namespace that has the exclusive lock    */
specifier|public
name|void
name|releaseNamespaceExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|String
name|nsName
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|TableQueue
name|tableQueue
init|=
name|getTableQueue
argument_list|(
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
argument_list|)
decl_stmt|;
specifier|final
name|NamespaceQueue
name|queue
init|=
name|getNamespaceQueue
argument_list|(
name|nsName
argument_list|)
decl_stmt|;
name|queue
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
if|if
condition|(
name|tableQueue
operator|.
name|releaseSharedLock
argument_list|()
condition|)
block|{
name|addToRunQueue
argument_list|(
name|tableRunQueue
argument_list|,
name|tableQueue
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ============================================================================
comment|//  Server Locking Helpers
comment|// ============================================================================
comment|/**    * Try to acquire the exclusive lock on the specified server.    * @see #releaseServerExclusiveLock(Procedure,ServerName)    * @param procedure the procedure trying to acquire the lock    * @param serverName Server to lock    * @return true if we were able to acquire the lock on the server, otherwise false.    */
specifier|public
name|boolean
name|tryAcquireServerExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
name|ServerQueue
name|queue
init|=
name|getServerQueue
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|removeFromRunQueue
argument_list|(
name|serverRunQueue
argument_list|,
name|queue
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Release the exclusive lock    * @see #tryAcquireServerExclusiveLock(Procedure,ServerName)    * @param procedure the procedure releasing the lock    * @param serverName the server that has the exclusive lock    */
specifier|public
name|void
name|releaseServerExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
name|ServerQueue
name|queue
init|=
name|getServerQueue
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
name|queue
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
name|addToRunQueue
argument_list|(
name|serverRunQueue
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Try to acquire the shared lock on the specified server.    * @see #releaseServerSharedLock(Procedure,ServerName)    * @param procedure the procedure releasing the lock    * @param serverName Server to lock    * @return true if we were able to acquire the lock on the server, otherwise false.    */
specifier|public
name|boolean
name|tryAcquireServerSharedLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
return|return
name|getServerQueueWithLock
argument_list|(
name|serverName
argument_list|)
operator|.
name|trySharedLock
argument_list|()
return|;
block|}
comment|/**    * Release the shared lock taken    * @see #tryAcquireServerSharedLock(Procedure,ServerName)    * @param procedure the procedure releasing the lock    * @param serverName the server that has the shared lock    */
specifier|public
name|void
name|releaseServerSharedLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
name|getServerQueueWithLock
argument_list|(
name|serverName
argument_list|)
operator|.
name|releaseSharedLock
argument_list|()
expr_stmt|;
block|}
comment|// ============================================================================
comment|//  Generic Helpers
comment|// ============================================================================
specifier|private
specifier|static
interface|interface
name|QueueInterface
block|{
name|boolean
name|isAvailable
parameter_list|()
function_decl|;
name|boolean
name|isEmpty
parameter_list|()
function_decl|;
name|int
name|size
parameter_list|()
function_decl|;
name|void
name|add
parameter_list|(
name|Procedure
name|proc
parameter_list|,
name|boolean
name|addFront
parameter_list|)
function_decl|;
name|boolean
name|requireExclusiveLock
parameter_list|(
name|Procedure
name|proc
parameter_list|)
function_decl|;
name|Procedure
name|peek
parameter_list|()
function_decl|;
name|Procedure
name|poll
parameter_list|()
function_decl|;
name|boolean
name|isSuspended
parameter_list|()
function_decl|;
block|}
specifier|private
specifier|static
specifier|abstract
class|class
name|Queue
parameter_list|<
name|TKey
extends|extends
name|Comparable
parameter_list|<
name|TKey
parameter_list|>
parameter_list|>
extends|extends
name|AvlLinkedNode
argument_list|<
name|Queue
argument_list|<
name|TKey
argument_list|>
argument_list|>
implements|implements
name|QueueInterface
block|{
specifier|private
name|boolean
name|suspended
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|exclusiveLockProcIdOwner
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
specifier|private
name|int
name|sharedLock
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|TKey
name|key
decl_stmt|;
specifier|private
specifier|final
name|int
name|priority
decl_stmt|;
specifier|public
name|Queue
parameter_list|(
name|TKey
name|key
parameter_list|)
block|{
name|this
argument_list|(
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Queue
parameter_list|(
name|TKey
name|key
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
block|}
specifier|protected
name|TKey
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
specifier|protected
name|int
name|getPriority
parameter_list|()
block|{
return|return
name|priority
return|;
block|}
comment|/**      * True if the queue is not in the run-queue and it is owned by an event.      */
specifier|public
name|boolean
name|isSuspended
parameter_list|()
block|{
return|return
name|suspended
return|;
block|}
specifier|protected
name|boolean
name|setSuspended
parameter_list|(
name|boolean
name|isSuspended
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|suspended
operator|==
name|isSuspended
condition|)
return|return
literal|false
return|;
name|this
operator|.
name|suspended
operator|=
name|isSuspended
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// ======================================================================
comment|//  Read/Write Locking helpers
comment|// ======================================================================
specifier|public
specifier|synchronized
name|boolean
name|isLocked
parameter_list|()
block|{
return|return
name|hasExclusiveLock
argument_list|()
operator|||
name|sharedLock
operator|>
literal|0
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|hasExclusiveLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|exclusiveLockProcIdOwner
operator|!=
name|Long
operator|.
name|MIN_VALUE
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|trySharedLock
parameter_list|()
block|{
if|if
condition|(
name|hasExclusiveLock
argument_list|()
condition|)
return|return
literal|false
return|;
name|sharedLock
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|releaseSharedLock
parameter_list|()
block|{
return|return
operator|--
name|sharedLock
operator|==
literal|0
return|;
block|}
specifier|protected
specifier|synchronized
name|boolean
name|isSingleSharedLock
parameter_list|()
block|{
return|return
name|sharedLock
operator|==
literal|1
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|isLockOwner
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
return|return
name|exclusiveLockProcIdOwner
operator|==
name|procId
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|hasParentLock
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
return|return
name|proc
operator|.
name|hasParent
argument_list|()
operator|&&
operator|(
name|isLockOwner
argument_list|(
name|proc
operator|.
name|getParentProcId
argument_list|()
argument_list|)
operator|||
name|isLockOwner
argument_list|(
name|proc
operator|.
name|getRootProcId
argument_list|()
argument_list|)
operator|)
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|hasLockAccess
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
return|return
name|isLockOwner
argument_list|(
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
operator|||
name|hasParentLock
argument_list|(
name|proc
argument_list|)
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|tryExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
if|if
condition|(
name|isLocked
argument_list|()
condition|)
return|return
name|hasLockAccess
argument_list|(
name|proc
argument_list|)
return|;
name|exclusiveLockProcIdOwner
operator|=
name|proc
operator|.
name|getProcId
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|releaseExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
if|if
condition|(
name|isLockOwner
argument_list|(
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
condition|)
block|{
name|exclusiveLockProcIdOwner
operator|=
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|// This should go away when we have the new AM and its events
comment|// and we move xlock to the lock-event-queue.
specifier|public
specifier|synchronized
name|boolean
name|isAvailable
parameter_list|()
block|{
return|return
operator|!
name|hasExclusiveLock
argument_list|()
operator|&&
operator|!
name|isEmpty
argument_list|()
return|;
block|}
comment|// ======================================================================
comment|//  Generic Helpers
comment|// ======================================================================
specifier|public
name|int
name|compareKey
parameter_list|(
name|TKey
name|cmpKey
parameter_list|)
block|{
return|return
name|key
operator|.
name|compareTo
argument_list|(
name|cmpKey
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Queue
argument_list|<
name|TKey
argument_list|>
name|other
parameter_list|)
block|{
return|return
name|compareKey
argument_list|(
name|other
operator|.
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s(%s, suspended=%s xlock=%s sharedLock=%s size=%s)"
argument_list|,
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|key
argument_list|,
name|isSuspended
argument_list|()
argument_list|,
name|hasExclusiveLock
argument_list|()
condition|?
literal|"true ("
operator|+
name|exclusiveLockProcIdOwner
operator|+
literal|")"
else|:
literal|"false"
argument_list|,
name|sharedLock
argument_list|,
name|size
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|// ======================================================================
comment|//  Helper Data Structures
comment|// ======================================================================
specifier|private
specifier|static
specifier|abstract
class|class
name|QueueImpl
parameter_list|<
name|TKey
extends|extends
name|Comparable
parameter_list|<
name|TKey
parameter_list|>
parameter_list|>
extends|extends
name|Queue
argument_list|<
name|TKey
argument_list|>
block|{
specifier|private
specifier|final
name|ArrayDeque
argument_list|<
name|Procedure
argument_list|>
name|runnables
init|=
operator|new
name|ArrayDeque
argument_list|<
name|Procedure
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|QueueImpl
parameter_list|(
name|TKey
name|key
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
specifier|public
name|QueueImpl
parameter_list|(
name|TKey
name|key
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|add
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|,
specifier|final
name|boolean
name|addToFront
parameter_list|)
block|{
if|if
condition|(
name|addToFront
condition|)
block|{
name|addFront
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addBack
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|addFront
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
name|runnables
operator|.
name|addFirst
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|addBack
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
name|runnables
operator|.
name|addLast
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Procedure
name|peek
parameter_list|()
block|{
return|return
name|runnables
operator|.
name|peek
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Procedure
name|poll
parameter_list|()
block|{
return|return
name|runnables
operator|.
name|poll
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|runnables
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|runnables
operator|.
name|size
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|FairQueue
parameter_list|<
name|T
extends|extends
name|Comparable
parameter_list|<
name|T
parameter_list|>
parameter_list|>
block|{
specifier|private
specifier|final
name|int
name|quantum
decl_stmt|;
specifier|private
name|Queue
argument_list|<
name|T
argument_list|>
name|currentQueue
init|=
literal|null
decl_stmt|;
specifier|private
name|Queue
argument_list|<
name|T
argument_list|>
name|queueHead
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|currentQuantum
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|size
init|=
literal|0
decl_stmt|;
specifier|public
name|FairQueue
parameter_list|()
block|{
name|this
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
name|FairQueue
parameter_list|(
name|int
name|quantum
parameter_list|)
block|{
name|this
operator|.
name|quantum
operator|=
name|quantum
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasRunnables
parameter_list|()
block|{
return|return
name|size
operator|>
literal|0
return|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
name|queueHead
operator|=
name|AvlIterableList
operator|.
name|append
argument_list|(
name|queueHead
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentQueue
operator|==
literal|null
condition|)
name|setNextQueue
argument_list|(
name|queueHead
argument_list|)
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
name|Queue
argument_list|<
name|T
argument_list|>
name|nextQueue
init|=
name|AvlIterableList
operator|.
name|readNext
argument_list|(
name|queue
argument_list|)
decl_stmt|;
name|queueHead
operator|=
name|AvlIterableList
operator|.
name|remove
argument_list|(
name|queueHead
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentQueue
operator|==
name|queue
condition|)
block|{
name|setNextQueue
argument_list|(
name|queueHead
operator|!=
literal|null
condition|?
name|nextQueue
else|:
literal|null
argument_list|)
expr_stmt|;
block|}
name|size
operator|--
expr_stmt|;
block|}
specifier|public
name|Queue
argument_list|<
name|T
argument_list|>
name|poll
parameter_list|()
block|{
if|if
condition|(
name|currentQuantum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|nextQueue
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
comment|// nothing here
block|}
name|currentQuantum
operator|=
name|calculateQuantum
argument_list|(
name|currentQueue
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|currentQuantum
operator|--
expr_stmt|;
block|}
comment|// This should go away when we have the new AM and its events
if|if
condition|(
operator|!
name|currentQueue
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
name|Queue
argument_list|<
name|T
argument_list|>
name|lastQueue
init|=
name|currentQueue
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|nextQueue
argument_list|()
condition|)
return|return
literal|null
return|;
block|}
do|while
condition|(
name|currentQueue
operator|!=
name|lastQueue
operator|&&
operator|!
name|currentQueue
operator|.
name|isAvailable
argument_list|()
condition|)
do|;
name|currentQuantum
operator|=
name|calculateQuantum
argument_list|(
name|currentQueue
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|currentQueue
return|;
block|}
specifier|private
name|boolean
name|nextQueue
parameter_list|()
block|{
if|if
condition|(
name|currentQueue
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|currentQueue
operator|=
name|AvlIterableList
operator|.
name|readNext
argument_list|(
name|currentQueue
argument_list|)
expr_stmt|;
return|return
name|currentQueue
operator|!=
literal|null
return|;
block|}
specifier|private
name|void
name|setNextQueue
parameter_list|(
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
name|currentQueue
operator|=
name|queue
expr_stmt|;
if|if
condition|(
name|queue
operator|!=
literal|null
condition|)
block|{
name|currentQuantum
operator|=
name|calculateQuantum
argument_list|(
name|currentQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentQuantum
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|calculateQuantum
parameter_list|(
specifier|final
name|Queue
name|queue
parameter_list|)
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|queue
operator|.
name|getPriority
argument_list|()
operator|*
name|quantum
argument_list|)
return|;
comment|// TODO
block|}
block|}
block|}
end_class

end_unit

