begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUTKey WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|TableProcedureInterface
operator|.
name|TableOperationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|AbstractProcedureScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|LockAndQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|LockedResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|LockedResourceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|Procedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlIterableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlKeyComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlTreeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * ProcedureScheduler for the Master Procedures.  * This ProcedureScheduler tries to provide to the ProcedureExecutor procedures  * that can be executed without having to wait on a lock.  * Most of the master operations can be executed concurrently, if they  * are operating on different tables (e.g. two create table procedures can be performed  * at the same time) or against two different servers; say two servers that crashed at  * about the same time.  *  *<p>Each procedure should implement an Interface providing information for this queue.  * For example table related procedures should implement TableProcedureInterface.  * Each procedure will be pushed in its own queue, and based on the operation type  * we may make smarter decisions: e.g. we can abort all the operations preceding  * a delete table, or similar.  *  *<h4>Concurrency control</h4>  * Concurrent access to member variables (tableRunQueue, serverRunQueue, locking, tableMap,  * serverBuckets) is controlled by schedLock(). This mainly includes:<br>  *<ul>  *<li>  *     {@link #push(Procedure, boolean, boolean)}: A push will add a Queue back to run-queue  *     when:  *<ol>  *<li>Queue was empty before push (so must have been out of run-queue)</li>  *<li>Child procedure is added (which means parent procedure holds exclusive lock, and it  *           must have moved Queue out of run-queue)</li>  *</ol>  *</li>  *<li>  *     {@link #poll(long)}: A poll will remove a Queue from run-queue when:  *<ol>  *<li>Queue becomes empty after poll</li>  *<li>Exclusive lock is requested by polled procedure and lock is available (returns the  *           procedure)</li>  *<li>Exclusive lock is requested but lock is not available (returns null)</li>  *<li>Polled procedure is child of parent holding exclusive lock and the next procedure is  *           not a child</li>  *</ol>  *</li>  *<li>  *     Namespace/table/region locks: Queue is added back to run-queue when lock being released is:  *<ol>  *<li>Exclusive lock</li>  *<li>Last shared lock (in case queue was removed because next procedure in queue required  *           exclusive lock)</li>  *</ol>  *</li>  *</ul>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|MasterProcedureScheduler
extends|extends
name|AbstractProcedureScheduler
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MasterProcedureScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|AvlKeyComparator
argument_list|<
name|ServerQueue
argument_list|>
name|SERVER_QUEUE_KEY_COMPARATOR
init|=
parameter_list|(
name|n
parameter_list|,
name|k
parameter_list|)
lambda|->
name|n
operator|.
name|compareKey
argument_list|(
operator|(
name|ServerName
operator|)
name|k
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|AvlKeyComparator
argument_list|<
name|TableQueue
argument_list|>
name|TABLE_QUEUE_KEY_COMPARATOR
init|=
parameter_list|(
name|n
parameter_list|,
name|k
parameter_list|)
lambda|->
name|n
operator|.
name|compareKey
argument_list|(
operator|(
name|TableName
operator|)
name|k
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|AvlKeyComparator
argument_list|<
name|PeerQueue
argument_list|>
name|PEER_QUEUE_KEY_COMPARATOR
init|=
parameter_list|(
name|n
parameter_list|,
name|k
parameter_list|)
lambda|->
name|n
operator|.
name|compareKey
argument_list|(
operator|(
name|String
operator|)
name|k
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|AvlKeyComparator
argument_list|<
name|MetaQueue
argument_list|>
name|META_QUEUE_KEY_COMPARATOR
init|=
parameter_list|(
name|n
parameter_list|,
name|k
parameter_list|)
lambda|->
name|n
operator|.
name|compareKey
argument_list|(
operator|(
name|TableName
operator|)
name|k
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|FairQueue
argument_list|<
name|ServerName
argument_list|>
name|serverRunQueue
init|=
operator|new
name|FairQueue
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|FairQueue
argument_list|<
name|TableName
argument_list|>
name|tableRunQueue
init|=
operator|new
name|FairQueue
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|FairQueue
argument_list|<
name|String
argument_list|>
name|peerRunQueue
init|=
operator|new
name|FairQueue
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|FairQueue
argument_list|<
name|TableName
argument_list|>
name|metaRunQueue
init|=
operator|new
name|FairQueue
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ServerQueue
index|[]
name|serverBuckets
init|=
operator|new
name|ServerQueue
index|[
literal|128
index|]
decl_stmt|;
specifier|private
name|TableQueue
name|tableMap
init|=
literal|null
decl_stmt|;
specifier|private
name|PeerQueue
name|peerMap
init|=
literal|null
decl_stmt|;
specifier|private
name|MetaQueue
name|metaMap
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|SchemaLocking
name|locking
init|=
operator|new
name|SchemaLocking
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|yield
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
name|push
argument_list|(
name|proc
argument_list|,
name|isTableProcedure
argument_list|(
name|proc
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|enqueue
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|,
specifier|final
name|boolean
name|addFront
parameter_list|)
block|{
if|if
condition|(
name|isMetaProcedure
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|doAdd
argument_list|(
name|metaRunQueue
argument_list|,
name|getMetaQueue
argument_list|()
argument_list|,
name|proc
argument_list|,
name|addFront
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isTableProcedure
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|doAdd
argument_list|(
name|tableRunQueue
argument_list|,
name|getTableQueue
argument_list|(
name|getTableName
argument_list|(
name|proc
argument_list|)
argument_list|)
argument_list|,
name|proc
argument_list|,
name|addFront
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isServerProcedure
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|doAdd
argument_list|(
name|serverRunQueue
argument_list|,
name|getServerQueue
argument_list|(
name|getServerName
argument_list|(
name|proc
argument_list|)
argument_list|)
argument_list|,
name|proc
argument_list|,
name|addFront
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isPeerProcedure
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|doAdd
argument_list|(
name|peerRunQueue
argument_list|,
name|getPeerQueue
argument_list|(
name|getPeerId
argument_list|(
name|proc
argument_list|)
argument_list|)
argument_list|,
name|proc
argument_list|,
name|addFront
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: at the moment we only have Table and Server procedures
comment|// if you are implementing a non-table/non-server procedure, you have two options: create
comment|// a group for all the non-table/non-server procedures or try to find a key for your
comment|// non-table/non-server procedures and implement something similar to the TableRunQueue.
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"RQs for non-table/non-server procedures are not implemented yet: "
operator|+
name|proc
argument_list|)
throw|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|doAdd
parameter_list|(
specifier|final
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|,
specifier|final
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|,
specifier|final
name|Procedure
argument_list|<
name|?
argument_list|>
name|proc
parameter_list|,
specifier|final
name|boolean
name|addFront
parameter_list|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|proc
argument_list|,
name|addFront
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|queue
operator|.
name|getLockStatus
argument_list|()
operator|.
name|hasExclusiveLock
argument_list|()
operator|||
name|queue
operator|.
name|getLockStatus
argument_list|()
operator|.
name|isLockOwner
argument_list|(
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
condition|)
block|{
comment|// if the queue was not remove for an xlock execution
comment|// or the proc is the lock owner, put the queue back into execution
name|addToRunQueue
argument_list|(
name|fairq
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|queue
operator|.
name|getLockStatus
argument_list|()
operator|.
name|hasParentLock
argument_list|(
name|proc
argument_list|)
condition|)
block|{
assert|assert
name|addFront
operator|:
literal|"expected to add a child in the front"
assert|;
comment|// our (proc) parent has the xlock,
comment|// so the queue is not in the fairq (run-queue)
comment|// add it back to let the child run (inherit the lock)
name|addToRunQueue
argument_list|(
name|fairq
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|queueHasRunnables
parameter_list|()
block|{
return|return
name|metaRunQueue
operator|.
name|hasRunnables
argument_list|()
operator|||
name|tableRunQueue
operator|.
name|hasRunnables
argument_list|()
operator|||
name|serverRunQueue
operator|.
name|hasRunnables
argument_list|()
operator|||
name|peerRunQueue
operator|.
name|hasRunnables
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Procedure
name|dequeue
parameter_list|()
block|{
comment|// meta procedure is always the first priority
name|Procedure
argument_list|<
name|?
argument_list|>
name|pollResult
init|=
name|doPoll
argument_list|(
name|metaRunQueue
argument_list|)
decl_stmt|;
comment|// For now, let server handling have precedence over table handling; presumption is that it
comment|// is more important handling crashed servers than it is running the
comment|// enabling/disabling tables, etc.
if|if
condition|(
name|pollResult
operator|==
literal|null
condition|)
block|{
name|pollResult
operator|=
name|doPoll
argument_list|(
name|serverRunQueue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pollResult
operator|==
literal|null
condition|)
block|{
name|pollResult
operator|=
name|doPoll
argument_list|(
name|peerRunQueue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pollResult
operator|==
literal|null
condition|)
block|{
name|pollResult
operator|=
name|doPoll
argument_list|(
name|tableRunQueue
argument_list|)
expr_stmt|;
block|}
return|return
name|pollResult
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|>
name|Procedure
argument_list|<
name|?
argument_list|>
name|doPoll
parameter_list|(
specifier|final
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|)
block|{
specifier|final
name|Queue
argument_list|<
name|T
argument_list|>
name|rq
init|=
name|fairq
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|rq
operator|==
literal|null
operator|||
operator|!
name|rq
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Procedure
argument_list|<
name|?
argument_list|>
name|pollResult
init|=
name|rq
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|pollResult
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|boolean
name|xlockReq
init|=
name|rq
operator|.
name|requireExclusiveLock
argument_list|(
name|pollResult
argument_list|)
decl_stmt|;
if|if
condition|(
name|xlockReq
operator|&&
name|rq
operator|.
name|getLockStatus
argument_list|()
operator|.
name|isLocked
argument_list|()
operator|&&
operator|!
name|rq
operator|.
name|getLockStatus
argument_list|()
operator|.
name|hasLockAccess
argument_list|(
name|pollResult
argument_list|)
condition|)
block|{
comment|// someone is already holding the lock (e.g. shared lock). avoid a yield
name|removeFromRunQueue
argument_list|(
name|fairq
argument_list|,
name|rq
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|rq
operator|.
name|poll
argument_list|()
expr_stmt|;
if|if
condition|(
name|rq
operator|.
name|isEmpty
argument_list|()
operator|||
name|xlockReq
condition|)
block|{
name|removeFromRunQueue
argument_list|(
name|fairq
argument_list|,
name|rq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|.
name|getLockStatus
argument_list|()
operator|.
name|hasParentLock
argument_list|(
name|pollResult
argument_list|)
condition|)
block|{
comment|// if the rq is in the fairq because of runnable child
comment|// check if the next procedure is still a child.
comment|// if not, remove the rq from the fairq and go back to the xlock state
name|Procedure
argument_list|<
name|?
argument_list|>
name|nextProc
init|=
name|rq
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextProc
operator|!=
literal|null
operator|&&
operator|!
name|Procedure
operator|.
name|haveSameParent
argument_list|(
name|nextProc
argument_list|,
name|pollResult
argument_list|)
condition|)
block|{
name|removeFromRunQueue
argument_list|(
name|fairq
argument_list|,
name|rq
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pollResult
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|LockedResource
argument_list|>
name|getLocks
parameter_list|()
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|locking
operator|.
name|getLocks
argument_list|()
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|LockedResource
name|getLockResource
parameter_list|(
name|LockedResourceType
name|resourceType
parameter_list|,
name|String
name|resourceName
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|locking
operator|.
name|getLockResource
argument_list|(
name|resourceType
argument_list|,
name|resourceName
argument_list|)
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
name|clearQueue
argument_list|()
expr_stmt|;
name|locking
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|clearQueue
parameter_list|()
block|{
comment|// Remove Servers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|serverBuckets
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|clear
argument_list|(
name|serverBuckets
index|[
name|i
index|]
argument_list|,
name|serverRunQueue
argument_list|,
name|SERVER_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
name|serverBuckets
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
comment|// Remove Tables
name|clear
argument_list|(
name|tableMap
argument_list|,
name|tableRunQueue
argument_list|,
name|TABLE_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
name|tableMap
operator|=
literal|null
expr_stmt|;
comment|// Remove Peers
name|clear
argument_list|(
name|peerMap
argument_list|,
name|peerRunQueue
argument_list|,
name|PEER_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
name|peerMap
operator|=
literal|null
expr_stmt|;
assert|assert
name|size
argument_list|()
operator|==
literal|0
operator|:
literal|"expected queue size to be 0, got "
operator|+
name|size
argument_list|()
assert|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|,
name|TNode
extends|extends
name|Queue
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|clear
parameter_list|(
name|TNode
name|treeMap
parameter_list|,
specifier|final
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|,
specifier|final
name|AvlKeyComparator
argument_list|<
name|TNode
argument_list|>
name|comparator
parameter_list|)
block|{
while|while
condition|(
name|treeMap
operator|!=
literal|null
condition|)
block|{
name|Queue
argument_list|<
name|T
argument_list|>
name|node
init|=
name|AvlTree
operator|.
name|getFirst
argument_list|(
name|treeMap
argument_list|)
decl_stmt|;
name|treeMap
operator|=
name|AvlTree
operator|.
name|remove
argument_list|(
name|treeMap
argument_list|,
name|node
operator|.
name|getKey
argument_list|()
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|fairq
operator|!=
literal|null
condition|)
name|removeFromRunQueue
argument_list|(
name|fairq
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|queueSize
parameter_list|(
name|Queue
argument_list|<
name|?
argument_list|>
name|head
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|AvlTreeIterator
argument_list|<
name|Queue
argument_list|<
name|?
argument_list|>
argument_list|>
name|iter
init|=
operator|new
name|AvlTreeIterator
argument_list|<
name|Queue
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|head
argument_list|)
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|count
operator|+=
name|iter
operator|.
name|next
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|queueSize
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ServerQueue
name|serverMap
range|:
name|serverBuckets
control|)
block|{
name|count
operator|+=
name|queueSize
argument_list|(
name|serverMap
argument_list|)
expr_stmt|;
block|}
name|count
operator|+=
name|queueSize
argument_list|(
name|tableMap
argument_list|)
expr_stmt|;
name|count
operator|+=
name|queueSize
argument_list|(
name|peerMap
argument_list|)
expr_stmt|;
name|count
operator|+=
name|queueSize
argument_list|(
name|metaMap
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|completionCleanup
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
if|if
condition|(
name|proc
operator|instanceof
name|TableProcedureInterface
condition|)
block|{
name|TableProcedureInterface
name|iProcTable
init|=
operator|(
name|TableProcedureInterface
operator|)
name|proc
decl_stmt|;
name|boolean
name|tableDeleted
decl_stmt|;
if|if
condition|(
name|proc
operator|.
name|hasException
argument_list|()
condition|)
block|{
name|Exception
name|procEx
init|=
name|proc
operator|.
name|getException
argument_list|()
operator|.
name|unwrapRemoteException
argument_list|()
decl_stmt|;
if|if
condition|(
name|iProcTable
operator|.
name|getTableOperationType
argument_list|()
operator|==
name|TableOperationType
operator|.
name|CREATE
condition|)
block|{
comment|// create failed because the table already exist
name|tableDeleted
operator|=
operator|!
operator|(
name|procEx
operator|instanceof
name|TableExistsException
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// the operation failed because the table does not exist
name|tableDeleted
operator|=
operator|(
name|procEx
operator|instanceof
name|TableNotFoundException
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// the table was deleted
name|tableDeleted
operator|=
operator|(
name|iProcTable
operator|.
name|getTableOperationType
argument_list|()
operator|==
name|TableOperationType
operator|.
name|DELETE
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tableDeleted
condition|)
block|{
name|markTableAsDeleted
argument_list|(
name|iProcTable
operator|.
name|getTableName
argument_list|()
argument_list|,
name|proc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|proc
operator|instanceof
name|PeerProcedureInterface
condition|)
block|{
name|PeerProcedureInterface
name|iProcPeer
init|=
operator|(
name|PeerProcedureInterface
operator|)
name|proc
decl_stmt|;
name|tryCleanupPeerQueue
argument_list|(
name|iProcPeer
operator|.
name|getPeerId
argument_list|()
argument_list|,
name|proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No cleanup for ServerProcedureInterface types, yet.
return|return;
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|addToRunQueue
parameter_list|(
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|,
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
if|if
condition|(
operator|!
name|AvlIterableList
operator|.
name|isLinked
argument_list|(
name|queue
argument_list|)
operator|&&
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fairq
operator|.
name|add
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|removeFromRunQueue
parameter_list|(
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|,
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
if|if
condition|(
name|AvlIterableList
operator|.
name|isLinked
argument_list|(
name|queue
argument_list|)
condition|)
block|{
name|fairq
operator|.
name|remove
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ============================================================================
comment|//  Table Queue Lookup Helpers
comment|// ============================================================================
specifier|private
name|TableQueue
name|getTableQueue
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
name|TableQueue
name|node
init|=
name|AvlTree
operator|.
name|get
argument_list|(
name|tableMap
argument_list|,
name|tableName
argument_list|,
name|TABLE_QUEUE_KEY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
return|return
name|node
return|;
name|node
operator|=
operator|new
name|TableQueue
argument_list|(
name|tableName
argument_list|,
name|MasterProcedureUtil
operator|.
name|getTablePriority
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|locking
operator|.
name|getTableLock
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|tableName
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tableMap
operator|=
name|AvlTree
operator|.
name|insert
argument_list|(
name|tableMap
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|private
name|void
name|removeTableQueue
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
name|tableMap
operator|=
name|AvlTree
operator|.
name|remove
argument_list|(
name|tableMap
argument_list|,
name|tableName
argument_list|,
name|TABLE_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
name|locking
operator|.
name|removeTableLock
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|isTableProcedure
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|proc
parameter_list|)
block|{
return|return
name|proc
operator|instanceof
name|TableProcedureInterface
return|;
block|}
specifier|private
specifier|static
name|TableName
name|getTableName
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|proc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|TableProcedureInterface
operator|)
name|proc
operator|)
operator|.
name|getTableName
argument_list|()
return|;
block|}
comment|// ============================================================================
comment|//  Server Queue Lookup Helpers
comment|// ============================================================================
specifier|private
name|ServerQueue
name|getServerQueue
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|getBucketIndex
argument_list|(
name|serverBuckets
argument_list|,
name|serverName
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|ServerQueue
name|node
init|=
name|AvlTree
operator|.
name|get
argument_list|(
name|serverBuckets
index|[
name|index
index|]
argument_list|,
name|serverName
argument_list|,
name|SERVER_QUEUE_KEY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
return|return
name|node
return|;
name|node
operator|=
operator|new
name|ServerQueue
argument_list|(
name|serverName
argument_list|,
name|locking
operator|.
name|getServerLock
argument_list|(
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
name|serverBuckets
index|[
name|index
index|]
operator|=
name|AvlTree
operator|.
name|insert
argument_list|(
name|serverBuckets
index|[
name|index
index|]
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|private
specifier|static
name|int
name|getBucketIndex
parameter_list|(
name|Object
index|[]
name|buckets
parameter_list|,
name|int
name|hashCode
parameter_list|)
block|{
return|return
name|Math
operator|.
name|abs
argument_list|(
name|hashCode
argument_list|)
operator|%
name|buckets
operator|.
name|length
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isServerProcedure
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|proc
parameter_list|)
block|{
return|return
name|proc
operator|instanceof
name|ServerProcedureInterface
return|;
block|}
specifier|private
specifier|static
name|ServerName
name|getServerName
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|proc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ServerProcedureInterface
operator|)
name|proc
operator|)
operator|.
name|getServerName
argument_list|()
return|;
block|}
comment|// ============================================================================
comment|//  Peer Queue Lookup Helpers
comment|// ============================================================================
specifier|private
name|PeerQueue
name|getPeerQueue
parameter_list|(
name|String
name|peerId
parameter_list|)
block|{
name|PeerQueue
name|node
init|=
name|AvlTree
operator|.
name|get
argument_list|(
name|peerMap
argument_list|,
name|peerId
argument_list|,
name|PEER_QUEUE_KEY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
return|return
name|node
return|;
block|}
name|node
operator|=
operator|new
name|PeerQueue
argument_list|(
name|peerId
argument_list|,
name|locking
operator|.
name|getPeerLock
argument_list|(
name|peerId
argument_list|)
argument_list|)
expr_stmt|;
name|peerMap
operator|=
name|AvlTree
operator|.
name|insert
argument_list|(
name|peerMap
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|private
name|void
name|removePeerQueue
parameter_list|(
name|String
name|peerId
parameter_list|)
block|{
name|peerMap
operator|=
name|AvlTree
operator|.
name|remove
argument_list|(
name|peerMap
argument_list|,
name|peerId
argument_list|,
name|PEER_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
name|locking
operator|.
name|removePeerLock
argument_list|(
name|peerId
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|tryCleanupPeerQueue
parameter_list|(
name|String
name|peerId
parameter_list|,
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
name|PeerQueue
name|queue
init|=
name|AvlTree
operator|.
name|get
argument_list|(
name|peerMap
argument_list|,
name|peerId
argument_list|,
name|PEER_QUEUE_KEY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|LockAndQueue
name|lock
init|=
name|locking
operator|.
name|getPeerLock
argument_list|(
name|peerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|lock
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|removeFromRunQueue
argument_list|(
name|peerRunQueue
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|removePeerQueue
argument_list|(
name|peerId
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isPeerProcedure
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|proc
parameter_list|)
block|{
return|return
name|proc
operator|instanceof
name|PeerProcedureInterface
return|;
block|}
specifier|private
specifier|static
name|String
name|getPeerId
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|proc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|PeerProcedureInterface
operator|)
name|proc
operator|)
operator|.
name|getPeerId
argument_list|()
return|;
block|}
comment|// ============================================================================
comment|//  Meta Queue Lookup Helpers
comment|// ============================================================================
specifier|private
name|MetaQueue
name|getMetaQueue
parameter_list|()
block|{
name|MetaQueue
name|node
init|=
name|AvlTree
operator|.
name|get
argument_list|(
name|metaMap
argument_list|,
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|,
name|META_QUEUE_KEY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
return|return
name|node
return|;
block|}
name|node
operator|=
operator|new
name|MetaQueue
argument_list|(
name|locking
operator|.
name|getMetaLock
argument_list|()
argument_list|)
expr_stmt|;
name|metaMap
operator|=
name|AvlTree
operator|.
name|insert
argument_list|(
name|metaMap
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isMetaProcedure
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|proc
parameter_list|)
block|{
return|return
name|proc
operator|instanceof
name|MetaProcedureInterface
return|;
block|}
comment|// ============================================================================
comment|//  Table Locking Helpers
comment|// ============================================================================
comment|/**    * Get lock info for a resource of specified type and name and log details    */
specifier|private
name|void
name|logLockedResource
parameter_list|(
name|LockedResourceType
name|resourceType
parameter_list|,
name|String
name|resourceName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
name|LockedResource
name|lockedResource
init|=
name|getLockResource
argument_list|(
name|resourceType
argument_list|,
name|resourceName
argument_list|)
decl_stmt|;
if|if
condition|(
name|lockedResource
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
name|resourceType
operator|.
name|toString
argument_list|()
operator|+
literal|" '"
operator|+
name|resourceName
operator|+
literal|"', shared lock count="
operator|+
name|lockedResource
operator|.
name|getSharedLockCount
argument_list|()
decl_stmt|;
name|Procedure
argument_list|<
name|?
argument_list|>
name|proc
init|=
name|lockedResource
operator|.
name|getExclusiveLockOwnerProcedure
argument_list|()
decl_stmt|;
if|if
condition|(
name|proc
operator|!=
literal|null
condition|)
block|{
name|msg
operator|+=
literal|", exclusively locked by procId="
operator|+
name|proc
operator|.
name|getProcId
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Suspend the procedure if the specified table is already locked.    * Other operations in the table-queue will be executed after the lock is released.    * @param procedure the procedure trying to acquire the lock    * @param table Table to lock    * @return true if the procedure has to wait for the table to be available    */
specifier|public
name|boolean
name|waitTableExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|String
name|namespace
init|=
name|table
operator|.
name|getNamespaceAsString
argument_list|()
decl_stmt|;
specifier|final
name|LockAndQueue
name|namespaceLock
init|=
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|namespace
argument_list|)
decl_stmt|;
specifier|final
name|LockAndQueue
name|tableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|namespaceLock
operator|.
name|trySharedLock
argument_list|()
condition|)
block|{
name|waitProcedure
argument_list|(
name|namespaceLock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|logLockedResource
argument_list|(
name|LockedResourceType
operator|.
name|NAMESPACE
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|tableLock
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|namespaceLock
operator|.
name|releaseSharedLock
argument_list|()
expr_stmt|;
name|waitProcedure
argument_list|(
name|tableLock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|logLockedResource
argument_list|(
name|LockedResourceType
operator|.
name|TABLE
argument_list|,
name|table
operator|.
name|getNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|removeFromRunQueue
argument_list|(
name|tableRunQueue
argument_list|,
name|getTableQueue
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wake the procedures waiting for the specified table    * @param procedure the procedure releasing the lock    * @param table the name of the table that has the exclusive lock    */
specifier|public
name|void
name|wakeTableExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|namespaceLock
init|=
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|table
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|LockAndQueue
name|tableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|int
name|waitingCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tableLock
operator|.
name|hasParentLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|tableLock
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
name|waitingCount
operator|+=
name|wakeWaitingProcedures
argument_list|(
name|tableLock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namespaceLock
operator|.
name|releaseSharedLock
argument_list|()
condition|)
block|{
name|waitingCount
operator|+=
name|wakeWaitingProcedures
argument_list|(
name|namespaceLock
argument_list|)
expr_stmt|;
block|}
name|addToRunQueue
argument_list|(
name|tableRunQueue
argument_list|,
name|getTableQueue
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|wakePollIfNeeded
argument_list|(
name|waitingCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Suspend the procedure if the specified table is already locked.    * other "read" operations in the table-queue may be executed concurrently,    * @param procedure the procedure trying to acquire the lock    * @param table Table to lock    * @return true if the procedure has to wait for the table to be available    */
specifier|public
name|boolean
name|waitTableSharedLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
return|return
name|waitTableQueueSharedLock
argument_list|(
name|procedure
argument_list|,
name|table
argument_list|)
operator|==
literal|null
return|;
block|}
specifier|private
name|TableQueue
name|waitTableQueueSharedLock
parameter_list|(
specifier|final
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|namespaceLock
init|=
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|table
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|LockAndQueue
name|tableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|namespaceLock
operator|.
name|trySharedLock
argument_list|()
condition|)
block|{
name|waitProcedure
argument_list|(
name|namespaceLock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|tableLock
operator|.
name|trySharedLock
argument_list|()
condition|)
block|{
name|namespaceLock
operator|.
name|releaseSharedLock
argument_list|()
expr_stmt|;
name|waitProcedure
argument_list|(
name|tableLock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|getTableQueue
argument_list|(
name|table
argument_list|)
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wake the procedures waiting for the specified table    * @param procedure the procedure releasing the lock    * @param table the name of the table that has the shared lock    */
specifier|public
name|void
name|wakeTableSharedLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|namespaceLock
init|=
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|table
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|LockAndQueue
name|tableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|int
name|waitingCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tableLock
operator|.
name|releaseSharedLock
argument_list|()
condition|)
block|{
name|addToRunQueue
argument_list|(
name|tableRunQueue
argument_list|,
name|getTableQueue
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|waitingCount
operator|+=
name|wakeWaitingProcedures
argument_list|(
name|tableLock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namespaceLock
operator|.
name|releaseSharedLock
argument_list|()
condition|)
block|{
name|waitingCount
operator|+=
name|wakeWaitingProcedures
argument_list|(
name|namespaceLock
argument_list|)
expr_stmt|;
block|}
name|wakePollIfNeeded
argument_list|(
name|waitingCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Tries to remove the queue and the table-lock of the specified table.    * If there are new operations pending (e.g. a new create),    * the remove will not be performed.    * @param table the name of the table that should be marked as deleted    * @param procedure the procedure that is removing the table    * @return true if deletion succeeded, false otherwise meaning that there are    *     other new operations pending for that table (e.g. a new create).    */
annotation|@
name|VisibleForTesting
name|boolean
name|markTableAsDeleted
parameter_list|(
specifier|final
name|TableName
name|table
parameter_list|,
specifier|final
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|TableQueue
name|queue
init|=
name|getTableQueue
argument_list|(
name|table
argument_list|)
decl_stmt|;
specifier|final
name|LockAndQueue
name|tableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|queue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|tableLock
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
comment|// remove the table from the run-queue and the map
if|if
condition|(
name|AvlIterableList
operator|.
name|isLinked
argument_list|(
name|queue
argument_list|)
condition|)
block|{
name|tableRunQueue
operator|.
name|remove
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
name|removeTableQueue
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: If there are no create, we can drop all the other ops
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// ============================================================================
comment|//  Region Locking Helpers
comment|// ============================================================================
comment|/**    * Suspend the procedure if the specified region is already locked.    * @param procedure the procedure trying to acquire the lock on the region    * @param regionInfo the region we are trying to lock    * @return true if the procedure has to wait for the regions to be available    */
specifier|public
name|boolean
name|waitRegion
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
return|return
name|waitRegions
argument_list|(
name|procedure
argument_list|,
name|regionInfo
operator|.
name|getTable
argument_list|()
argument_list|,
name|regionInfo
argument_list|)
return|;
block|}
comment|/**    * Suspend the procedure if the specified set of regions are already locked.    * @param procedure the procedure trying to acquire the lock on the regions    * @param table the table name of the regions we are trying to lock    * @param regionInfo the list of regions we are trying to lock    * @return true if the procedure has to wait for the regions to be available    */
specifier|public
name|boolean
name|waitRegions
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|,
specifier|final
name|RegionInfo
modifier|...
name|regionInfo
parameter_list|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|regionInfo
argument_list|,
name|RegionInfo
operator|.
name|COMPARATOR
argument_list|)
expr_stmt|;
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// If there is parent procedure, it would have already taken xlock, so no need to take
comment|// shared lock here. Otherwise, take shared lock.
if|if
condition|(
operator|!
name|procedure
operator|.
name|hasParent
argument_list|()
operator|&&
name|waitTableQueueSharedLock
argument_list|(
name|procedure
argument_list|,
name|table
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// acquire region xlocks or wait
name|boolean
name|hasLock
init|=
literal|true
decl_stmt|;
specifier|final
name|LockAndQueue
index|[]
name|regionLocks
init|=
operator|new
name|LockAndQueue
index|[
name|regionInfo
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionInfo
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} checking lock on {}"
argument_list|,
name|procedure
argument_list|,
name|regionInfo
index|[
name|i
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
name|table
operator|!=
literal|null
assert|;
assert|assert
name|regionInfo
index|[
name|i
index|]
operator|!=
literal|null
assert|;
assert|assert
name|regionInfo
index|[
name|i
index|]
operator|.
name|getTable
argument_list|()
operator|!=
literal|null
assert|;
assert|assert
name|regionInfo
index|[
name|i
index|]
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|table
argument_list|)
operator|:
name|regionInfo
index|[
name|i
index|]
operator|+
literal|" "
operator|+
name|procedure
assert|;
assert|assert
name|i
operator|==
literal|0
operator|||
name|regionInfo
index|[
name|i
index|]
operator|!=
name|regionInfo
index|[
name|i
operator|-
literal|1
index|]
operator|:
literal|"duplicate region: "
operator|+
name|regionInfo
index|[
name|i
index|]
assert|;
name|regionLocks
index|[
name|i
index|]
operator|=
name|locking
operator|.
name|getRegionLock
argument_list|(
name|regionInfo
index|[
name|i
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regionLocks
index|[
name|i
index|]
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|waitProcedure
argument_list|(
name|regionLocks
index|[
name|i
index|]
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|hasLock
operator|=
literal|false
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|regionLocks
index|[
name|i
index|]
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|hasLock
operator|&&
operator|!
name|procedure
operator|.
name|hasParent
argument_list|()
condition|)
block|{
name|wakeTableSharedLock
argument_list|(
name|procedure
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|hasLock
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wake the procedures waiting for the specified region    * @param procedure the procedure that was holding the region    * @param regionInfo the region the procedure was holding    */
specifier|public
name|void
name|wakeRegion
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
name|wakeRegions
argument_list|(
name|procedure
argument_list|,
name|regionInfo
operator|.
name|getTable
argument_list|()
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wake the procedures waiting for the specified regions    * @param procedure the procedure that was holding the regions    * @param regionInfo the list of regions the procedure was holding    */
specifier|public
name|void
name|wakeRegions
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|,
specifier|final
name|RegionInfo
modifier|...
name|regionInfo
parameter_list|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|regionInfo
argument_list|,
name|RegionInfo
operator|.
name|COMPARATOR
argument_list|)
expr_stmt|;
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|numProcs
init|=
literal|0
decl_stmt|;
specifier|final
name|Procedure
index|[]
name|nextProcs
init|=
operator|new
name|Procedure
index|[
name|regionInfo
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionInfo
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
assert|assert
name|regionInfo
index|[
name|i
index|]
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|table
argument_list|)
assert|;
assert|assert
name|i
operator|==
literal|0
operator|||
name|regionInfo
index|[
name|i
index|]
operator|!=
name|regionInfo
index|[
name|i
operator|-
literal|1
index|]
operator|:
literal|"duplicate region: "
operator|+
name|regionInfo
index|[
name|i
index|]
assert|;
name|LockAndQueue
name|regionLock
init|=
name|locking
operator|.
name|getRegionLock
argument_list|(
name|regionInfo
index|[
name|i
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionLock
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|regionLock
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// release one procedure at the time since regions has an xlock
name|nextProcs
index|[
name|numProcs
operator|++
index|]
operator|=
name|regionLock
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|locking
operator|.
name|removeRegionLock
argument_list|(
name|regionInfo
index|[
name|i
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// awake procedures if any
for|for
control|(
name|int
name|i
init|=
name|numProcs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|wakeProcedure
argument_list|(
name|nextProcs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|wakePollIfNeeded
argument_list|(
name|numProcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|procedure
operator|.
name|hasParent
argument_list|()
condition|)
block|{
comment|// release the table shared-lock.
comment|// (if we have a parent, it is holding an xlock so we didn't take the shared-lock)
name|wakeTableSharedLock
argument_list|(
name|procedure
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ============================================================================
comment|//  Namespace Locking Helpers
comment|// ============================================================================
comment|/**    * Suspend the procedure if the specified namespace is already locked.    * @see #wakeNamespaceExclusiveLock(Procedure,String)    * @param procedure the procedure trying to acquire the lock    * @param namespace Namespace to lock    * @return true if the procedure has to wait for the namespace to be available    */
specifier|public
name|boolean
name|waitNamespaceExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|String
name|namespace
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|systemNamespaceTableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|systemNamespaceTableLock
operator|.
name|trySharedLock
argument_list|()
condition|)
block|{
name|waitProcedure
argument_list|(
name|systemNamespaceTableLock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|logLockedResource
argument_list|(
name|LockedResourceType
operator|.
name|TABLE
argument_list|,
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
operator|.
name|getNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|final
name|LockAndQueue
name|namespaceLock
init|=
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|namespace
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|namespaceLock
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|systemNamespaceTableLock
operator|.
name|releaseSharedLock
argument_list|()
expr_stmt|;
name|waitProcedure
argument_list|(
name|namespaceLock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|logLockedResource
argument_list|(
name|LockedResourceType
operator|.
name|NAMESPACE
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wake the procedures waiting for the specified namespace    * @see #waitNamespaceExclusiveLock(Procedure,String)    * @param procedure the procedure releasing the lock    * @param namespace the namespace that has the exclusive lock    */
specifier|public
name|void
name|wakeNamespaceExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|String
name|namespace
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|namespaceLock
init|=
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|namespace
argument_list|)
decl_stmt|;
specifier|final
name|LockAndQueue
name|systemNamespaceTableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
argument_list|)
decl_stmt|;
name|namespaceLock
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
name|int
name|waitingCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|systemNamespaceTableLock
operator|.
name|releaseSharedLock
argument_list|()
condition|)
block|{
name|addToRunQueue
argument_list|(
name|tableRunQueue
argument_list|,
name|getTableQueue
argument_list|(
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|waitingCount
operator|+=
name|wakeWaitingProcedures
argument_list|(
name|systemNamespaceTableLock
argument_list|)
expr_stmt|;
block|}
name|waitingCount
operator|+=
name|wakeWaitingProcedures
argument_list|(
name|namespaceLock
argument_list|)
expr_stmt|;
name|wakePollIfNeeded
argument_list|(
name|waitingCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ============================================================================
comment|//  Server Locking Helpers
comment|// ============================================================================
comment|/**    * Try to acquire the exclusive lock on the specified server.    * @see #wakeServerExclusiveLock(Procedure,ServerName)    * @param procedure the procedure trying to acquire the lock    * @param serverName Server to lock    * @return true if the procedure has to wait for the server to be available    */
specifier|public
name|boolean
name|waitServerExclusiveLock
parameter_list|(
specifier|final
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|lock
init|=
name|locking
operator|.
name|getServerLock
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|lock
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|removeFromRunQueue
argument_list|(
name|serverRunQueue
argument_list|,
name|getServerQueue
argument_list|(
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|waitProcedure
argument_list|(
name|lock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|logLockedResource
argument_list|(
name|LockedResourceType
operator|.
name|SERVER
argument_list|,
name|serverName
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wake the procedures waiting for the specified server    * @see #waitServerExclusiveLock(Procedure,ServerName)    * @param procedure the procedure releasing the lock    * @param serverName the server that has the exclusive lock    */
specifier|public
name|void
name|wakeServerExclusiveLock
parameter_list|(
specifier|final
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|lock
init|=
name|locking
operator|.
name|getServerLock
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
name|lock
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
name|addToRunQueue
argument_list|(
name|serverRunQueue
argument_list|,
name|getServerQueue
argument_list|(
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|waitingCount
init|=
name|wakeWaitingProcedures
argument_list|(
name|lock
argument_list|)
decl_stmt|;
name|wakePollIfNeeded
argument_list|(
name|waitingCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ============================================================================
comment|//  Peer Locking Helpers
comment|// ============================================================================
comment|/**    * Try to acquire the exclusive lock on the specified peer.    * @see #wakePeerExclusiveLock(Procedure, String)    * @param procedure the procedure trying to acquire the lock    * @param peerId peer to lock    * @return true if the procedure has to wait for the peer to be available    */
specifier|public
name|boolean
name|waitPeerExclusiveLock
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
parameter_list|,
name|String
name|peerId
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|lock
init|=
name|locking
operator|.
name|getPeerLock
argument_list|(
name|peerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|lock
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|removeFromRunQueue
argument_list|(
name|peerRunQueue
argument_list|,
name|getPeerQueue
argument_list|(
name|peerId
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|waitProcedure
argument_list|(
name|lock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|logLockedResource
argument_list|(
name|LockedResourceType
operator|.
name|PEER
argument_list|,
name|peerId
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wake the procedures waiting for the specified peer    * @see #waitPeerExclusiveLock(Procedure, String)    * @param procedure the procedure releasing the lock    * @param peerId the peer that has the exclusive lock    */
specifier|public
name|void
name|wakePeerExclusiveLock
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
parameter_list|,
name|String
name|peerId
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|lock
init|=
name|locking
operator|.
name|getPeerLock
argument_list|(
name|peerId
argument_list|)
decl_stmt|;
name|lock
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
name|addToRunQueue
argument_list|(
name|peerRunQueue
argument_list|,
name|getPeerQueue
argument_list|(
name|peerId
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|waitingCount
init|=
name|wakeWaitingProcedures
argument_list|(
name|lock
argument_list|)
decl_stmt|;
name|wakePollIfNeeded
argument_list|(
name|waitingCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ============================================================================
comment|// Meta Locking Helpers
comment|// ============================================================================
comment|/**    * Try to acquire the exclusive lock on meta.    * @see #wakeMetaExclusiveLock(Procedure)    * @param procedure the procedure trying to acquire the lock    * @return true if the procedure has to wait for meta to be available    */
specifier|public
name|boolean
name|waitMetaExclusiveLock
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|lock
init|=
name|locking
operator|.
name|getMetaLock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lock
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|removeFromRunQueue
argument_list|(
name|metaRunQueue
argument_list|,
name|getMetaQueue
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|waitProcedure
argument_list|(
name|lock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|logLockedResource
argument_list|(
name|LockedResourceType
operator|.
name|META
argument_list|,
name|TableName
operator|.
name|META_TABLE_NAME
operator|.
name|getNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wake the procedures waiting for meta.    * @see #waitMetaExclusiveLock(Procedure)    * @param procedure the procedure releasing the lock    */
specifier|public
name|void
name|wakeMetaExclusiveLock
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|lock
init|=
name|locking
operator|.
name|getMetaLock
argument_list|()
decl_stmt|;
name|lock
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
name|addToRunQueue
argument_list|(
name|metaRunQueue
argument_list|,
name|getMetaQueue
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|waitingCount
init|=
name|wakeWaitingProcedures
argument_list|(
name|lock
argument_list|)
decl_stmt|;
name|wakePollIfNeeded
argument_list|(
name|waitingCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * For debugging. Expensive.    */
annotation|@
name|VisibleForTesting
specifier|public
name|String
name|dumpLocks
parameter_list|()
throws|throws
name|IOException
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// TODO: Refactor so we stream out locks for case when millions; i.e. take a PrintWriter
return|return
name|this
operator|.
name|locking
operator|.
name|toString
argument_list|()
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

