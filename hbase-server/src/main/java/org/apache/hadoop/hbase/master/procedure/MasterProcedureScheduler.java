begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUTKey WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ProcedureInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|locking
operator|.
name|LockProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|TableProcedureInterface
operator|.
name|TableOperationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|AbstractProcedureScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|LockAndQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|LockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|LockStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|Procedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureDeque
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlIterableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlKeyComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlLinkedNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AvlUtil
operator|.
name|AvlTreeIterator
import|;
end_import

begin_comment
comment|/**  * ProcedureScheduler for the Master Procedures.  * This ProcedureScheduler tries to provide to the ProcedureExecutor procedures  * that can be executed without having to wait on a lock.  * Most of the master operations can be executed concurrently, if they  * are operating on different tables (e.g. two create table procedures can be performed  * at the same time) or against two different servers; say two servers that crashed at  * about the same time.  *  *<p>Each procedure should implement an Interface providing information for this queue.  * For example table related procedures should implement TableProcedureInterface.  * Each procedure will be pushed in its own queue, and based on the operation type  * we may make smarter decisions: e.g. we can abort all the operations preceding  * a delete table, or similar.  *  *<h4>Concurrency control</h4>  * Concurrent access to member variables (tableRunQueue, serverRunQueue, locking, tableMap,  * serverBuckets) is controlled by schedLock(). This mainly includes:<br>  *<ul>  *<li>  *     {@link #push(Procedure, boolean, boolean)}: A push will add a Queue back to run-queue  *     when:  *<ol>  *<li>Queue was empty before push (so must have been out of run-queue)</li>  *<li>Child procedure is added (which means parent procedure holds exclusive lock, and it  *           must have moved Queue out of run-queue)</li>  *</ol>  *</li>  *<li>  *     {@link #poll(long)}: A poll will remove a Queue from run-queue when:  *<ol>  *<li>Queue becomes empty after poll</li>  *<li>Exclusive lock is requested by polled procedure and lock is available (returns the  *           procedure)</li>  *<li>Exclusive lock is requested but lock is not available (returns null)</li>  *<li>Polled procedure is child of parent holding exclusive lock and the next procedure is  *           not a child</li>  *</ol>  *</li>  *<li>  *     Namespace/table/region locks: Queue is added back to run-queue when lock being released is:  *<ol>  *<li>Exclusive lock</li>  *<li>Last shared lock (in case queue was removed because next procedure in queue required  *           exclusive lock)</li>  *</ol>  *</li>  *</ul>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|MasterProcedureScheduler
extends|extends
name|AbstractProcedureScheduler
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|MasterProcedureScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|ServerQueueKeyComparator
name|SERVER_QUEUE_KEY_COMPARATOR
init|=
operator|new
name|ServerQueueKeyComparator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|TableQueueKeyComparator
name|TABLE_QUEUE_KEY_COMPARATOR
init|=
operator|new
name|TableQueueKeyComparator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|FairQueue
argument_list|<
name|ServerName
argument_list|>
name|serverRunQueue
init|=
operator|new
name|FairQueue
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|FairQueue
argument_list|<
name|TableName
argument_list|>
name|tableRunQueue
init|=
operator|new
name|FairQueue
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ServerQueue
index|[]
name|serverBuckets
init|=
operator|new
name|ServerQueue
index|[
literal|128
index|]
decl_stmt|;
specifier|private
name|TableQueue
name|tableMap
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|SchemaLocking
name|locking
init|=
operator|new
name|SchemaLocking
argument_list|()
decl_stmt|;
comment|/**    * Table priority is used when scheduling procedures from {@link #tableRunQueue}. A TableQueue    * with priority 2 will get its procedures scheduled at twice the rate as compared to    * TableQueue with priority 1.    */
specifier|private
specifier|static
class|class
name|TablePriorities
block|{
specifier|final
name|int
name|metaTablePriority
decl_stmt|;
specifier|final
name|int
name|userTablePriority
decl_stmt|;
specifier|final
name|int
name|sysTablePriority
decl_stmt|;
name|TablePriorities
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|metaTablePriority
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.procedure.queue.meta.table.priority"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sysTablePriority
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.procedure.queue.system.table.priority"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|userTablePriority
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.procedure.queue.user.table.priority"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|getPriority
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
name|metaTablePriority
return|;
block|}
elseif|else
if|if
condition|(
name|tableName
operator|.
name|isSystemTable
argument_list|()
condition|)
block|{
return|return
name|sysTablePriority
return|;
block|}
return|return
name|userTablePriority
return|;
block|}
block|}
specifier|private
specifier|final
name|TablePriorities
name|tablePriorities
decl_stmt|;
specifier|public
name|MasterProcedureScheduler
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
name|tablePriorities
operator|=
operator|new
name|TablePriorities
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|yield
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
name|push
argument_list|(
name|proc
argument_list|,
name|isTableProcedure
argument_list|(
name|proc
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|enqueue
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|,
specifier|final
name|boolean
name|addFront
parameter_list|)
block|{
if|if
condition|(
name|isTableProcedure
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|doAdd
argument_list|(
name|tableRunQueue
argument_list|,
name|getTableQueue
argument_list|(
name|getTableName
argument_list|(
name|proc
argument_list|)
argument_list|)
argument_list|,
name|proc
argument_list|,
name|addFront
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isServerProcedure
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|doAdd
argument_list|(
name|serverRunQueue
argument_list|,
name|getServerQueue
argument_list|(
name|getServerName
argument_list|(
name|proc
argument_list|)
argument_list|)
argument_list|,
name|proc
argument_list|,
name|addFront
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: at the moment we only have Table and Server procedures
comment|// if you are implementing a non-table/non-server procedure, you have two options: create
comment|// a group for all the non-table/non-server procedures or try to find a key for your
comment|// non-table/non-server procedures and implement something similar to the TableRunQueue.
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"RQs for non-table/non-server procedures are not implemented yet: "
operator|+
name|proc
argument_list|)
throw|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|doAdd
parameter_list|(
specifier|final
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|,
specifier|final
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|,
specifier|final
name|Procedure
name|proc
parameter_list|,
specifier|final
name|boolean
name|addFront
parameter_list|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|proc
argument_list|,
name|addFront
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|queue
operator|.
name|getLockStatus
argument_list|()
operator|.
name|hasExclusiveLock
argument_list|()
operator|||
name|queue
operator|.
name|getLockStatus
argument_list|()
operator|.
name|isLockOwner
argument_list|(
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
condition|)
block|{
comment|// if the queue was not remove for an xlock execution
comment|// or the proc is the lock owner, put the queue back into execution
name|addToRunQueue
argument_list|(
name|fairq
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|queue
operator|.
name|getLockStatus
argument_list|()
operator|.
name|hasParentLock
argument_list|(
name|proc
argument_list|)
condition|)
block|{
assert|assert
name|addFront
operator|:
literal|"expected to add a child in the front"
assert|;
comment|// our (proc) parent has the xlock,
comment|// so the queue is not in the fairq (run-queue)
comment|// add it back to let the child run (inherit the lock)
name|addToRunQueue
argument_list|(
name|fairq
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|queueHasRunnables
parameter_list|()
block|{
return|return
name|tableRunQueue
operator|.
name|hasRunnables
argument_list|()
operator|||
name|serverRunQueue
operator|.
name|hasRunnables
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Procedure
name|dequeue
parameter_list|()
block|{
comment|// For now, let server handling have precedence over table handling; presumption is that it
comment|// is more important handling crashed servers than it is running the
comment|// enabling/disabling tables, etc.
name|Procedure
name|pollResult
init|=
name|doPoll
argument_list|(
name|serverRunQueue
argument_list|)
decl_stmt|;
if|if
condition|(
name|pollResult
operator|==
literal|null
condition|)
block|{
name|pollResult
operator|=
name|doPoll
argument_list|(
name|tableRunQueue
argument_list|)
expr_stmt|;
block|}
return|return
name|pollResult
return|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|>
name|Procedure
name|doPoll
parameter_list|(
specifier|final
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|)
block|{
specifier|final
name|Queue
argument_list|<
name|T
argument_list|>
name|rq
init|=
name|fairq
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|rq
operator|==
literal|null
operator|||
operator|!
name|rq
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Procedure
name|pollResult
init|=
name|rq
operator|.
name|peek
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|xlockReq
init|=
name|rq
operator|.
name|requireExclusiveLock
argument_list|(
name|pollResult
argument_list|)
decl_stmt|;
if|if
condition|(
name|xlockReq
operator|&&
name|rq
operator|.
name|getLockStatus
argument_list|()
operator|.
name|isLocked
argument_list|()
operator|&&
operator|!
name|rq
operator|.
name|getLockStatus
argument_list|()
operator|.
name|hasLockAccess
argument_list|(
name|pollResult
argument_list|)
condition|)
block|{
comment|// someone is already holding the lock (e.g. shared lock). avoid a yield
name|removeFromRunQueue
argument_list|(
name|fairq
argument_list|,
name|rq
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|rq
operator|.
name|poll
argument_list|()
expr_stmt|;
if|if
condition|(
name|rq
operator|.
name|isEmpty
argument_list|()
operator|||
name|xlockReq
condition|)
block|{
name|removeFromRunQueue
argument_list|(
name|fairq
argument_list|,
name|rq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|.
name|getLockStatus
argument_list|()
operator|.
name|hasParentLock
argument_list|(
name|pollResult
argument_list|)
condition|)
block|{
comment|// if the rq is in the fairq because of runnable child
comment|// check if the next procedure is still a child.
comment|// if not, remove the rq from the fairq and go back to the xlock state
name|Procedure
name|nextProc
init|=
name|rq
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextProc
operator|!=
literal|null
operator|&&
operator|!
name|Procedure
operator|.
name|haveSameParent
argument_list|(
name|nextProc
argument_list|,
name|pollResult
argument_list|)
condition|)
block|{
name|removeFromRunQueue
argument_list|(
name|fairq
argument_list|,
name|rq
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pollResult
return|;
block|}
specifier|private
name|LockInfo
name|createLockInfo
parameter_list|(
name|LockInfo
operator|.
name|ResourceType
name|resourceType
parameter_list|,
name|String
name|resourceName
parameter_list|,
name|LockAndQueue
name|queue
parameter_list|)
block|{
name|LockInfo
name|info
init|=
operator|new
name|LockInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|setResourceType
argument_list|(
name|resourceType
argument_list|)
expr_stmt|;
name|info
operator|.
name|setResourceName
argument_list|(
name|resourceName
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|.
name|hasExclusiveLock
argument_list|()
condition|)
block|{
name|info
operator|.
name|setLockType
argument_list|(
name|LockInfo
operator|.
name|LockType
operator|.
name|EXCLUSIVE
argument_list|)
expr_stmt|;
name|Procedure
argument_list|<
name|?
argument_list|>
name|exclusiveLockOwnerProcedure
init|=
name|queue
operator|.
name|getExclusiveLockOwnerProcedure
argument_list|()
decl_stmt|;
name|ProcedureInfo
name|exclusiveLockOwnerProcedureInfo
init|=
name|ProcedureUtil
operator|.
name|convertToProcedureInfo
argument_list|(
name|exclusiveLockOwnerProcedure
argument_list|)
decl_stmt|;
name|info
operator|.
name|setExclusiveLockOwnerProcedure
argument_list|(
name|exclusiveLockOwnerProcedureInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|queue
operator|.
name|getSharedLockCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|info
operator|.
name|setLockType
argument_list|(
name|LockInfo
operator|.
name|LockType
operator|.
name|SHARED
argument_list|)
expr_stmt|;
name|info
operator|.
name|setSharedLockCount
argument_list|(
name|queue
operator|.
name|getSharedLockCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
range|:
name|queue
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|procedure
operator|instanceof
name|LockProcedure
operator|)
condition|)
block|{
continue|continue;
block|}
name|LockProcedure
name|lockProcedure
init|=
operator|(
name|LockProcedure
operator|)
name|procedure
decl_stmt|;
name|LockInfo
operator|.
name|WaitingProcedure
name|waitingProcedure
init|=
operator|new
name|LockInfo
operator|.
name|WaitingProcedure
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|lockProcedure
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
name|waitingProcedure
operator|.
name|setLockType
argument_list|(
name|LockInfo
operator|.
name|LockType
operator|.
name|EXCLUSIVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHARED
case|:
name|waitingProcedure
operator|.
name|setLockType
argument_list|(
name|LockInfo
operator|.
name|LockType
operator|.
name|SHARED
argument_list|)
expr_stmt|;
break|break;
block|}
name|ProcedureInfo
name|procedureInfo
init|=
name|ProcedureUtil
operator|.
name|convertToProcedureInfo
argument_list|(
name|lockProcedure
argument_list|)
decl_stmt|;
name|waitingProcedure
operator|.
name|setProcedure
argument_list|(
name|procedureInfo
argument_list|)
expr_stmt|;
name|info
operator|.
name|addWaitingProcedure
argument_list|(
name|waitingProcedure
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|LockInfo
argument_list|>
name|listLocks
parameter_list|()
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|LockInfo
argument_list|>
name|lockInfos
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|LockAndQueue
argument_list|>
name|entry
range|:
name|locking
operator|.
name|serverLocks
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|serverName
init|=
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getServerName
argument_list|()
decl_stmt|;
name|LockAndQueue
name|queue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|queue
operator|.
name|isLocked
argument_list|()
condition|)
block|{
name|LockInfo
name|lockInfo
init|=
name|createLockInfo
argument_list|(
name|LockInfo
operator|.
name|ResourceType
operator|.
name|SERVER
argument_list|,
name|serverName
argument_list|,
name|queue
argument_list|)
decl_stmt|;
name|lockInfos
operator|.
name|add
argument_list|(
name|lockInfo
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|LockAndQueue
argument_list|>
name|entry
range|:
name|locking
operator|.
name|namespaceLocks
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|namespaceName
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|LockAndQueue
name|queue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|queue
operator|.
name|isLocked
argument_list|()
condition|)
block|{
name|LockInfo
name|lockInfo
init|=
name|createLockInfo
argument_list|(
name|LockInfo
operator|.
name|ResourceType
operator|.
name|NAMESPACE
argument_list|,
name|namespaceName
argument_list|,
name|queue
argument_list|)
decl_stmt|;
name|lockInfos
operator|.
name|add
argument_list|(
name|lockInfo
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Entry
argument_list|<
name|TableName
argument_list|,
name|LockAndQueue
argument_list|>
name|entry
range|:
name|locking
operator|.
name|tableLocks
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|tableName
init|=
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getNameAsString
argument_list|()
decl_stmt|;
name|LockAndQueue
name|queue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|queue
operator|.
name|isLocked
argument_list|()
condition|)
block|{
name|LockInfo
name|lockInfo
init|=
name|createLockInfo
argument_list|(
name|LockInfo
operator|.
name|ResourceType
operator|.
name|TABLE
argument_list|,
name|tableName
argument_list|,
name|queue
argument_list|)
decl_stmt|;
name|lockInfos
operator|.
name|add
argument_list|(
name|lockInfo
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|LockAndQueue
argument_list|>
name|entry
range|:
name|locking
operator|.
name|regionLocks
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|regionName
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|LockAndQueue
name|queue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|queue
operator|.
name|isLocked
argument_list|()
condition|)
block|{
name|LockInfo
name|lockInfo
init|=
name|createLockInfo
argument_list|(
name|LockInfo
operator|.
name|ResourceType
operator|.
name|REGION
argument_list|,
name|regionName
argument_list|,
name|queue
argument_list|)
decl_stmt|;
name|lockInfos
operator|.
name|add
argument_list|(
name|lockInfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lockInfos
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
name|clearQueue
argument_list|()
expr_stmt|;
name|locking
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|clearQueue
parameter_list|()
block|{
comment|// Remove Servers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|serverBuckets
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|clear
argument_list|(
name|serverBuckets
index|[
name|i
index|]
argument_list|,
name|serverRunQueue
argument_list|,
name|SERVER_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
name|serverBuckets
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
comment|// Remove Tables
name|clear
argument_list|(
name|tableMap
argument_list|,
name|tableRunQueue
argument_list|,
name|TABLE_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
name|tableMap
operator|=
literal|null
expr_stmt|;
assert|assert
name|size
argument_list|()
operator|==
literal|0
operator|:
literal|"expected queue size to be 0, got "
operator|+
name|size
argument_list|()
assert|;
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|,
name|TNode
extends|extends
name|Queue
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|clear
parameter_list|(
name|TNode
name|treeMap
parameter_list|,
specifier|final
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|,
specifier|final
name|AvlKeyComparator
argument_list|<
name|TNode
argument_list|>
name|comparator
parameter_list|)
block|{
while|while
condition|(
name|treeMap
operator|!=
literal|null
condition|)
block|{
name|Queue
argument_list|<
name|T
argument_list|>
name|node
init|=
name|AvlTree
operator|.
name|getFirst
argument_list|(
name|treeMap
argument_list|)
decl_stmt|;
name|treeMap
operator|=
name|AvlTree
operator|.
name|remove
argument_list|(
name|treeMap
argument_list|,
name|node
operator|.
name|getKey
argument_list|()
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|fairq
operator|!=
literal|null
condition|)
name|removeFromRunQueue
argument_list|(
name|fairq
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|int
name|queueSize
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|// Server queues
specifier|final
name|AvlTreeIterator
argument_list|<
name|ServerQueue
argument_list|>
name|serverIter
init|=
operator|new
name|AvlTreeIterator
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|serverBuckets
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|serverIter
operator|.
name|seekFirst
argument_list|(
name|serverBuckets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|serverIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|count
operator|+=
name|serverIter
operator|.
name|next
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Table queues
specifier|final
name|AvlTreeIterator
argument_list|<
name|TableQueue
argument_list|>
name|tableIter
init|=
operator|new
name|AvlTreeIterator
argument_list|<>
argument_list|(
name|tableMap
argument_list|)
decl_stmt|;
while|while
condition|(
name|tableIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|count
operator|+=
name|tableIter
operator|.
name|next
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|completionCleanup
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
block|{
if|if
condition|(
name|proc
operator|instanceof
name|TableProcedureInterface
condition|)
block|{
name|TableProcedureInterface
name|iProcTable
init|=
operator|(
name|TableProcedureInterface
operator|)
name|proc
decl_stmt|;
name|boolean
name|tableDeleted
decl_stmt|;
if|if
condition|(
name|proc
operator|.
name|hasException
argument_list|()
condition|)
block|{
name|Exception
name|procEx
init|=
name|proc
operator|.
name|getException
argument_list|()
operator|.
name|unwrapRemoteException
argument_list|()
decl_stmt|;
if|if
condition|(
name|iProcTable
operator|.
name|getTableOperationType
argument_list|()
operator|==
name|TableOperationType
operator|.
name|CREATE
condition|)
block|{
comment|// create failed because the table already exist
name|tableDeleted
operator|=
operator|!
operator|(
name|procEx
operator|instanceof
name|TableExistsException
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// the operation failed because the table does not exist
name|tableDeleted
operator|=
operator|(
name|procEx
operator|instanceof
name|TableNotFoundException
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// the table was deleted
name|tableDeleted
operator|=
operator|(
name|iProcTable
operator|.
name|getTableOperationType
argument_list|()
operator|==
name|TableOperationType
operator|.
name|DELETE
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tableDeleted
condition|)
block|{
name|markTableAsDeleted
argument_list|(
name|iProcTable
operator|.
name|getTableName
argument_list|()
argument_list|,
name|proc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// No cleanup for ServerProcedureInterface types, yet.
return|return;
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|addToRunQueue
parameter_list|(
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|,
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
if|if
condition|(
operator|!
name|AvlIterableList
operator|.
name|isLinked
argument_list|(
name|queue
argument_list|)
operator|&&
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fairq
operator|.
name|add
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|removeFromRunQueue
parameter_list|(
name|FairQueue
argument_list|<
name|T
argument_list|>
name|fairq
parameter_list|,
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
if|if
condition|(
name|AvlIterableList
operator|.
name|isLinked
argument_list|(
name|queue
argument_list|)
condition|)
block|{
name|fairq
operator|.
name|remove
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ============================================================================
comment|//  Table Queue Lookup Helpers
comment|// ============================================================================
specifier|private
name|TableQueue
name|getTableQueue
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
name|TableQueue
name|node
init|=
name|AvlTree
operator|.
name|get
argument_list|(
name|tableMap
argument_list|,
name|tableName
argument_list|,
name|TABLE_QUEUE_KEY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
return|return
name|node
return|;
name|node
operator|=
operator|new
name|TableQueue
argument_list|(
name|tableName
argument_list|,
name|tablePriorities
operator|.
name|getPriority
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|locking
operator|.
name|getTableLock
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|tableName
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tableMap
operator|=
name|AvlTree
operator|.
name|insert
argument_list|(
name|tableMap
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|private
name|void
name|removeTableQueue
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
name|tableMap
operator|=
name|AvlTree
operator|.
name|remove
argument_list|(
name|tableMap
argument_list|,
name|tableName
argument_list|,
name|TABLE_QUEUE_KEY_COMPARATOR
argument_list|)
expr_stmt|;
name|locking
operator|.
name|removeTableLock
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|isTableProcedure
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
return|return
name|proc
operator|instanceof
name|TableProcedureInterface
return|;
block|}
specifier|private
specifier|static
name|TableName
name|getTableName
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|TableProcedureInterface
operator|)
name|proc
operator|)
operator|.
name|getTableName
argument_list|()
return|;
block|}
comment|// ============================================================================
comment|//  Server Queue Lookup Helpers
comment|// ============================================================================
specifier|private
name|ServerQueue
name|getServerQueue
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|getBucketIndex
argument_list|(
name|serverBuckets
argument_list|,
name|serverName
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|ServerQueue
name|node
init|=
name|AvlTree
operator|.
name|get
argument_list|(
name|serverBuckets
index|[
name|index
index|]
argument_list|,
name|serverName
argument_list|,
name|SERVER_QUEUE_KEY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
return|return
name|node
return|;
name|node
operator|=
operator|new
name|ServerQueue
argument_list|(
name|serverName
argument_list|,
name|locking
operator|.
name|getServerLock
argument_list|(
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
name|serverBuckets
index|[
name|index
index|]
operator|=
name|AvlTree
operator|.
name|insert
argument_list|(
name|serverBuckets
index|[
name|index
index|]
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|private
specifier|static
name|int
name|getBucketIndex
parameter_list|(
name|Object
index|[]
name|buckets
parameter_list|,
name|int
name|hashCode
parameter_list|)
block|{
return|return
name|Math
operator|.
name|abs
argument_list|(
name|hashCode
argument_list|)
operator|%
name|buckets
operator|.
name|length
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isServerProcedure
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
return|return
name|proc
operator|instanceof
name|ServerProcedureInterface
return|;
block|}
specifier|private
specifier|static
name|ServerName
name|getServerName
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ServerProcedureInterface
operator|)
name|proc
operator|)
operator|.
name|getServerName
argument_list|()
return|;
block|}
comment|// ============================================================================
comment|//  Table and Server Queue Implementation
comment|// ============================================================================
specifier|private
specifier|static
class|class
name|ServerQueueKeyComparator
implements|implements
name|AvlKeyComparator
argument_list|<
name|ServerQueue
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compareKey
parameter_list|(
name|ServerQueue
name|node
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
return|return
name|node
operator|.
name|compareKey
argument_list|(
operator|(
name|ServerName
operator|)
name|key
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|ServerQueue
extends|extends
name|Queue
argument_list|<
name|ServerName
argument_list|>
block|{
specifier|public
name|ServerQueue
parameter_list|(
name|ServerName
name|serverName
parameter_list|,
name|LockStatus
name|serverLock
parameter_list|)
block|{
name|super
argument_list|(
name|serverName
argument_list|,
name|serverLock
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|requireExclusiveLock
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
name|ServerProcedureInterface
name|spi
init|=
operator|(
name|ServerProcedureInterface
operator|)
name|proc
decl_stmt|;
switch|switch
condition|(
name|spi
operator|.
name|getServerOperationType
argument_list|()
condition|)
block|{
case|case
name|CRASH_HANDLER
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"unexpected type "
operator|+
name|spi
operator|.
name|getServerOperationType
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
class|class
name|TableQueueKeyComparator
implements|implements
name|AvlKeyComparator
argument_list|<
name|TableQueue
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compareKey
parameter_list|(
name|TableQueue
name|node
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
return|return
name|node
operator|.
name|compareKey
argument_list|(
operator|(
name|TableName
operator|)
name|key
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|TableQueue
extends|extends
name|Queue
argument_list|<
name|TableName
argument_list|>
block|{
specifier|private
specifier|final
name|LockStatus
name|namespaceLockStatus
decl_stmt|;
specifier|public
name|TableQueue
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|int
name|priority
parameter_list|,
name|LockStatus
name|tableLock
parameter_list|,
name|LockStatus
name|namespaceLockStatus
parameter_list|)
block|{
name|super
argument_list|(
name|tableName
argument_list|,
name|priority
argument_list|,
name|tableLock
argument_list|)
expr_stmt|;
name|this
operator|.
name|namespaceLockStatus
operator|=
name|namespaceLockStatus
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAvailable
parameter_list|()
block|{
comment|// if there are no items in the queue, or the namespace is locked.
comment|// we can't execute operation on this table
if|if
condition|(
name|isEmpty
argument_list|()
operator|||
name|namespaceLockStatus
operator|.
name|hasExclusiveLock
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getLockStatus
argument_list|()
operator|.
name|hasExclusiveLock
argument_list|()
condition|)
block|{
comment|// if we have an exclusive lock already taken
comment|// only child of the lock owner can be executed
specifier|final
name|Procedure
name|nextProc
init|=
name|peek
argument_list|()
decl_stmt|;
return|return
name|nextProc
operator|!=
literal|null
operator|&&
name|getLockStatus
argument_list|()
operator|.
name|hasLockAccess
argument_list|(
name|nextProc
argument_list|)
return|;
block|}
comment|// no xlock
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|requireExclusiveLock
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
return|return
name|requireTableExclusiveLock
argument_list|(
operator|(
name|TableProcedureInterface
operator|)
name|proc
argument_list|)
return|;
block|}
block|}
comment|// ============================================================================
comment|//  Table Locking Helpers
comment|// ============================================================================
specifier|private
specifier|static
name|boolean
name|requireTableExclusiveLock
parameter_list|(
name|TableProcedureInterface
name|proc
parameter_list|)
block|{
switch|switch
condition|(
name|proc
operator|.
name|getTableOperationType
argument_list|()
condition|)
block|{
case|case
name|CREATE
case|:
case|case
name|DELETE
case|:
case|case
name|DISABLE
case|:
case|case
name|ENABLE
case|:
return|return
literal|true
return|;
case|case
name|EDIT
case|:
comment|// we allow concurrent edit on the NS table
return|return
operator|!
name|proc
operator|.
name|getTableName
argument_list|()
operator|.
name|equals
argument_list|(
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
argument_list|)
return|;
case|case
name|READ
case|:
return|return
literal|false
return|;
comment|// region operations are using the shared-lock on the table
comment|// and then they will grab an xlock on the region.
case|case
name|SPLIT
case|:
case|case
name|MERGE
case|:
case|case
name|ASSIGN
case|:
case|case
name|UNASSIGN
case|:
case|case
name|REGION_EDIT
case|:
return|return
literal|false
return|;
default|default:
break|break;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"unexpected type "
operator|+
name|proc
operator|.
name|getTableOperationType
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Suspend the procedure if the specified table is already locked.    * Other operations in the table-queue will be executed after the lock is released.    * @param procedure the procedure trying to acquire the lock    * @param table Table to lock    * @return true if the procedure has to wait for the table to be available    */
specifier|public
name|boolean
name|waitTableExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|namespaceLock
init|=
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|table
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|LockAndQueue
name|tableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|namespaceLock
operator|.
name|trySharedLock
argument_list|()
condition|)
block|{
name|waitProcedure
argument_list|(
name|namespaceLock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|tableLock
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|namespaceLock
operator|.
name|releaseSharedLock
argument_list|()
expr_stmt|;
name|waitProcedure
argument_list|(
name|tableLock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|removeFromRunQueue
argument_list|(
name|tableRunQueue
argument_list|,
name|getTableQueue
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wake the procedures waiting for the specified table    * @param procedure the procedure releasing the lock    * @param table the name of the table that has the exclusive lock    */
specifier|public
name|void
name|wakeTableExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|namespaceLock
init|=
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|table
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|LockAndQueue
name|tableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|int
name|waitingCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tableLock
operator|.
name|hasParentLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|tableLock
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
name|waitingCount
operator|+=
name|wakeWaitingProcedures
argument_list|(
name|tableLock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namespaceLock
operator|.
name|releaseSharedLock
argument_list|()
condition|)
block|{
name|waitingCount
operator|+=
name|wakeWaitingProcedures
argument_list|(
name|namespaceLock
argument_list|)
expr_stmt|;
block|}
name|addToRunQueue
argument_list|(
name|tableRunQueue
argument_list|,
name|getTableQueue
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|wakePollIfNeeded
argument_list|(
name|waitingCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Suspend the procedure if the specified table is already locked.    * other "read" operations in the table-queue may be executed concurrently,    * @param procedure the procedure trying to acquire the lock    * @param table Table to lock    * @return true if the procedure has to wait for the table to be available    */
specifier|public
name|boolean
name|waitTableSharedLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
return|return
name|waitTableQueueSharedLock
argument_list|(
name|procedure
argument_list|,
name|table
argument_list|)
operator|==
literal|null
return|;
block|}
specifier|private
name|TableQueue
name|waitTableQueueSharedLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|namespaceLock
init|=
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|table
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|LockAndQueue
name|tableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|namespaceLock
operator|.
name|trySharedLock
argument_list|()
condition|)
block|{
name|waitProcedure
argument_list|(
name|namespaceLock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|tableLock
operator|.
name|trySharedLock
argument_list|()
condition|)
block|{
name|namespaceLock
operator|.
name|releaseSharedLock
argument_list|()
expr_stmt|;
name|waitProcedure
argument_list|(
name|tableLock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|getTableQueue
argument_list|(
name|table
argument_list|)
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wake the procedures waiting for the specified table    * @param procedure the procedure releasing the lock    * @param table the name of the table that has the shared lock    */
specifier|public
name|void
name|wakeTableSharedLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|namespaceLock
init|=
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|table
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|LockAndQueue
name|tableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|int
name|waitingCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tableLock
operator|.
name|releaseSharedLock
argument_list|()
condition|)
block|{
name|addToRunQueue
argument_list|(
name|tableRunQueue
argument_list|,
name|getTableQueue
argument_list|(
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|waitingCount
operator|+=
name|wakeWaitingProcedures
argument_list|(
name|tableLock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namespaceLock
operator|.
name|releaseSharedLock
argument_list|()
condition|)
block|{
name|waitingCount
operator|+=
name|wakeWaitingProcedures
argument_list|(
name|namespaceLock
argument_list|)
expr_stmt|;
block|}
name|wakePollIfNeeded
argument_list|(
name|waitingCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Tries to remove the queue and the table-lock of the specified table.    * If there are new operations pending (e.g. a new create),    * the remove will not be performed.    * @param table the name of the table that should be marked as deleted    * @param procedure the procedure that is removing the table    * @return true if deletion succeeded, false otherwise meaning that there are    *     other new operations pending for that table (e.g. a new create).    */
annotation|@
name|VisibleForTesting
specifier|protected
name|boolean
name|markTableAsDeleted
parameter_list|(
specifier|final
name|TableName
name|table
parameter_list|,
specifier|final
name|Procedure
name|procedure
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|TableQueue
name|queue
init|=
name|getTableQueue
argument_list|(
name|table
argument_list|)
decl_stmt|;
specifier|final
name|LockAndQueue
name|tableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|queue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|tableLock
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
comment|// remove the table from the run-queue and the map
if|if
condition|(
name|AvlIterableList
operator|.
name|isLinked
argument_list|(
name|queue
argument_list|)
condition|)
block|{
name|tableRunQueue
operator|.
name|remove
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
name|removeTableQueue
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: If there are no create, we can drop all the other ops
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// ============================================================================
comment|//  Region Locking Helpers
comment|// ============================================================================
comment|/**    * Suspend the procedure if the specified region is already locked.    * @param procedure the procedure trying to acquire the lock on the region    * @param regionInfo the region we are trying to lock    * @return true if the procedure has to wait for the regions to be available    */
specifier|public
name|boolean
name|waitRegion
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
return|return
name|waitRegions
argument_list|(
name|procedure
argument_list|,
name|regionInfo
operator|.
name|getTable
argument_list|()
argument_list|,
name|regionInfo
argument_list|)
return|;
block|}
comment|/**    * Suspend the procedure if the specified set of regions are already locked.    * @param procedure the procedure trying to acquire the lock on the regions    * @param table the table name of the regions we are trying to lock    * @param regionInfo the list of regions we are trying to lock    * @return true if the procedure has to wait for the regions to be available    */
specifier|public
name|boolean
name|waitRegions
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|,
specifier|final
name|HRegionInfo
modifier|...
name|regionInfo
parameter_list|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// If there is parent procedure, it would have already taken xlock, so no need to take
comment|// shared lock here. Otherwise, take shared lock.
if|if
condition|(
operator|!
name|procedure
operator|.
name|hasParent
argument_list|()
operator|&&
name|waitTableQueueSharedLock
argument_list|(
name|procedure
argument_list|,
name|table
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// acquire region xlocks or wait
name|boolean
name|hasLock
init|=
literal|true
decl_stmt|;
specifier|final
name|LockAndQueue
index|[]
name|regionLocks
init|=
operator|new
name|LockAndQueue
index|[
name|regionInfo
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionInfo
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
assert|assert
name|regionInfo
index|[
name|i
index|]
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|table
argument_list|)
assert|;
assert|assert
name|i
operator|==
literal|0
operator|||
name|regionInfo
index|[
name|i
index|]
operator|!=
name|regionInfo
index|[
name|i
operator|-
literal|1
index|]
operator|:
literal|"duplicate region: "
operator|+
name|regionInfo
index|[
name|i
index|]
assert|;
name|regionLocks
index|[
name|i
index|]
operator|=
name|locking
operator|.
name|getRegionLock
argument_list|(
name|regionInfo
index|[
name|i
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regionLocks
index|[
name|i
index|]
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|waitProcedure
argument_list|(
name|regionLocks
index|[
name|i
index|]
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
name|hasLock
operator|=
literal|false
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|regionLocks
index|[
name|i
index|]
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|hasLock
operator|&&
operator|!
name|procedure
operator|.
name|hasParent
argument_list|()
condition|)
block|{
name|wakeTableSharedLock
argument_list|(
name|procedure
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|hasLock
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wake the procedures waiting for the specified region    * @param procedure the procedure that was holding the region    * @param regionInfo the region the procedure was holding    */
specifier|public
name|void
name|wakeRegion
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|wakeRegions
argument_list|(
name|procedure
argument_list|,
name|regionInfo
operator|.
name|getTable
argument_list|()
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wake the procedures waiting for the specified regions    * @param procedure the procedure that was holding the regions    * @param regionInfo the list of regions the procedure was holding    */
specifier|public
name|void
name|wakeRegions
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|TableName
name|table
parameter_list|,
specifier|final
name|HRegionInfo
modifier|...
name|regionInfo
parameter_list|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|numProcs
init|=
literal|0
decl_stmt|;
specifier|final
name|Procedure
index|[]
name|nextProcs
init|=
operator|new
name|Procedure
index|[
name|regionInfo
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionInfo
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
assert|assert
name|regionInfo
index|[
name|i
index|]
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|table
argument_list|)
assert|;
assert|assert
name|i
operator|==
literal|0
operator|||
name|regionInfo
index|[
name|i
index|]
operator|!=
name|regionInfo
index|[
name|i
operator|-
literal|1
index|]
operator|:
literal|"duplicate region: "
operator|+
name|regionInfo
index|[
name|i
index|]
assert|;
name|LockAndQueue
name|regionLock
init|=
name|locking
operator|.
name|getRegionLock
argument_list|(
name|regionInfo
index|[
name|i
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionLock
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|regionLock
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// release one procedure at the time since regions has an xlock
name|nextProcs
index|[
name|numProcs
operator|++
index|]
operator|=
name|regionLock
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|locking
operator|.
name|removeRegionLock
argument_list|(
name|regionInfo
index|[
name|i
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// awake procedures if any
for|for
control|(
name|int
name|i
init|=
name|numProcs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|wakeProcedure
argument_list|(
name|nextProcs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|wakePollIfNeeded
argument_list|(
name|numProcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|procedure
operator|.
name|hasParent
argument_list|()
condition|)
block|{
comment|// release the table shared-lock.
comment|// (if we have a parent, it is holding an xlock so we didn't take the shared-lock)
name|wakeTableSharedLock
argument_list|(
name|procedure
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ============================================================================
comment|//  Namespace Locking Helpers
comment|// ============================================================================
comment|/**    * Suspend the procedure if the specified namespace is already locked.    * @see #wakeNamespaceExclusiveLock(Procedure,String)    * @param procedure the procedure trying to acquire the lock    * @param namespace Namespace to lock    * @return true if the procedure has to wait for the namespace to be available    */
specifier|public
name|boolean
name|waitNamespaceExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|String
name|namespace
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|systemNamespaceTableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|systemNamespaceTableLock
operator|.
name|trySharedLock
argument_list|()
condition|)
block|{
name|waitProcedure
argument_list|(
name|systemNamespaceTableLock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|final
name|LockAndQueue
name|namespaceLock
init|=
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|namespace
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|namespaceLock
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|systemNamespaceTableLock
operator|.
name|releaseSharedLock
argument_list|()
expr_stmt|;
name|waitProcedure
argument_list|(
name|namespaceLock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wake the procedures waiting for the specified namespace    * @see #waitNamespaceExclusiveLock(Procedure,String)    * @param procedure the procedure releasing the lock    * @param namespace the namespace that has the exclusive lock    */
specifier|public
name|void
name|wakeNamespaceExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|String
name|namespace
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|namespaceLock
init|=
name|locking
operator|.
name|getNamespaceLock
argument_list|(
name|namespace
argument_list|)
decl_stmt|;
specifier|final
name|LockAndQueue
name|systemNamespaceTableLock
init|=
name|locking
operator|.
name|getTableLock
argument_list|(
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
argument_list|)
decl_stmt|;
name|namespaceLock
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
name|int
name|waitingCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|systemNamespaceTableLock
operator|.
name|releaseSharedLock
argument_list|()
condition|)
block|{
name|addToRunQueue
argument_list|(
name|tableRunQueue
argument_list|,
name|getTableQueue
argument_list|(
name|TableName
operator|.
name|NAMESPACE_TABLE_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|waitingCount
operator|+=
name|wakeWaitingProcedures
argument_list|(
name|systemNamespaceTableLock
argument_list|)
expr_stmt|;
block|}
name|waitingCount
operator|+=
name|wakeWaitingProcedures
argument_list|(
name|namespaceLock
argument_list|)
expr_stmt|;
name|wakePollIfNeeded
argument_list|(
name|waitingCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ============================================================================
comment|//  Server Locking Helpers
comment|// ============================================================================
comment|/**    * Try to acquire the exclusive lock on the specified server.    * @see #wakeServerExclusiveLock(Procedure,ServerName)    * @param procedure the procedure trying to acquire the lock    * @param serverName Server to lock    * @return true if the procedure has to wait for the server to be available    */
specifier|public
name|boolean
name|waitServerExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|lock
init|=
name|locking
operator|.
name|getServerLock
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|lock
operator|.
name|tryExclusiveLock
argument_list|(
name|procedure
argument_list|)
condition|)
block|{
name|removeFromRunQueue
argument_list|(
name|serverRunQueue
argument_list|,
name|getServerQueue
argument_list|(
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|waitProcedure
argument_list|(
name|lock
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wake the procedures waiting for the specified server    * @see #waitServerExclusiveLock(Procedure,ServerName)    * @param procedure the procedure releasing the lock    * @param serverName the server that has the exclusive lock    */
specifier|public
name|void
name|wakeServerExclusiveLock
parameter_list|(
specifier|final
name|Procedure
name|procedure
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
name|schedLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|LockAndQueue
name|lock
init|=
name|locking
operator|.
name|getServerLock
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
name|lock
operator|.
name|releaseExclusiveLock
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
name|addToRunQueue
argument_list|(
name|serverRunQueue
argument_list|,
name|getServerQueue
argument_list|(
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|waitingCount
init|=
name|wakeWaitingProcedures
argument_list|(
name|lock
argument_list|)
decl_stmt|;
name|wakePollIfNeeded
argument_list|(
name|waitingCount
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|schedUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ============================================================================
comment|//  Generic Helpers
comment|// ============================================================================
specifier|private
specifier|static
specifier|abstract
class|class
name|Queue
parameter_list|<
name|TKey
extends|extends
name|Comparable
parameter_list|<
name|TKey
parameter_list|>
parameter_list|>
extends|extends
name|AvlLinkedNode
argument_list|<
name|Queue
argument_list|<
name|TKey
argument_list|>
argument_list|>
block|{
specifier|abstract
name|boolean
name|requireExclusiveLock
parameter_list|(
name|Procedure
name|proc
parameter_list|)
function_decl|;
specifier|private
specifier|final
name|TKey
name|key
decl_stmt|;
specifier|private
specifier|final
name|int
name|priority
decl_stmt|;
specifier|private
specifier|final
name|ProcedureDeque
name|runnables
init|=
operator|new
name|ProcedureDeque
argument_list|()
decl_stmt|;
comment|// Reference to status of lock on entity this queue represents.
specifier|private
specifier|final
name|LockStatus
name|lockStatus
decl_stmt|;
specifier|public
name|Queue
parameter_list|(
name|TKey
name|key
parameter_list|,
name|LockStatus
name|lockStatus
parameter_list|)
block|{
name|this
argument_list|(
name|key
argument_list|,
literal|1
argument_list|,
name|lockStatus
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Queue
parameter_list|(
name|TKey
name|key
parameter_list|,
name|int
name|priority
parameter_list|,
name|LockStatus
name|lockStatus
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
name|this
operator|.
name|lockStatus
operator|=
name|lockStatus
expr_stmt|;
block|}
specifier|protected
name|TKey
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
specifier|protected
name|int
name|getPriority
parameter_list|()
block|{
return|return
name|priority
return|;
block|}
specifier|protected
name|LockStatus
name|getLockStatus
parameter_list|()
block|{
return|return
name|lockStatus
return|;
block|}
comment|// This should go away when we have the new AM and its events
comment|// and we move xlock to the lock-event-queue.
specifier|public
name|boolean
name|isAvailable
parameter_list|()
block|{
return|return
operator|!
name|lockStatus
operator|.
name|hasExclusiveLock
argument_list|()
operator|&&
operator|!
name|isEmpty
argument_list|()
return|;
block|}
comment|// ======================================================================
comment|//  Functions to handle procedure queue
comment|// ======================================================================
specifier|public
name|void
name|add
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|,
specifier|final
name|boolean
name|addToFront
parameter_list|)
block|{
if|if
condition|(
name|addToFront
condition|)
block|{
name|runnables
operator|.
name|addFirst
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|runnables
operator|.
name|addLast
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|Procedure
name|peek
parameter_list|()
block|{
return|return
name|runnables
operator|.
name|peek
argument_list|()
return|;
block|}
specifier|public
name|Procedure
name|poll
parameter_list|()
block|{
return|return
name|runnables
operator|.
name|poll
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|runnables
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|runnables
operator|.
name|size
argument_list|()
return|;
block|}
comment|// ======================================================================
comment|//  Generic Helpers
comment|// ======================================================================
specifier|public
name|int
name|compareKey
parameter_list|(
name|TKey
name|cmpKey
parameter_list|)
block|{
return|return
name|key
operator|.
name|compareTo
argument_list|(
name|cmpKey
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Queue
argument_list|<
name|TKey
argument_list|>
name|other
parameter_list|)
block|{
return|return
name|compareKey
argument_list|(
name|other
operator|.
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s(%s, xlock=%s sharedLock=%s size=%s)"
argument_list|,
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|key
argument_list|,
name|lockStatus
operator|.
name|hasExclusiveLock
argument_list|()
condition|?
literal|"true ("
operator|+
name|lockStatus
operator|.
name|getExclusiveLockProcIdOwner
argument_list|()
operator|+
literal|")"
else|:
literal|"false"
argument_list|,
name|lockStatus
operator|.
name|getSharedLockCount
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Locks on namespaces, tables, and regions.    * Since LockAndQueue implementation is NOT thread-safe, schedLock() guards all calls to these    * locks.    */
specifier|private
specifier|static
class|class
name|SchemaLocking
block|{
specifier|final
name|Map
argument_list|<
name|ServerName
argument_list|,
name|LockAndQueue
argument_list|>
name|serverLocks
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LockAndQueue
argument_list|>
name|namespaceLocks
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|TableName
argument_list|,
name|LockAndQueue
argument_list|>
name|tableLocks
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Single map for all regions irrespective of tables. Key is encoded region name.
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LockAndQueue
argument_list|>
name|regionLocks
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
parameter_list|<
name|T
parameter_list|>
name|LockAndQueue
name|getLock
parameter_list|(
name|Map
argument_list|<
name|T
argument_list|,
name|LockAndQueue
argument_list|>
name|map
parameter_list|,
name|T
name|key
parameter_list|)
block|{
name|LockAndQueue
name|lock
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|lock
operator|==
literal|null
condition|)
block|{
name|lock
operator|=
operator|new
name|LockAndQueue
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
name|lock
return|;
block|}
name|LockAndQueue
name|getTableLock
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|getLock
argument_list|(
name|tableLocks
argument_list|,
name|tableName
argument_list|)
return|;
block|}
name|LockAndQueue
name|removeTableLock
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|tableLocks
operator|.
name|remove
argument_list|(
name|tableName
argument_list|)
return|;
block|}
name|LockAndQueue
name|getNamespaceLock
parameter_list|(
name|String
name|namespace
parameter_list|)
block|{
return|return
name|getLock
argument_list|(
name|namespaceLocks
argument_list|,
name|namespace
argument_list|)
return|;
block|}
name|LockAndQueue
name|getRegionLock
parameter_list|(
name|String
name|encodedRegionName
parameter_list|)
block|{
return|return
name|getLock
argument_list|(
name|regionLocks
argument_list|,
name|encodedRegionName
argument_list|)
return|;
block|}
name|LockAndQueue
name|removeRegionLock
parameter_list|(
name|String
name|encodedRegionName
parameter_list|)
block|{
return|return
name|regionLocks
operator|.
name|remove
argument_list|(
name|encodedRegionName
argument_list|)
return|;
block|}
name|LockAndQueue
name|getServerLock
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
return|return
name|getLock
argument_list|(
name|serverLocks
argument_list|,
name|serverName
argument_list|)
return|;
block|}
comment|/**      * Removes all locks by clearing the maps.      * Used when procedure executor is stopped for failure and recovery testing.      */
annotation|@
name|VisibleForTesting
name|void
name|clear
parameter_list|()
block|{
name|serverLocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|namespaceLocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|tableLocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|regionLocks
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"serverLocks="
operator|+
name|filterUnlocked
argument_list|(
name|this
operator|.
name|serverLocks
argument_list|)
operator|+
literal|", namespaceLocks="
operator|+
name|filterUnlocked
argument_list|(
name|this
operator|.
name|namespaceLocks
argument_list|)
operator|+
literal|", tableLocks="
operator|+
name|filterUnlocked
argument_list|(
name|this
operator|.
name|tableLocks
argument_list|)
operator|+
literal|", regionLocks="
operator|+
name|filterUnlocked
argument_list|(
name|this
operator|.
name|regionLocks
argument_list|)
return|;
block|}
specifier|private
name|String
name|filterUnlocked
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|LockAndQueue
argument_list|>
name|locks
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"{"
argument_list|)
decl_stmt|;
name|int
name|initialLength
init|=
name|sb
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|LockAndQueue
argument_list|>
name|entry
range|:
name|locks
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|isLocked
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
name|initialLength
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|// ======================================================================
comment|//  Helper Data Structures
comment|// ======================================================================
specifier|private
specifier|static
class|class
name|FairQueue
parameter_list|<
name|T
extends|extends
name|Comparable
parameter_list|<
name|T
parameter_list|>
parameter_list|>
block|{
specifier|private
specifier|final
name|int
name|quantum
decl_stmt|;
specifier|private
name|Queue
argument_list|<
name|T
argument_list|>
name|currentQueue
init|=
literal|null
decl_stmt|;
specifier|private
name|Queue
argument_list|<
name|T
argument_list|>
name|queueHead
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|currentQuantum
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|size
init|=
literal|0
decl_stmt|;
specifier|public
name|FairQueue
parameter_list|()
block|{
name|this
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
name|FairQueue
parameter_list|(
name|int
name|quantum
parameter_list|)
block|{
name|this
operator|.
name|quantum
operator|=
name|quantum
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasRunnables
parameter_list|()
block|{
return|return
name|size
operator|>
literal|0
return|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
name|queueHead
operator|=
name|AvlIterableList
operator|.
name|append
argument_list|(
name|queueHead
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentQueue
operator|==
literal|null
condition|)
name|setNextQueue
argument_list|(
name|queueHead
argument_list|)
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
name|Queue
argument_list|<
name|T
argument_list|>
name|nextQueue
init|=
name|AvlIterableList
operator|.
name|readNext
argument_list|(
name|queue
argument_list|)
decl_stmt|;
name|queueHead
operator|=
name|AvlIterableList
operator|.
name|remove
argument_list|(
name|queueHead
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentQueue
operator|==
name|queue
condition|)
block|{
name|setNextQueue
argument_list|(
name|queueHead
operator|!=
literal|null
condition|?
name|nextQueue
else|:
literal|null
argument_list|)
expr_stmt|;
block|}
name|size
operator|--
expr_stmt|;
block|}
specifier|public
name|Queue
argument_list|<
name|T
argument_list|>
name|poll
parameter_list|()
block|{
if|if
condition|(
name|currentQuantum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|nextQueue
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
comment|// nothing here
block|}
name|currentQuantum
operator|=
name|calculateQuantum
argument_list|(
name|currentQueue
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|currentQuantum
operator|--
expr_stmt|;
block|}
comment|// This should go away when we have the new AM and its events
if|if
condition|(
operator|!
name|currentQueue
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
name|Queue
argument_list|<
name|T
argument_list|>
name|lastQueue
init|=
name|currentQueue
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|nextQueue
argument_list|()
condition|)
return|return
literal|null
return|;
block|}
do|while
condition|(
name|currentQueue
operator|!=
name|lastQueue
operator|&&
operator|!
name|currentQueue
operator|.
name|isAvailable
argument_list|()
condition|)
do|;
name|currentQuantum
operator|=
name|calculateQuantum
argument_list|(
name|currentQueue
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|currentQueue
return|;
block|}
specifier|private
name|boolean
name|nextQueue
parameter_list|()
block|{
if|if
condition|(
name|currentQueue
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|currentQueue
operator|=
name|AvlIterableList
operator|.
name|readNext
argument_list|(
name|currentQueue
argument_list|)
expr_stmt|;
return|return
name|currentQueue
operator|!=
literal|null
return|;
block|}
specifier|private
name|void
name|setNextQueue
parameter_list|(
name|Queue
argument_list|<
name|T
argument_list|>
name|queue
parameter_list|)
block|{
name|currentQueue
operator|=
name|queue
expr_stmt|;
if|if
condition|(
name|queue
operator|!=
literal|null
condition|)
block|{
name|currentQuantum
operator|=
name|calculateQuantum
argument_list|(
name|currentQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentQuantum
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|calculateQuantum
parameter_list|(
specifier|final
name|Queue
name|queue
parameter_list|)
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|queue
operator|.
name|getPriority
argument_list|()
operator|*
name|quantum
argument_list|)
return|;
comment|// TODO
block|}
block|}
comment|/**    * For debugging. Expensive.     * @throws IOException     */
annotation|@
name|VisibleForTesting
specifier|public
name|String
name|dumpLocks
parameter_list|()
throws|throws
name|IOException
block|{
comment|// TODO: Refactor so we stream out locks for case when millions; i.e. take a PrintWriter
return|return
name|this
operator|.
name|locking
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

