begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|fs
operator|.
name|HFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|FSDataInputStreamWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|compress
operator|.
name|Compression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|compress
operator|.
name|Compression
operator|.
name|Algorithm
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|HFileBlockDecodingContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|HFileBlockDefaultDecodingContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|HFileBlockDefaultEncodingContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|HFileBlockEncodingContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|bucket
operator|.
name|BucketCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ChecksumType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CompoundBloomFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * Reading {@link HFile} version 1 and 2 blocks, and writing version 2 blocks.  *<ul>  *<li>In version 1 all blocks are always compressed or uncompressed, as  * specified by the {@link HFile}'s compression algorithm, with a type-specific  * magic record stored in the beginning of the compressed data (i.e. one needs  * to uncompress the compressed block to determine the block type). There is  * only a single compression algorithm setting for all blocks. Offset and size  * information from the block index are required to read a block.  *<li>In version 2 a block is structured as follows:  *<ul>  *<li>Magic record identifying the block type (8 bytes)  *<li>Compressed block size, header not included (4 bytes)  *<li>Uncompressed block size, header not included (4 bytes)  *<li>The offset of the previous block of the same type (8 bytes). This is  * used to be able to navigate to the previous block without going to the block  *<li>For minorVersions>=1, there is an additional 4 byte field   * bytesPerChecksum that records the number of bytes in a checksum chunk.  *<li>For minorVersions>=1, there is a 4 byte value to store the size of  * data on disk (excluding the checksums)  *<li>For minorVersions>=1, a series of 4 byte checksums, one each for  * the number of bytes specified by bytesPerChecksum.  * index.  *<li>Compressed data (or uncompressed data if compression is disabled). The  * compression algorithm is the same for all the blocks in the {@link HFile},  * similarly to what was done in version 1.  *</ul>  *</ul>  * The version 2 block representation in the block cache is the same as above,  * except that the data section is always uncompressed in the cache.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|HFileBlock
implements|implements
name|Cacheable
block|{
comment|/**    * On a checksum failure on a Reader, these many suceeding read    * requests switch back to using hdfs checksums before auto-reenabling    * hbase checksum verification.    */
specifier|static
specifier|final
name|int
name|CHECKSUM_VERIFICATION_NUM_IO_THRESHOLD
init|=
literal|3
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|FILL_HEADER
init|=
literal|true
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DONT_FILL_HEADER
init|=
literal|false
decl_stmt|;
comment|/**    * The size of block header when blockType is {@link BlockType#ENCODED_DATA}.    * This extends normal header by adding the id of encoder.    */
specifier|public
specifier|static
specifier|final
name|int
name|ENCODED_HEADER_SIZE
init|=
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE
operator|+
name|DataBlockEncoding
operator|.
name|ID_SIZE
decl_stmt|;
specifier|static
specifier|final
name|byte
index|[]
name|DUMMY_HEADER_NO_CHECKSUM
init|=
operator|new
name|byte
index|[
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE_NO_CHECKSUM
index|]
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|BYTE_BUFFER_HEAP_SIZE
init|=
operator|(
name|int
operator|)
name|ClassSize
operator|.
name|estimateBase
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
operator|new
name|byte
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// meta.usesHBaseChecksum+offset+nextBlockOnDiskSizeWithHeader
specifier|public
specifier|static
specifier|final
name|int
name|EXTRA_SERIALIZATION_SPACE
init|=
name|Bytes
operator|.
name|SIZEOF_BYTE
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
operator|+
name|Bytes
operator|.
name|SIZEOF_LONG
decl_stmt|;
comment|/**    * Each checksum value is an integer that can be stored in 4 bytes.    */
specifier|static
specifier|final
name|int
name|CHECKSUM_SIZE
init|=
name|Bytes
operator|.
name|SIZEOF_INT
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CacheableDeserializer
argument_list|<
name|Cacheable
argument_list|>
name|blockDeserializer
init|=
operator|new
name|CacheableDeserializer
argument_list|<
name|Cacheable
argument_list|>
argument_list|()
block|{
specifier|public
name|HFileBlock
name|deserialize
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|,
name|boolean
name|reuse
parameter_list|)
throws|throws
name|IOException
block|{
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|limit
argument_list|()
operator|-
name|HFileBlock
operator|.
name|EXTRA_SERIALIZATION_SPACE
argument_list|)
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|ByteBuffer
name|newByteBuffer
decl_stmt|;
if|if
condition|(
name|reuse
condition|)
block|{
name|newByteBuffer
operator|=
name|buf
operator|.
name|slice
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|newByteBuffer
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|buf
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
name|newByteBuffer
operator|.
name|put
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|position
argument_list|(
name|buf
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|limit
argument_list|()
operator|+
name|HFileBlock
operator|.
name|EXTRA_SERIALIZATION_SPACE
argument_list|)
expr_stmt|;
name|boolean
name|usesChecksum
init|=
name|buf
operator|.
name|get
argument_list|()
operator|==
operator|(
name|byte
operator|)
literal|1
decl_stmt|;
name|HFileBlock
name|ourBuffer
init|=
operator|new
name|HFileBlock
argument_list|(
name|newByteBuffer
argument_list|,
name|usesChecksum
argument_list|)
decl_stmt|;
name|ourBuffer
operator|.
name|offset
operator|=
name|buf
operator|.
name|getLong
argument_list|()
expr_stmt|;
name|ourBuffer
operator|.
name|nextBlockOnDiskSizeWithHeader
operator|=
name|buf
operator|.
name|getInt
argument_list|()
expr_stmt|;
return|return
name|ourBuffer
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getDeserialiserIdentifier
parameter_list|()
block|{
return|return
name|deserializerIdentifier
return|;
block|}
annotation|@
name|Override
specifier|public
name|HFileBlock
name|deserialize
parameter_list|(
name|ByteBuffer
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|deserialize
argument_list|(
name|b
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|deserializerIdentifier
decl_stmt|;
static|static
block|{
name|deserializerIdentifier
operator|=
name|CacheableDeserializerIdManager
operator|.
name|registerDeserializer
argument_list|(
name|blockDeserializer
argument_list|)
expr_stmt|;
block|}
specifier|private
name|BlockType
name|blockType
decl_stmt|;
comment|/** Size on disk without the header. It includes checksum data too. */
specifier|private
name|int
name|onDiskSizeWithoutHeader
decl_stmt|;
comment|/** Size of pure data. Does not include header or checksums */
specifier|private
specifier|final
name|int
name|uncompressedSizeWithoutHeader
decl_stmt|;
comment|/** The offset of the previous block on disk */
specifier|private
specifier|final
name|long
name|prevBlockOffset
decl_stmt|;
comment|/** Size on disk of header and data. Does not include checksum data */
specifier|private
specifier|final
name|int
name|onDiskDataSizeWithHeader
decl_stmt|;
comment|/** The in-memory representation of the hfile block */
specifier|private
name|ByteBuffer
name|buf
decl_stmt|;
comment|/** Meta data that holds meta information on the hfileblock**/
specifier|private
name|HFileContext
name|fileContext
decl_stmt|;
comment|/**    * The offset of this block in the file. Populated by the reader for    * convenience of access. This offset is not part of the block header.    */
specifier|private
name|long
name|offset
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * The on-disk size of the next block, including the header, obtained by    * peeking into the first {@link HConstants#HFILEBLOCK_HEADER_SIZE} bytes of the next block's    * header, or -1 if unknown.    */
specifier|private
name|int
name|nextBlockOnDiskSizeWithHeader
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * Creates a new {@link HFile} block from the given fields. This constructor    * is mostly used when the block data has already been read and uncompressed,    * and is sitting in a byte buffer.     *    * @param blockType the type of this block, see {@link BlockType}    * @param onDiskSizeWithoutHeader compressed size of the block if compression    *          is used, otherwise uncompressed size, header size not included    * @param uncompressedSizeWithoutHeader uncompressed size of the block,    *          header size not included. Equals onDiskSizeWithoutHeader if    *          compression is disabled.    * @param prevBlockOffset the offset of the previous block in the    *          {@link HFile}    * @param buf block header ({@link HConstants#HFILEBLOCK_HEADER_SIZE} bytes) followed by    *          uncompressed data. This    * @param fillHeader true to fill in the first {@link HConstants#HFILEBLOCK_HEADER_SIZE} bytes of    *          the buffer based on the header fields provided    * @param offset the file offset the block was read from    * @param bytesPerChecksum the number of bytes per checksum chunk    * @param checksumType the checksum algorithm to use    * @param onDiskDataSizeWithHeader size of header and data on disk not    *        including checksum data    * @param fileContext HFile meta data    */
name|HFileBlock
parameter_list|(
name|BlockType
name|blockType
parameter_list|,
name|int
name|onDiskSizeWithoutHeader
parameter_list|,
name|int
name|uncompressedSizeWithoutHeader
parameter_list|,
name|long
name|prevBlockOffset
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|,
name|boolean
name|fillHeader
parameter_list|,
name|long
name|offset
parameter_list|,
name|int
name|onDiskDataSizeWithHeader
parameter_list|,
name|HFileContext
name|fileContext
parameter_list|)
block|{
name|this
operator|.
name|blockType
operator|=
name|blockType
expr_stmt|;
name|this
operator|.
name|onDiskSizeWithoutHeader
operator|=
name|onDiskSizeWithoutHeader
expr_stmt|;
name|this
operator|.
name|uncompressedSizeWithoutHeader
operator|=
name|uncompressedSizeWithoutHeader
expr_stmt|;
name|this
operator|.
name|prevBlockOffset
operator|=
name|prevBlockOffset
expr_stmt|;
name|this
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|fillHeader
condition|)
name|overwriteHeader
argument_list|()
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|onDiskDataSizeWithHeader
operator|=
name|onDiskDataSizeWithHeader
expr_stmt|;
name|this
operator|.
name|fileContext
operator|=
name|fileContext
expr_stmt|;
block|}
comment|/**    * Creates a block from an existing buffer starting with a header. Rewinds    * and takes ownership of the buffer. By definition of rewind, ignores the    * buffer position, but if you slice the buffer beforehand, it will rewind    * to that point. The reason this has a minorNumber and not a majorNumber is    * because majorNumbers indicate the format of a HFile whereas minorNumbers     * indicate the format inside a HFileBlock.    */
name|HFileBlock
parameter_list|(
name|ByteBuffer
name|b
parameter_list|,
name|boolean
name|usesHBaseChecksum
parameter_list|)
throws|throws
name|IOException
block|{
name|b
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|blockType
operator|=
name|BlockType
operator|.
name|read
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|onDiskSizeWithoutHeader
operator|=
name|b
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|uncompressedSizeWithoutHeader
operator|=
name|b
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|prevBlockOffset
operator|=
name|b
operator|.
name|getLong
argument_list|()
expr_stmt|;
name|HFileContextBuilder
name|contextBuilder
init|=
operator|new
name|HFileContextBuilder
argument_list|()
decl_stmt|;
name|contextBuilder
operator|.
name|withHBaseCheckSum
argument_list|(
name|usesHBaseChecksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|usesHBaseChecksum
condition|)
block|{
name|contextBuilder
operator|.
name|withChecksumType
argument_list|(
name|ChecksumType
operator|.
name|codeToType
argument_list|(
name|b
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|contextBuilder
operator|.
name|withBytesPerCheckSum
argument_list|(
name|b
operator|.
name|getInt
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|onDiskDataSizeWithHeader
operator|=
name|b
operator|.
name|getInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|contextBuilder
operator|.
name|withChecksumType
argument_list|(
name|ChecksumType
operator|.
name|NULL
argument_list|)
expr_stmt|;
name|contextBuilder
operator|.
name|withBytesPerCheckSum
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|onDiskDataSizeWithHeader
operator|=
name|onDiskSizeWithoutHeader
operator|+
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE_NO_CHECKSUM
expr_stmt|;
block|}
name|this
operator|.
name|fileContext
operator|=
name|contextBuilder
operator|.
name|build
argument_list|()
expr_stmt|;
name|buf
operator|=
name|b
expr_stmt|;
name|buf
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
specifier|public
name|BlockType
name|getBlockType
parameter_list|()
block|{
return|return
name|blockType
return|;
block|}
comment|/** @return get data block encoding id that was used to encode this block */
specifier|public
name|short
name|getDataBlockEncodingId
parameter_list|()
block|{
if|if
condition|(
name|blockType
operator|!=
name|BlockType
operator|.
name|ENCODED_DATA
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Querying encoder ID of a block "
operator|+
literal|"of type other than "
operator|+
name|BlockType
operator|.
name|ENCODED_DATA
operator|+
literal|": "
operator|+
name|blockType
argument_list|)
throw|;
block|}
return|return
name|buf
operator|.
name|getShort
argument_list|(
name|headerSize
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return the on-disk size of the block with header size included. This    * includes the header, the data and the checksum data.    */
specifier|public
name|int
name|getOnDiskSizeWithHeader
parameter_list|()
block|{
return|return
name|onDiskSizeWithoutHeader
operator|+
name|headerSize
argument_list|()
return|;
block|}
comment|/**    * Returns the size of the compressed part of the block in case compression    * is used, or the uncompressed size of the data part otherwise. Header size    * and checksum data size is not included.    *    * @return the on-disk size of the data part of the block, header and    *         checksum not included.     */
specifier|public
name|int
name|getOnDiskSizeWithoutHeader
parameter_list|()
block|{
return|return
name|onDiskSizeWithoutHeader
return|;
block|}
comment|/**    * @return the uncompressed size of the data part of the block, header not    *         included    */
specifier|public
name|int
name|getUncompressedSizeWithoutHeader
parameter_list|()
block|{
return|return
name|uncompressedSizeWithoutHeader
return|;
block|}
comment|/**    * @return the offset of the previous block of the same type in the file, or    *         -1 if unknown    */
specifier|public
name|long
name|getPrevBlockOffset
parameter_list|()
block|{
return|return
name|prevBlockOffset
return|;
block|}
comment|/**    * Writes header fields into the first {@link HConstants#HFILEBLOCK_HEADER_SIZE} bytes of the    * buffer. Resets the buffer position to the end of header as side effect.    */
specifier|private
name|void
name|overwriteHeader
parameter_list|()
block|{
name|buf
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|blockType
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|putInt
argument_list|(
name|onDiskSizeWithoutHeader
argument_list|)
expr_stmt|;
name|buf
operator|.
name|putInt
argument_list|(
name|uncompressedSizeWithoutHeader
argument_list|)
expr_stmt|;
name|buf
operator|.
name|putLong
argument_list|(
name|prevBlockOffset
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns a buffer that does not include the header. The array offset points    * to the start of the block data right after the header. The underlying data    * array is not copied. Checksum data is not included in the returned buffer.    *    * @return the buffer with header skipped    */
specifier|public
name|ByteBuffer
name|getBufferWithoutHeader
parameter_list|()
block|{
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|headerSize
argument_list|()
argument_list|,
name|buf
operator|.
name|limit
argument_list|()
operator|-
name|headerSize
argument_list|()
operator|-
name|totalChecksumBytes
argument_list|()
argument_list|)
operator|.
name|slice
argument_list|()
return|;
block|}
comment|/**    * Returns the buffer this block stores internally. The clients must not    * modify the buffer object. This method has to be public because it is    * used in {@link CompoundBloomFilter} to avoid object creation on every    * Bloom filter lookup, but has to be used with caution. Checksum data    * is not included in the returned buffer.    *    * @return the buffer of this block for read-only operations    */
specifier|public
name|ByteBuffer
name|getBufferReadOnly
parameter_list|()
block|{
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|buf
operator|.
name|limit
argument_list|()
operator|-
name|totalChecksumBytes
argument_list|()
argument_list|)
operator|.
name|slice
argument_list|()
return|;
block|}
comment|/**    * Returns the buffer of this block, including header data. The clients must    * not modify the buffer object. This method has to be public because it is    * used in {@link BucketCache} to avoid buffer copy.    *     * @return the byte buffer with header included for read-only operations    */
specifier|public
name|ByteBuffer
name|getBufferReadOnlyWithHeader
parameter_list|()
block|{
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|buf
operator|.
name|limit
argument_list|()
argument_list|)
operator|.
name|slice
argument_list|()
return|;
block|}
comment|/**    * Returns a byte buffer of this block, including header data, positioned at    * the beginning of header. The underlying data array is not copied.    *    * @return the byte buffer with header included    */
name|ByteBuffer
name|getBufferWithHeader
parameter_list|()
block|{
name|ByteBuffer
name|dupBuf
init|=
name|buf
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|dupBuf
operator|.
name|rewind
argument_list|()
expr_stmt|;
return|return
name|dupBuf
return|;
block|}
specifier|private
name|void
name|sanityCheckAssertion
parameter_list|(
name|long
name|valueFromBuf
parameter_list|,
name|long
name|valueFromField
parameter_list|,
name|String
name|fieldName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|valueFromBuf
operator|!=
name|valueFromField
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|fieldName
operator|+
literal|" in the buffer ("
operator|+
name|valueFromBuf
operator|+
literal|") is different from that in the field ("
operator|+
name|valueFromField
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Checks if the block is internally consistent, i.e. the first    * {@link HConstants#HFILEBLOCK_HEADER_SIZE} bytes of the buffer contain a valid header consistent    * with the fields. This function is primary for testing and debugging, and    * is not thread-safe, because it alters the internal buffer pointer.    */
name|void
name|sanityCheck
parameter_list|()
throws|throws
name|IOException
block|{
name|buf
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|{
name|BlockType
name|blockTypeFromBuf
init|=
name|BlockType
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockTypeFromBuf
operator|!=
name|blockType
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block type stored in the buffer: "
operator|+
name|blockTypeFromBuf
operator|+
literal|", block type field: "
operator|+
name|blockType
argument_list|)
throw|;
block|}
block|}
name|sanityCheckAssertion
argument_list|(
name|buf
operator|.
name|getInt
argument_list|()
argument_list|,
name|onDiskSizeWithoutHeader
argument_list|,
literal|"onDiskSizeWithoutHeader"
argument_list|)
expr_stmt|;
name|sanityCheckAssertion
argument_list|(
name|buf
operator|.
name|getInt
argument_list|()
argument_list|,
name|uncompressedSizeWithoutHeader
argument_list|,
literal|"uncompressedSizeWithoutHeader"
argument_list|)
expr_stmt|;
name|sanityCheckAssertion
argument_list|(
name|buf
operator|.
name|getLong
argument_list|()
argument_list|,
name|prevBlockOffset
argument_list|,
literal|"prevBlocKOffset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|fileContext
operator|.
name|shouldUseHBaseChecksum
argument_list|()
condition|)
block|{
name|sanityCheckAssertion
argument_list|(
name|buf
operator|.
name|get
argument_list|()
argument_list|,
name|this
operator|.
name|fileContext
operator|.
name|getChecksumType
argument_list|()
operator|.
name|getCode
argument_list|()
argument_list|,
literal|"checksumType"
argument_list|)
expr_stmt|;
name|sanityCheckAssertion
argument_list|(
name|buf
operator|.
name|getInt
argument_list|()
argument_list|,
name|this
operator|.
name|fileContext
operator|.
name|getBytesPerChecksum
argument_list|()
argument_list|,
literal|"bytesPerChecksum"
argument_list|)
expr_stmt|;
name|sanityCheckAssertion
argument_list|(
name|buf
operator|.
name|getInt
argument_list|()
argument_list|,
name|onDiskDataSizeWithHeader
argument_list|,
literal|"onDiskDataSizeWithHeader"
argument_list|)
expr_stmt|;
block|}
name|int
name|cksumBytes
init|=
name|totalChecksumBytes
argument_list|()
decl_stmt|;
name|int
name|hdrSize
init|=
name|headerSize
argument_list|()
decl_stmt|;
name|int
name|expectedBufLimit
init|=
name|uncompressedSizeWithoutHeader
operator|+
name|headerSize
argument_list|()
operator|+
name|cksumBytes
decl_stmt|;
if|if
condition|(
name|buf
operator|.
name|limit
argument_list|()
operator|!=
name|expectedBufLimit
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Expected buffer limit "
operator|+
name|expectedBufLimit
operator|+
literal|", got "
operator|+
name|buf
operator|.
name|limit
argument_list|()
argument_list|)
throw|;
block|}
comment|// We might optionally allocate HFILEBLOCK_HEADER_SIZE more bytes to read the next
comment|// block's, header, so there are two sensible values for buffer capacity.
name|int
name|size
init|=
name|uncompressedSizeWithoutHeader
operator|+
name|hdrSize
operator|+
name|cksumBytes
decl_stmt|;
if|if
condition|(
name|buf
operator|.
name|capacity
argument_list|()
operator|!=
name|size
operator|&&
name|buf
operator|.
name|capacity
argument_list|()
operator|!=
name|size
operator|+
name|hdrSize
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Invalid buffer capacity: "
operator|+
name|buf
operator|.
name|capacity
argument_list|()
operator|+
literal|", expected "
operator|+
name|size
operator|+
literal|" or "
operator|+
operator|(
name|size
operator|+
name|hdrSize
operator|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"blockType="
operator|+
name|blockType
operator|+
literal|", onDiskSizeWithoutHeader="
operator|+
name|onDiskSizeWithoutHeader
operator|+
literal|", uncompressedSizeWithoutHeader="
operator|+
name|uncompressedSizeWithoutHeader
operator|+
literal|", prevBlockOffset="
operator|+
name|prevBlockOffset
operator|+
literal|", dataBeginsWith="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|headerSize
argument_list|()
argument_list|,
name|Math
operator|.
name|min
argument_list|(
literal|32
argument_list|,
name|buf
operator|.
name|limit
argument_list|()
operator|-
name|buf
operator|.
name|arrayOffset
argument_list|()
operator|-
name|headerSize
argument_list|()
argument_list|)
argument_list|)
operator|+
literal|", fileOffset="
operator|+
name|offset
return|;
block|}
specifier|private
name|void
name|validateOnDiskSizeWithoutHeader
parameter_list|(
name|int
name|expectedOnDiskSizeWithoutHeader
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|onDiskSizeWithoutHeader
operator|!=
name|expectedOnDiskSizeWithoutHeader
condition|)
block|{
name|String
name|blockInfoMsg
init|=
literal|"Block offset: "
operator|+
name|offset
operator|+
literal|", data starts with: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|Math
operator|.
name|min
argument_list|(
literal|32
argument_list|,
name|buf
operator|.
name|limit
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"On-disk size without header provided is "
operator|+
name|expectedOnDiskSizeWithoutHeader
operator|+
literal|", but block "
operator|+
literal|"header contains "
operator|+
name|onDiskSizeWithoutHeader
operator|+
literal|". "
operator|+
name|blockInfoMsg
argument_list|)
throw|;
block|}
block|}
comment|/**    * Always allocates a new buffer of the correct size. Copies header bytes    * from the existing buffer. Does not change header fields.     * Reserve room to keep checksum bytes too.    *    * @param extraBytes whether to reserve room in the buffer to read the next    *          block's header    */
specifier|private
name|void
name|allocateBuffer
parameter_list|(
name|boolean
name|extraBytes
parameter_list|)
block|{
name|int
name|cksumBytes
init|=
name|totalChecksumBytes
argument_list|()
decl_stmt|;
name|int
name|capacityNeeded
init|=
name|headerSize
argument_list|()
operator|+
name|uncompressedSizeWithoutHeader
operator|+
name|cksumBytes
operator|+
operator|(
name|extraBytes
condition|?
name|headerSize
argument_list|()
else|:
literal|0
operator|)
decl_stmt|;
name|ByteBuffer
name|newBuf
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|capacityNeeded
argument_list|)
decl_stmt|;
comment|// Copy header bytes.
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|newBuf
operator|.
name|array
argument_list|()
argument_list|,
name|newBuf
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|headerSize
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|=
name|newBuf
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|headerSize
argument_list|()
operator|+
name|uncompressedSizeWithoutHeader
operator|+
name|cksumBytes
argument_list|)
expr_stmt|;
block|}
comment|/** An additional sanity-check in case no compression is being used. */
specifier|public
name|void
name|assumeUncompressed
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|onDiskSizeWithoutHeader
operator|!=
name|uncompressedSizeWithoutHeader
operator|+
name|totalChecksumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Using no compression but "
operator|+
literal|"onDiskSizeWithoutHeader="
operator|+
name|onDiskSizeWithoutHeader
operator|+
literal|", "
operator|+
literal|"uncompressedSizeWithoutHeader="
operator|+
name|uncompressedSizeWithoutHeader
operator|+
literal|", numChecksumbytes="
operator|+
name|totalChecksumBytes
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * @param expectedType the expected type of this block    * @throws IOException if this block's type is different than expected    */
specifier|public
name|void
name|expectType
parameter_list|(
name|BlockType
name|expectedType
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blockType
operator|!=
name|expectedType
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid block type: expected="
operator|+
name|expectedType
operator|+
literal|", actual="
operator|+
name|blockType
argument_list|)
throw|;
block|}
block|}
comment|/** @return the offset of this block in the file it was read from */
specifier|public
name|long
name|getOffset
parameter_list|()
block|{
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"HFile block offset not initialized properly"
argument_list|)
throw|;
block|}
return|return
name|offset
return|;
block|}
comment|/**    * @return a byte stream reading the data section of this block    */
specifier|public
name|DataInputStream
name|getByteStream
parameter_list|()
block|{
return|return
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|headerSize
argument_list|()
argument_list|,
name|buf
operator|.
name|limit
argument_list|()
operator|-
name|headerSize
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
name|long
name|size
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|OBJECT
operator|+
comment|// Block type, byte buffer and meta references
literal|3
operator|*
name|ClassSize
operator|.
name|REFERENCE
operator|+
comment|// On-disk size, uncompressed size, and next block's on-disk size
comment|// bytePerChecksum and onDiskDataSize
literal|4
operator|*
name|Bytes
operator|.
name|SIZEOF_INT
operator|+
comment|// This and previous block offset
literal|2
operator|*
name|Bytes
operator|.
name|SIZEOF_LONG
operator|+
comment|// Heap size of the meta object. meta will be always not null.
name|fileContext
operator|.
name|heapSize
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|!=
literal|null
condition|)
block|{
comment|// Deep overhead of the byte buffer. Needs to be aligned separately.
name|size
operator|+=
name|ClassSize
operator|.
name|align
argument_list|(
name|buf
operator|.
name|capacity
argument_list|()
operator|+
name|BYTE_BUFFER_HEAP_SIZE
argument_list|)
expr_stmt|;
block|}
return|return
name|ClassSize
operator|.
name|align
argument_list|(
name|size
argument_list|)
return|;
block|}
comment|/**    * Read from an input stream. Analogous to    * {@link IOUtils#readFully(InputStream, byte[], int, int)}, but specifies a    * number of "extra" bytes that would be desirable but not absolutely    * necessary to read.    *    * @param in the input stream to read from    * @param buf the buffer to read into    * @param bufOffset the destination offset in the buffer    * @param necessaryLen the number of bytes that are absolutely necessary to    *          read    * @param extraLen the number of extra bytes that would be nice to read    * @return true if succeeded reading the extra bytes    * @throws IOException if failed to read the necessary bytes    */
specifier|public
specifier|static
name|boolean
name|readWithExtra
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|byte
name|buf
index|[]
parameter_list|,
name|int
name|bufOffset
parameter_list|,
name|int
name|necessaryLen
parameter_list|,
name|int
name|extraLen
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|bytesRemaining
init|=
name|necessaryLen
operator|+
name|extraLen
decl_stmt|;
while|while
condition|(
name|bytesRemaining
operator|>
literal|0
condition|)
block|{
name|int
name|ret
init|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|bufOffset
argument_list|,
name|bytesRemaining
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|bytesRemaining
operator|<=
name|extraLen
condition|)
block|{
comment|// We could not read the "extra data", but that is OK.
break|break;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Premature EOF from inputStream (read "
operator|+
literal|"returned "
operator|+
name|ret
operator|+
literal|", was trying to read "
operator|+
name|necessaryLen
operator|+
literal|" necessary bytes and "
operator|+
name|extraLen
operator|+
literal|" extra bytes, "
operator|+
literal|"successfully read "
operator|+
operator|(
name|necessaryLen
operator|+
name|extraLen
operator|-
name|bytesRemaining
operator|)
argument_list|)
throw|;
block|}
name|bufOffset
operator|+=
name|ret
expr_stmt|;
name|bytesRemaining
operator|-=
name|ret
expr_stmt|;
block|}
return|return
name|bytesRemaining
operator|<=
literal|0
return|;
block|}
comment|/**    * @return the on-disk size of the next block (including the header size)    *         that was read by peeking into the next block's header    */
specifier|public
name|int
name|getNextBlockOnDiskSizeWithHeader
parameter_list|()
block|{
return|return
name|nextBlockOnDiskSizeWithHeader
return|;
block|}
comment|/**    * Unified version 2 {@link HFile} block writer. The intended usage pattern    * is as follows:    *<ol>    *<li>Construct an {@link HFileBlock.Writer}, providing a compression algorithm.    *<li>Call {@link Writer#startWriting} and get a data stream to write to.    *<li>Write your data into the stream.    *<li>Call {@link Writer#writeHeaderAndData(FSDataOutputStream)} as many times as you need to.    * store the serialized block into an external stream.    *<li>Repeat to write more blocks.    *</ol>    *<p>    */
specifier|public
specifier|static
class|class
name|Writer
block|{
specifier|private
enum|enum
name|State
block|{
name|INIT
block|,
name|WRITING
block|,
name|BLOCK_READY
block|}
empty_stmt|;
comment|/** Writer state. Used to ensure the correct usage protocol. */
specifier|private
name|State
name|state
init|=
name|State
operator|.
name|INIT
decl_stmt|;
comment|/** Data block encoder used for data blocks */
specifier|private
specifier|final
name|HFileDataBlockEncoder
name|dataBlockEncoder
decl_stmt|;
specifier|private
name|HFileBlockEncodingContext
name|dataBlockEncodingCtx
decl_stmt|;
comment|/** block encoding context for non-data blocks */
specifier|private
name|HFileBlockDefaultEncodingContext
name|defaultBlockEncodingCtx
decl_stmt|;
comment|/**      * The stream we use to accumulate data in uncompressed format for each      * block. We reset this stream at the end of each block and reuse it. The      * header is written as the first {@link HConstants#HFILEBLOCK_HEADER_SIZE} bytes into this      * stream.      */
specifier|private
name|ByteArrayOutputStream
name|baosInMemory
decl_stmt|;
comment|/**      * Current block type. Set in {@link #startWriting(BlockType)}. Could be      * changed in {@link #encodeDataBlockForDisk()} from {@link BlockType#DATA}      * to {@link BlockType#ENCODED_DATA}.      */
specifier|private
name|BlockType
name|blockType
decl_stmt|;
comment|/**      * A stream that we write uncompressed bytes to, which compresses them and      * writes them to {@link #baosInMemory}.      */
specifier|private
name|DataOutputStream
name|userDataStream
decl_stmt|;
comment|/**      * Bytes to be written to the file system, including the header. Compressed      * if compression is turned on. It also includes the checksum data that       * immediately follows the block data. (header + data + checksums)      */
specifier|private
name|byte
index|[]
name|onDiskBytesWithHeader
decl_stmt|;
comment|/**      * The size of the checksum data on disk. It is used only if data is      * not compressed. If data is compressed, then the checksums are already      * part of onDiskBytesWithHeader. If data is uncompressed, then this      * variable stores the checksum data for this block.      */
specifier|private
name|byte
index|[]
name|onDiskChecksum
decl_stmt|;
comment|/**      * Valid in the READY state. Contains the header and the uncompressed (but      * potentially encoded, if this is a data block) bytes, so the length is      * {@link #uncompressedSizeWithoutHeader} + {@link org.apache.hadoop.hbase.HConstants#HFILEBLOCK_HEADER_SIZE}.      * Does not store checksums.      */
specifier|private
name|byte
index|[]
name|uncompressedBytesWithHeader
decl_stmt|;
comment|/**      * Current block's start offset in the {@link HFile}. Set in      * {@link #writeHeaderAndData(FSDataOutputStream)}.      */
specifier|private
name|long
name|startOffset
decl_stmt|;
comment|/**      * Offset of previous block by block type. Updated when the next block is      * started.      */
specifier|private
name|long
index|[]
name|prevOffsetByType
decl_stmt|;
comment|/** The offset of the previous block of the same type */
specifier|private
name|long
name|prevOffset
decl_stmt|;
comment|/** Meta data that holds information about the hfileblock**/
specifier|private
name|HFileContext
name|fileContext
decl_stmt|;
comment|/**      * @param dataBlockEncoder data block encoding algorithm to use      */
specifier|public
name|Writer
parameter_list|(
name|HFileDataBlockEncoder
name|dataBlockEncoder
parameter_list|,
name|HFileContext
name|fileContext
parameter_list|)
block|{
name|this
operator|.
name|dataBlockEncoder
operator|=
name|dataBlockEncoder
operator|!=
literal|null
condition|?
name|dataBlockEncoder
else|:
name|NoOpDataBlockEncoder
operator|.
name|INSTANCE
expr_stmt|;
name|defaultBlockEncodingCtx
operator|=
operator|new
name|HFileBlockDefaultEncodingContext
argument_list|(
literal|null
argument_list|,
name|HConstants
operator|.
name|HFILEBLOCK_DUMMY_HEADER
argument_list|,
name|fileContext
argument_list|)
expr_stmt|;
name|dataBlockEncodingCtx
operator|=
name|this
operator|.
name|dataBlockEncoder
operator|.
name|newOnDiskDataBlockEncodingContext
argument_list|(
name|HConstants
operator|.
name|HFILEBLOCK_DUMMY_HEADER
argument_list|,
name|fileContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileContext
operator|.
name|getBytesPerChecksum
argument_list|()
operator|<
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported value of bytesPerChecksum. "
operator|+
literal|" Minimum is "
operator|+
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE
operator|+
literal|" but the configured value is "
operator|+
name|fileContext
operator|.
name|getBytesPerChecksum
argument_list|()
argument_list|)
throw|;
block|}
name|baosInMemory
operator|=
operator|new
name|ByteArrayOutputStream
argument_list|()
expr_stmt|;
name|prevOffsetByType
operator|=
operator|new
name|long
index|[
name|BlockType
operator|.
name|values
argument_list|()
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|prevOffsetByType
operator|.
name|length
condition|;
operator|++
name|i
control|)
name|prevOffsetByType
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|fileContext
operator|=
name|fileContext
expr_stmt|;
block|}
comment|/**      * Starts writing into the block. The previous block's data is discarded.      *      * @return the stream the user can write their data into      * @throws IOException      */
specifier|public
name|DataOutputStream
name|startWriting
parameter_list|(
name|BlockType
name|newBlockType
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|BLOCK_READY
operator|&&
name|startOffset
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// We had a previous block that was written to a stream at a specific
comment|// offset. Save that offset as the last offset of a block of that type.
name|prevOffsetByType
index|[
name|blockType
operator|.
name|getId
argument_list|()
index|]
operator|=
name|startOffset
expr_stmt|;
block|}
name|startOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|blockType
operator|=
name|newBlockType
expr_stmt|;
name|baosInMemory
operator|.
name|reset
argument_list|()
expr_stmt|;
name|baosInMemory
operator|.
name|write
argument_list|(
name|HConstants
operator|.
name|HFILEBLOCK_DUMMY_HEADER
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|WRITING
expr_stmt|;
comment|// We will compress it later in finishBlock()
name|userDataStream
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|baosInMemory
argument_list|)
expr_stmt|;
return|return
name|userDataStream
return|;
block|}
comment|/**      * Returns the stream for the user to write to. The block writer takes care      * of handling compression and buffering for caching on write. Can only be      * called in the "writing" state.      *      * @return the data output stream for the user to write to      */
name|DataOutputStream
name|getUserDataStream
parameter_list|()
block|{
name|expectState
argument_list|(
name|State
operator|.
name|WRITING
argument_list|)
expr_stmt|;
return|return
name|userDataStream
return|;
block|}
comment|/**      * Transitions the block writer from the "writing" state to the "block      * ready" state.  Does nothing if a block is already finished.      */
specifier|private
name|void
name|ensureBlockReady
parameter_list|()
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|!=
name|State
operator|.
name|INIT
argument_list|,
literal|"Unexpected state: "
operator|+
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|BLOCK_READY
condition|)
return|return;
comment|// This will set state to BLOCK_READY.
name|finishBlock
argument_list|()
expr_stmt|;
block|}
comment|/**      * An internal method that flushes the compressing stream (if using      * compression), serializes the header, and takes care of the separate      * uncompressed stream for caching on write, if applicable. Sets block      * write state to "block ready".      */
specifier|private
name|void
name|finishBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|userDataStream
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// This does an array copy, so it is safe to cache this byte array.
name|uncompressedBytesWithHeader
operator|=
name|baosInMemory
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
name|prevOffset
operator|=
name|prevOffsetByType
index|[
name|blockType
operator|.
name|getId
argument_list|()
index|]
expr_stmt|;
comment|// We need to set state before we can package the block up for
comment|// cache-on-write. In a way, the block is ready, but not yet encoded or
comment|// compressed.
name|state
operator|=
name|State
operator|.
name|BLOCK_READY
expr_stmt|;
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|DATA
condition|)
block|{
name|encodeDataBlockForDisk
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|defaultBlockEncodingCtx
operator|.
name|compressAfterEncodingWithBlockType
argument_list|(
name|uncompressedBytesWithHeader
argument_list|,
name|blockType
argument_list|)
expr_stmt|;
name|onDiskBytesWithHeader
operator|=
name|defaultBlockEncodingCtx
operator|.
name|getOnDiskBytesWithHeader
argument_list|()
expr_stmt|;
block|}
name|int
name|numBytes
init|=
operator|(
name|int
operator|)
name|ChecksumUtil
operator|.
name|numBytes
argument_list|(
name|onDiskBytesWithHeader
operator|.
name|length
argument_list|,
name|fileContext
operator|.
name|getBytesPerChecksum
argument_list|()
argument_list|)
decl_stmt|;
comment|// put the header for on disk bytes
name|putHeader
argument_list|(
name|onDiskBytesWithHeader
argument_list|,
literal|0
argument_list|,
name|onDiskBytesWithHeader
operator|.
name|length
operator|+
name|numBytes
argument_list|,
name|uncompressedBytesWithHeader
operator|.
name|length
argument_list|,
name|onDiskBytesWithHeader
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// set the header for the uncompressed bytes (for cache-on-write)
name|putHeader
argument_list|(
name|uncompressedBytesWithHeader
argument_list|,
literal|0
argument_list|,
name|onDiskBytesWithHeader
operator|.
name|length
operator|+
name|numBytes
argument_list|,
name|uncompressedBytesWithHeader
operator|.
name|length
argument_list|,
name|onDiskBytesWithHeader
operator|.
name|length
argument_list|)
expr_stmt|;
name|onDiskChecksum
operator|=
operator|new
name|byte
index|[
name|numBytes
index|]
expr_stmt|;
name|ChecksumUtil
operator|.
name|generateChecksums
argument_list|(
name|onDiskBytesWithHeader
argument_list|,
literal|0
argument_list|,
name|onDiskBytesWithHeader
operator|.
name|length
argument_list|,
name|onDiskChecksum
argument_list|,
literal|0
argument_list|,
name|fileContext
operator|.
name|getChecksumType
argument_list|()
argument_list|,
name|fileContext
operator|.
name|getBytesPerChecksum
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Encodes this block if it is a data block and encoding is turned on in      * {@link #dataBlockEncoder}.      */
specifier|private
name|void
name|encodeDataBlockForDisk
parameter_list|()
throws|throws
name|IOException
block|{
comment|// do data block encoding, if data block encoder is set
name|ByteBuffer
name|rawKeyValues
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|uncompressedBytesWithHeader
argument_list|,
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE
argument_list|,
name|uncompressedBytesWithHeader
operator|.
name|length
operator|-
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE
argument_list|)
operator|.
name|slice
argument_list|()
decl_stmt|;
comment|// do the encoding
name|dataBlockEncoder
operator|.
name|beforeWriteToDisk
argument_list|(
name|rawKeyValues
argument_list|,
name|dataBlockEncodingCtx
argument_list|,
name|blockType
argument_list|)
expr_stmt|;
name|uncompressedBytesWithHeader
operator|=
name|dataBlockEncodingCtx
operator|.
name|getUncompressedBytesWithHeader
argument_list|()
expr_stmt|;
name|onDiskBytesWithHeader
operator|=
name|dataBlockEncodingCtx
operator|.
name|getOnDiskBytesWithHeader
argument_list|()
expr_stmt|;
name|blockType
operator|=
name|dataBlockEncodingCtx
operator|.
name|getBlockType
argument_list|()
expr_stmt|;
block|}
comment|/**      * Put the header into the given byte array at the given offset.      * @param onDiskSize size of the block on disk header + data + checksum      * @param uncompressedSize size of the block after decompression (but      *          before optional data block decoding) including header      * @param onDiskDataSize size of the block on disk with header      *        and data but not including the checksums      */
specifier|private
name|void
name|putHeader
parameter_list|(
name|byte
index|[]
name|dest
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|onDiskSize
parameter_list|,
name|int
name|uncompressedSize
parameter_list|,
name|int
name|onDiskDataSize
parameter_list|)
block|{
name|offset
operator|=
name|blockType
operator|.
name|put
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|,
name|onDiskSize
operator|-
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|,
name|uncompressedSize
operator|-
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|Bytes
operator|.
name|putLong
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|,
name|prevOffset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|,
name|fileContext
operator|.
name|getChecksumType
argument_list|()
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
name|offset
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|,
name|fileContext
operator|.
name|getBytesPerChecksum
argument_list|()
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|putInt
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|,
name|onDiskDataSize
argument_list|)
expr_stmt|;
block|}
comment|/**      * Similar to {@link #writeHeaderAndData(FSDataOutputStream)}, but records      * the offset of this block so that it can be referenced in the next block      * of the same type.      *      * @param out      * @throws IOException      */
specifier|public
name|void
name|writeHeaderAndData
parameter_list|(
name|FSDataOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|offset
init|=
name|out
operator|.
name|getPos
argument_list|()
decl_stmt|;
if|if
condition|(
name|startOffset
operator|!=
operator|-
literal|1
operator|&&
name|offset
operator|!=
name|startOffset
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"A "
operator|+
name|blockType
operator|+
literal|" block written to a "
operator|+
literal|"stream twice, first at offset "
operator|+
name|startOffset
operator|+
literal|", then at "
operator|+
name|offset
argument_list|)
throw|;
block|}
name|startOffset
operator|=
name|offset
expr_stmt|;
name|finishBlockAndWriteHeaderAndData
argument_list|(
operator|(
name|DataOutputStream
operator|)
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes the header and the compressed data of this block (or uncompressed      * data when not using compression) into the given stream. Can be called in      * the "writing" state or in the "block ready" state. If called in the      * "writing" state, transitions the writer to the "block ready" state.      *      * @param out the output stream to write the      * @throws IOException      */
specifier|private
name|void
name|finishBlockAndWriteHeaderAndData
parameter_list|(
name|DataOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureBlockReady
argument_list|()
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|onDiskBytesWithHeader
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|onDiskChecksum
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the header or the compressed data (or uncompressed data when not      * using compression) as a byte array. Can be called in the "writing" state      * or in the "block ready" state. If called in the "writing" state,      * transitions the writer to the "block ready" state. This returns      * the header + data + checksums stored on disk.      *      * @return header and data as they would be stored on disk in a byte array      * @throws IOException      */
name|byte
index|[]
name|getHeaderAndDataForTest
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureBlockReady
argument_list|()
expr_stmt|;
comment|// This is not very optimal, because we are doing an extra copy.
comment|// But this method is used only by unit tests.
name|byte
index|[]
name|output
init|=
operator|new
name|byte
index|[
name|onDiskBytesWithHeader
operator|.
name|length
operator|+
name|onDiskChecksum
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|onDiskBytesWithHeader
argument_list|,
literal|0
argument_list|,
name|output
argument_list|,
literal|0
argument_list|,
name|onDiskBytesWithHeader
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|onDiskChecksum
argument_list|,
literal|0
argument_list|,
name|output
argument_list|,
name|onDiskBytesWithHeader
operator|.
name|length
argument_list|,
name|onDiskChecksum
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**      * Releases resources used by this writer.      */
specifier|public
name|void
name|release
parameter_list|()
block|{
if|if
condition|(
name|dataBlockEncodingCtx
operator|!=
literal|null
condition|)
block|{
name|dataBlockEncodingCtx
operator|.
name|close
argument_list|()
expr_stmt|;
name|dataBlockEncodingCtx
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|defaultBlockEncodingCtx
operator|!=
literal|null
condition|)
block|{
name|defaultBlockEncodingCtx
operator|.
name|close
argument_list|()
expr_stmt|;
name|defaultBlockEncodingCtx
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**      * Returns the on-disk size of the data portion of the block. This is the      * compressed size if compression is enabled. Can only be called in the      * "block ready" state. Header is not compressed, and its size is not      * included in the return value.      *      * @return the on-disk size of the block, not including the header.      */
name|int
name|getOnDiskSizeWithoutHeader
parameter_list|()
block|{
name|expectState
argument_list|(
name|State
operator|.
name|BLOCK_READY
argument_list|)
expr_stmt|;
return|return
name|onDiskBytesWithHeader
operator|.
name|length
operator|+
name|onDiskChecksum
operator|.
name|length
operator|-
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE
return|;
block|}
comment|/**      * Returns the on-disk size of the block. Can only be called in the      * "block ready" state.      *      * @return the on-disk size of the block ready to be written, including the      *         header size, the data and the checksum data.      */
name|int
name|getOnDiskSizeWithHeader
parameter_list|()
block|{
name|expectState
argument_list|(
name|State
operator|.
name|BLOCK_READY
argument_list|)
expr_stmt|;
return|return
name|onDiskBytesWithHeader
operator|.
name|length
operator|+
name|onDiskChecksum
operator|.
name|length
return|;
block|}
comment|/**      * The uncompressed size of the block data. Does not include header size.      */
name|int
name|getUncompressedSizeWithoutHeader
parameter_list|()
block|{
name|expectState
argument_list|(
name|State
operator|.
name|BLOCK_READY
argument_list|)
expr_stmt|;
return|return
name|uncompressedBytesWithHeader
operator|.
name|length
operator|-
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE
return|;
block|}
comment|/**      * The uncompressed size of the block data, including header size.      */
name|int
name|getUncompressedSizeWithHeader
parameter_list|()
block|{
name|expectState
argument_list|(
name|State
operator|.
name|BLOCK_READY
argument_list|)
expr_stmt|;
return|return
name|uncompressedBytesWithHeader
operator|.
name|length
return|;
block|}
comment|/** @return true if a block is being written  */
specifier|public
name|boolean
name|isWriting
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|WRITING
return|;
block|}
comment|/**      * Returns the number of bytes written into the current block so far, or      * zero if not writing the block at the moment. Note that this will return      * zero in the "block ready" state as well.      *      * @return the number of bytes written      */
specifier|public
name|int
name|blockSizeWritten
parameter_list|()
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|WRITING
condition|)
return|return
literal|0
return|;
return|return
name|userDataStream
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns the header followed by the uncompressed data, even if using      * compression. This is needed for storing uncompressed blocks in the block      * cache. Can be called in the "writing" state or the "block ready" state.      * Returns only the header and data, does not include checksum data.      *      * @return uncompressed block bytes for caching on write      */
name|ByteBuffer
name|getUncompressedBufferWithHeader
parameter_list|()
block|{
name|expectState
argument_list|(
name|State
operator|.
name|BLOCK_READY
argument_list|)
expr_stmt|;
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|uncompressedBytesWithHeader
argument_list|)
return|;
block|}
specifier|private
name|void
name|expectState
parameter_list|(
name|State
name|expectedState
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|expectedState
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Expected state: "
operator|+
name|expectedState
operator|+
literal|", actual state: "
operator|+
name|state
argument_list|)
throw|;
block|}
block|}
comment|/**      * Takes the given {@link BlockWritable} instance, creates a new block of      * its appropriate type, writes the writable into this block, and flushes      * the block into the output stream. The writer is instructed not to buffer      * uncompressed bytes for cache-on-write.      *      * @param bw the block-writable object to write as a block      * @param out the file system output stream      * @throws IOException      */
specifier|public
name|void
name|writeBlock
parameter_list|(
name|BlockWritable
name|bw
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|bw
operator|.
name|writeToBlock
argument_list|(
name|startWriting
argument_list|(
name|bw
operator|.
name|getBlockType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeHeaderAndData
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new HFileBlock. Checksums have already been validated, so      * the byte buffer passed into the constructor of this newly created      * block does not have checksum data even though the header minor       * version is MINOR_VERSION_WITH_CHECKSUM. This is indicated by setting a      * 0 value in bytesPerChecksum.      */
specifier|public
name|HFileBlock
name|getBlockForCaching
parameter_list|()
block|{
name|HFileContext
name|newContext
init|=
operator|new
name|HFileContextBuilder
argument_list|()
operator|.
name|withBlockSize
argument_list|(
name|fileContext
operator|.
name|getBlocksize
argument_list|()
argument_list|)
operator|.
name|withBytesPerCheckSum
argument_list|(
literal|0
argument_list|)
operator|.
name|withChecksumType
argument_list|(
name|ChecksumType
operator|.
name|NULL
argument_list|)
comment|// no checksums in cached data
operator|.
name|withCompressionAlgo
argument_list|(
name|fileContext
operator|.
name|getCompression
argument_list|()
argument_list|)
operator|.
name|withDataBlockEncodingInCache
argument_list|(
name|fileContext
operator|.
name|getEncodingInCache
argument_list|()
argument_list|)
operator|.
name|withDataBlockEncodingOnDisk
argument_list|(
name|fileContext
operator|.
name|getEncodingOnDisk
argument_list|()
argument_list|)
operator|.
name|withHBaseCheckSum
argument_list|(
name|fileContext
operator|.
name|shouldUseHBaseChecksum
argument_list|()
argument_list|)
operator|.
name|withCompressTags
argument_list|(
name|fileContext
operator|.
name|shouldCompressTags
argument_list|()
argument_list|)
operator|.
name|withIncludesMvcc
argument_list|(
name|fileContext
operator|.
name|shouldIncludeMvcc
argument_list|()
argument_list|)
operator|.
name|withIncludesTags
argument_list|(
name|fileContext
operator|.
name|shouldIncludeTags
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
operator|new
name|HFileBlock
argument_list|(
name|blockType
argument_list|,
name|getOnDiskSizeWithoutHeader
argument_list|()
argument_list|,
name|getUncompressedSizeWithoutHeader
argument_list|()
argument_list|,
name|prevOffset
argument_list|,
name|getUncompressedBufferWithHeader
argument_list|()
argument_list|,
name|DONT_FILL_HEADER
argument_list|,
name|startOffset
argument_list|,
name|onDiskBytesWithHeader
operator|.
name|length
operator|+
name|onDiskChecksum
operator|.
name|length
argument_list|,
name|newContext
argument_list|)
return|;
block|}
block|}
comment|/** Something that can be written into a block. */
specifier|public
interface|interface
name|BlockWritable
block|{
comment|/** The type of block this data should use. */
name|BlockType
name|getBlockType
parameter_list|()
function_decl|;
comment|/**      * Writes the block to the provided stream. Must not write any magic      * records.      *      * @param out a stream to write uncompressed data into      */
name|void
name|writeToBlock
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|// Block readers and writers
comment|/** An interface allowing to iterate {@link HFileBlock}s. */
specifier|public
interface|interface
name|BlockIterator
block|{
comment|/**      * Get the next block, or null if there are no more blocks to iterate.      */
name|HFileBlock
name|nextBlock
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**      * Similar to {@link #nextBlock()} but checks block type, throws an      * exception if incorrect, and returns the HFile block      */
name|HFileBlock
name|nextBlockWithBlockType
parameter_list|(
name|BlockType
name|blockType
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|/** A full-fledged reader with iteration ability. */
specifier|public
interface|interface
name|FSReader
block|{
comment|/**      * Reads the block at the given offset in the file with the given on-disk      * size and uncompressed size.      *      * @param offset      * @param onDiskSize the on-disk size of the entire block, including all      *          applicable headers, or -1 if unknown      * @param uncompressedSize the uncompressed size of the compressed part of      *          the block, or -1 if unknown      * @return the newly read block      */
name|HFileBlock
name|readBlockData
parameter_list|(
name|long
name|offset
parameter_list|,
name|long
name|onDiskSize
parameter_list|,
name|int
name|uncompressedSize
parameter_list|,
name|boolean
name|pread
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Creates a block iterator over the given portion of the {@link HFile}.      * The iterator returns blocks starting with offset such that offset<=      * startOffset< endOffset.      *      * @param startOffset the offset of the block to start iteration with      * @param endOffset the offset to end iteration at (exclusive)      * @return an iterator of blocks between the two given offsets      */
name|BlockIterator
name|blockRange
parameter_list|(
name|long
name|startOffset
parameter_list|,
name|long
name|endOffset
parameter_list|)
function_decl|;
comment|/** Closes the backing streams */
name|void
name|closeStreams
parameter_list|()
throws|throws
name|IOException
function_decl|;
block|}
comment|/**    * A common implementation of some methods of {@link FSReader} and some    * tools for implementing HFile format version-specific block readers.    */
specifier|private
specifier|abstract
specifier|static
class|class
name|AbstractFSReader
implements|implements
name|FSReader
block|{
comment|/** Compression algorithm used by the {@link HFile} */
comment|/** The size of the file we are reading from, or -1 if unknown. */
specifier|protected
name|long
name|fileSize
decl_stmt|;
comment|/** The size of the header */
specifier|protected
specifier|final
name|int
name|hdrSize
decl_stmt|;
comment|/** The filesystem used to access data */
specifier|protected
name|HFileSystem
name|hfs
decl_stmt|;
comment|/** The path (if any) where this data is coming from */
specifier|protected
name|Path
name|path
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|streamLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
comment|/** The default buffer size for our buffered streams */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_BUFFER_SIZE
init|=
literal|1
operator|<<
literal|20
decl_stmt|;
specifier|protected
name|HFileContext
name|fileContext
decl_stmt|;
specifier|public
name|AbstractFSReader
parameter_list|(
name|long
name|fileSize
parameter_list|,
name|HFileSystem
name|hfs
parameter_list|,
name|Path
name|path
parameter_list|,
name|HFileContext
name|fileContext
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|fileSize
operator|=
name|fileSize
expr_stmt|;
name|this
operator|.
name|hfs
operator|=
name|hfs
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|fileContext
operator|=
name|fileContext
expr_stmt|;
name|this
operator|.
name|hdrSize
operator|=
name|headerSize
argument_list|(
name|fileContext
operator|.
name|shouldUseHBaseChecksum
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|BlockIterator
name|blockRange
parameter_list|(
specifier|final
name|long
name|startOffset
parameter_list|,
specifier|final
name|long
name|endOffset
parameter_list|)
block|{
return|return
operator|new
name|BlockIterator
argument_list|()
block|{
specifier|private
name|long
name|offset
init|=
name|startOffset
decl_stmt|;
annotation|@
name|Override
specifier|public
name|HFileBlock
name|nextBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|>=
name|endOffset
condition|)
return|return
literal|null
return|;
name|HFileBlock
name|b
init|=
name|readBlockData
argument_list|(
name|offset
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|b
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
annotation|@
name|Override
specifier|public
name|HFileBlock
name|nextBlockWithBlockType
parameter_list|(
name|BlockType
name|blockType
parameter_list|)
throws|throws
name|IOException
block|{
name|HFileBlock
name|blk
init|=
name|nextBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|blk
operator|.
name|getBlockType
argument_list|()
operator|!=
name|blockType
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected block of type "
operator|+
name|blockType
operator|+
literal|" but found "
operator|+
name|blk
operator|.
name|getBlockType
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|blk
return|;
block|}
block|}
return|;
block|}
comment|/**      * Does a positional read or a seek and read into the given buffer. Returns      * the on-disk size of the next block, or -1 if it could not be determined.      *      * @param dest destination buffer      * @param destOffset offset in the destination buffer      * @param size size of the block to be read      * @param peekIntoNextBlock whether to read the next block's on-disk size      * @param fileOffset position in the stream to read at      * @param pread whether we should do a positional read      * @param istream The input source of data      * @return the on-disk size of the next block with header size included, or      *         -1 if it could not be determined      * @throws IOException      */
specifier|protected
name|int
name|readAtOffset
parameter_list|(
name|FSDataInputStream
name|istream
parameter_list|,
name|byte
index|[]
name|dest
parameter_list|,
name|int
name|destOffset
parameter_list|,
name|int
name|size
parameter_list|,
name|boolean
name|peekIntoNextBlock
parameter_list|,
name|long
name|fileOffset
parameter_list|,
name|boolean
name|pread
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|peekIntoNextBlock
operator|&&
name|destOffset
operator|+
name|size
operator|+
name|hdrSize
operator|>
name|dest
operator|.
name|length
condition|)
block|{
comment|// We are asked to read the next block's header as well, but there is
comment|// not enough room in the array.
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Attempted to read "
operator|+
name|size
operator|+
literal|" bytes and "
operator|+
name|hdrSize
operator|+
literal|" bytes of next header into a "
operator|+
name|dest
operator|.
name|length
operator|+
literal|"-byte array at offset "
operator|+
name|destOffset
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|pread
operator|&&
name|streamLock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
comment|// Seek + read. Better for scanning.
try|try
block|{
name|istream
operator|.
name|seek
argument_list|(
name|fileOffset
argument_list|)
expr_stmt|;
name|long
name|realOffset
init|=
name|istream
operator|.
name|getPos
argument_list|()
decl_stmt|;
if|if
condition|(
name|realOffset
operator|!=
name|fileOffset
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Tried to seek to "
operator|+
name|fileOffset
operator|+
literal|" to "
operator|+
literal|"read "
operator|+
name|size
operator|+
literal|" bytes, but pos="
operator|+
name|realOffset
operator|+
literal|" after seek"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|peekIntoNextBlock
condition|)
block|{
name|IOUtils
operator|.
name|readFully
argument_list|(
name|istream
argument_list|,
name|dest
argument_list|,
name|destOffset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|// Try to read the next block header.
if|if
condition|(
operator|!
name|readWithExtra
argument_list|(
name|istream
argument_list|,
name|dest
argument_list|,
name|destOffset
argument_list|,
name|size
argument_list|,
name|hdrSize
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
finally|finally
block|{
name|streamLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Positional read. Better for random reads; or when the streamLock is already locked.
name|int
name|extraSize
init|=
name|peekIntoNextBlock
condition|?
name|hdrSize
else|:
literal|0
decl_stmt|;
name|int
name|ret
init|=
name|istream
operator|.
name|read
argument_list|(
name|fileOffset
argument_list|,
name|dest
argument_list|,
name|destOffset
argument_list|,
name|size
operator|+
name|extraSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
name|size
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Positional read of "
operator|+
name|size
operator|+
literal|" bytes "
operator|+
literal|"failed at offset "
operator|+
name|fileOffset
operator|+
literal|" (returned "
operator|+
name|ret
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|ret
operator|==
name|size
operator|||
name|ret
operator|<
name|size
operator|+
name|extraSize
condition|)
block|{
comment|// Could not read the next block's header, or did not try.
return|return
operator|-
literal|1
return|;
block|}
block|}
assert|assert
name|peekIntoNextBlock
assert|;
return|return
name|Bytes
operator|.
name|toInt
argument_list|(
name|dest
argument_list|,
name|destOffset
operator|+
name|size
operator|+
name|BlockType
operator|.
name|MAGIC_LENGTH
argument_list|)
operator|+
name|hdrSize
return|;
block|}
block|}
comment|/**    * We always prefetch the header of the next block, so that we know its    * on-disk size in advance and can read it in one operation.    */
specifier|private
specifier|static
class|class
name|PrefetchedHeader
block|{
name|long
name|offset
init|=
operator|-
literal|1
decl_stmt|;
name|byte
index|[]
name|header
init|=
operator|new
name|byte
index|[
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE
index|]
decl_stmt|;
name|ByteBuffer
name|buf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|header
argument_list|,
literal|0
argument_list|,
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE
argument_list|)
decl_stmt|;
block|}
comment|/** Reads version 2 blocks from the filesystem. */
specifier|static
class|class
name|FSReaderV2
extends|extends
name|AbstractFSReader
block|{
comment|/** The file system stream of the underlying {@link HFile} that       * does or doesn't do checksum validations in the filesystem */
specifier|protected
name|FSDataInputStreamWrapper
name|streamWrapper
decl_stmt|;
comment|/** Data block encoding used to read from file */
specifier|protected
name|HFileDataBlockEncoder
name|dataBlockEncoder
init|=
name|NoOpDataBlockEncoder
operator|.
name|INSTANCE
decl_stmt|;
specifier|private
name|HFileBlockDecodingContext
name|encodedBlockDecodingCtx
decl_stmt|;
specifier|private
name|HFileBlockDefaultDecodingContext
name|defaultDecodingCtx
decl_stmt|;
specifier|private
name|ThreadLocal
argument_list|<
name|PrefetchedHeader
argument_list|>
name|prefetchedHeaderForThread
init|=
operator|new
name|ThreadLocal
argument_list|<
name|PrefetchedHeader
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|PrefetchedHeader
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|PrefetchedHeader
argument_list|()
return|;
block|}
block|}
decl_stmt|;
specifier|public
name|FSReaderV2
parameter_list|(
name|FSDataInputStreamWrapper
name|stream
parameter_list|,
name|long
name|fileSize
parameter_list|,
name|HFileSystem
name|hfs
parameter_list|,
name|Path
name|path
parameter_list|,
name|HFileContext
name|fileContext
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|fileSize
argument_list|,
name|hfs
argument_list|,
name|path
argument_list|,
name|fileContext
argument_list|)
expr_stmt|;
name|this
operator|.
name|streamWrapper
operator|=
name|stream
expr_stmt|;
comment|// Older versions of HBase didn't support checksum.
name|this
operator|.
name|streamWrapper
operator|.
name|prepareForBlockReader
argument_list|(
operator|!
name|fileContext
operator|.
name|shouldUseHBaseChecksum
argument_list|()
argument_list|)
expr_stmt|;
name|defaultDecodingCtx
operator|=
operator|new
name|HFileBlockDefaultDecodingContext
argument_list|(
name|fileContext
argument_list|)
expr_stmt|;
name|encodedBlockDecodingCtx
operator|=
operator|new
name|HFileBlockDefaultDecodingContext
argument_list|(
name|fileContext
argument_list|)
expr_stmt|;
block|}
comment|/**      * A constructor that reads files with the latest minor version.      * This is used by unit tests only.      */
name|FSReaderV2
parameter_list|(
name|FSDataInputStream
name|istream
parameter_list|,
name|long
name|fileSize
parameter_list|,
name|HFileContext
name|fileContext
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|FSDataInputStreamWrapper
argument_list|(
name|istream
argument_list|)
argument_list|,
name|fileSize
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|fileContext
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reads a version 2 block. Tries to do as little memory allocation as      * possible, using the provided on-disk size.      *      * @param offset the offset in the stream to read at      * @param onDiskSizeWithHeaderL the on-disk size of the block, including      *          the header, or -1 if unknown      * @param uncompressedSize the uncompressed size of the the block. Always      *          expected to be -1. This parameter is only used in version 1.      * @param pread whether to use a positional read      */
annotation|@
name|Override
specifier|public
name|HFileBlock
name|readBlockData
parameter_list|(
name|long
name|offset
parameter_list|,
name|long
name|onDiskSizeWithHeaderL
parameter_list|,
name|int
name|uncompressedSize
parameter_list|,
name|boolean
name|pread
parameter_list|)
throws|throws
name|IOException
block|{
comment|// get a copy of the current state of whether to validate
comment|// hbase checksums or not for this read call. This is not
comment|// thread-safe but the one constaint is that if we decide
comment|// to skip hbase checksum verification then we are
comment|// guaranteed to use hdfs checksum verification.
name|boolean
name|doVerificationThruHBaseChecksum
init|=
name|streamWrapper
operator|.
name|shouldUseHBaseChecksum
argument_list|()
decl_stmt|;
name|FSDataInputStream
name|is
init|=
name|streamWrapper
operator|.
name|getStream
argument_list|(
name|doVerificationThruHBaseChecksum
argument_list|)
decl_stmt|;
name|HFileBlock
name|blk
init|=
name|readBlockDataInternal
argument_list|(
name|is
argument_list|,
name|offset
argument_list|,
name|onDiskSizeWithHeaderL
argument_list|,
name|uncompressedSize
argument_list|,
name|pread
argument_list|,
name|doVerificationThruHBaseChecksum
argument_list|)
decl_stmt|;
if|if
condition|(
name|blk
operator|==
literal|null
condition|)
block|{
name|HFile
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"HBase checksum verification failed for file "
operator|+
name|path
operator|+
literal|" at offset "
operator|+
name|offset
operator|+
literal|" filesize "
operator|+
name|fileSize
operator|+
literal|". Retrying read with HDFS checksums turned on..."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doVerificationThruHBaseChecksum
condition|)
block|{
name|String
name|msg
init|=
literal|"HBase checksum verification failed for file "
operator|+
name|path
operator|+
literal|" at offset "
operator|+
name|offset
operator|+
literal|" filesize "
operator|+
name|fileSize
operator|+
literal|" but this cannot happen because doVerify is "
operator|+
name|doVerificationThruHBaseChecksum
decl_stmt|;
name|HFile
operator|.
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
comment|// cannot happen case here
block|}
name|HFile
operator|.
name|checksumFailures
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// update metrics
comment|// If we have a checksum failure, we fall back into a mode where
comment|// the next few reads use HDFS level checksums. We aim to make the
comment|// next CHECKSUM_VERIFICATION_NUM_IO_THRESHOLD reads avoid
comment|// hbase checksum verification, but since this value is set without
comment|// holding any locks, it can so happen that we might actually do
comment|// a few more than precisely this number.
name|is
operator|=
name|this
operator|.
name|streamWrapper
operator|.
name|fallbackToFsChecksum
argument_list|(
name|CHECKSUM_VERIFICATION_NUM_IO_THRESHOLD
argument_list|)
expr_stmt|;
name|doVerificationThruHBaseChecksum
operator|=
literal|false
expr_stmt|;
name|blk
operator|=
name|readBlockDataInternal
argument_list|(
name|is
argument_list|,
name|offset
argument_list|,
name|onDiskSizeWithHeaderL
argument_list|,
name|uncompressedSize
argument_list|,
name|pread
argument_list|,
name|doVerificationThruHBaseChecksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
literal|null
condition|)
block|{
name|HFile
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"HDFS checksum verification suceeded for file "
operator|+
name|path
operator|+
literal|" at offset "
operator|+
name|offset
operator|+
literal|" filesize "
operator|+
name|fileSize
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|blk
operator|==
literal|null
operator|&&
operator|!
name|doVerificationThruHBaseChecksum
condition|)
block|{
name|String
name|msg
init|=
literal|"readBlockData failed, possibly due to "
operator|+
literal|"checksum verification failed for file "
operator|+
name|path
operator|+
literal|" at offset "
operator|+
name|offset
operator|+
literal|" filesize "
operator|+
name|fileSize
decl_stmt|;
name|HFile
operator|.
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|// If there is a checksum mismatch earlier, then retry with
comment|// HBase checksums switched off and use HDFS checksum verification.
comment|// This triggers HDFS to detect and fix corrupt replicas. The
comment|// next checksumOffCount read requests will use HDFS checksums.
comment|// The decrementing of this.checksumOffCount is not thread-safe,
comment|// but it is harmless because eventually checksumOffCount will be
comment|// a negative number.
name|streamWrapper
operator|.
name|checksumOk
argument_list|()
expr_stmt|;
return|return
name|blk
return|;
block|}
comment|/**      * Reads a version 2 block.       *      * @param offset the offset in the stream to read at      * @param onDiskSizeWithHeaderL the on-disk size of the block, including      *          the header, or -1 if unknown      * @param uncompressedSize the uncompressed size of the the block. Always      *          expected to be -1. This parameter is only used in version 1.      * @param pread whether to use a positional read      * @param verifyChecksum Whether to use HBase checksums.       *        If HBase checksum is switched off, then use HDFS checksum.      * @return the HFileBlock or null if there is a HBase checksum mismatch      */
specifier|private
name|HFileBlock
name|readBlockDataInternal
parameter_list|(
name|FSDataInputStream
name|is
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|onDiskSizeWithHeaderL
parameter_list|,
name|int
name|uncompressedSize
parameter_list|,
name|boolean
name|pread
parameter_list|,
name|boolean
name|verifyChecksum
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid offset="
operator|+
name|offset
operator|+
literal|" trying to read "
operator|+
literal|"block (onDiskSize="
operator|+
name|onDiskSizeWithHeaderL
operator|+
literal|", uncompressedSize="
operator|+
name|uncompressedSize
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|uncompressedSize
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Version 2 block reader API does not need "
operator|+
literal|"the uncompressed size parameter"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|onDiskSizeWithHeaderL
operator|<
name|hdrSize
operator|&&
name|onDiskSizeWithHeaderL
operator|!=
operator|-
literal|1
operator|)
operator|||
name|onDiskSizeWithHeaderL
operator|>=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid onDisksize="
operator|+
name|onDiskSizeWithHeaderL
operator|+
literal|": expected to be at least "
operator|+
name|hdrSize
operator|+
literal|" and at most "
operator|+
name|Integer
operator|.
name|MAX_VALUE
operator|+
literal|", or -1 (offset="
operator|+
name|offset
operator|+
literal|", uncompressedSize="
operator|+
name|uncompressedSize
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|int
name|onDiskSizeWithHeader
init|=
operator|(
name|int
operator|)
name|onDiskSizeWithHeaderL
decl_stmt|;
comment|// See if we can avoid reading the header. This is desirable, because
comment|// we will not incur a backward seek operation if we have already
comment|// read this block's header as part of the previous read's look-ahead.
comment|// And we also want to skip reading the header again if it has already
comment|// been read.
name|PrefetchedHeader
name|prefetchedHeader
init|=
name|prefetchedHeaderForThread
operator|.
name|get
argument_list|()
decl_stmt|;
name|ByteBuffer
name|headerBuf
init|=
name|prefetchedHeader
operator|.
name|offset
operator|==
name|offset
condition|?
name|prefetchedHeader
operator|.
name|buf
else|:
literal|null
decl_stmt|;
name|int
name|nextBlockOnDiskSize
init|=
literal|0
decl_stmt|;
comment|// Allocate enough space to fit the next block's header too.
name|byte
index|[]
name|onDiskBlock
init|=
literal|null
decl_stmt|;
name|HFileBlock
name|b
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|onDiskSizeWithHeader
operator|>
literal|0
condition|)
block|{
comment|// We know the total on-disk size but not the uncompressed size. Read
comment|// the entire block into memory, then parse the header and decompress
comment|// from memory if using compression. This code path is used when
comment|// doing a random read operation relying on the block index, as well as
comment|// when the client knows the on-disk size from peeking into the next
comment|// block's header (e.g. this block's header) when reading the previous
comment|// block. This is the faster and more preferable case.
comment|// Size that we have to skip in case we have already read the header.
name|int
name|preReadHeaderSize
init|=
name|headerBuf
operator|==
literal|null
condition|?
literal|0
else|:
name|hdrSize
decl_stmt|;
name|onDiskBlock
operator|=
operator|new
name|byte
index|[
name|onDiskSizeWithHeader
operator|+
name|hdrSize
index|]
expr_stmt|;
name|nextBlockOnDiskSize
operator|=
name|readAtOffset
argument_list|(
name|is
argument_list|,
name|onDiskBlock
argument_list|,
name|preReadHeaderSize
argument_list|,
name|onDiskSizeWithHeader
operator|-
name|preReadHeaderSize
argument_list|,
literal|true
argument_list|,
name|offset
operator|+
name|preReadHeaderSize
argument_list|,
name|pread
argument_list|)
expr_stmt|;
if|if
condition|(
name|headerBuf
operator|!=
literal|null
condition|)
block|{
comment|// the header has been read when reading the previous block, copy
comment|// to this block's header
name|System
operator|.
name|arraycopy
argument_list|(
name|headerBuf
operator|.
name|array
argument_list|()
argument_list|,
name|headerBuf
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|onDiskBlock
argument_list|,
literal|0
argument_list|,
name|hdrSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|headerBuf
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|onDiskBlock
argument_list|,
literal|0
argument_list|,
name|hdrSize
argument_list|)
expr_stmt|;
block|}
comment|// We know the total on-disk size but not the uncompressed size. Read
comment|// the entire block into memory, then parse the header and decompress
comment|// from memory if using compression. Here we have already read the
comment|// block's header
try|try
block|{
name|b
operator|=
operator|new
name|HFileBlock
argument_list|(
name|headerBuf
argument_list|,
name|this
operator|.
name|fileContext
operator|.
name|shouldUseHBaseChecksum
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// Seen in load testing. Provide comprehensive debug info.
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to read compressed block at "
operator|+
name|offset
operator|+
literal|", onDiskSizeWithoutHeader="
operator|+
name|onDiskSizeWithHeader
operator|+
literal|", preReadHeaderSize="
operator|+
name|hdrSize
operator|+
literal|", header.length="
operator|+
name|prefetchedHeader
operator|.
name|header
operator|.
name|length
operator|+
literal|", header bytes: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|prefetchedHeader
operator|.
name|header
argument_list|,
literal|0
argument_list|,
name|hdrSize
argument_list|)
argument_list|,
name|ex
argument_list|)
throw|;
block|}
comment|// if the caller specifies a onDiskSizeWithHeader, validate it.
name|int
name|onDiskSizeWithoutHeader
init|=
name|onDiskSizeWithHeader
operator|-
name|hdrSize
decl_stmt|;
assert|assert
name|onDiskSizeWithoutHeader
operator|>=
literal|0
assert|;
name|b
operator|.
name|validateOnDiskSizeWithoutHeader
argument_list|(
name|onDiskSizeWithoutHeader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Check headerBuf to see if we have read this block's header as part of
comment|// reading the previous block. This is an optimization of peeking into
comment|// the next block's header (e.g.this block's header) when reading the
comment|// previous block. This is the faster and more preferable case. If the
comment|// header is already there, don't read the header again.
comment|// Unfortunately, we still have to do a separate read operation to
comment|// read the header.
if|if
condition|(
name|headerBuf
operator|==
literal|null
condition|)
block|{
comment|// From the header, determine the on-disk size of the given hfile
comment|// block, and read the remaining data, thereby incurring two read
comment|// operations. This might happen when we are doing the first read
comment|// in a series of reads or a random read, and we don't have access
comment|// to the block index. This is costly and should happen very rarely.
name|headerBuf
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|hdrSize
argument_list|)
expr_stmt|;
name|readAtOffset
argument_list|(
name|is
argument_list|,
name|headerBuf
operator|.
name|array
argument_list|()
argument_list|,
name|headerBuf
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|hdrSize
argument_list|,
literal|false
argument_list|,
name|offset
argument_list|,
name|pread
argument_list|)
expr_stmt|;
block|}
name|b
operator|=
operator|new
name|HFileBlock
argument_list|(
name|headerBuf
argument_list|,
name|this
operator|.
name|fileContext
operator|.
name|shouldUseHBaseChecksum
argument_list|()
argument_list|)
expr_stmt|;
name|onDiskBlock
operator|=
operator|new
name|byte
index|[
name|b
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
operator|+
name|hdrSize
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|headerBuf
operator|.
name|array
argument_list|()
argument_list|,
name|headerBuf
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|onDiskBlock
argument_list|,
literal|0
argument_list|,
name|hdrSize
argument_list|)
expr_stmt|;
name|nextBlockOnDiskSize
operator|=
name|readAtOffset
argument_list|(
name|is
argument_list|,
name|onDiskBlock
argument_list|,
name|hdrSize
argument_list|,
name|b
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
operator|-
name|hdrSize
argument_list|,
literal|true
argument_list|,
name|offset
operator|+
name|hdrSize
argument_list|,
name|pread
argument_list|)
expr_stmt|;
name|onDiskSizeWithHeader
operator|=
name|b
operator|.
name|onDiskSizeWithoutHeader
operator|+
name|hdrSize
expr_stmt|;
block|}
name|Algorithm
name|compressAlgo
init|=
name|fileContext
operator|.
name|getCompression
argument_list|()
decl_stmt|;
name|boolean
name|isCompressed
init|=
name|compressAlgo
operator|!=
literal|null
operator|&&
name|compressAlgo
operator|!=
name|Compression
operator|.
name|Algorithm
operator|.
name|NONE
decl_stmt|;
if|if
condition|(
operator|!
name|isCompressed
condition|)
block|{
name|b
operator|.
name|assumeUncompressed
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|verifyChecksum
operator|&&
operator|!
name|validateBlockChecksum
argument_list|(
name|b
argument_list|,
name|onDiskBlock
argument_list|,
name|hdrSize
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
comment|// checksum mismatch
block|}
if|if
condition|(
name|isCompressed
condition|)
block|{
comment|// This will allocate a new buffer but keep header bytes.
name|b
operator|.
name|allocateBuffer
argument_list|(
name|nextBlockOnDiskSize
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|blockType
operator|.
name|equals
argument_list|(
name|BlockType
operator|.
name|ENCODED_DATA
argument_list|)
condition|)
block|{
name|encodedBlockDecodingCtx
operator|.
name|prepareDecoding
argument_list|(
name|b
operator|.
name|getOnDiskSizeWithoutHeader
argument_list|()
argument_list|,
name|b
operator|.
name|getUncompressedSizeWithoutHeader
argument_list|()
argument_list|,
name|b
operator|.
name|getBufferWithoutHeader
argument_list|()
argument_list|,
name|onDiskBlock
argument_list|,
name|hdrSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|defaultDecodingCtx
operator|.
name|prepareDecoding
argument_list|(
name|b
operator|.
name|getOnDiskSizeWithoutHeader
argument_list|()
argument_list|,
name|b
operator|.
name|getUncompressedSizeWithoutHeader
argument_list|()
argument_list|,
name|b
operator|.
name|getBufferWithoutHeader
argument_list|()
argument_list|,
name|onDiskBlock
argument_list|,
name|hdrSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextBlockOnDiskSize
operator|>
literal|0
condition|)
block|{
comment|// Copy next block's header bytes into the new block if we have them.
name|System
operator|.
name|arraycopy
argument_list|(
name|onDiskBlock
argument_list|,
name|onDiskSizeWithHeader
argument_list|,
name|b
operator|.
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|b
operator|.
name|buf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|hdrSize
operator|+
name|b
operator|.
name|uncompressedSizeWithoutHeader
operator|+
name|b
operator|.
name|totalChecksumBytes
argument_list|()
argument_list|,
name|hdrSize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// The onDiskBlock will become the headerAndDataBuffer for this block.
comment|// If nextBlockOnDiskSizeWithHeader is not zero, the onDiskBlock already
comment|// contains the header of next block, so no need to set next
comment|// block's header in it.
name|b
operator|=
operator|new
name|HFileBlock
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|onDiskBlock
argument_list|,
literal|0
argument_list|,
name|onDiskSizeWithHeader
argument_list|)
argument_list|,
name|this
operator|.
name|fileContext
operator|.
name|shouldUseHBaseChecksum
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|nextBlockOnDiskSizeWithHeader
operator|=
name|nextBlockOnDiskSize
expr_stmt|;
comment|// Set prefetched header
if|if
condition|(
name|b
operator|.
name|nextBlockOnDiskSizeWithHeader
operator|>
literal|0
condition|)
block|{
name|prefetchedHeader
operator|.
name|offset
operator|=
name|offset
operator|+
name|b
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|onDiskBlock
argument_list|,
name|onDiskSizeWithHeader
argument_list|,
name|prefetchedHeader
operator|.
name|header
argument_list|,
literal|0
argument_list|,
name|hdrSize
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|b
operator|.
name|fileContext
operator|.
name|setIncludesTags
argument_list|(
name|this
operator|.
name|fileContext
operator|.
name|shouldIncludeTags
argument_list|()
argument_list|)
expr_stmt|;
name|b
operator|.
name|fileContext
operator|.
name|setIncludesMvcc
argument_list|(
name|this
operator|.
name|fileContext
operator|.
name|shouldIncludeMvcc
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
name|void
name|setIncludesMemstoreTS
parameter_list|(
name|boolean
name|includesMemstoreTS
parameter_list|)
block|{
name|this
operator|.
name|fileContext
operator|.
name|setIncludesMvcc
argument_list|(
name|includesMemstoreTS
argument_list|)
expr_stmt|;
block|}
name|void
name|setDataBlockEncoder
parameter_list|(
name|HFileDataBlockEncoder
name|encoder
parameter_list|)
block|{
name|this
operator|.
name|dataBlockEncoder
operator|=
name|encoder
expr_stmt|;
name|encodedBlockDecodingCtx
operator|=
name|encoder
operator|.
name|newOnDiskDataBlockDecodingContext
argument_list|(
name|this
operator|.
name|fileContext
argument_list|)
expr_stmt|;
block|}
comment|/**      * Generates the checksum for the header as well as the data and      * then validates that it matches the value stored in the header.      * If there is a checksum mismatch, then return false. Otherwise      * return true.      */
specifier|protected
name|boolean
name|validateBlockChecksum
parameter_list|(
name|HFileBlock
name|block
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|int
name|hdrSize
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ChecksumUtil
operator|.
name|validateBlockChecksum
argument_list|(
name|path
argument_list|,
name|block
argument_list|,
name|data
argument_list|,
name|hdrSize
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|closeStreams
parameter_list|()
throws|throws
name|IOException
block|{
name|streamWrapper
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|getSerializedLength
parameter_list|()
block|{
if|if
condition|(
name|buf
operator|!=
literal|null
condition|)
block|{
return|return
name|this
operator|.
name|buf
operator|.
name|limit
argument_list|()
operator|+
name|HFileBlock
operator|.
name|EXTRA_SERIALIZATION_SPACE
return|;
block|}
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|serialize
parameter_list|(
name|ByteBuffer
name|destination
parameter_list|)
block|{
name|ByteBuffer
name|dupBuf
init|=
name|this
operator|.
name|buf
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|dupBuf
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|destination
operator|.
name|put
argument_list|(
name|dupBuf
argument_list|)
expr_stmt|;
name|serializeExtraInfo
argument_list|(
name|destination
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|serializeExtraInfo
parameter_list|(
name|ByteBuffer
name|destination
parameter_list|)
block|{
name|destination
operator|.
name|put
argument_list|(
name|this
operator|.
name|fileContext
operator|.
name|shouldUseHBaseChecksum
argument_list|()
condition|?
operator|(
name|byte
operator|)
literal|1
else|:
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|destination
operator|.
name|putLong
argument_list|(
name|this
operator|.
name|offset
argument_list|)
expr_stmt|;
name|destination
operator|.
name|putInt
argument_list|(
name|this
operator|.
name|nextBlockOnDiskSizeWithHeader
argument_list|)
expr_stmt|;
name|destination
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|CacheableDeserializer
argument_list|<
name|Cacheable
argument_list|>
name|getDeserializer
parameter_list|()
block|{
return|return
name|HFileBlock
operator|.
name|blockDeserializer
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|comparison
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|comparison
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|comparison
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|comparison
operator|.
name|getClass
argument_list|()
operator|!=
name|this
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|HFileBlock
name|castedComparison
init|=
operator|(
name|HFileBlock
operator|)
name|comparison
decl_stmt|;
if|if
condition|(
name|castedComparison
operator|.
name|blockType
operator|!=
name|this
operator|.
name|blockType
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|castedComparison
operator|.
name|nextBlockOnDiskSizeWithHeader
operator|!=
name|this
operator|.
name|nextBlockOnDiskSizeWithHeader
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|castedComparison
operator|.
name|offset
operator|!=
name|this
operator|.
name|offset
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|castedComparison
operator|.
name|onDiskSizeWithoutHeader
operator|!=
name|this
operator|.
name|onDiskSizeWithoutHeader
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|castedComparison
operator|.
name|prevBlockOffset
operator|!=
name|this
operator|.
name|prevBlockOffset
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|castedComparison
operator|.
name|uncompressedSizeWithoutHeader
operator|!=
name|this
operator|.
name|uncompressedSizeWithoutHeader
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|buf
operator|.
name|compareTo
argument_list|(
name|castedComparison
operator|.
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|buf
operator|.
name|position
argument_list|()
operator|!=
name|castedComparison
operator|.
name|buf
operator|.
name|position
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|buf
operator|.
name|limit
argument_list|()
operator|!=
name|castedComparison
operator|.
name|buf
operator|.
name|limit
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|DataBlockEncoding
name|getDataBlockEncoding
parameter_list|()
block|{
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|ENCODED_DATA
condition|)
block|{
return|return
name|DataBlockEncoding
operator|.
name|getEncodingById
argument_list|(
name|getDataBlockEncodingId
argument_list|()
argument_list|)
return|;
block|}
return|return
name|DataBlockEncoding
operator|.
name|NONE
return|;
block|}
name|byte
name|getChecksumType
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileContext
operator|.
name|getChecksumType
argument_list|()
operator|.
name|getCode
argument_list|()
return|;
block|}
name|int
name|getBytesPerChecksum
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileContext
operator|.
name|getBytesPerChecksum
argument_list|()
return|;
block|}
name|int
name|getOnDiskDataSizeWithHeader
parameter_list|()
block|{
return|return
name|this
operator|.
name|onDiskDataSizeWithHeader
return|;
block|}
comment|/**     * Calcuate the number of bytes required to store all the checksums    * for this block. Each checksum value is a 4 byte integer.    */
name|int
name|totalChecksumBytes
parameter_list|()
block|{
comment|// If the hfile block has minorVersion 0, then there are no checksum
comment|// data to validate. Similarly, a zero value in this.bytesPerChecksum
comment|// indicates that cached blocks do not have checksum data because
comment|// checksums were already validated when the block was read from disk.
if|if
condition|(
operator|!
name|fileContext
operator|.
name|shouldUseHBaseChecksum
argument_list|()
operator|||
name|this
operator|.
name|fileContext
operator|.
name|getBytesPerChecksum
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|(
name|int
operator|)
name|ChecksumUtil
operator|.
name|numBytes
argument_list|(
name|onDiskDataSizeWithHeader
argument_list|,
name|this
operator|.
name|fileContext
operator|.
name|getBytesPerChecksum
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the size of this block header.    */
specifier|public
name|int
name|headerSize
parameter_list|()
block|{
return|return
name|headerSize
argument_list|(
name|this
operator|.
name|fileContext
operator|.
name|shouldUseHBaseChecksum
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Maps a minor version to the size of the header.    */
specifier|public
specifier|static
name|int
name|headerSize
parameter_list|(
name|boolean
name|usesHBaseChecksum
parameter_list|)
block|{
if|if
condition|(
name|usesHBaseChecksum
condition|)
block|{
return|return
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE
return|;
block|}
return|return
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE_NO_CHECKSUM
return|;
block|}
comment|/**    * Return the appropriate DUMMY_HEADER for the minor version    */
specifier|public
name|byte
index|[]
name|getDummyHeaderForVersion
parameter_list|()
block|{
return|return
name|getDummyHeaderForVersion
argument_list|(
name|this
operator|.
name|fileContext
operator|.
name|shouldUseHBaseChecksum
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return the appropriate DUMMY_HEADER for the minor version    */
specifier|static
specifier|private
name|byte
index|[]
name|getDummyHeaderForVersion
parameter_list|(
name|boolean
name|usesHBaseChecksum
parameter_list|)
block|{
if|if
condition|(
name|usesHBaseChecksum
condition|)
block|{
return|return
name|HConstants
operator|.
name|HFILEBLOCK_DUMMY_HEADER
return|;
block|}
return|return
name|DUMMY_HEADER_NO_CHECKSUM
return|;
block|}
specifier|public
name|HFileContext
name|getHFileContext
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileContext
return|;
block|}
comment|/**    * Convert the contents of the block header into a human readable string.    * This is mostly helpful for debugging. This assumes that the block    * has minor version> 0.    */
specifier|static
name|String
name|toStringHeader
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|offset
init|=
name|buf
operator|.
name|arrayOffset
argument_list|()
decl_stmt|;
name|byte
index|[]
name|b
init|=
name|buf
operator|.
name|array
argument_list|()
decl_stmt|;
name|long
name|magic
init|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|b
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|BlockType
name|bt
init|=
name|BlockType
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|Bytes
operator|.
name|SIZEOF_LONG
expr_stmt|;
name|int
name|compressedBlockSizeNoHeader
init|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|b
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
name|int
name|uncompressedBlockSizeNoHeader
init|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|b
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
name|long
name|prevBlockOffset
init|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|b
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|Bytes
operator|.
name|SIZEOF_LONG
expr_stmt|;
name|byte
name|cksumtype
init|=
name|b
index|[
name|offset
index|]
decl_stmt|;
name|offset
operator|+=
name|Bytes
operator|.
name|SIZEOF_BYTE
expr_stmt|;
name|long
name|bytesPerChecksum
init|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|b
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
name|long
name|onDiskDataSizeWithHeader
init|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|b
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
return|return
literal|" Header dump: magic: "
operator|+
name|magic
operator|+
literal|" blockType "
operator|+
name|bt
operator|+
literal|" compressedBlockSizeNoHeader "
operator|+
name|compressedBlockSizeNoHeader
operator|+
literal|" uncompressedBlockSizeNoHeader "
operator|+
name|uncompressedBlockSizeNoHeader
operator|+
literal|" prevBlockOffset "
operator|+
name|prevBlockOffset
operator|+
literal|" checksumType "
operator|+
name|ChecksumType
operator|.
name|codeToType
argument_list|(
name|cksumtype
argument_list|)
operator|+
literal|" bytesPerChecksum "
operator|+
name|bytesPerChecksum
operator|+
literal|" onDiskDataSizeWithHeader "
operator|+
name|onDiskDataSizeWithHeader
return|;
block|}
block|}
end_class

end_unit

