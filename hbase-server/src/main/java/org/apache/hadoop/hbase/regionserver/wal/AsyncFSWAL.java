begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
package|;
end_package

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|RingBuffer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|Sequence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|Sequencer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseInterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|AsyncFSOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|trace
operator|.
name|TraceUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|AsyncFSWALProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALEdit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALKeyImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALProvider
operator|.
name|AsyncWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|Channel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|EventLoop
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|EventLoopGroup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SingleThreadEventExecutor
import|;
end_import

begin_comment
comment|/**  * An asynchronous implementation of FSWAL.  *<p>  * Here 'waitingConsumePayloads' acts as the RingBuffer in FSHLog.  *<p>  * For append, we process it as follow:  *<ol>  *<li>In the caller thread(typically, in the rpc handler thread):  *<ol>  *<li>Insert the entry into 'waitingConsumePayloads'. Use ringbuffer sequence as txid.</li>  *<li>Schedule the consumer task if needed. See {@link #shouldScheduleConsumer()} for more details.  *</li>  *</ol>  *</li>  *<li>In the consumer task(executed in a single threaded thread pool)  *<ol>  *<li>Poll the entry from {@link #waitingConsumePayloads} and insert it into  * {@link #toWriteAppends}</li>  *<li>Poll the entry from {@link #toWriteAppends}, append it to the AsyncWriter, and insert it into  * {@link #unackedAppends}</li>  *<li>If the buffered size reaches {@link #batchSize}, or there is a sync request, then we call  * sync on the AsyncWriter.</li>  *<li>In the callback methods:  *<ul>  *<li>If succeeded, poll the entry from {@link #unackedAppends} and drop it.</li>  *<li>If failed, add all the entries in {@link #unackedAppends} back to {@link #toWriteAppends} and  * wait for writing them again.</li>  *</ul>  *</li>  *</ol>  *</li>  *</ol>  * For sync, the processing stages are almost same. And different from FSHLog, we will open a new  * writer and rewrite unacked entries to the new writer and sync again if we hit a sync error.  *<p>  * Here we only describe the logic of doReplaceWriter. The main logic of rollWriter is same with  * FSHLog.<br>  * For a normal roll request(for example, we have reached the log roll size):  *<ol>  *<li>In the log roller thread, we will set {@link #waitingRoll} to true and  * {@link #readyForRolling} to false, and then wait on {@link #readyForRolling}(see  * {@link #waitForSafePoint()}).</li>  *<li>In the consumer thread, we will stop polling entries from {@link #waitingConsumePayloads} if  * {@link #waitingRoll} is true, and also stop writing the entries in {@link #toWriteAppends} out.  *</li>  *<li>If there are unflush data in the writer, sync them.</li>  *<li>When all out-going sync request is finished, i.e, the {@link #unackedAppends} is empty,  * signal the {@link #readyForRollingCond}.</li>  *<li>Back to the log roller thread, now we can confirm that there are no out-going entries, i.e.,  * we reach a safe point. So it is safe to replace old writer with new writer now.</li>  *<li>Set {@link #writerBroken} and {@link #waitingRoll} to false.</li>  *<li>Schedule the consumer task.</li>  *<li>Schedule a background task to close the old writer.</li>  *</ol>  * For a broken writer roll request, the only difference is that we can bypass the wait for safe  * point stage.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|CONFIG
argument_list|)
specifier|public
class|class
name|AsyncFSWAL
extends|extends
name|AbstractFSWAL
argument_list|<
name|AsyncWriter
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AsyncFSWAL
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|SyncFuture
argument_list|>
name|SEQ_COMPARATOR
init|=
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
block|{
name|int
name|c
init|=
name|Long
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|getTxid
argument_list|()
argument_list|,
name|o2
operator|.
name|getTxid
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|c
operator|!=
literal|0
condition|?
name|c
else|:
name|Integer
operator|.
name|compare
argument_list|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|o1
argument_list|)
argument_list|,
name|System
operator|.
name|identityHashCode
argument_list|(
name|o2
argument_list|)
argument_list|)
return|;
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|WAL_BATCH_SIZE
init|=
literal|"hbase.wal.batch.size"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_WAL_BATCH_SIZE
init|=
literal|64L
operator|*
literal|1024
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASYNC_WAL_USE_SHARED_EVENT_LOOP
init|=
literal|"hbase.wal.async.use-shared-event-loop"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_ASYNC_WAL_USE_SHARED_EVENT_LOOP
init|=
literal|false
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASYNC_WAL_WAIT_ON_SHUTDOWN_IN_SECONDS
init|=
literal|"hbase.wal.async.wait.on.shutdown.seconds"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_ASYNC_WAL_WAIT_ON_SHUTDOWN_IN_SECONDS
init|=
literal|5
decl_stmt|;
specifier|private
specifier|final
name|EventLoopGroup
name|eventLoopGroup
decl_stmt|;
specifier|private
specifier|final
name|ExecutorService
name|consumeExecutor
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Channel
argument_list|>
name|channelClass
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|consumeLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Runnable
name|consumer
init|=
name|this
operator|::
name|consume
decl_stmt|;
comment|// check if there is already a consumer task in the event loop's task queue
specifier|private
specifier|final
name|Supplier
argument_list|<
name|Boolean
argument_list|>
name|hasConsumerTask
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MAX_EPOCH
init|=
literal|0x3FFFFFFF
decl_stmt|;
comment|// the lowest bit is waitingRoll, which means new writer is created and we are waiting for old
comment|// writer to be closed.
comment|// the second lowest bit is writerBorken which means the current writer is broken and rollWriter
comment|// is needed.
comment|// all other bits are the epoch number of the current writer, this is used to detect whether the
comment|// writer is still the one when you issue the sync.
comment|// notice that, modification to this field is only allowed under the protection of consumeLock.
specifier|private
specifier|volatile
name|int
name|epochAndState
decl_stmt|;
comment|// used to guard the log roll request when we exceed the log roll size.
specifier|private
name|boolean
name|rollRequested
decl_stmt|;
specifier|private
name|boolean
name|readyForRolling
decl_stmt|;
specifier|private
specifier|final
name|Condition
name|readyForRollingCond
init|=
name|consumeLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|RingBuffer
argument_list|<
name|RingBufferTruck
argument_list|>
name|waitingConsumePayloads
decl_stmt|;
specifier|private
specifier|final
name|Sequence
name|waitingConsumePayloadsGatingSequence
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|consumerScheduled
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|long
name|batchSize
decl_stmt|;
specifier|private
specifier|final
name|ExecutorService
name|closeExecutor
init|=
name|Executors
operator|.
name|newCachedThreadPool
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"Close-WAL-Writer-%d"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|AsyncFSOutput
name|fsOut
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|FSWALEntry
argument_list|>
name|toWriteAppends
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|FSWALEntry
argument_list|>
name|unackedAppends
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|SortedSet
argument_list|<
name|SyncFuture
argument_list|>
name|syncFutures
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|SEQ_COMPARATOR
argument_list|)
decl_stmt|;
comment|// the highest txid of WAL entries being processed
specifier|private
name|long
name|highestProcessedAppendTxid
decl_stmt|;
comment|// file length when we issue last sync request on the writer
specifier|private
name|long
name|fileLengthAtLastSync
decl_stmt|;
specifier|private
name|long
name|highestProcessedAppendTxidAtLastSync
decl_stmt|;
specifier|private
specifier|final
name|int
name|waitOnShutdownInSeconds
decl_stmt|;
specifier|public
name|AsyncFSWAL
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|rootDir
parameter_list|,
name|String
name|logDir
parameter_list|,
name|String
name|archiveDir
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|List
argument_list|<
name|WALActionsListener
argument_list|>
name|listeners
parameter_list|,
name|boolean
name|failIfWALExists
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|,
name|EventLoopGroup
name|eventLoopGroup
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Channel
argument_list|>
name|channelClass
parameter_list|)
throws|throws
name|FailedLogCloseException
throws|,
name|IOException
block|{
name|super
argument_list|(
name|fs
argument_list|,
name|rootDir
argument_list|,
name|logDir
argument_list|,
name|archiveDir
argument_list|,
name|conf
argument_list|,
name|listeners
argument_list|,
name|failIfWALExists
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|this
operator|.
name|eventLoopGroup
operator|=
name|eventLoopGroup
expr_stmt|;
name|this
operator|.
name|channelClass
operator|=
name|channelClass
expr_stmt|;
name|Supplier
argument_list|<
name|Boolean
argument_list|>
name|hasConsumerTask
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|ASYNC_WAL_USE_SHARED_EVENT_LOOP
argument_list|,
name|DEFAULT_ASYNC_WAL_USE_SHARED_EVENT_LOOP
argument_list|)
condition|)
block|{
name|this
operator|.
name|consumeExecutor
operator|=
name|eventLoopGroup
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|consumeExecutor
operator|instanceof
name|SingleThreadEventExecutor
condition|)
block|{
try|try
block|{
name|Field
name|field
init|=
name|SingleThreadEventExecutor
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"taskQueue"
argument_list|)
decl_stmt|;
name|field
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Queue
argument_list|<
name|?
argument_list|>
name|queue
init|=
operator|(
name|Queue
argument_list|<
name|?
argument_list|>
operator|)
name|field
operator|.
name|get
argument_list|(
name|consumeExecutor
argument_list|)
decl_stmt|;
name|hasConsumerTask
operator|=
parameter_list|()
lambda|->
name|queue
operator|.
name|peek
argument_list|()
operator|==
name|consumer
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can not get task queue of "
operator|+
name|consumeExecutor
operator|+
literal|", this is not necessary, just give up"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|hasConsumerTask
operator|=
parameter_list|()
lambda|->
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|hasConsumerTask
operator|=
parameter_list|()
lambda|->
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|ThreadPoolExecutor
name|threadPool
init|=
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|0L
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|,
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"AsyncFSWAL-%d"
argument_list|)
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hasConsumerTask
operator|=
parameter_list|()
lambda|->
name|threadPool
operator|.
name|getQueue
argument_list|()
operator|.
name|peek
argument_list|()
operator|==
name|consumer
expr_stmt|;
name|this
operator|.
name|consumeExecutor
operator|=
name|threadPool
expr_stmt|;
block|}
name|this
operator|.
name|hasConsumerTask
operator|=
name|hasConsumerTask
expr_stmt|;
name|int
name|preallocatedEventCount
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.wal.disruptor.event.count"
argument_list|,
literal|1024
operator|*
literal|16
argument_list|)
decl_stmt|;
name|waitingConsumePayloads
operator|=
name|RingBuffer
operator|.
name|createMultiProducer
argument_list|(
name|RingBufferTruck
operator|::
operator|new
argument_list|,
name|preallocatedEventCount
argument_list|)
expr_stmt|;
name|waitingConsumePayloadsGatingSequence
operator|=
operator|new
name|Sequence
argument_list|(
name|Sequencer
operator|.
name|INITIAL_CURSOR_VALUE
argument_list|)
expr_stmt|;
name|waitingConsumePayloads
operator|.
name|addGatingSequences
argument_list|(
name|waitingConsumePayloadsGatingSequence
argument_list|)
expr_stmt|;
comment|// inrease the ringbuffer sequence so our txid is start from 1
name|waitingConsumePayloads
operator|.
name|publish
argument_list|(
name|waitingConsumePayloads
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|waitingConsumePayloadsGatingSequence
operator|.
name|set
argument_list|(
name|waitingConsumePayloads
operator|.
name|getCursor
argument_list|()
argument_list|)
expr_stmt|;
name|batchSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|WAL_BATCH_SIZE
argument_list|,
name|DEFAULT_WAL_BATCH_SIZE
argument_list|)
expr_stmt|;
name|waitOnShutdownInSeconds
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|ASYNC_WAL_WAIT_ON_SHUTDOWN_IN_SECONDS
argument_list|,
name|DEFAULT_ASYNC_WAL_WAIT_ON_SHUTDOWN_IN_SECONDS
argument_list|)
expr_stmt|;
name|rollWriter
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|waitingRoll
parameter_list|(
name|int
name|epochAndState
parameter_list|)
block|{
return|return
operator|(
name|epochAndState
operator|&
literal|1
operator|)
operator|!=
literal|0
return|;
block|}
specifier|private
specifier|static
name|boolean
name|writerBroken
parameter_list|(
name|int
name|epochAndState
parameter_list|)
block|{
return|return
operator|(
operator|(
name|epochAndState
operator|>>>
literal|1
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
return|;
block|}
specifier|private
specifier|static
name|int
name|epoch
parameter_list|(
name|int
name|epochAndState
parameter_list|)
block|{
return|return
name|epochAndState
operator|>>>
literal|2
return|;
block|}
comment|// return whether we have successfully set readyForRolling to true.
specifier|private
name|boolean
name|trySetReadyForRolling
parameter_list|()
block|{
comment|// Check without holding lock first. Usually we will just return here.
comment|// waitingRoll is volatile and unacedEntries is only accessed inside event loop so it is safe to
comment|// check them outside the consumeLock.
if|if
condition|(
operator|!
name|waitingRoll
argument_list|(
name|epochAndState
argument_list|)
operator|||
operator|!
name|unackedAppends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|consumeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// 1. a roll is requested
comment|// 2. all out-going entries have been acked(we have confirmed above).
if|if
condition|(
name|waitingRoll
argument_list|(
name|epochAndState
argument_list|)
condition|)
block|{
name|readyForRolling
operator|=
literal|true
expr_stmt|;
name|readyForRollingCond
operator|.
name|signalAll
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|consumeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|syncFailed
parameter_list|(
name|long
name|epochWhenSync
parameter_list|,
name|Throwable
name|error
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"sync failed"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|boolean
name|shouldRequestLogRoll
init|=
literal|true
decl_stmt|;
name|consumeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|currentEpochAndState
init|=
name|epochAndState
decl_stmt|;
if|if
condition|(
name|epoch
argument_list|(
name|currentEpochAndState
argument_list|)
operator|!=
name|epochWhenSync
operator|||
name|writerBroken
argument_list|(
name|currentEpochAndState
argument_list|)
condition|)
block|{
comment|// this is not the previous writer which means we have already rolled the writer.
comment|// or this is still the current writer, but we have already marked it as broken and request
comment|// a roll.
return|return;
block|}
name|this
operator|.
name|epochAndState
operator|=
name|currentEpochAndState
operator||
literal|0b10
expr_stmt|;
if|if
condition|(
name|waitingRoll
argument_list|(
name|currentEpochAndState
argument_list|)
condition|)
block|{
name|readyForRolling
operator|=
literal|true
expr_stmt|;
name|readyForRollingCond
operator|.
name|signalAll
argument_list|()
expr_stmt|;
comment|// this means we have already in the middle of a rollWriter so just tell the roller thread
comment|// that you can continue without requesting an extra log roll.
name|shouldRequestLogRoll
operator|=
literal|false
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|consumeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|FSWALEntry
argument_list|>
name|iter
init|=
name|unackedAppends
operator|.
name|descendingIterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|toWriteAppends
operator|.
name|addFirst
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|highestUnsyncedTxid
operator|=
name|highestSyncedTxid
operator|.
name|get
argument_list|()
expr_stmt|;
if|if
condition|(
name|shouldRequestLogRoll
condition|)
block|{
comment|// request a roll.
name|requestLogRoll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|syncCompleted
parameter_list|(
name|AsyncWriter
name|writer
parameter_list|,
name|long
name|processedTxid
parameter_list|,
name|long
name|startTimeNs
parameter_list|)
block|{
name|highestSyncedTxid
operator|.
name|set
argument_list|(
name|processedTxid
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|FSWALEntry
argument_list|>
name|iter
init|=
name|unackedAppends
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|getTxid
argument_list|()
operator|<=
name|processedTxid
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|postSync
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNs
argument_list|,
name|finishSync
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|trySetReadyForRolling
argument_list|()
condition|)
block|{
comment|// we have just finished a roll, then do not need to check for log rolling, the writer will be
comment|// closed soon.
return|return;
block|}
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|<
name|logrollsize
operator|||
name|rollRequested
condition|)
block|{
return|return;
block|}
name|rollRequested
operator|=
literal|true
expr_stmt|;
name|requestLogRoll
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|sync
parameter_list|(
name|AsyncWriter
name|writer
parameter_list|)
block|{
name|fileLengthAtLastSync
operator|=
name|writer
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|long
name|currentHighestProcessedAppendTxid
init|=
name|highestProcessedAppendTxid
decl_stmt|;
name|highestProcessedAppendTxidAtLastSync
operator|=
name|currentHighestProcessedAppendTxid
expr_stmt|;
specifier|final
name|long
name|startTimeNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
specifier|final
name|long
name|epoch
init|=
operator|(
name|long
operator|)
name|epochAndState
operator|>>>
literal|2L
decl_stmt|;
name|writer
operator|.
name|sync
argument_list|()
operator|.
name|whenCompleteAsync
argument_list|(
parameter_list|(
name|result
parameter_list|,
name|error
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|error
operator|!=
literal|null
condition|)
block|{
name|syncFailed
argument_list|(
name|epoch
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syncCompleted
argument_list|(
name|writer
argument_list|,
name|currentHighestProcessedAppendTxid
argument_list|,
name|startTimeNs
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|consumeExecutor
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addTimeAnnotation
parameter_list|(
name|SyncFuture
name|future
parameter_list|,
name|String
name|annotation
parameter_list|)
block|{
name|TraceUtil
operator|.
name|addTimelineAnnotation
argument_list|(
name|annotation
argument_list|)
expr_stmt|;
comment|// TODO handle htrace API change, see HBASE-18895
comment|// future.setSpan(scope.getSpan());
block|}
specifier|private
name|int
name|finishSyncLowerThanTxid
parameter_list|(
name|long
name|txid
parameter_list|,
name|boolean
name|addSyncTrace
parameter_list|)
block|{
name|int
name|finished
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|SyncFuture
argument_list|>
name|iter
init|=
name|syncFutures
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SyncFuture
name|sync
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|sync
operator|.
name|getTxid
argument_list|()
operator|<=
name|txid
condition|)
block|{
name|sync
operator|.
name|done
argument_list|(
name|txid
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|finished
operator|++
expr_stmt|;
if|if
condition|(
name|addSyncTrace
condition|)
block|{
name|addTimeAnnotation
argument_list|(
name|sync
argument_list|,
literal|"writer synced"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|finished
return|;
block|}
comment|// try advancing the highestSyncedTxid as much as possible
specifier|private
name|int
name|finishSync
parameter_list|(
name|boolean
name|addSyncTrace
parameter_list|)
block|{
if|if
condition|(
name|unackedAppends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// All outstanding appends have been acked.
if|if
condition|(
name|toWriteAppends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Also no appends that wait to be written out, then just finished all pending syncs.
name|long
name|maxSyncTxid
init|=
name|highestSyncedTxid
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
name|SyncFuture
name|sync
range|:
name|syncFutures
control|)
block|{
name|maxSyncTxid
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxSyncTxid
argument_list|,
name|sync
operator|.
name|getTxid
argument_list|()
argument_list|)
expr_stmt|;
name|sync
operator|.
name|done
argument_list|(
name|maxSyncTxid
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|addSyncTrace
condition|)
block|{
name|addTimeAnnotation
argument_list|(
name|sync
argument_list|,
literal|"writer synced"
argument_list|)
expr_stmt|;
block|}
block|}
name|highestSyncedTxid
operator|.
name|set
argument_list|(
name|maxSyncTxid
argument_list|)
expr_stmt|;
name|int
name|finished
init|=
name|syncFutures
operator|.
name|size
argument_list|()
decl_stmt|;
name|syncFutures
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|finished
return|;
block|}
else|else
block|{
comment|// There is no append between highestProcessedAppendTxid and lowestUnprocessedAppendTxid, so
comment|// if highestSyncedTxid>= highestProcessedAppendTxid, then all syncs whose txid are between
comment|// highestProcessedAppendTxid and lowestUnprocessedAppendTxid can be finished.
name|long
name|lowestUnprocessedAppendTxid
init|=
name|toWriteAppends
operator|.
name|peek
argument_list|()
operator|.
name|getTxid
argument_list|()
decl_stmt|;
assert|assert
name|lowestUnprocessedAppendTxid
operator|>
name|highestProcessedAppendTxid
assert|;
name|long
name|doneTxid
init|=
name|lowestUnprocessedAppendTxid
operator|-
literal|1
decl_stmt|;
name|highestSyncedTxid
operator|.
name|set
argument_list|(
name|doneTxid
argument_list|)
expr_stmt|;
return|return
name|finishSyncLowerThanTxid
argument_list|(
name|doneTxid
argument_list|,
name|addSyncTrace
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// There are still unacked appends. So let's move the highestSyncedTxid to the txid of the
comment|// first unacked append minus 1.
name|long
name|lowestUnackedAppendTxid
init|=
name|unackedAppends
operator|.
name|peek
argument_list|()
operator|.
name|getTxid
argument_list|()
decl_stmt|;
name|long
name|doneTxid
init|=
name|Math
operator|.
name|max
argument_list|(
name|lowestUnackedAppendTxid
operator|-
literal|1
argument_list|,
name|highestSyncedTxid
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|highestSyncedTxid
operator|.
name|set
argument_list|(
name|doneTxid
argument_list|)
expr_stmt|;
return|return
name|finishSyncLowerThanTxid
argument_list|(
name|doneTxid
argument_list|,
name|addSyncTrace
argument_list|)
return|;
block|}
block|}
specifier|private
name|void
name|appendAndSync
parameter_list|()
block|{
specifier|final
name|AsyncWriter
name|writer
init|=
name|this
operator|.
name|writer
decl_stmt|;
comment|// maybe a sync request is not queued when we issue a sync, so check here to see if we could
comment|// finish some.
name|finishSync
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|long
name|newHighestProcessedAppendTxid
init|=
operator|-
literal|1L
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|FSWALEntry
argument_list|>
name|iter
init|=
name|toWriteAppends
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|FSWALEntry
name|entry
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|appended
decl_stmt|;
try|try
block|{
name|appended
operator|=
name|append
argument_list|(
name|writer
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"should not happen"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|newHighestProcessedAppendTxid
operator|=
name|entry
operator|.
name|getTxid
argument_list|()
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|appended
condition|)
block|{
name|unackedAppends
operator|.
name|addLast
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|-
name|fileLengthAtLastSync
operator|>=
name|batchSize
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|// if we have a newer transaction id, update it.
comment|// otherwise, use the previous transaction id.
if|if
condition|(
name|newHighestProcessedAppendTxid
operator|>
literal|0
condition|)
block|{
name|highestProcessedAppendTxid
operator|=
name|newHighestProcessedAppendTxid
expr_stmt|;
block|}
else|else
block|{
name|newHighestProcessedAppendTxid
operator|=
name|highestProcessedAppendTxid
expr_stmt|;
block|}
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|-
name|fileLengthAtLastSync
operator|>=
name|batchSize
condition|)
block|{
comment|// sync because buffer size limit.
name|sync
argument_list|(
name|writer
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|==
name|fileLengthAtLastSync
condition|)
block|{
comment|// we haven't written anything out, just advance the highestSyncedSequence since we may only
comment|// stamped some region sequence id.
if|if
condition|(
name|unackedAppends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|highestSyncedTxid
operator|.
name|set
argument_list|(
name|highestProcessedAppendTxid
argument_list|)
expr_stmt|;
name|finishSync
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|trySetReadyForRolling
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|// reach here means that we have some unsynced data but haven't reached the batch size yet
comment|// but we will not issue a sync directly here even if there are sync requests because we may
comment|// have some new data in the ringbuffer, so let's just return here and delay the decision of
comment|// whether to issue a sync in the caller method.
block|}
specifier|private
name|void
name|consume
parameter_list|()
block|{
name|consumeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|currentEpochAndState
init|=
name|epochAndState
decl_stmt|;
if|if
condition|(
name|writerBroken
argument_list|(
name|currentEpochAndState
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|waitingRoll
argument_list|(
name|currentEpochAndState
argument_list|)
condition|)
block|{
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|>
name|fileLengthAtLastSync
condition|)
block|{
comment|// issue a sync
name|sync
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|unackedAppends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|readyForRolling
operator|=
literal|true
expr_stmt|;
name|readyForRollingCond
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
finally|finally
block|{
name|consumeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|long
name|nextCursor
init|=
name|waitingConsumePayloadsGatingSequence
operator|.
name|get
argument_list|()
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|long
name|cursorBound
init|=
name|waitingConsumePayloads
operator|.
name|getCursor
argument_list|()
init|;
name|nextCursor
operator|<=
name|cursorBound
condition|;
name|nextCursor
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|waitingConsumePayloads
operator|.
name|isPublished
argument_list|(
name|nextCursor
argument_list|)
condition|)
block|{
break|break;
block|}
name|RingBufferTruck
name|truck
init|=
name|waitingConsumePayloads
operator|.
name|get
argument_list|(
name|nextCursor
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|truck
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|APPEND
case|:
name|toWriteAppends
operator|.
name|addLast
argument_list|(
name|truck
operator|.
name|unloadAppend
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYNC
case|:
name|syncFutures
operator|.
name|add
argument_list|(
name|truck
operator|.
name|unloadSync
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"RingBufferTruck with unexpected type: "
operator|+
name|truck
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|waitingConsumePayloadsGatingSequence
operator|.
name|set
argument_list|(
name|nextCursor
argument_list|)
expr_stmt|;
block|}
name|appendAndSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|hasConsumerTask
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|toWriteAppends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|waitingConsumePayloadsGatingSequence
operator|.
name|get
argument_list|()
operator|==
name|waitingConsumePayloads
operator|.
name|getCursor
argument_list|()
condition|)
block|{
name|consumerScheduled
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// recheck here since in append and sync we do not hold the consumeLock. Thing may
comment|// happen like
comment|// 1. we check cursor, no new entry
comment|// 2. someone publishes a new entry to ringbuffer and the consumerScheduled is true and
comment|// give up scheduling the consumer task.
comment|// 3. we set consumerScheduled to false and also give up scheduling consumer task.
if|if
condition|(
name|waitingConsumePayloadsGatingSequence
operator|.
name|get
argument_list|()
operator|==
name|waitingConsumePayloads
operator|.
name|getCursor
argument_list|()
condition|)
block|{
comment|// we will give up consuming so if there are some unsynced data we need to issue a sync.
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|>
name|fileLengthAtLastSync
operator|&&
operator|!
name|syncFutures
operator|.
name|isEmpty
argument_list|()
operator|&&
name|syncFutures
operator|.
name|last
argument_list|()
operator|.
name|getTxid
argument_list|()
operator|>
name|highestProcessedAppendTxidAtLastSync
condition|)
block|{
comment|// no new data in the ringbuffer and we have at least one sync request
name|sync
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
comment|// maybe someone has grabbed this before us
if|if
condition|(
operator|!
name|consumerScheduled
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
block|}
comment|// reschedule if we still have something to write.
name|consumeExecutor
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|shouldScheduleConsumer
parameter_list|()
block|{
name|int
name|currentEpochAndState
init|=
name|epochAndState
decl_stmt|;
if|if
condition|(
name|writerBroken
argument_list|(
name|currentEpochAndState
argument_list|)
operator|||
name|waitingRoll
argument_list|(
name|currentEpochAndState
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|consumerScheduled
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|append
parameter_list|(
name|RegionInfo
name|hri
parameter_list|,
name|WALKeyImpl
name|key
parameter_list|,
name|WALEdit
name|edits
parameter_list|,
name|boolean
name|inMemstore
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|txid
init|=
name|stampSequenceIdAndPublishToRingBuffer
argument_list|(
name|hri
argument_list|,
name|key
argument_list|,
name|edits
argument_list|,
name|inMemstore
argument_list|,
name|waitingConsumePayloads
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldScheduleConsumer
argument_list|()
condition|)
block|{
name|consumeExecutor
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
return|return
name|txid
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"AsyncFSWAL.sync"
argument_list|)
init|)
block|{
name|long
name|txid
init|=
name|waitingConsumePayloads
operator|.
name|next
argument_list|()
decl_stmt|;
name|SyncFuture
name|future
decl_stmt|;
try|try
block|{
name|future
operator|=
name|getSyncFuture
argument_list|(
name|txid
argument_list|)
expr_stmt|;
name|RingBufferTruck
name|truck
init|=
name|waitingConsumePayloads
operator|.
name|get
argument_list|(
name|txid
argument_list|)
decl_stmt|;
name|truck
operator|.
name|load
argument_list|(
name|future
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|waitingConsumePayloads
operator|.
name|publish
argument_list|(
name|txid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shouldScheduleConsumer
argument_list|()
condition|)
block|{
name|consumeExecutor
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
name|blockOnSync
argument_list|(
name|future
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|(
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|highestSyncedTxid
operator|.
name|get
argument_list|()
operator|>=
name|txid
condition|)
block|{
return|return;
block|}
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"AsyncFSWAL.sync"
argument_list|)
init|)
block|{
comment|// here we do not use ring buffer sequence as txid
name|long
name|sequence
init|=
name|waitingConsumePayloads
operator|.
name|next
argument_list|()
decl_stmt|;
name|SyncFuture
name|future
decl_stmt|;
try|try
block|{
name|future
operator|=
name|getSyncFuture
argument_list|(
name|txid
argument_list|)
expr_stmt|;
name|RingBufferTruck
name|truck
init|=
name|waitingConsumePayloads
operator|.
name|get
argument_list|(
name|sequence
argument_list|)
decl_stmt|;
name|truck
operator|.
name|load
argument_list|(
name|future
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|waitingConsumePayloads
operator|.
name|publish
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shouldScheduleConsumer
argument_list|()
condition|)
block|{
name|consumeExecutor
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
name|blockOnSync
argument_list|(
name|future
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|AsyncWriter
name|createWriterInstance
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|AsyncFSWALProvider
operator|.
name|createAsyncWriter
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|path
argument_list|,
literal|false
argument_list|,
name|eventLoopGroup
argument_list|,
name|channelClass
argument_list|)
return|;
block|}
specifier|private
name|void
name|waitForSafePoint
parameter_list|()
block|{
name|consumeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|currentEpochAndState
init|=
name|epochAndState
decl_stmt|;
if|if
condition|(
name|writerBroken
argument_list|(
name|currentEpochAndState
argument_list|)
operator|||
name|this
operator|.
name|writer
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|consumerScheduled
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|epochAndState
operator|=
name|currentEpochAndState
operator||
literal|1
expr_stmt|;
name|readyForRolling
operator|=
literal|false
expr_stmt|;
name|consumeExecutor
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|readyForRolling
condition|)
block|{
name|readyForRollingCond
operator|.
name|awaitUninterruptibly
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|consumeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|long
name|doReplaceWriter
parameter_list|(
name|Path
name|oldPath
parameter_list|,
name|Path
name|newPath
parameter_list|,
name|AsyncWriter
name|nextWriter
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForSafePoint
argument_list|()
expr_stmt|;
specifier|final
name|AsyncWriter
name|oldWriter
init|=
name|this
operator|.
name|writer
decl_stmt|;
name|this
operator|.
name|writer
operator|=
name|nextWriter
expr_stmt|;
if|if
condition|(
name|nextWriter
operator|!=
literal|null
operator|&&
name|nextWriter
operator|instanceof
name|AsyncProtobufLogWriter
condition|)
block|{
name|this
operator|.
name|fsOut
operator|=
operator|(
operator|(
name|AsyncProtobufLogWriter
operator|)
name|nextWriter
operator|)
operator|.
name|getOutput
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|fileLengthAtLastSync
operator|=
name|nextWriter
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|this
operator|.
name|rollRequested
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|highestProcessedAppendTxidAtLastSync
operator|=
literal|0L
expr_stmt|;
name|consumeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|consumerScheduled
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|int
name|currentEpoch
init|=
name|epochAndState
operator|>>>
literal|2
decl_stmt|;
name|int
name|nextEpoch
init|=
name|currentEpoch
operator|==
name|MAX_EPOCH
condition|?
literal|0
else|:
name|currentEpoch
operator|+
literal|1
decl_stmt|;
comment|// set a new epoch and also clear waitingRoll and writerBroken
name|this
operator|.
name|epochAndState
operator|=
name|nextEpoch
operator|<<
literal|2
expr_stmt|;
name|consumeExecutor
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|consumeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|executeClose
argument_list|(
name|closeExecutor
argument_list|,
name|oldWriter
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doShutdown
parameter_list|()
throws|throws
name|IOException
block|{
name|waitForSafePoint
argument_list|()
expr_stmt|;
name|executeClose
argument_list|(
name|closeExecutor
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|closeExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|closeExecutor
operator|.
name|awaitTermination
argument_list|(
name|waitOnShutdownInSeconds
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"We have waited "
operator|+
name|waitOnShutdownInSeconds
operator|+
literal|" seconds but"
operator|+
literal|" the close of async writer doesn't complete."
operator|+
literal|"Please check the status of underlying filesystem"
operator|+
literal|" or increase the wait time by the config \""
operator|+
name|ASYNC_WAL_WAIT_ON_SHUTDOWN_IN_SECONDS
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The wait for close of async writer is interrupted"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|IOException
name|error
init|=
operator|new
name|IOException
argument_list|(
literal|"WAL has been closed"
argument_list|)
decl_stmt|;
name|long
name|nextCursor
init|=
name|waitingConsumePayloadsGatingSequence
operator|.
name|get
argument_list|()
operator|+
literal|1
decl_stmt|;
comment|// drain all the pending sync requests
for|for
control|(
name|long
name|cursorBound
init|=
name|waitingConsumePayloads
operator|.
name|getCursor
argument_list|()
init|;
name|nextCursor
operator|<=
name|cursorBound
condition|;
name|nextCursor
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|waitingConsumePayloads
operator|.
name|isPublished
argument_list|(
name|nextCursor
argument_list|)
condition|)
block|{
break|break;
block|}
name|RingBufferTruck
name|truck
init|=
name|waitingConsumePayloads
operator|.
name|get
argument_list|(
name|nextCursor
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|truck
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|SYNC
case|:
name|syncFutures
operator|.
name|add
argument_list|(
name|truck
operator|.
name|unloadSync
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|// and fail them
name|syncFutures
operator|.
name|forEach
argument_list|(
name|f
lambda|->
name|f
operator|.
name|done
argument_list|(
name|f
operator|.
name|getTxid
argument_list|()
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|consumeExecutor
operator|instanceof
name|EventLoop
operator|)
condition|)
block|{
name|consumeExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|long
name|executeClose
parameter_list|(
name|ExecutorService
name|closeExecutor
parameter_list|,
name|AsyncWriter
name|writer
parameter_list|)
block|{
name|long
name|fileLength
decl_stmt|;
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|fileLength
operator|=
name|writer
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|closeExecutor
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"close old writer failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fileLength
operator|=
literal|0L
expr_stmt|;
block|}
return|return
name|fileLength
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doAppend
parameter_list|(
name|AsyncWriter
name|writer
parameter_list|,
name|FSWALEntry
name|entry
parameter_list|)
block|{
name|writer
operator|.
name|append
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|DatanodeInfo
index|[]
name|getPipeline
parameter_list|()
block|{
name|AsyncFSOutput
name|output
init|=
name|this
operator|.
name|fsOut
decl_stmt|;
return|return
name|output
operator|!=
literal|null
condition|?
name|output
operator|.
name|getPipeline
argument_list|()
else|:
operator|new
name|DatanodeInfo
index|[
literal|0
index|]
return|;
block|}
annotation|@
name|Override
name|int
name|getLogReplication
parameter_list|()
block|{
return|return
name|getPipeline
argument_list|()
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|doCheckLogLowReplication
parameter_list|()
block|{
comment|// not like FSHLog, AsyncFSOutput will fail immediately if there are errors writing to DNs, so
comment|// typically there is no 'low replication' state, only a 'broken' state.
name|AsyncFSOutput
name|output
init|=
name|this
operator|.
name|fsOut
decl_stmt|;
return|return
name|output
operator|!=
literal|null
operator|&&
name|output
operator|.
name|isBroken
argument_list|()
return|;
block|}
block|}
end_class

end_unit

