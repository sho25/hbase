begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
operator|.
name|REGION_SERVER_HANDLER_COUNT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|shouldRetryCreate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|EventLoop
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Promise
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseInterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|AsyncFSOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|NameNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|AsyncFSWALProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALProvider
operator|.
name|AsyncWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|NullScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|Trace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|TraceScope
import|;
end_import

begin_comment
comment|/**  * An asynchronous implementation of FSWAL.  *<p>  * Here 'waitingConsumePayloads' acts as the RingBuffer in FSHLog. We do not use RingBuffer here  * because RingBuffer need an exclusive thread to consume the entries in it, and here we want to run  * the append and sync operation inside EventLoop. We can not use EventLoop as the RingBuffer's  * executor otherwise the EventLoop can not process any other events such as socket read and write.  *<p>  * For append, we process it as follow:  *<ol>  *<li>In the caller thread(typically, in the rpc handler thread):  *<ol>  *<li>Lock 'waitingConsumePayloads', bump nextTxid, and insert the entry to  * 'waitingConsumePayloads'.</li>  *<li>Schedule the consumer task if needed. See {@link #shouldScheduleConsumer()} for more details.  *</li>  *</ol>  *</li>  *<li>In the consumer task(in the EventLoop thread)  *<ol>  *<li>Poll the entry from 'waitingConsumePayloads' and insert it into 'waitingAppendEntries'</li>  *<li>Poll the entry from 'waitingAppendEntries', append it to the AsyncWriter, and insert it into  * 'unackedEntries'</li>  *<li>If the buffered size reaches {@link #batchSize}, or there is a sync request, then we call  * sync on the AsyncWriter.</li>  *<li>In the callback methods(CompletionHandler):  *<ul>  *<li>If succeeded, poll the entry from 'unackedEntries' and drop it.</li>  *<li>If failed, add all the entries in 'unackedEntries' back to 'waitingAppendEntries' and wait  * for writing them again.</li>  *</ul>  *</li>  *</ol>  *</li>  *</ol>  * For sync, the processing stages are almost same except that if it is not assigned with a new  * 'txid', we just assign the previous 'txid' to it without bumping the 'nextTxid'. And different  * from FSHLog, we will open a new writer and rewrite unacked entries to the new writer and sync  * again if we hit a sync error.  *<p>  * Here we only describe the logic of doReplaceWriter. The main logic of rollWriter is same with  * FSHLog.<br>  * For a normal roll request(for example, we have reached the log roll size):  *<ol>  *<li>In the log roller thread, we add a roll payload to 'waitingConsumePayloads', and then wait on  * the rollPromise(see {@link #waitForSafePoint()}).</li>  *<li>In the consumer thread, we will stop polling entries from 'waitingConsumePayloads' if we hit  * a Payload which contains a roll request.</li>  *<li>Append all entries to current writer, issue a sync request if possible.</li>  *<li>If sync succeeded, check if we could finish a roll request. There 3 conditions:  *<ul>  *<li>'rollPromise' is not null which means we have a pending roll request.</li>  *<li>'waitingAppendEntries' is empty.</li>  *<li>'unackedEntries' is empty.</li>  *</ul>  *</li>  *<li>Back to the log roller thread, now we can confirm that there are no out-going entries, i.e.,  * we reach a safe point. So it is safe to replace old writer with new writer now.</li>  *<li>Acquire 'waitingConsumePayloads' lock, set 'writerBroken' and 'waitingRoll' to false, cancel  * log roller exit checker if any(see the comments in the 'failed' method of the sync  * CompletionHandler to see why we need a checker here).</li>  *<li>Schedule the consumer task if needed.</li>  *<li>Schedule a background task to close the old writer.</li>  *</ol>  * For a broken writer roll request, the only difference is that we can bypass the wait for safe  * point stage. See the comments in the 'failed' method of the sync CompletionHandler for more  * details.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|CONFIG
argument_list|)
specifier|public
class|class
name|AsyncFSWAL
extends|extends
name|AbstractFSWAL
argument_list|<
name|AsyncWriter
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AsyncFSWAL
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|WAL_BATCH_SIZE
init|=
literal|"hbase.wal.batch.size"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_WAL_BATCH_SIZE
init|=
literal|64L
operator|*
literal|1024
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASYNC_WAL_CREATE_MAX_RETRIES
init|=
literal|"hbase.wal.async.create.retries"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_ASYNC_WAL_CREATE_MAX_RETRIES
init|=
literal|10
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASYNC_WAL_LOG_ROLLER_EXITED_CHECK_INTERVAL_MS
init|=
literal|"hbase.wal.async.logroller.exited.check.interval.ms"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_ASYNC_WAL_LOG_ROLLER_EXITED_CHECK_INTERVAL_MS
init|=
literal|1000
decl_stmt|;
comment|/**    * Carry things that we want to pass to the consume task in event loop. Only one field can be    * non-null.    *<p>    * TODO: need to unify this and {@link RingBufferTruck}. There are mostly the same thing.    */
specifier|private
specifier|static
specifier|final
class|class
name|Payload
block|{
comment|// a wal entry which need to be appended
specifier|public
specifier|final
name|FSWALEntry
name|entry
decl_stmt|;
comment|// indicate that we need to sync our wal writer.
specifier|public
specifier|final
name|SyncFuture
name|sync
decl_stmt|;
comment|// incidate that we want to roll the writer.
specifier|public
specifier|final
name|Promise
argument_list|<
name|Void
argument_list|>
name|roll
decl_stmt|;
specifier|public
name|Payload
parameter_list|(
name|FSWALEntry
name|entry
parameter_list|)
block|{
name|this
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
name|this
operator|.
name|sync
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|roll
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|Payload
parameter_list|(
name|SyncFuture
name|sync
parameter_list|)
block|{
name|this
operator|.
name|entry
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|sync
operator|=
name|sync
expr_stmt|;
name|this
operator|.
name|roll
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|Payload
parameter_list|(
name|Promise
argument_list|<
name|Void
argument_list|>
name|roll
parameter_list|)
block|{
name|this
operator|.
name|entry
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|sync
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|roll
operator|=
name|roll
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Payload [entry="
operator|+
name|entry
operator|+
literal|", sync="
operator|+
name|sync
operator|+
literal|", roll="
operator|+
name|roll
operator|+
literal|"]"
return|;
block|}
block|}
specifier|private
specifier|final
name|EventLoop
name|eventLoop
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|Payload
argument_list|>
name|waitingConsumePayloads
decl_stmt|;
comment|// like the ringbuffer sequence. Every FSWALEntry and SyncFuture will be assigned a txid and
comment|// then added to waitingConsumePayloads.
specifier|private
name|long
name|nextTxid
init|=
literal|1L
decl_stmt|;
specifier|private
name|boolean
name|consumerScheduled
decl_stmt|;
comment|// new writer is created and we are waiting for old writer to be closed.
specifier|private
name|boolean
name|waitingRoll
decl_stmt|;
comment|// writer is broken and rollWriter is needed.
specifier|private
name|boolean
name|writerBroken
decl_stmt|;
specifier|private
specifier|final
name|long
name|batchSize
decl_stmt|;
specifier|private
specifier|final
name|int
name|createMaxRetries
decl_stmt|;
specifier|private
specifier|final
name|long
name|logRollerExitedCheckIntervalMs
decl_stmt|;
specifier|private
specifier|final
name|ExecutorService
name|closeExecutor
init|=
name|Executors
operator|.
name|newCachedThreadPool
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"Close-WAL-Writer-%d"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|AsyncFSOutput
name|fsOut
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|FSWALEntry
argument_list|>
name|waitingAppendEntries
init|=
operator|new
name|ArrayDeque
argument_list|<
name|FSWALEntry
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|FSWALEntry
argument_list|>
name|unackedEntries
init|=
operator|new
name|ArrayDeque
argument_list|<
name|FSWALEntry
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|PriorityQueue
argument_list|<
name|SyncFuture
argument_list|>
name|syncFutures
init|=
operator|new
name|PriorityQueue
argument_list|<
name|SyncFuture
argument_list|>
argument_list|(
literal|11
argument_list|,
name|SEQ_COMPARATOR
argument_list|)
decl_stmt|;
specifier|private
name|Promise
argument_list|<
name|Void
argument_list|>
name|rollPromise
decl_stmt|;
comment|// the highest txid of WAL entries being processed
specifier|private
name|long
name|highestProcessedTxid
decl_stmt|;
comment|// file length when we issue last sync request on the writer
specifier|private
name|long
name|fileLengthAtLastSync
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|logRollerExited
decl_stmt|;
specifier|private
specifier|final
class|class
name|LogRollerExitedChecker
implements|implements
name|Runnable
block|{
specifier|private
name|boolean
name|cancelled
decl_stmt|;
specifier|private
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|future
decl_stmt|;
specifier|public
specifier|synchronized
name|void
name|setFuture
parameter_list|(
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|)
block|{
name|this
operator|.
name|future
operator|=
name|future
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
operator|!
name|logRollerExited
condition|)
block|{
return|return;
block|}
comment|// rollWriter is called in the log roller thread, and logRollerExited will be set just before
comment|// the log rolled exit. So here we can confirm that no one could cancel us if the 'canceled'
comment|// check passed. So it is safe to release the lock after checking 'canceled' flag.
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|cancelled
condition|)
block|{
return|return;
block|}
block|}
name|unackedEntries
operator|.
name|clear
argument_list|()
expr_stmt|;
name|waitingAppendEntries
operator|.
name|clear
argument_list|()
expr_stmt|;
name|IOException
name|error
init|=
operator|new
name|IOException
argument_list|(
literal|"sync failed but log roller exited"
argument_list|)
decl_stmt|;
for|for
control|(
name|SyncFuture
name|future
init|;
operator|(
name|future
operator|=
name|syncFutures
operator|.
name|peek
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|future
operator|.
name|done
argument_list|(
name|highestProcessedTxid
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|syncFutures
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|waitingConsumePayloads
init|)
block|{
for|for
control|(
name|Payload
name|p
range|:
name|waitingConsumePayloads
control|)
block|{
if|if
condition|(
name|p
operator|.
name|entry
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|p
operator|.
name|entry
operator|.
name|stampRegionSequenceId
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"should not happen"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|.
name|sync
operator|!=
literal|null
condition|)
block|{
name|p
operator|.
name|sync
operator|.
name|done
argument_list|(
name|nextTxid
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
name|waitingConsumePayloads
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
specifier|synchronized
name|void
name|cancel
parameter_list|()
block|{
name|future
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|cancelled
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|private
name|LogRollerExitedChecker
name|logRollerExitedChecker
decl_stmt|;
specifier|public
name|AsyncFSWAL
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|rootDir
parameter_list|,
name|String
name|logDir
parameter_list|,
name|String
name|archiveDir
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|List
argument_list|<
name|WALActionsListener
argument_list|>
name|listeners
parameter_list|,
name|boolean
name|failIfWALExists
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|,
name|EventLoop
name|eventLoop
parameter_list|)
throws|throws
name|FailedLogCloseException
throws|,
name|IOException
block|{
name|super
argument_list|(
name|fs
argument_list|,
name|rootDir
argument_list|,
name|logDir
argument_list|,
name|archiveDir
argument_list|,
name|conf
argument_list|,
name|listeners
argument_list|,
name|failIfWALExists
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|this
operator|.
name|eventLoop
operator|=
name|eventLoop
expr_stmt|;
name|int
name|maxHandlersCount
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|REGION_SERVER_HANDLER_COUNT
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|waitingConsumePayloads
operator|=
operator|new
name|ArrayDeque
argument_list|<
name|Payload
argument_list|>
argument_list|(
name|maxHandlersCount
operator|*
literal|3
argument_list|)
expr_stmt|;
name|batchSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|WAL_BATCH_SIZE
argument_list|,
name|DEFAULT_WAL_BATCH_SIZE
argument_list|)
expr_stmt|;
name|createMaxRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|ASYNC_WAL_CREATE_MAX_RETRIES
argument_list|,
name|DEFAULT_ASYNC_WAL_CREATE_MAX_RETRIES
argument_list|)
expr_stmt|;
name|logRollerExitedCheckIntervalMs
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|ASYNC_WAL_LOG_ROLLER_EXITED_CHECK_INTERVAL_MS
argument_list|,
name|DEFAULT_ASYNC_WAL_LOG_ROLLER_EXITED_CHECK_INTERVAL_MS
argument_list|)
expr_stmt|;
name|rollWriter
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|tryFinishRoll
parameter_list|()
block|{
comment|// 1. a roll is requested
comment|// 2. we have written out all entries before the roll point.
comment|// 3. all entries have been acked.
if|if
condition|(
name|rollPromise
operator|!=
literal|null
operator|&&
name|waitingAppendEntries
operator|.
name|isEmpty
argument_list|()
operator|&&
name|unackedEntries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|rollPromise
operator|.
name|trySuccess
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|rollPromise
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|syncFailed
parameter_list|(
name|Throwable
name|error
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"sync failed"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|// Here we depends on the implementation of FanOutOneBlockAsyncDFSOutput and netty.
comment|// When error occur, FanOutOneBlockAsyncDFSOutput will fail all pending flush requests. It
comment|// is execute inside EventLoop. And in DefaultPromise in netty, it will notifyListener
comment|// directly if it is already in the EventLoop thread. And in the listener method, it will
comment|// call us. So here we know that all failed flush request will call us continuously, and
comment|// before the last one finish, no other task can be executed in EventLoop. So here we are
comment|// safe to use writerBroken as a guard.
comment|// Do not forget to revisit this if we change the implementation of
comment|// FanOutOneBlockAsyncDFSOutput!
synchronized|synchronized
init|(
name|waitingConsumePayloads
init|)
block|{
if|if
condition|(
name|writerBroken
condition|)
block|{
return|return;
block|}
comment|// schedule a periodical task to check if log roller is exited. Otherwise the the sync
comment|// request maybe blocked forever since we are still waiting for a new writer to write the
comment|// pending data and sync it...
name|logRollerExitedChecker
operator|=
operator|new
name|LogRollerExitedChecker
argument_list|()
expr_stmt|;
comment|// we are currently in the EventLoop thread, so it is safe to set the future after
comment|// schedule it since the task can not be executed before we release the thread.
name|logRollerExitedChecker
operator|.
name|setFuture
argument_list|(
name|eventLoop
operator|.
name|scheduleAtFixedRate
argument_list|(
name|logRollerExitedChecker
argument_list|,
name|logRollerExitedCheckIntervalMs
argument_list|,
name|logRollerExitedCheckIntervalMs
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|writerBroken
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|FSWALEntry
argument_list|>
name|iter
init|=
name|unackedEntries
operator|.
name|descendingIterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|waitingAppendEntries
operator|.
name|addFirst
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|highestUnsyncedTxid
operator|=
name|highestSyncedTxid
operator|.
name|get
argument_list|()
expr_stmt|;
if|if
condition|(
name|rollPromise
operator|!=
literal|null
condition|)
block|{
name|rollPromise
operator|.
name|trySuccess
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|rollPromise
operator|=
literal|null
expr_stmt|;
return|return;
block|}
comment|// request a roll.
if|if
condition|(
operator|!
name|rollWriterLock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
return|return;
block|}
try|try
block|{
name|requestLogRoll
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|rollWriterLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|syncCompleted
parameter_list|(
name|AsyncWriter
name|writer
parameter_list|,
name|long
name|processedTxid
parameter_list|,
name|long
name|startTimeNs
parameter_list|)
block|{
name|highestSyncedTxid
operator|.
name|set
argument_list|(
name|processedTxid
argument_list|)
expr_stmt|;
name|int
name|syncCount
init|=
name|finishSync
argument_list|(
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|FSWALEntry
argument_list|>
name|iter
init|=
name|unackedEntries
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|getTxid
argument_list|()
operator|<=
name|processedTxid
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|postSync
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNs
argument_list|,
name|syncCount
argument_list|)
expr_stmt|;
name|tryFinishRoll
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rollWriterLock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
return|return;
block|}
try|try
block|{
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|>=
name|logrollsize
condition|)
block|{
name|requestLogRoll
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|rollWriterLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|sync
parameter_list|(
specifier|final
name|AsyncWriter
name|writer
parameter_list|,
specifier|final
name|long
name|processedTxid
parameter_list|)
block|{
name|fileLengthAtLastSync
operator|=
name|writer
operator|.
name|getLength
argument_list|()
expr_stmt|;
specifier|final
name|long
name|startTimeNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|writer
operator|.
name|sync
argument_list|()
operator|.
name|whenComplete
argument_list|(
parameter_list|(
name|result
parameter_list|,
name|error
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|error
operator|!=
literal|null
condition|)
block|{
name|syncFailed
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syncCompleted
argument_list|(
name|writer
argument_list|,
name|processedTxid
argument_list|,
name|startTimeNs
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addTimeAnnotation
parameter_list|(
name|SyncFuture
name|future
parameter_list|,
name|String
name|annotation
parameter_list|)
block|{
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|continueSpan
argument_list|(
name|future
operator|.
name|getSpan
argument_list|()
argument_list|)
decl_stmt|;
name|Trace
operator|.
name|addTimelineAnnotation
argument_list|(
name|annotation
argument_list|)
expr_stmt|;
name|future
operator|.
name|setSpan
argument_list|(
name|scope
operator|.
name|detach
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|finishSync
parameter_list|(
name|boolean
name|addSyncTrace
parameter_list|)
block|{
name|long
name|doneTxid
init|=
name|highestSyncedTxid
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
name|finished
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SyncFuture
name|future
init|;
operator|(
name|future
operator|=
name|syncFutures
operator|.
name|peek
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
if|if
condition|(
name|future
operator|.
name|getTxid
argument_list|()
operator|<=
name|doneTxid
condition|)
block|{
name|future
operator|.
name|done
argument_list|(
name|doneTxid
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|syncFutures
operator|.
name|remove
argument_list|()
expr_stmt|;
name|finished
operator|++
expr_stmt|;
name|addTimeAnnotation
argument_list|(
name|future
argument_list|,
literal|"writer synced"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|finished
return|;
block|}
specifier|private
name|void
name|consume
parameter_list|()
block|{
specifier|final
name|AsyncWriter
name|writer
init|=
name|this
operator|.
name|writer
decl_stmt|;
comment|// maybe a sync request is not queued when we issue a sync, so check here to see if we could
comment|// finish some.
name|finishSync
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|long
name|newHighestProcessedTxid
init|=
operator|-
literal|1L
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|FSWALEntry
argument_list|>
name|iter
init|=
name|waitingAppendEntries
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|FSWALEntry
name|entry
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|appended
decl_stmt|;
try|try
block|{
name|appended
operator|=
name|append
argument_list|(
name|writer
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"should not happen"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|newHighestProcessedTxid
operator|=
name|entry
operator|.
name|getTxid
argument_list|()
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|appended
condition|)
block|{
name|unackedEntries
operator|.
name|addLast
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|-
name|fileLengthAtLastSync
operator|>=
name|batchSize
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|// if we have a newer transaction id, update it.
comment|// otherwise, use the previous transaction id.
if|if
condition|(
name|newHighestProcessedTxid
operator|>
literal|0
condition|)
block|{
name|highestProcessedTxid
operator|=
name|newHighestProcessedTxid
expr_stmt|;
block|}
else|else
block|{
name|newHighestProcessedTxid
operator|=
name|highestProcessedTxid
expr_stmt|;
block|}
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|-
name|fileLengthAtLastSync
operator|>=
name|batchSize
condition|)
block|{
comment|// sync because buffer size limit.
name|sync
argument_list|(
name|writer
argument_list|,
name|newHighestProcessedTxid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|syncFutures
operator|.
name|isEmpty
argument_list|()
operator|||
name|rollPromise
operator|!=
literal|null
operator|)
operator|&&
name|writer
operator|.
name|getLength
argument_list|()
operator|>
name|fileLengthAtLastSync
condition|)
block|{
comment|// first we should have at least one sync request or a roll request
comment|// second we should have some unsynced data.
name|sync
argument_list|(
name|writer
argument_list|,
name|newHighestProcessedTxid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|==
name|fileLengthAtLastSync
condition|)
block|{
comment|// we haven't written anything out, just advance the highestSyncedSequence since we may only
comment|// stamped some region sequence id.
name|highestSyncedTxid
operator|.
name|set
argument_list|(
name|newHighestProcessedTxid
argument_list|)
expr_stmt|;
name|finishSync
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|tryFinishRoll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|SyncFuture
argument_list|>
name|SEQ_COMPARATOR
init|=
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
block|{
name|int
name|c
init|=
name|Long
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|getTxid
argument_list|()
argument_list|,
name|o2
operator|.
name|getTxid
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|c
operator|!=
literal|0
condition|?
name|c
else|:
name|Integer
operator|.
name|compare
argument_list|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|o1
argument_list|)
argument_list|,
name|System
operator|.
name|identityHashCode
argument_list|(
name|o2
argument_list|)
argument_list|)
return|;
block|}
decl_stmt|;
specifier|private
specifier|final
name|Runnable
name|consumer
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
synchronized|synchronized
init|(
name|waitingConsumePayloads
init|)
block|{
assert|assert
name|consumerScheduled
assert|;
if|if
condition|(
name|writerBroken
condition|)
block|{
comment|// waiting for reschedule after rollWriter.
name|consumerScheduled
operator|=
literal|false
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|waitingRoll
condition|)
block|{
comment|// we may have toWriteEntries if the consume method does not write all pending entries
comment|// out, this is usually happen if we have too many toWriteEntries that exceeded the
comment|// batchSize limit.
if|if
condition|(
name|waitingAppendEntries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|consumerScheduled
operator|=
literal|false
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
for|for
control|(
name|Payload
name|p
init|;
operator|(
name|p
operator|=
name|waitingConsumePayloads
operator|.
name|pollFirst
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|.
name|entry
operator|!=
literal|null
condition|)
block|{
name|waitingAppendEntries
operator|.
name|addLast
argument_list|(
name|p
operator|.
name|entry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|.
name|sync
operator|!=
literal|null
condition|)
block|{
name|syncFutures
operator|.
name|add
argument_list|(
name|p
operator|.
name|sync
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rollPromise
operator|=
name|p
operator|.
name|roll
expr_stmt|;
name|waitingRoll
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|consume
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|waitingConsumePayloads
init|)
block|{
if|if
condition|(
name|waitingRoll
condition|)
block|{
if|if
condition|(
name|waitingAppendEntries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|consumerScheduled
operator|=
literal|false
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|waitingConsumePayloads
operator|.
name|isEmpty
argument_list|()
operator|&&
name|waitingAppendEntries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|consumerScheduled
operator|=
literal|false
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// reschedule if we still have something to write.
name|eventLoop
operator|.
name|execute
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
specifier|private
name|boolean
name|shouldScheduleConsumer
parameter_list|()
block|{
if|if
condition|(
name|writerBroken
operator|||
name|waitingRoll
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|consumerScheduled
condition|)
block|{
return|return
literal|false
return|;
block|}
name|consumerScheduled
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|append
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|,
name|WALKey
name|key
parameter_list|,
name|WALEdit
name|edits
parameter_list|,
name|boolean
name|inMemstore
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|scheduleTask
decl_stmt|;
name|long
name|txid
decl_stmt|;
synchronized|synchronized
init|(
name|waitingConsumePayloads
init|)
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot append; log is closed"
argument_list|)
throw|;
block|}
name|txid
operator|=
name|nextTxid
operator|++
expr_stmt|;
name|FSWALEntry
name|entry
init|=
operator|new
name|FSWALEntry
argument_list|(
name|txid
argument_list|,
name|key
argument_list|,
name|edits
argument_list|,
name|hri
argument_list|,
name|inMemstore
argument_list|)
decl_stmt|;
name|scheduleTask
operator|=
name|shouldScheduleConsumer
argument_list|()
expr_stmt|;
name|waitingConsumePayloads
operator|.
name|add
argument_list|(
operator|new
name|Payload
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scheduleTask
condition|)
block|{
name|eventLoop
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
return|return
name|txid
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"AsyncFSWAL.sync"
argument_list|)
decl_stmt|;
try|try
block|{
name|SyncFuture
name|future
decl_stmt|;
name|boolean
name|scheduleTask
decl_stmt|;
synchronized|synchronized
init|(
name|waitingConsumePayloads
init|)
block|{
name|scheduleTask
operator|=
name|shouldScheduleConsumer
argument_list|()
expr_stmt|;
name|future
operator|=
name|getSyncFuture
argument_list|(
name|nextTxid
operator|-
literal|1
argument_list|,
name|scope
operator|.
name|detach
argument_list|()
argument_list|)
expr_stmt|;
name|waitingConsumePayloads
operator|.
name|addLast
argument_list|(
operator|new
name|Payload
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scheduleTask
condition|)
block|{
name|eventLoop
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
name|scope
operator|=
name|Trace
operator|.
name|continueSpan
argument_list|(
name|blockOnSync
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
assert|assert
name|scope
operator|==
name|NullScope
operator|.
name|INSTANCE
operator|||
operator|!
name|scope
operator|.
name|isDetached
argument_list|()
assert|;
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|(
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|highestSyncedTxid
operator|.
name|get
argument_list|()
operator|>=
name|txid
condition|)
block|{
return|return;
block|}
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"AsyncFSWAL.sync"
argument_list|)
decl_stmt|;
try|try
block|{
name|SyncFuture
name|future
init|=
name|getSyncFuture
argument_list|(
name|txid
argument_list|,
name|scope
operator|.
name|detach
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|scheduleTask
decl_stmt|;
synchronized|synchronized
init|(
name|waitingConsumePayloads
init|)
block|{
name|scheduleTask
operator|=
name|shouldScheduleConsumer
argument_list|()
expr_stmt|;
name|waitingConsumePayloads
operator|.
name|addLast
argument_list|(
operator|new
name|Payload
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scheduleTask
condition|)
block|{
name|eventLoop
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
name|scope
operator|=
name|Trace
operator|.
name|continueSpan
argument_list|(
name|blockOnSync
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
assert|assert
name|scope
operator|==
name|NullScope
operator|.
name|INSTANCE
operator|||
operator|!
name|scope
operator|.
name|isDetached
argument_list|()
assert|;
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|logRollerExited
parameter_list|()
block|{
name|logRollerExited
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|AsyncWriter
name|createWriterInstance
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|overwrite
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|retry
init|=
literal|0
init|;
condition|;
name|retry
operator|++
control|)
block|{
try|try
block|{
return|return
name|AsyncFSWALProvider
operator|.
name|createAsyncWriter
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|path
argument_list|,
name|overwrite
argument_list|,
name|eventLoop
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"create wal log writer "
operator|+
name|path
operator|+
literal|" failed, retry = "
operator|+
name|retry
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldRetryCreate
argument_list|(
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
name|retry
operator|>=
name|createMaxRetries
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
throw|throw
name|e
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|NameNodeException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"create wal log writer "
operator|+
name|path
operator|+
literal|" failed, retry = "
operator|+
name|retry
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
operator|>=
name|createMaxRetries
condition|)
block|{
break|break;
block|}
comment|// overwrite the old broken file.
name|overwrite
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|ConnectionUtils
operator|.
name|getPauseTime
argument_list|(
literal|100
argument_list|,
name|retry
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
block|}
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to create wal log writer "
operator|+
name|path
operator|+
literal|" after retrying "
operator|+
name|createMaxRetries
operator|+
literal|" time(s)"
argument_list|)
throw|;
block|}
specifier|private
name|void
name|waitForSafePoint
parameter_list|()
block|{
name|Future
argument_list|<
name|Void
argument_list|>
name|roll
decl_stmt|;
name|boolean
name|scheduleTask
decl_stmt|;
synchronized|synchronized
init|(
name|waitingConsumePayloads
init|)
block|{
if|if
condition|(
operator|!
name|writerBroken
operator|&&
name|this
operator|.
name|writer
operator|!=
literal|null
condition|)
block|{
name|Promise
argument_list|<
name|Void
argument_list|>
name|promise
init|=
name|eventLoop
operator|.
name|newPromise
argument_list|()
decl_stmt|;
if|if
condition|(
name|consumerScheduled
condition|)
block|{
name|scheduleTask
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|scheduleTask
operator|=
name|consumerScheduled
operator|=
literal|true
expr_stmt|;
block|}
name|waitingConsumePayloads
operator|.
name|addLast
argument_list|(
operator|new
name|Payload
argument_list|(
name|promise
argument_list|)
argument_list|)
expr_stmt|;
name|roll
operator|=
name|promise
expr_stmt|;
block|}
else|else
block|{
name|roll
operator|=
name|eventLoop
operator|.
name|newSucceededFuture
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|scheduleTask
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scheduleTask
condition|)
block|{
name|eventLoop
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
name|roll
operator|.
name|awaitUninterruptibly
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|long
name|doReplaceWriter
parameter_list|(
name|Path
name|oldPath
parameter_list|,
name|Path
name|newPath
parameter_list|,
name|AsyncWriter
name|nextWriter
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForSafePoint
argument_list|()
expr_stmt|;
specifier|final
name|AsyncWriter
name|oldWriter
init|=
name|this
operator|.
name|writer
decl_stmt|;
name|this
operator|.
name|writer
operator|=
name|nextWriter
expr_stmt|;
if|if
condition|(
name|nextWriter
operator|!=
literal|null
operator|&&
name|nextWriter
operator|instanceof
name|AsyncProtobufLogWriter
condition|)
block|{
name|this
operator|.
name|fsOut
operator|=
operator|(
operator|(
name|AsyncProtobufLogWriter
operator|)
name|nextWriter
operator|)
operator|.
name|getOutput
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|fileLengthAtLastSync
operator|=
literal|0L
expr_stmt|;
name|boolean
name|scheduleTask
decl_stmt|;
synchronized|synchronized
init|(
name|waitingConsumePayloads
init|)
block|{
name|writerBroken
operator|=
name|waitingRoll
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|logRollerExitedChecker
operator|!=
literal|null
condition|)
block|{
name|logRollerExitedChecker
operator|.
name|cancel
argument_list|()
expr_stmt|;
name|logRollerExitedChecker
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|consumerScheduled
condition|)
block|{
name|scheduleTask
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|waitingConsumePayloads
operator|.
name|isEmpty
argument_list|()
operator|&&
name|waitingAppendEntries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|scheduleTask
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|scheduleTask
operator|=
name|consumerScheduled
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|scheduleTask
condition|)
block|{
name|eventLoop
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
name|long
name|oldFileLen
decl_stmt|;
if|if
condition|(
name|oldWriter
operator|!=
literal|null
condition|)
block|{
name|oldFileLen
operator|=
name|oldWriter
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|closeExecutor
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
name|oldWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"close old writer failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oldFileLen
operator|=
literal|0L
expr_stmt|;
block|}
return|return
name|oldFileLen
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doShutdown
parameter_list|()
throws|throws
name|IOException
block|{
name|waitForSafePoint
argument_list|()
expr_stmt|;
name|this
operator|.
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|writer
operator|=
literal|null
expr_stmt|;
name|closeExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doAppend
parameter_list|(
name|AsyncWriter
name|writer
parameter_list|,
name|FSWALEntry
name|entry
parameter_list|)
block|{
name|writer
operator|.
name|append
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|DatanodeInfo
index|[]
name|getPipeline
parameter_list|()
block|{
name|AsyncFSOutput
name|output
init|=
name|this
operator|.
name|fsOut
decl_stmt|;
return|return
name|output
operator|!=
literal|null
condition|?
name|output
operator|.
name|getPipeline
argument_list|()
else|:
operator|new
name|DatanodeInfo
index|[
literal|0
index|]
return|;
block|}
annotation|@
name|Override
name|int
name|getLogReplication
parameter_list|()
block|{
return|return
name|getPipeline
argument_list|()
operator|.
name|length
return|;
block|}
block|}
end_class

end_unit

