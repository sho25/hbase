begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|shouldRetryCreate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|RingBuffer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|Sequence
import|;
end_import

begin_import
import|import
name|com
operator|.
name|lmax
operator|.
name|disruptor
operator|.
name|Sequencer
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|Channel
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|EventLoop
import|;
end_import

begin_import
import|import
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SingleThreadEventExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseInterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|AsyncFSOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|asyncfs
operator|.
name|FanOutOneBlockAsyncDFSOutputHelper
operator|.
name|NameNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|AsyncFSWALProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALProvider
operator|.
name|AsyncWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|NullScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|Span
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|Trace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|TraceScope
import|;
end_import

begin_comment
comment|/**  * An asynchronous implementation of FSWAL.  *<p>  * Here 'waitingConsumePayloads' acts as the RingBuffer in FSHLog.  *<p>  * For append, we process it as follow:  *<ol>  *<li>In the caller thread(typically, in the rpc handler thread):  *<ol>  *<li>Insert the entry into 'waitingConsumePayloads'. Use ringbuffer sequence as txid.</li>  *<li>Schedule the consumer task if needed. See {@link #shouldScheduleConsumer()} for more details.  *</li>  *</ol>  *</li>  *<li>In the consumer task(in the EventLoop thread)  *<ol>  *<li>Poll the entry from {@link #waitingConsumePayloads} and insert it into  * {@link #toWriteAppends}</li>  *<li>Poll the entry from {@link #toWriteAppends}, append it to the AsyncWriter, and insert it into  * {@link #unackedAppends}</li>  *<li>If the buffered size reaches {@link #batchSize}, or there is a sync request, then we call  * sync on the AsyncWriter.</li>  *<li>In the callback methods:  *<ul>  *<li>If succeeded, poll the entry from {@link #unackedAppends} and drop it.</li>  *<li>If failed, add all the entries in {@link #unackedAppends} back to {@link #toWriteAppends} and  * wait for writing them again.</li>  *</ul>  *</li>  *</ol>  *</li>  *</ol>  * For sync, the processing stages are almost same. And different from FSHLog, we will open a new  * writer and rewrite unacked entries to the new writer and sync again if we hit a sync error.  *<p>  * Here we only describe the logic of doReplaceWriter. The main logic of rollWriter is same with  * FSHLog.<br>  * For a normal roll request(for example, we have reached the log roll size):  *<ol>  *<li>In the log roller thread, we will set {@link #waitingRoll} to true and  * {@link #readyForRolling} to false, and then wait on {@link #readyForRolling}(see  * {@link #waitForSafePoint()}).</li>  *<li>In the consumer thread, we will stop polling entries from {@link #waitingConsumePayloads} if  * {@link #waitingRoll} is true, and also stop writing the entries in {@link #toWriteAppends} out.  *</li>  *<li>If there are unflush data in the writer, sync them.</li>  *<li>When all out-going sync request is finished, i.e, the {@link #unackedAppends} is empty,  * signal the {@link #readyForRollingCond}.</li>  *<li>Back to the log roller thread, now we can confirm that there are no out-going entries, i.e.,  * we reach a safe point. So it is safe to replace old writer with new writer now.</li>  *<li>Set {@link #writerBroken} and {@link #waitingRoll} to false, cancel log roller exit checker  * if any(see the comments in the {@link #syncFailed(Throwable)} method to see why we need a checker  * here).</li>  *<li>Schedule the consumer task.</li>  *<li>Schedule a background task to close the old writer.</li>  *</ol>  * For a broken writer roll request, the only difference is that we can bypass the wait for safe  * point stage. See the comments in the {@link #syncFailed(Throwable)} method for more details.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|CONFIG
argument_list|)
specifier|public
class|class
name|AsyncFSWAL
extends|extends
name|AbstractFSWAL
argument_list|<
name|AsyncWriter
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AsyncFSWAL
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|SyncFuture
argument_list|>
name|SEQ_COMPARATOR
init|=
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
block|{
name|int
name|c
init|=
name|Long
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|getTxid
argument_list|()
argument_list|,
name|o2
operator|.
name|getTxid
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|c
operator|!=
literal|0
condition|?
name|c
else|:
name|Integer
operator|.
name|compare
argument_list|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|o1
argument_list|)
argument_list|,
name|System
operator|.
name|identityHashCode
argument_list|(
name|o2
argument_list|)
argument_list|)
return|;
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|WAL_BATCH_SIZE
init|=
literal|"hbase.wal.batch.size"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_WAL_BATCH_SIZE
init|=
literal|64L
operator|*
literal|1024
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASYNC_WAL_CREATE_MAX_RETRIES
init|=
literal|"hbase.wal.async.create.retries"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_ASYNC_WAL_CREATE_MAX_RETRIES
init|=
literal|10
decl_stmt|;
specifier|private
specifier|final
name|EventLoop
name|eventLoop
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Channel
argument_list|>
name|channelClass
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|consumeLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Runnable
name|consumer
init|=
name|this
operator|::
name|consume
decl_stmt|;
comment|// check if there is already a consumer task in the event loop's task queue
specifier|private
specifier|final
name|Supplier
argument_list|<
name|Boolean
argument_list|>
name|hasConsumerTask
decl_stmt|;
comment|// new writer is created and we are waiting for old writer to be closed.
specifier|private
specifier|volatile
name|boolean
name|waitingRoll
decl_stmt|;
specifier|private
name|boolean
name|readyForRolling
decl_stmt|;
specifier|private
specifier|final
name|Condition
name|readyForRollingCond
init|=
name|consumeLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|RingBuffer
argument_list|<
name|RingBufferTruck
argument_list|>
name|waitingConsumePayloads
decl_stmt|;
specifier|private
specifier|final
name|Sequence
name|waitingConsumePayloadsGatingSequence
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|consumerScheduled
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// writer is broken and rollWriter is needed.
specifier|private
specifier|volatile
name|boolean
name|writerBroken
decl_stmt|;
specifier|private
specifier|final
name|long
name|batchSize
decl_stmt|;
specifier|private
specifier|final
name|int
name|createMaxRetries
decl_stmt|;
specifier|private
specifier|final
name|ExecutorService
name|closeExecutor
init|=
name|Executors
operator|.
name|newCachedThreadPool
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"Close-WAL-Writer-%d"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|AsyncFSOutput
name|fsOut
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|FSWALEntry
argument_list|>
name|toWriteAppends
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|FSWALEntry
argument_list|>
name|unackedAppends
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|SortedSet
argument_list|<
name|SyncFuture
argument_list|>
name|syncFutures
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|SEQ_COMPARATOR
argument_list|)
decl_stmt|;
comment|// the highest txid of WAL entries being processed
specifier|private
name|long
name|highestProcessedAppendTxid
decl_stmt|;
comment|// file length when we issue last sync request on the writer
specifier|private
name|long
name|fileLengthAtLastSync
decl_stmt|;
specifier|private
name|long
name|highestProcessedAppendTxidAtLastSync
decl_stmt|;
specifier|public
name|AsyncFSWAL
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|rootDir
parameter_list|,
name|String
name|logDir
parameter_list|,
name|String
name|archiveDir
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|List
argument_list|<
name|WALActionsListener
argument_list|>
name|listeners
parameter_list|,
name|boolean
name|failIfWALExists
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|,
name|EventLoop
name|eventLoop
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Channel
argument_list|>
name|channelClass
parameter_list|)
throws|throws
name|FailedLogCloseException
throws|,
name|IOException
block|{
name|super
argument_list|(
name|fs
argument_list|,
name|rootDir
argument_list|,
name|logDir
argument_list|,
name|archiveDir
argument_list|,
name|conf
argument_list|,
name|listeners
argument_list|,
name|failIfWALExists
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|this
operator|.
name|eventLoop
operator|=
name|eventLoop
expr_stmt|;
name|this
operator|.
name|channelClass
operator|=
name|channelClass
expr_stmt|;
name|Supplier
argument_list|<
name|Boolean
argument_list|>
name|hasConsumerTask
decl_stmt|;
if|if
condition|(
name|eventLoop
operator|instanceof
name|SingleThreadEventExecutor
condition|)
block|{
try|try
block|{
name|Field
name|field
init|=
name|SingleThreadEventExecutor
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"taskQueue"
argument_list|)
decl_stmt|;
name|field
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Queue
argument_list|<
name|?
argument_list|>
name|queue
init|=
operator|(
name|Queue
argument_list|<
name|?
argument_list|>
operator|)
name|field
operator|.
name|get
argument_list|(
name|eventLoop
argument_list|)
decl_stmt|;
name|hasConsumerTask
operator|=
parameter_list|()
lambda|->
name|queue
operator|.
name|peek
argument_list|()
operator|==
name|consumer
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can not get task queue of "
operator|+
name|eventLoop
operator|+
literal|", this is not necessary, just give up"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|hasConsumerTask
operator|=
parameter_list|()
lambda|->
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|hasConsumerTask
operator|=
parameter_list|()
lambda|->
literal|false
expr_stmt|;
block|}
name|this
operator|.
name|hasConsumerTask
operator|=
name|hasConsumerTask
expr_stmt|;
name|int
name|preallocatedEventCount
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.wal.disruptor.event.count"
argument_list|,
literal|1024
operator|*
literal|16
argument_list|)
decl_stmt|;
name|waitingConsumePayloads
operator|=
name|RingBuffer
operator|.
name|createMultiProducer
argument_list|(
name|RingBufferTruck
operator|::
operator|new
argument_list|,
name|preallocatedEventCount
argument_list|)
expr_stmt|;
name|waitingConsumePayloadsGatingSequence
operator|=
operator|new
name|Sequence
argument_list|(
name|Sequencer
operator|.
name|INITIAL_CURSOR_VALUE
argument_list|)
expr_stmt|;
name|waitingConsumePayloads
operator|.
name|addGatingSequences
argument_list|(
name|waitingConsumePayloadsGatingSequence
argument_list|)
expr_stmt|;
comment|// inrease the ringbuffer sequence so our txid is start from 1
name|waitingConsumePayloads
operator|.
name|publish
argument_list|(
name|waitingConsumePayloads
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|waitingConsumePayloadsGatingSequence
operator|.
name|set
argument_list|(
name|waitingConsumePayloads
operator|.
name|getCursor
argument_list|()
argument_list|)
expr_stmt|;
name|batchSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|WAL_BATCH_SIZE
argument_list|,
name|DEFAULT_WAL_BATCH_SIZE
argument_list|)
expr_stmt|;
name|createMaxRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|ASYNC_WAL_CREATE_MAX_RETRIES
argument_list|,
name|DEFAULT_ASYNC_WAL_CREATE_MAX_RETRIES
argument_list|)
expr_stmt|;
name|rollWriter
argument_list|()
expr_stmt|;
block|}
comment|// return whether we have successfully set readyForRolling to true.
specifier|private
name|boolean
name|trySetReadyForRolling
parameter_list|()
block|{
comment|// Check without holding lock first. Usually we will just return here.
comment|// waitingRoll is volatile and unacedEntries is only accessed inside event loop so it is safe to
comment|// check them outside the consumeLock.
if|if
condition|(
operator|!
name|waitingRoll
operator|||
operator|!
name|unackedAppends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|consumeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// 1. a roll is requested
comment|// 2. all out-going entries have been acked(we have confirmed above).
if|if
condition|(
name|waitingRoll
condition|)
block|{
name|readyForRolling
operator|=
literal|true
expr_stmt|;
name|readyForRollingCond
operator|.
name|signalAll
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|consumeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|syncFailed
parameter_list|(
name|Throwable
name|error
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"sync failed"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|// Here we depends on the implementation of FanOutOneBlockAsyncDFSOutput and netty.
comment|// When error occur, FanOutOneBlockAsyncDFSOutput will fail all pending flush requests. It
comment|// is execute inside EventLoop. And in DefaultPromise in netty, it will notifyListener
comment|// directly if it is already in the EventLoop thread. And in the listener method, it will
comment|// call us. So here we know that all failed flush request will call us continuously, and
comment|// before the last one finish, no other task can be executed in EventLoop. So here we are
comment|// safe to use writerBroken as a guard.
comment|// Do not forget to revisit this if we change the implementation of
comment|// FanOutOneBlockAsyncDFSOutput!
name|consumeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|writerBroken
condition|)
block|{
return|return;
block|}
name|writerBroken
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|waitingRoll
condition|)
block|{
name|readyForRolling
operator|=
literal|true
expr_stmt|;
name|readyForRollingCond
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|consumeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|FSWALEntry
argument_list|>
name|iter
init|=
name|unackedAppends
operator|.
name|descendingIterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|toWriteAppends
operator|.
name|addFirst
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|highestUnsyncedTxid
operator|=
name|highestSyncedTxid
operator|.
name|get
argument_list|()
expr_stmt|;
comment|// request a roll.
name|requestLogRoll
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|syncCompleted
parameter_list|(
name|AsyncWriter
name|writer
parameter_list|,
name|long
name|processedTxid
parameter_list|,
name|long
name|startTimeNs
parameter_list|)
block|{
name|highestSyncedTxid
operator|.
name|set
argument_list|(
name|processedTxid
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|FSWALEntry
argument_list|>
name|iter
init|=
name|unackedAppends
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|getTxid
argument_list|()
operator|<=
name|processedTxid
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|postSync
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNs
argument_list|,
name|finishSync
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Ideally, we should set a flag to indicate that the log roll has already been requested for
comment|// the current writer and give up here, and reset the flag when roll is finished. But we
comment|// finish roll in the log roller thread so the flag need to be set by different thread which
comment|// typically means we need to use a lock to protect it and do fencing. As the log roller will
comment|// aggregate the roll requests of the same WAL, so it is safe to call requestLogRoll multiple
comment|// times before the roll actual happens. But we need to stop if we set readyForRolling to true
comment|// and wake up the log roller thread waiting in waitForSafePoint as the rollWriter call may
comment|// return firstly and then we run the code below and request a roll on the new writer.
if|if
condition|(
name|trySetReadyForRolling
argument_list|()
condition|)
block|{
comment|// we have just finished a roll, then do not need to check for log rolling, the writer will be
comment|// closed soon.
return|return;
block|}
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|<
name|logrollsize
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|rollWriterLock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
return|return;
block|}
try|try
block|{
name|requestLogRoll
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|rollWriterLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|sync
parameter_list|(
name|AsyncWriter
name|writer
parameter_list|)
block|{
name|fileLengthAtLastSync
operator|=
name|writer
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|long
name|currentHighestProcessedAppendTxid
init|=
name|highestProcessedAppendTxid
decl_stmt|;
name|highestProcessedAppendTxidAtLastSync
operator|=
name|currentHighestProcessedAppendTxid
expr_stmt|;
specifier|final
name|long
name|startTimeNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|writer
operator|.
name|sync
argument_list|()
operator|.
name|whenComplete
argument_list|(
parameter_list|(
name|result
parameter_list|,
name|error
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|error
operator|!=
literal|null
condition|)
block|{
name|syncFailed
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syncCompleted
argument_list|(
name|writer
argument_list|,
name|currentHighestProcessedAppendTxid
argument_list|,
name|startTimeNs
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addTimeAnnotation
parameter_list|(
name|SyncFuture
name|future
parameter_list|,
name|String
name|annotation
parameter_list|)
block|{
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|continueSpan
argument_list|(
name|future
operator|.
name|getSpan
argument_list|()
argument_list|)
decl_stmt|;
name|Trace
operator|.
name|addTimelineAnnotation
argument_list|(
name|annotation
argument_list|)
expr_stmt|;
name|future
operator|.
name|setSpan
argument_list|(
name|scope
operator|.
name|detach
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|finishSyncLowerThanTxid
parameter_list|(
name|long
name|txid
parameter_list|,
name|boolean
name|addSyncTrace
parameter_list|)
block|{
name|int
name|finished
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|SyncFuture
argument_list|>
name|iter
init|=
name|syncFutures
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SyncFuture
name|sync
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|sync
operator|.
name|getTxid
argument_list|()
operator|<=
name|txid
condition|)
block|{
name|sync
operator|.
name|done
argument_list|(
name|txid
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|finished
operator|++
expr_stmt|;
if|if
condition|(
name|addSyncTrace
condition|)
block|{
name|addTimeAnnotation
argument_list|(
name|sync
argument_list|,
literal|"writer synced"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|finished
return|;
block|}
comment|// try advancing the highestSyncedTxid as much as possible
specifier|private
name|int
name|finishSync
parameter_list|(
name|boolean
name|addSyncTrace
parameter_list|)
block|{
if|if
condition|(
name|unackedAppends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// All outstanding appends have been acked.
if|if
condition|(
name|toWriteAppends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Also no appends that wait to be written out, then just finished all pending syncs.
name|long
name|maxSyncTxid
init|=
name|highestSyncedTxid
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
name|SyncFuture
name|sync
range|:
name|syncFutures
control|)
block|{
name|maxSyncTxid
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxSyncTxid
argument_list|,
name|sync
operator|.
name|getTxid
argument_list|()
argument_list|)
expr_stmt|;
name|sync
operator|.
name|done
argument_list|(
name|maxSyncTxid
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|addSyncTrace
condition|)
block|{
name|addTimeAnnotation
argument_list|(
name|sync
argument_list|,
literal|"writer synced"
argument_list|)
expr_stmt|;
block|}
block|}
name|highestSyncedTxid
operator|.
name|set
argument_list|(
name|maxSyncTxid
argument_list|)
expr_stmt|;
name|int
name|finished
init|=
name|syncFutures
operator|.
name|size
argument_list|()
decl_stmt|;
name|syncFutures
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|finished
return|;
block|}
else|else
block|{
comment|// There is no append between highestProcessedAppendTxid and lowestUnprocessedAppendTxid, so
comment|// if highestSyncedTxid>= highestProcessedAppendTxid, then all syncs whose txid are between
comment|// highestProcessedAppendTxid and lowestUnprocessedAppendTxid can be finished.
name|long
name|lowestUnprocessedAppendTxid
init|=
name|toWriteAppends
operator|.
name|peek
argument_list|()
operator|.
name|getTxid
argument_list|()
decl_stmt|;
assert|assert
name|lowestUnprocessedAppendTxid
operator|>
name|highestProcessedAppendTxid
assert|;
name|long
name|doneTxid
init|=
name|lowestUnprocessedAppendTxid
operator|-
literal|1
decl_stmt|;
name|highestSyncedTxid
operator|.
name|set
argument_list|(
name|doneTxid
argument_list|)
expr_stmt|;
return|return
name|finishSyncLowerThanTxid
argument_list|(
name|doneTxid
argument_list|,
name|addSyncTrace
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// There are still unacked appends. So let's move the highestSyncedTxid to the txid of the
comment|// first unacked append minus 1.
name|long
name|lowestUnackedAppendTxid
init|=
name|unackedAppends
operator|.
name|peek
argument_list|()
operator|.
name|getTxid
argument_list|()
decl_stmt|;
name|long
name|doneTxid
init|=
name|Math
operator|.
name|max
argument_list|(
name|lowestUnackedAppendTxid
operator|-
literal|1
argument_list|,
name|highestSyncedTxid
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|highestSyncedTxid
operator|.
name|set
argument_list|(
name|doneTxid
argument_list|)
expr_stmt|;
return|return
name|finishSyncLowerThanTxid
argument_list|(
name|doneTxid
argument_list|,
name|addSyncTrace
argument_list|)
return|;
block|}
block|}
specifier|private
name|void
name|appendAndSync
parameter_list|()
block|{
specifier|final
name|AsyncWriter
name|writer
init|=
name|this
operator|.
name|writer
decl_stmt|;
comment|// maybe a sync request is not queued when we issue a sync, so check here to see if we could
comment|// finish some.
name|finishSync
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|long
name|newHighestProcessedAppendTxid
init|=
operator|-
literal|1L
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|FSWALEntry
argument_list|>
name|iter
init|=
name|toWriteAppends
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|FSWALEntry
name|entry
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|appended
decl_stmt|;
name|Span
name|span
init|=
name|entry
operator|.
name|detachSpan
argument_list|()
decl_stmt|;
comment|// the span maybe null if this is a retry after rolling.
if|if
condition|(
name|span
operator|!=
literal|null
condition|)
block|{
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|continueSpan
argument_list|(
name|span
argument_list|)
decl_stmt|;
try|try
block|{
name|appended
operator|=
name|append
argument_list|(
name|writer
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"should not happen"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
assert|assert
name|scope
operator|==
name|NullScope
operator|.
name|INSTANCE
operator|||
operator|!
name|scope
operator|.
name|isDetached
argument_list|()
assert|;
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// append scope is complete
block|}
block|}
else|else
block|{
try|try
block|{
name|appended
operator|=
name|append
argument_list|(
name|writer
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"should not happen"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|newHighestProcessedAppendTxid
operator|=
name|entry
operator|.
name|getTxid
argument_list|()
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|appended
condition|)
block|{
name|unackedAppends
operator|.
name|addLast
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|-
name|fileLengthAtLastSync
operator|>=
name|batchSize
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|// if we have a newer transaction id, update it.
comment|// otherwise, use the previous transaction id.
if|if
condition|(
name|newHighestProcessedAppendTxid
operator|>
literal|0
condition|)
block|{
name|highestProcessedAppendTxid
operator|=
name|newHighestProcessedAppendTxid
expr_stmt|;
block|}
else|else
block|{
name|newHighestProcessedAppendTxid
operator|=
name|highestProcessedAppendTxid
expr_stmt|;
block|}
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|-
name|fileLengthAtLastSync
operator|>=
name|batchSize
condition|)
block|{
comment|// sync because buffer size limit.
name|sync
argument_list|(
name|writer
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|==
name|fileLengthAtLastSync
condition|)
block|{
comment|// we haven't written anything out, just advance the highestSyncedSequence since we may only
comment|// stamped some region sequence id.
if|if
condition|(
name|unackedAppends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|highestSyncedTxid
operator|.
name|set
argument_list|(
name|highestProcessedAppendTxid
argument_list|)
expr_stmt|;
name|finishSync
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|trySetReadyForRolling
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|// we have some unsynced data but haven't reached the batch size yet
if|if
condition|(
operator|!
name|syncFutures
operator|.
name|isEmpty
argument_list|()
operator|&&
name|syncFutures
operator|.
name|last
argument_list|()
operator|.
name|getTxid
argument_list|()
operator|>
name|highestProcessedAppendTxidAtLastSync
condition|)
block|{
comment|// we have at least one sync request
name|sync
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|consume
parameter_list|()
block|{
name|consumeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|writerBroken
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|waitingRoll
condition|)
block|{
if|if
condition|(
name|writer
operator|.
name|getLength
argument_list|()
operator|>
name|fileLengthAtLastSync
condition|)
block|{
comment|// issue a sync
name|sync
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|unackedAppends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|readyForRolling
operator|=
literal|true
expr_stmt|;
name|readyForRollingCond
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
finally|finally
block|{
name|consumeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|long
name|nextCursor
init|=
name|waitingConsumePayloadsGatingSequence
operator|.
name|get
argument_list|()
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|long
name|cursorBound
init|=
name|waitingConsumePayloads
operator|.
name|getCursor
argument_list|()
init|;
name|nextCursor
operator|<=
name|cursorBound
condition|;
name|nextCursor
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|waitingConsumePayloads
operator|.
name|isPublished
argument_list|(
name|nextCursor
argument_list|)
condition|)
block|{
break|break;
block|}
name|RingBufferTruck
name|truck
init|=
name|waitingConsumePayloads
operator|.
name|get
argument_list|(
name|nextCursor
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|truck
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|APPEND
case|:
name|toWriteAppends
operator|.
name|addLast
argument_list|(
name|truck
operator|.
name|unloadAppend
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYNC
case|:
name|syncFutures
operator|.
name|add
argument_list|(
name|truck
operator|.
name|unloadSync
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"RingBufferTruck with unexpected type: "
operator|+
name|truck
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|waitingConsumePayloadsGatingSequence
operator|.
name|set
argument_list|(
name|nextCursor
argument_list|)
expr_stmt|;
block|}
name|appendAndSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|hasConsumerTask
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|toWriteAppends
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|waitingConsumePayloadsGatingSequence
operator|.
name|get
argument_list|()
operator|==
name|waitingConsumePayloads
operator|.
name|getCursor
argument_list|()
condition|)
block|{
name|consumerScheduled
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// recheck here since in append and sync we do not hold the consumeLock. Thing may
comment|// happen like
comment|// 1. we check cursor, no new entry
comment|// 2. someone publishes a new entry to ringbuffer and the consumerScheduled is true and
comment|// give up scheduling the consumer task.
comment|// 3. we set consumerScheduled to false and also give up scheduling consumer task.
if|if
condition|(
name|waitingConsumePayloadsGatingSequence
operator|.
name|get
argument_list|()
operator|==
name|waitingConsumePayloads
operator|.
name|getCursor
argument_list|()
condition|)
block|{
return|return;
block|}
else|else
block|{
comment|// maybe someone has grabbed this before us
if|if
condition|(
operator|!
name|consumerScheduled
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
block|}
comment|// reschedule if we still have something to write.
name|eventLoop
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|shouldScheduleConsumer
parameter_list|()
block|{
if|if
condition|(
name|writerBroken
operator|||
name|waitingRoll
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|consumerScheduled
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|append
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|,
name|WALKey
name|key
parameter_list|,
name|WALEdit
name|edits
parameter_list|,
name|boolean
name|inMemstore
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|txid
init|=
name|stampSequenceIdAndPublishToRingBuffer
argument_list|(
name|hri
argument_list|,
name|key
argument_list|,
name|edits
argument_list|,
name|inMemstore
argument_list|,
name|waitingConsumePayloads
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldScheduleConsumer
argument_list|()
condition|)
block|{
name|eventLoop
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
return|return
name|txid
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"AsyncFSWAL.sync"
argument_list|)
decl_stmt|;
try|try
block|{
name|long
name|txid
init|=
name|waitingConsumePayloads
operator|.
name|next
argument_list|()
decl_stmt|;
name|SyncFuture
name|future
decl_stmt|;
try|try
block|{
name|future
operator|=
name|getSyncFuture
argument_list|(
name|txid
argument_list|,
name|scope
operator|.
name|detach
argument_list|()
argument_list|)
expr_stmt|;
name|RingBufferTruck
name|truck
init|=
name|waitingConsumePayloads
operator|.
name|get
argument_list|(
name|txid
argument_list|)
decl_stmt|;
name|truck
operator|.
name|load
argument_list|(
name|future
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|waitingConsumePayloads
operator|.
name|publish
argument_list|(
name|txid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shouldScheduleConsumer
argument_list|()
condition|)
block|{
name|eventLoop
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
name|scope
operator|=
name|Trace
operator|.
name|continueSpan
argument_list|(
name|blockOnSync
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
assert|assert
name|scope
operator|==
name|NullScope
operator|.
name|INSTANCE
operator|||
operator|!
name|scope
operator|.
name|isDetached
argument_list|()
assert|;
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|(
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|highestSyncedTxid
operator|.
name|get
argument_list|()
operator|>=
name|txid
condition|)
block|{
return|return;
block|}
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"AsyncFSWAL.sync"
argument_list|)
decl_stmt|;
try|try
block|{
comment|// here we do not use ring buffer sequence as txid
name|long
name|sequence
init|=
name|waitingConsumePayloads
operator|.
name|next
argument_list|()
decl_stmt|;
name|SyncFuture
name|future
decl_stmt|;
try|try
block|{
name|future
operator|=
name|getSyncFuture
argument_list|(
name|txid
argument_list|,
name|scope
operator|.
name|detach
argument_list|()
argument_list|)
expr_stmt|;
name|RingBufferTruck
name|truck
init|=
name|waitingConsumePayloads
operator|.
name|get
argument_list|(
name|sequence
argument_list|)
decl_stmt|;
name|truck
operator|.
name|load
argument_list|(
name|future
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|waitingConsumePayloads
operator|.
name|publish
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shouldScheduleConsumer
argument_list|()
condition|)
block|{
name|eventLoop
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
name|scope
operator|=
name|Trace
operator|.
name|continueSpan
argument_list|(
name|blockOnSync
argument_list|(
name|future
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
assert|assert
name|scope
operator|==
name|NullScope
operator|.
name|INSTANCE
operator|||
operator|!
name|scope
operator|.
name|isDetached
argument_list|()
assert|;
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|AsyncWriter
name|createWriterInstance
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|overwrite
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|retry
init|=
literal|0
init|;
condition|;
name|retry
operator|++
control|)
block|{
try|try
block|{
return|return
name|AsyncFSWALProvider
operator|.
name|createAsyncWriter
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|path
argument_list|,
name|overwrite
argument_list|,
name|eventLoop
argument_list|,
name|channelClass
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"create wal log writer "
operator|+
name|path
operator|+
literal|" failed, retry = "
operator|+
name|retry
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldRetryCreate
argument_list|(
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
name|retry
operator|>=
name|createMaxRetries
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
name|IOException
name|ioe
init|=
name|e
operator|.
name|unwrapRemoteException
argument_list|()
decl_stmt|;
comment|// this usually means master already think we are dead so let's fail all the pending
comment|// syncs. The shutdown process of RS will wait for all regions to be closed before calling
comment|// WAL.close so if we do not wake up the thread blocked by sync here it will cause dead
comment|// lock.
if|if
condition|(
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Parent directory doesn't exist:"
argument_list|)
condition|)
block|{
name|syncFutures
operator|.
name|forEach
argument_list|(
name|f
lambda|->
name|f
operator|.
name|done
argument_list|(
name|f
operator|.
name|getTxid
argument_list|()
argument_list|,
name|ioe
argument_list|)
argument_list|)
expr_stmt|;
block|}
throw|throw
name|ioe
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|NameNodeException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"create wal log writer "
operator|+
name|path
operator|+
literal|" failed, retry = "
operator|+
name|retry
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
operator|>=
name|createMaxRetries
condition|)
block|{
break|break;
block|}
comment|// overwrite the old broken file.
name|overwrite
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|ConnectionUtils
operator|.
name|getPauseTime
argument_list|(
literal|100
argument_list|,
name|retry
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
block|}
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to create wal log writer "
operator|+
name|path
operator|+
literal|" after retrying "
operator|+
name|createMaxRetries
operator|+
literal|" time(s)"
argument_list|)
throw|;
block|}
specifier|private
name|void
name|waitForSafePoint
parameter_list|()
block|{
name|consumeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|writerBroken
operator|||
name|this
operator|.
name|writer
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|consumerScheduled
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|waitingRoll
operator|=
literal|true
expr_stmt|;
name|readyForRolling
operator|=
literal|false
expr_stmt|;
name|eventLoop
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|readyForRolling
condition|)
block|{
name|readyForRollingCond
operator|.
name|awaitUninterruptibly
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|consumeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|long
name|doReplaceWriter
parameter_list|(
name|Path
name|oldPath
parameter_list|,
name|Path
name|newPath
parameter_list|,
name|AsyncWriter
name|nextWriter
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForSafePoint
argument_list|()
expr_stmt|;
specifier|final
name|AsyncWriter
name|oldWriter
init|=
name|this
operator|.
name|writer
decl_stmt|;
name|this
operator|.
name|writer
operator|=
name|nextWriter
expr_stmt|;
if|if
condition|(
name|nextWriter
operator|!=
literal|null
operator|&&
name|nextWriter
operator|instanceof
name|AsyncProtobufLogWriter
condition|)
block|{
name|this
operator|.
name|fsOut
operator|=
operator|(
operator|(
name|AsyncProtobufLogWriter
operator|)
name|nextWriter
operator|)
operator|.
name|getOutput
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|fileLengthAtLastSync
operator|=
literal|0L
expr_stmt|;
name|this
operator|.
name|highestProcessedAppendTxidAtLastSync
operator|=
literal|0L
expr_stmt|;
name|consumeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|consumerScheduled
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writerBroken
operator|=
name|waitingRoll
operator|=
literal|false
expr_stmt|;
name|eventLoop
operator|.
name|execute
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|consumeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|long
name|oldFileLen
decl_stmt|;
if|if
condition|(
name|oldWriter
operator|!=
literal|null
condition|)
block|{
name|oldFileLen
operator|=
name|oldWriter
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|closeExecutor
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
name|oldWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"close old writer failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oldFileLen
operator|=
literal|0L
expr_stmt|;
block|}
return|return
name|oldFileLen
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doShutdown
parameter_list|()
throws|throws
name|IOException
block|{
name|waitForSafePoint
argument_list|()
expr_stmt|;
name|this
operator|.
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|writer
operator|=
literal|null
expr_stmt|;
name|closeExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|IOException
name|error
init|=
operator|new
name|IOException
argument_list|(
literal|"WAL has been closed"
argument_list|)
decl_stmt|;
name|syncFutures
operator|.
name|forEach
argument_list|(
name|f
lambda|->
name|f
operator|.
name|done
argument_list|(
name|f
operator|.
name|getTxid
argument_list|()
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doAppend
parameter_list|(
name|AsyncWriter
name|writer
parameter_list|,
name|FSWALEntry
name|entry
parameter_list|)
block|{
name|writer
operator|.
name|append
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|DatanodeInfo
index|[]
name|getPipeline
parameter_list|()
block|{
name|AsyncFSOutput
name|output
init|=
name|this
operator|.
name|fsOut
decl_stmt|;
return|return
name|output
operator|!=
literal|null
condition|?
name|output
operator|.
name|getPipeline
argument_list|()
else|:
operator|new
name|DatanodeInfo
index|[
literal|0
index|]
return|;
block|}
annotation|@
name|Override
name|int
name|getLogReplication
parameter_list|()
block|{
return|return
name|getPipeline
argument_list|()
operator|.
name|length
return|;
block|}
block|}
end_class

end_unit

