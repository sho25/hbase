begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|BindException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ServerSocket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|CancelledKeyException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|Channels
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedChannelException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|GatheringByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ReadableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SelectionKey
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|Selector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ServerSocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|WritableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|Sasl
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|SaslException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|SaslServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseInterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Operation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|codec
operator|.
name|Codec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|RegionMovedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ByteBufferOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|BoundedByteBufferPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MonitoredRPCHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|CellBlockMeta
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ConnectionHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ExceptionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|RequestHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ResponseHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|UserInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegionServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|AuthMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBasePolicyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcServer
operator|.
name|SaslDigestCallbackHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcServer
operator|.
name|SaslGssCallbackHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|SaslStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|SaslUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|UserProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|token
operator|.
name|AuthenticationTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Counter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
operator|.
name|AuthenticationMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AuthorizationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|PolicyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ProxyUsers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ServiceAuthorizationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
operator|.
name|InvalidToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|TraceInfo
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|BlockingService
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|CodedInputStream
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|MethodDescriptor
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
operator|.
name|Builder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ServiceException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|TextFormat
import|;
end_import

begin_comment
comment|/**  * An RPC server that hosts protobuf described Services.  *  * An RpcServer instance has a Listener that hosts the socket.  Listener has fixed number  * of Readers in an ExecutorPool, 10 by default.  The Listener does an accept and then  * round robin a Reader is chosen to do the read.  The reader is registered on Selector.  Read does  * total read off the channel and the parse from which it makes a Call.  The call is wrapped in a  * CallRunner and passed to the scheduler to be run.  Reader goes back to see if more to be done  * and loops till done.  *  *<p>Scheduler can be variously implemented but default simple scheduler has handlers to which it  * has given the queues into which calls (i.e. CallRunner instances) are inserted.  Handlers run  * taking from the queue.  They run the CallRunner#run method on each item gotten from queue  * and keep taking while the server is up.  *  * CallRunner#run executes the call.  When done, asks the included Call to put itself on new  * queue for Responder to pull from and return result to client.  *  * @see RpcClientImpl  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
name|HBaseInterfaceAudience
operator|.
name|COPROC
block|,
name|HBaseInterfaceAudience
operator|.
name|PHOENIX
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|RpcServer
implements|implements
name|RpcServerInterface
block|{
comment|// LOG is being used in CallRunner and the log level is being changed in tests
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|RpcServer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CallQueueTooBigException
name|CALL_QUEUE_TOO_BIG_EXCEPTION
init|=
operator|new
name|CallQueueTooBigException
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|authorize
decl_stmt|;
specifier|private
name|boolean
name|isSecurityEnabled
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|CURRENT_VERSION
init|=
literal|0
decl_stmt|;
comment|/**    * How many calls/handler are allowed in the queue.    */
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_CALLQUEUE_LENGTH_PER_HANDLER
init|=
literal|10
decl_stmt|;
comment|/**    * The maximum size that we can hold in the RPC queue    */
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_CALLQUEUE_SIZE
init|=
literal|1024
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|WARN_DELAYED_CALLS
init|=
literal|"hbase.ipc.warn.delayedrpc.number"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_WARN_DELAYED_CALLS
init|=
literal|1000
decl_stmt|;
specifier|private
specifier|final
name|int
name|warnDelayedCalls
decl_stmt|;
specifier|private
name|AtomicInteger
name|delayedCalls
decl_stmt|;
specifier|private
specifier|final
name|IPCUtil
name|ipcUtil
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|AUTH_FAILED_FOR
init|=
literal|"Auth failed for "
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|AUTH_SUCCESSFUL_FOR
init|=
literal|"Auth successful for "
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Log
name|AUDITLOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"SecurityLogger."
operator|+
name|Server
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
name|SecretManager
argument_list|<
name|TokenIdentifier
argument_list|>
name|secretManager
decl_stmt|;
specifier|protected
name|ServiceAuthorizationManager
name|authManager
decl_stmt|;
comment|/** This is set to Call object before Handler invokes an RPC and ybdie    * after the call returns.    */
specifier|protected
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Call
argument_list|>
name|CurCall
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Call
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Keeps MonitoredRPCHandler per handler thread. */
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|MonitoredRPCHandler
argument_list|>
name|MONITORED_RPC
init|=
operator|new
name|ThreadLocal
argument_list|<
name|MonitoredRPCHandler
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|InetSocketAddress
name|bindAddress
decl_stmt|;
specifier|protected
name|int
name|port
decl_stmt|;
comment|// port we listen on
specifier|protected
name|InetSocketAddress
name|address
decl_stmt|;
comment|// inet address we listen on
specifier|private
name|int
name|readThreads
decl_stmt|;
comment|// number of read threads
specifier|protected
name|int
name|maxIdleTime
decl_stmt|;
comment|// the maximum idle time after
comment|// which a client may be
comment|// disconnected
specifier|protected
name|int
name|thresholdIdleConnections
decl_stmt|;
comment|// the number of idle
comment|// connections after which we
comment|// will start cleaning up idle
comment|// connections
name|int
name|maxConnectionsToNuke
decl_stmt|;
comment|// the max number of
comment|// connections to nuke
comment|// during a cleanup
specifier|protected
name|MetricsHBaseServer
name|metrics
decl_stmt|;
specifier|protected
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|int
name|maxQueueSize
decl_stmt|;
specifier|protected
name|int
name|socketSendBufferSize
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|tcpNoDelay
decl_stmt|;
comment|// if T then disable Nagle's Algorithm
specifier|protected
specifier|final
name|boolean
name|tcpKeepAlive
decl_stmt|;
comment|// if T then use keepalives
specifier|protected
specifier|final
name|long
name|purgeTimeout
decl_stmt|;
comment|// in milliseconds
comment|/**    * This flag is used to indicate to sub threads when they should go down.  When we call    * {@link #start()}, all threads started will consult this flag on whether they should    * keep going.  It is set to false when {@link #stop()} is called.    */
specifier|volatile
name|boolean
name|running
init|=
literal|true
decl_stmt|;
comment|/**    * This flag is set to true after all threads are up and 'running' and the server is then opened    * for business by the call to {@link #start()}.    */
specifier|volatile
name|boolean
name|started
init|=
literal|false
decl_stmt|;
comment|/**    * This is a running count of the size of all outstanding calls by size.    */
specifier|protected
specifier|final
name|Counter
name|callQueueSize
init|=
operator|new
name|Counter
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|List
argument_list|<
name|Connection
argument_list|>
name|connectionList
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|LinkedList
argument_list|<
name|Connection
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|//maintain a list
comment|//of client connections
specifier|private
name|Listener
name|listener
init|=
literal|null
decl_stmt|;
specifier|protected
name|Responder
name|responder
init|=
literal|null
decl_stmt|;
specifier|protected
name|int
name|numConnections
init|=
literal|0
decl_stmt|;
specifier|protected
name|HBaseRPCErrorHandler
name|errorHandler
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|WARN_RESPONSE_TIME
init|=
literal|"hbase.ipc.warn.response.time"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|WARN_RESPONSE_SIZE
init|=
literal|"hbase.ipc.warn.response.size"
decl_stmt|;
comment|/** Default value for above params */
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_WARN_RESPONSE_TIME
init|=
literal|10000
decl_stmt|;
comment|// milliseconds
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_WARN_RESPONSE_SIZE
init|=
literal|100
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ObjectMapper
name|MAPPER
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|int
name|warnResponseTime
decl_stmt|;
specifier|private
specifier|final
name|int
name|warnResponseSize
decl_stmt|;
specifier|private
specifier|final
name|Server
name|server
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
decl_stmt|;
specifier|private
specifier|final
name|RpcScheduler
name|scheduler
decl_stmt|;
specifier|private
name|UserProvider
name|userProvider
decl_stmt|;
specifier|private
specifier|final
name|BoundedByteBufferPool
name|reservoir
decl_stmt|;
comment|/**    * Datastructure that holds all necessary to a method invocation and then afterward, carries    * the result.    */
class|class
name|Call
implements|implements
name|RpcCallContext
block|{
specifier|protected
name|int
name|id
decl_stmt|;
comment|// the client's call id
specifier|protected
name|BlockingService
name|service
decl_stmt|;
specifier|protected
name|MethodDescriptor
name|md
decl_stmt|;
specifier|protected
name|RequestHeader
name|header
decl_stmt|;
specifier|protected
name|Message
name|param
decl_stmt|;
comment|// the parameter passed
comment|// Optional cell data passed outside of protobufs.
specifier|protected
name|CellScanner
name|cellScanner
decl_stmt|;
specifier|protected
name|Connection
name|connection
decl_stmt|;
comment|// connection to client
specifier|protected
name|long
name|timestamp
decl_stmt|;
comment|// the time received when response is null
comment|// the time served when response is not null
comment|/**      * Chain of buffers to send as response.      */
specifier|protected
name|BufferChain
name|response
decl_stmt|;
specifier|protected
name|boolean
name|delayResponse
decl_stmt|;
specifier|protected
name|Responder
name|responder
decl_stmt|;
specifier|protected
name|boolean
name|delayReturnValue
decl_stmt|;
comment|// if the return value should be
comment|// set at call completion
specifier|protected
name|long
name|size
decl_stmt|;
comment|// size of current call
specifier|protected
name|boolean
name|isError
decl_stmt|;
specifier|protected
name|TraceInfo
name|tinfo
decl_stmt|;
specifier|private
name|ByteBuffer
name|cellBlock
init|=
literal|null
decl_stmt|;
specifier|private
name|User
name|user
decl_stmt|;
specifier|private
name|InetAddress
name|remoteAddress
decl_stmt|;
specifier|private
name|RpcCallback
name|callback
decl_stmt|;
name|Call
parameter_list|(
name|int
name|id
parameter_list|,
specifier|final
name|BlockingService
name|service
parameter_list|,
specifier|final
name|MethodDescriptor
name|md
parameter_list|,
name|RequestHeader
name|header
parameter_list|,
name|Message
name|param
parameter_list|,
name|CellScanner
name|cellScanner
parameter_list|,
name|Connection
name|connection
parameter_list|,
name|Responder
name|responder
parameter_list|,
name|long
name|size
parameter_list|,
name|TraceInfo
name|tinfo
parameter_list|,
specifier|final
name|InetAddress
name|remoteAddress
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|md
operator|=
name|md
expr_stmt|;
name|this
operator|.
name|header
operator|=
name|header
expr_stmt|;
name|this
operator|.
name|param
operator|=
name|param
expr_stmt|;
name|this
operator|.
name|cellScanner
operator|=
name|cellScanner
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|timestamp
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|this
operator|.
name|response
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|delayResponse
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|responder
operator|=
name|responder
expr_stmt|;
name|this
operator|.
name|isError
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|tinfo
operator|=
name|tinfo
expr_stmt|;
name|this
operator|.
name|user
operator|=
name|connection
operator|.
name|user
operator|==
literal|null
condition|?
literal|null
else|:
name|userProvider
operator|.
name|create
argument_list|(
name|connection
operator|.
name|user
argument_list|)
expr_stmt|;
name|this
operator|.
name|remoteAddress
operator|=
name|remoteAddress
expr_stmt|;
block|}
comment|/**      * Call is done. Execution happened and we returned results to client. It is now safe to      * cleanup.      */
name|void
name|done
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|cellBlock
operator|!=
literal|null
condition|)
block|{
comment|// Return buffer to reservoir now we are done with it.
name|reservoir
operator|.
name|putBuffer
argument_list|(
name|this
operator|.
name|cellBlock
argument_list|)
expr_stmt|;
name|this
operator|.
name|cellBlock
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|connection
operator|.
name|decRpcCount
argument_list|()
expr_stmt|;
comment|// Say that we're done with this call.
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toShortString
argument_list|()
operator|+
literal|" param: "
operator|+
operator|(
name|this
operator|.
name|param
operator|!=
literal|null
condition|?
name|ProtobufUtil
operator|.
name|getShortTextFormat
argument_list|(
name|this
operator|.
name|param
argument_list|)
else|:
literal|""
operator|)
operator|+
literal|" connection: "
operator|+
name|connection
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
name|RequestHeader
name|getHeader
parameter_list|()
block|{
return|return
name|this
operator|.
name|header
return|;
block|}
comment|/*      * Short string representation without param info because param itself could be huge depends on      * the payload of a command      */
name|String
name|toShortString
parameter_list|()
block|{
name|String
name|serviceName
init|=
name|this
operator|.
name|connection
operator|.
name|service
operator|!=
literal|null
condition|?
name|this
operator|.
name|connection
operator|.
name|service
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|getName
argument_list|()
else|:
literal|"null"
decl_stmt|;
return|return
literal|"callId: "
operator|+
name|this
operator|.
name|id
operator|+
literal|" service: "
operator|+
name|serviceName
operator|+
literal|" methodName: "
operator|+
operator|(
operator|(
name|this
operator|.
name|md
operator|!=
literal|null
operator|)
condition|?
name|this
operator|.
name|md
operator|.
name|getName
argument_list|()
else|:
literal|"n/a"
operator|)
operator|+
literal|" size: "
operator|+
name|StringUtils
operator|.
name|TraditionalBinaryPrefix
operator|.
name|long2String
argument_list|(
name|this
operator|.
name|size
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|+
literal|" connection: "
operator|+
name|connection
operator|.
name|toString
argument_list|()
return|;
block|}
name|String
name|toTraceString
parameter_list|()
block|{
name|String
name|serviceName
init|=
name|this
operator|.
name|connection
operator|.
name|service
operator|!=
literal|null
condition|?
name|this
operator|.
name|connection
operator|.
name|service
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|getName
argument_list|()
else|:
literal|""
decl_stmt|;
name|String
name|methodName
init|=
operator|(
name|this
operator|.
name|md
operator|!=
literal|null
operator|)
condition|?
name|this
operator|.
name|md
operator|.
name|getName
argument_list|()
else|:
literal|""
decl_stmt|;
return|return
name|serviceName
operator|+
literal|"."
operator|+
name|methodName
return|;
block|}
specifier|protected
specifier|synchronized
name|void
name|setSaslTokenResponse
parameter_list|(
name|ByteBuffer
name|response
parameter_list|)
block|{
name|this
operator|.
name|response
operator|=
operator|new
name|BufferChain
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|synchronized
name|void
name|setResponse
parameter_list|(
name|Object
name|m
parameter_list|,
specifier|final
name|CellScanner
name|cells
parameter_list|,
name|Throwable
name|t
parameter_list|,
name|String
name|errorMsg
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|isError
condition|)
return|return;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|this
operator|.
name|isError
operator|=
literal|true
expr_stmt|;
name|BufferChain
name|bc
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ResponseHeader
operator|.
name|Builder
name|headerBuilder
init|=
name|ResponseHeader
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
comment|// Presume it a pb Message.  Could be null.
name|Message
name|result
init|=
operator|(
name|Message
operator|)
name|m
decl_stmt|;
comment|// Call id.
name|headerBuilder
operator|.
name|setCallId
argument_list|(
name|this
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|ExceptionResponse
operator|.
name|Builder
name|exceptionBuilder
init|=
name|ExceptionResponse
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|exceptionBuilder
operator|.
name|setExceptionClassName
argument_list|(
name|t
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|exceptionBuilder
operator|.
name|setStackTrace
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
name|exceptionBuilder
operator|.
name|setDoNotRetry
argument_list|(
name|t
operator|instanceof
name|DoNotRetryIOException
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|RegionMovedException
condition|)
block|{
comment|// Special casing for this exception.  This is only one carrying a payload.
comment|// Do this instead of build a generic system for allowing exceptions carry
comment|// any kind of payload.
name|RegionMovedException
name|rme
init|=
operator|(
name|RegionMovedException
operator|)
name|t
decl_stmt|;
name|exceptionBuilder
operator|.
name|setHostname
argument_list|(
name|rme
operator|.
name|getHostname
argument_list|()
argument_list|)
expr_stmt|;
name|exceptionBuilder
operator|.
name|setPort
argument_list|(
name|rme
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Set the exception as the result of the method invocation.
name|headerBuilder
operator|.
name|setException
argument_list|(
name|exceptionBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Pass reservoir to buildCellBlock. Keep reference to returne so can add it back to the
comment|// reservoir when finished. This is hacky and the hack is not contained but benefits are
comment|// high when we can avoid a big buffer allocation on each rpc.
name|this
operator|.
name|cellBlock
operator|=
name|ipcUtil
operator|.
name|buildCellBlock
argument_list|(
name|this
operator|.
name|connection
operator|.
name|codec
argument_list|,
name|this
operator|.
name|connection
operator|.
name|compressionCodec
argument_list|,
name|cells
argument_list|,
name|reservoir
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cellBlock
operator|!=
literal|null
condition|)
block|{
name|CellBlockMeta
operator|.
name|Builder
name|cellBlockBuilder
init|=
name|CellBlockMeta
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
comment|// Presumes the cellBlock bytebuffer has been flipped so limit has total size in it.
name|cellBlockBuilder
operator|.
name|setLength
argument_list|(
name|this
operator|.
name|cellBlock
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
name|headerBuilder
operator|.
name|setCellBlockMeta
argument_list|(
name|cellBlockBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Message
name|header
init|=
name|headerBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Organize the response as a set of bytebuffers rather than collect it all together inside
comment|// one big byte array; save on allocations.
name|ByteBuffer
name|bbHeader
init|=
name|IPCUtil
operator|.
name|getDelimitedMessageAsByteBuffer
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|ByteBuffer
name|bbResult
init|=
name|IPCUtil
operator|.
name|getDelimitedMessageAsByteBuffer
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|int
name|totalSize
init|=
name|bbHeader
operator|.
name|capacity
argument_list|()
operator|+
operator|(
name|bbResult
operator|==
literal|null
condition|?
literal|0
else|:
name|bbResult
operator|.
name|limit
argument_list|()
operator|)
operator|+
operator|(
name|this
operator|.
name|cellBlock
operator|==
literal|null
condition|?
literal|0
else|:
name|this
operator|.
name|cellBlock
operator|.
name|limit
argument_list|()
operator|)
decl_stmt|;
name|ByteBuffer
name|bbTotalSize
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|totalSize
argument_list|)
argument_list|)
decl_stmt|;
name|bc
operator|=
operator|new
name|BufferChain
argument_list|(
name|bbTotalSize
argument_list|,
name|bbHeader
argument_list|,
name|bbResult
argument_list|,
name|this
operator|.
name|cellBlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|.
name|useWrap
condition|)
block|{
name|bc
operator|=
name|wrapWithSasl
argument_list|(
name|bc
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while creating response "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|response
operator|=
name|bc
expr_stmt|;
comment|// Once a response message is created and set to this.response, this Call can be treated as
comment|// done. The Responder thread will do the n/w write of this message back to client.
if|if
condition|(
name|this
operator|.
name|callback
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|callback
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Don't allow any exception here to kill this handler thread.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while running the Rpc Callback."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|BufferChain
name|wrapWithSasl
parameter_list|(
name|BufferChain
name|bc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|connection
operator|.
name|useSasl
condition|)
return|return
name|bc
return|;
comment|// Looks like no way around this; saslserver wants a byte array.  I have to make it one.
comment|// THIS IS A BIG UGLY COPY.
name|byte
index|[]
name|responseBytes
init|=
name|bc
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|byte
index|[]
name|token
decl_stmt|;
comment|// synchronization may be needed since there can be multiple Handler
comment|// threads using saslServer to wrap responses.
synchronized|synchronized
init|(
name|connection
operator|.
name|saslServer
init|)
block|{
name|token
operator|=
name|connection
operator|.
name|saslServer
operator|.
name|wrap
argument_list|(
name|responseBytes
argument_list|,
literal|0
argument_list|,
name|responseBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Adding saslServer wrapped token of size "
operator|+
name|token
operator|.
name|length
operator|+
literal|" as call response."
argument_list|)
expr_stmt|;
block|}
name|ByteBuffer
name|bbTokenLength
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|token
operator|.
name|length
argument_list|)
argument_list|)
decl_stmt|;
name|ByteBuffer
name|bbTokenBytes
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|token
argument_list|)
decl_stmt|;
return|return
operator|new
name|BufferChain
argument_list|(
name|bbTokenLength
argument_list|,
name|bbTokenBytes
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|endDelay
parameter_list|(
name|Object
name|result
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|this
operator|.
name|delayResponse
assert|;
assert|assert
name|this
operator|.
name|delayReturnValue
operator|||
name|result
operator|==
literal|null
assert|;
name|this
operator|.
name|delayResponse
operator|=
literal|false
expr_stmt|;
name|delayedCalls
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|delayReturnValue
condition|)
block|{
name|this
operator|.
name|setResponse
argument_list|(
name|result
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|responder
operator|.
name|doRespond
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|endDelay
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|endDelay
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|startDelay
parameter_list|(
name|boolean
name|delayReturnValue
parameter_list|)
block|{
assert|assert
operator|!
name|this
operator|.
name|delayResponse
assert|;
name|this
operator|.
name|delayResponse
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|delayReturnValue
operator|=
name|delayReturnValue
expr_stmt|;
name|int
name|numDelayed
init|=
name|delayedCalls
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|numDelayed
operator|>
name|warnDelayedCalls
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Too many delayed calls: limit "
operator|+
name|warnDelayedCalls
operator|+
literal|" current "
operator|+
name|numDelayed
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|endDelayThrowing
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|setResponse
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|t
argument_list|,
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|delayResponse
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|sendResponseIfReady
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|isDelayed
parameter_list|()
block|{
return|return
name|this
operator|.
name|delayResponse
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|isReturnValueDelayed
parameter_list|()
block|{
return|return
name|this
operator|.
name|delayReturnValue
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isClientCellBlockSupport
parameter_list|()
block|{
return|return
name|this
operator|.
name|connection
operator|!=
literal|null
operator|&&
name|this
operator|.
name|connection
operator|.
name|codec
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|disconnectSince
parameter_list|()
block|{
if|if
condition|(
operator|!
name|connection
operator|.
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
block|{
return|return
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|timestamp
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1L
return|;
block|}
block|}
specifier|public
name|long
name|getSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|size
return|;
block|}
comment|/**      * If we have a response, and delay is not set, then respond      * immediately.  Otherwise, do not respond to client.  This is      * called by the RPC code in the context of the Handler thread.      */
specifier|public
specifier|synchronized
name|void
name|sendResponseIfReady
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|delayResponse
condition|)
block|{
name|this
operator|.
name|responder
operator|.
name|doRespond
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|UserGroupInformation
name|getRemoteUser
parameter_list|()
block|{
return|return
name|connection
operator|.
name|user
return|;
block|}
annotation|@
name|Override
specifier|public
name|User
name|getRequestUser
parameter_list|()
block|{
return|return
name|user
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getRequestUserName
parameter_list|()
block|{
name|User
name|user
init|=
name|getRequestUser
argument_list|()
decl_stmt|;
return|return
name|user
operator|==
literal|null
condition|?
literal|null
else|:
name|user
operator|.
name|getShortName
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|InetAddress
name|getRemoteAddress
parameter_list|()
block|{
return|return
name|remoteAddress
return|;
block|}
annotation|@
name|Override
specifier|public
name|VersionInfo
name|getClientVersionInfo
parameter_list|()
block|{
return|return
name|connection
operator|.
name|getVersionInfo
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setCallBack
parameter_list|(
name|RpcCallback
name|callback
parameter_list|)
block|{
name|this
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
block|}
block|}
comment|/** Listens on the socket. Creates jobs for the handler threads*/
specifier|private
class|class
name|Listener
extends|extends
name|Thread
block|{
specifier|private
name|ServerSocketChannel
name|acceptChannel
init|=
literal|null
decl_stmt|;
comment|//the accept channel
specifier|private
name|Selector
name|selector
init|=
literal|null
decl_stmt|;
comment|//the selector that we use for the server
specifier|private
name|Reader
index|[]
name|readers
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|currentReader
init|=
literal|0
decl_stmt|;
specifier|private
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
specifier|private
name|long
name|lastCleanupRunTime
init|=
literal|0
decl_stmt|;
comment|//the last time when a cleanup connec-
comment|//-tion (for idle connections) ran
specifier|private
name|long
name|cleanupInterval
init|=
literal|10000
decl_stmt|;
comment|//the minimum interval between
comment|//two cleanup runs
specifier|private
name|int
name|backlogLength
decl_stmt|;
specifier|private
name|ExecutorService
name|readPool
decl_stmt|;
specifier|public
name|Listener
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|backlogLength
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.listen.queue.size"
argument_list|,
literal|128
argument_list|)
expr_stmt|;
comment|// Create a new server socket and set to non blocking mode
name|acceptChannel
operator|=
name|ServerSocketChannel
operator|.
name|open
argument_list|()
expr_stmt|;
name|acceptChannel
operator|.
name|configureBlocking
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Bind the server socket to the binding addrees (can be different from the default interface)
name|bind
argument_list|(
name|acceptChannel
operator|.
name|socket
argument_list|()
argument_list|,
name|bindAddress
argument_list|,
name|backlogLength
argument_list|)
expr_stmt|;
name|port
operator|=
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|getLocalPort
argument_list|()
expr_stmt|;
comment|//Could be an ephemeral port
name|address
operator|=
operator|(
name|InetSocketAddress
operator|)
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|getLocalSocketAddress
argument_list|()
expr_stmt|;
comment|// create a selector;
name|selector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
name|readers
operator|=
operator|new
name|Reader
index|[
name|readThreads
index|]
expr_stmt|;
name|readPool
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|readThreads
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"RpcServer.reader=%d,bindAddress="
operator|+
name|bindAddress
operator|.
name|getHostName
argument_list|()
operator|+
literal|",port="
operator|+
name|port
argument_list|)
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|readThreads
condition|;
operator|++
name|i
control|)
block|{
name|Reader
name|reader
init|=
operator|new
name|Reader
argument_list|()
decl_stmt|;
name|readers
index|[
name|i
index|]
operator|=
name|reader
expr_stmt|;
name|readPool
operator|.
name|execute
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": started "
operator|+
name|readThreads
operator|+
literal|" reader(s)."
argument_list|)
expr_stmt|;
comment|// Register accepts on the server socket with the selector.
name|acceptChannel
operator|.
name|register
argument_list|(
name|selector
argument_list|,
name|SelectionKey
operator|.
name|OP_ACCEPT
argument_list|)
expr_stmt|;
name|this
operator|.
name|setName
argument_list|(
literal|"RpcServer.listener,port="
operator|+
name|port
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
class|class
name|Reader
implements|implements
name|Runnable
block|{
specifier|private
specifier|volatile
name|boolean
name|adding
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|Selector
name|readSelector
decl_stmt|;
name|Reader
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|readSelector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|doRunLoop
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|readSelector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getName
argument_list|()
operator|+
literal|": error closing read selector in "
operator|+
name|getName
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|synchronized
name|void
name|doRunLoop
parameter_list|()
block|{
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|readSelector
operator|.
name|select
argument_list|()
expr_stmt|;
while|while
condition|(
name|adding
condition|)
block|{
name|this
operator|.
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|readSelector
operator|.
name|selectedKeys
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SelectionKey
name|key
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|key
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|isReadable
argument_list|()
condition|)
block|{
name|doRead
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Interrupted while sleeping"
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": IOException in Reader"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**        * This gets reader into the state that waits for the new channel        * to be registered with readSelector. If it was waiting in select()        * the thread will be woken up, otherwise whenever select() is called        * it will return even if there is nothing to read and wait        * in while(adding) for finishAdd call        */
specifier|public
name|void
name|startAdd
parameter_list|()
block|{
name|adding
operator|=
literal|true
expr_stmt|;
name|readSelector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|SelectionKey
name|registerChannel
parameter_list|(
name|SocketChannel
name|channel
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|channel
operator|.
name|register
argument_list|(
name|readSelector
argument_list|,
name|SelectionKey
operator|.
name|OP_READ
argument_list|)
return|;
block|}
specifier|public
specifier|synchronized
name|void
name|finishAdd
parameter_list|()
block|{
name|adding
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** cleanup connections from connectionList. Choose a random range      * to scan and also have a limit on the number of the connections      * that will be cleanedup per run. The criteria for cleanup is the time      * for which the connection was idle. If 'force' is true then all      * connections will be looked at for the cleanup.      * @param force all connections will be looked at for cleanup      */
specifier|private
name|void
name|cleanupConnections
parameter_list|(
name|boolean
name|force
parameter_list|)
block|{
if|if
condition|(
name|force
operator|||
name|numConnections
operator|>
name|thresholdIdleConnections
condition|)
block|{
name|long
name|currentTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|currentTime
operator|-
name|lastCleanupRunTime
operator|)
operator|<
name|cleanupInterval
condition|)
block|{
return|return;
block|}
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|numConnections
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|start
operator|=
name|rand
operator|.
name|nextInt
argument_list|()
operator|%
name|numConnections
expr_stmt|;
name|end
operator|=
name|rand
operator|.
name|nextInt
argument_list|()
operator|%
name|numConnections
expr_stmt|;
name|int
name|temp
decl_stmt|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
name|temp
operator|=
name|start
expr_stmt|;
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|int
name|i
init|=
name|start
decl_stmt|;
name|int
name|numNuked
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<=
name|end
condition|)
block|{
name|Connection
name|c
decl_stmt|;
synchronized|synchronized
init|(
name|connectionList
init|)
block|{
try|try
block|{
name|c
operator|=
name|connectionList
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|c
operator|.
name|timedOut
argument_list|(
name|currentTime
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": disconnecting client "
operator|+
name|c
operator|.
name|getHostAddress
argument_list|()
argument_list|)
expr_stmt|;
name|closeConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|numNuked
operator|++
expr_stmt|;
name|end
operator|--
expr_stmt|;
comment|//noinspection UnusedAssignment
name|c
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|numNuked
operator|==
name|maxConnectionsToNuke
condition|)
break|break;
block|}
else|else
name|i
operator|++
expr_stmt|;
block|}
name|lastCleanupRunTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": starting"
argument_list|)
expr_stmt|;
while|while
condition|(
name|running
condition|)
block|{
name|SelectionKey
name|key
init|=
literal|null
decl_stmt|;
try|try
block|{
name|selector
operator|.
name|select
argument_list|()
expr_stmt|;
comment|// FindBugs IS2_INCONSISTENT_SYNC
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|selector
operator|.
name|selectedKeys
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|key
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|key
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|isAcceptable
argument_list|()
condition|)
name|doAccept
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
name|key
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|e
parameter_list|)
block|{
if|if
condition|(
name|errorHandler
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|errorHandler
operator|.
name|checkOOME
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exiting on OutOfMemoryError"
argument_list|)
expr_stmt|;
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|cleanupConnections
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// we can run out of memory if we have too many threads
comment|// log the event and sleep for a minute and give
comment|// some thread(s) a chance to finish
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|": OutOfMemoryError in server select"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|cleanupConnections
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|60000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Interrupted while sleeping"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|cleanupConnections
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": stopping"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|acceptChannel
operator|.
name|close
argument_list|()
expr_stmt|;
name|selector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
name|selector
operator|=
literal|null
expr_stmt|;
name|acceptChannel
operator|=
literal|null
expr_stmt|;
comment|// clean up all connections
while|while
condition|(
operator|!
name|connectionList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|closeConnection
argument_list|(
name|connectionList
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|closeCurrentConnection
parameter_list|(
name|SelectionKey
name|key
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|Connection
name|c
init|=
operator|(
name|Connection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": disconnecting client "
operator|+
name|c
operator|.
name|getHostAddress
argument_list|()
operator|+
operator|(
name|e
operator|!=
literal|null
condition|?
literal|" on error "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
name|closeConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|key
operator|.
name|attach
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|InetSocketAddress
name|getAddress
parameter_list|()
block|{
return|return
name|address
return|;
block|}
name|void
name|doAccept
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|IOException
throws|,
name|OutOfMemoryError
block|{
name|Connection
name|c
decl_stmt|;
name|ServerSocketChannel
name|server
init|=
operator|(
name|ServerSocketChannel
operator|)
name|key
operator|.
name|channel
argument_list|()
decl_stmt|;
name|SocketChannel
name|channel
decl_stmt|;
while|while
condition|(
operator|(
name|channel
operator|=
name|server
operator|.
name|accept
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|channel
operator|.
name|configureBlocking
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|channel
operator|.
name|socket
argument_list|()
operator|.
name|setTcpNoDelay
argument_list|(
name|tcpNoDelay
argument_list|)
expr_stmt|;
name|channel
operator|.
name|socket
argument_list|()
operator|.
name|setKeepAlive
argument_list|(
name|tcpKeepAlive
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|channel
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
name|Reader
name|reader
init|=
name|getReader
argument_list|()
decl_stmt|;
try|try
block|{
name|reader
operator|.
name|startAdd
argument_list|()
expr_stmt|;
name|SelectionKey
name|readKey
init|=
name|reader
operator|.
name|registerChannel
argument_list|(
name|channel
argument_list|)
decl_stmt|;
name|c
operator|=
name|getConnection
argument_list|(
name|channel
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|readKey
operator|.
name|attach
argument_list|(
name|c
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|connectionList
init|)
block|{
name|connectionList
operator|.
name|add
argument_list|(
name|numConnections
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|numConnections
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": connection from "
operator|+
name|c
operator|.
name|toString
argument_list|()
operator|+
literal|"; # active connections: "
operator|+
name|numConnections
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reader
operator|.
name|finishAdd
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|void
name|doRead
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|int
name|count
decl_stmt|;
name|Connection
name|c
init|=
operator|(
name|Connection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|c
operator|.
name|setLastContact
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|count
operator|=
name|c
operator|.
name|readAndProcess
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|c
operator|.
name|setLastContact
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ieo
parameter_list|)
block|{
throw|throw
name|ieo
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": Caught exception while reading:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
operator|-
literal|1
expr_stmt|;
comment|//so that the (count< 0) block is executed
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": DISCONNECTING client "
operator|+
name|c
operator|.
name|toString
argument_list|()
operator|+
literal|" because read count="
operator|+
name|count
operator|+
literal|". Number of active connections: "
operator|+
name|numConnections
argument_list|)
expr_stmt|;
block|}
name|closeConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
specifier|synchronized
name|void
name|doStop
parameter_list|()
block|{
if|if
condition|(
name|selector
operator|!=
literal|null
condition|)
block|{
name|selector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|acceptChannel
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exception in closing listener socket. "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|readPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
comment|// The method that will return the next reader to work with
comment|// Simplistic implementation of round robin for now
name|Reader
name|getReader
parameter_list|()
block|{
name|currentReader
operator|=
operator|(
name|currentReader
operator|+
literal|1
operator|)
operator|%
name|readers
operator|.
name|length
expr_stmt|;
return|return
name|readers
index|[
name|currentReader
index|]
return|;
block|}
block|}
comment|// Sends responses of RPC back to clients.
specifier|protected
class|class
name|Responder
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|Selector
name|writeSelector
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|Connection
argument_list|>
name|writingCons
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|Connection
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|Responder
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|setName
argument_list|(
literal|"RpcServer.responder"
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writeSelector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
comment|// create a selector
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": starting"
argument_list|)
expr_stmt|;
try|try
block|{
name|doRunLoop
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": stopping"
argument_list|)
expr_stmt|;
try|try
block|{
name|writeSelector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getName
argument_list|()
operator|+
literal|": couldn't close write selector"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Take the list of the connections that want to write, and register them      * in the selector.      */
specifier|private
name|void
name|registerWrites
parameter_list|()
block|{
name|Iterator
argument_list|<
name|Connection
argument_list|>
name|it
init|=
name|writingCons
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Connection
name|c
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|SelectionKey
name|sk
init|=
name|c
operator|.
name|channel
operator|.
name|keyFor
argument_list|(
name|writeSelector
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|sk
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|c
operator|.
name|channel
operator|.
name|register
argument_list|(
name|writeSelector
argument_list|,
name|SelectionKey
operator|.
name|OP_WRITE
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
comment|// ignore: the client went away.
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sk
operator|.
name|interestOps
argument_list|(
name|SelectionKey
operator|.
name|OP_WRITE
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CancelledKeyException
name|e
parameter_list|)
block|{
comment|// ignore: the client went away.
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Add a connection to the list that want to write,      */
specifier|public
name|void
name|registerForWrite
parameter_list|(
name|Connection
name|c
parameter_list|)
block|{
if|if
condition|(
name|writingCons
operator|.
name|add
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|writeSelector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|doRunLoop
parameter_list|()
block|{
name|long
name|lastPurgeTime
init|=
literal|0
decl_stmt|;
comment|// last check for old calls.
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|registerWrites
argument_list|()
expr_stmt|;
name|int
name|keyCt
init|=
name|writeSelector
operator|.
name|select
argument_list|(
name|purgeTimeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyCt
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|Set
argument_list|<
name|SelectionKey
argument_list|>
name|keys
init|=
name|writeSelector
operator|.
name|selectedKeys
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|keys
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SelectionKey
name|key
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|key
operator|.
name|isValid
argument_list|()
operator|&&
name|key
operator|.
name|isWritable
argument_list|()
condition|)
block|{
name|doAsyncWrite
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": asyncWrite"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|lastPurgeTime
operator|=
name|purge
argument_list|(
name|lastPurgeTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|e
parameter_list|)
block|{
if|if
condition|(
name|errorHandler
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|errorHandler
operator|.
name|checkOOME
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exiting on OutOfMemoryError"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|//
comment|// we can run out of memory if we have too many threads
comment|// log the event and sleep for a minute and give
comment|// some thread(s) a chance to finish
comment|//
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|": OutOfMemoryError in server select"
argument_list|,
name|e
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|60000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Interrupted while sleeping"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exception in Responder "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": stopped"
argument_list|)
expr_stmt|;
block|}
comment|/**      * If there were some calls that have not been sent out for a      * long time, we close the connection.      * @return the time of the purge.      */
specifier|private
name|long
name|purge
parameter_list|(
name|long
name|lastPurgeTime
parameter_list|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|<
name|lastPurgeTime
operator|+
name|purgeTimeout
condition|)
block|{
return|return
name|lastPurgeTime
return|;
block|}
name|ArrayList
argument_list|<
name|Connection
argument_list|>
name|conWithOldCalls
init|=
operator|new
name|ArrayList
argument_list|<
name|Connection
argument_list|>
argument_list|()
decl_stmt|;
comment|// get the list of channels from list of keys.
synchronized|synchronized
init|(
name|writeSelector
operator|.
name|keys
argument_list|()
init|)
block|{
for|for
control|(
name|SelectionKey
name|key
range|:
name|writeSelector
operator|.
name|keys
argument_list|()
control|)
block|{
name|Connection
name|connection
init|=
operator|(
name|Connection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Coding error: SelectionKey key without attachment."
argument_list|)
throw|;
block|}
name|Call
name|call
init|=
name|connection
operator|.
name|responseQueue
operator|.
name|peekFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
operator|&&
name|now
operator|>
name|call
operator|.
name|timestamp
operator|+
name|purgeTimeout
condition|)
block|{
name|conWithOldCalls
operator|.
name|add
argument_list|(
name|call
operator|.
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Seems safer to close the connection outside of the synchronized loop...
for|for
control|(
name|Connection
name|connection
range|:
name|conWithOldCalls
control|)
block|{
name|closeConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
return|return
name|now
return|;
block|}
specifier|private
name|void
name|doAsyncWrite
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|Connection
name|connection
init|=
operator|(
name|Connection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"doAsyncWrite: no connection"
argument_list|)
throw|;
block|}
if|if
condition|(
name|key
operator|.
name|channel
argument_list|()
operator|!=
name|connection
operator|.
name|channel
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"doAsyncWrite: bad channel"
argument_list|)
throw|;
block|}
if|if
condition|(
name|processAllResponses
argument_list|(
name|connection
argument_list|)
condition|)
block|{
try|try
block|{
comment|// We wrote everything, so we don't need to be told when the socket is ready for
comment|//  write anymore.
name|key
operator|.
name|interestOps
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancelledKeyException
name|e
parameter_list|)
block|{
comment|/* The Listener/reader might have closed the socket.            * We don't explicitly cancel the key, so not sure if this will            * ever fire.            * This warning could be removed.            */
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while changing ops : "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Process the response for this call. You need to have the lock on      * {@link org.apache.hadoop.hbase.ipc.RpcServer.Connection#responseWriteLock}      *      * @param call the call      * @return true if we proceed the call fully, false otherwise.      * @throws IOException      */
specifier|private
name|boolean
name|processResponse
parameter_list|(
specifier|final
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|error
init|=
literal|true
decl_stmt|;
try|try
block|{
comment|// Send as much data as we can in the non-blocking fashion
name|long
name|numBytes
init|=
name|channelWrite
argument_list|(
name|call
operator|.
name|connection
operator|.
name|channel
argument_list|,
name|call
operator|.
name|response
argument_list|)
decl_stmt|;
if|if
condition|(
name|numBytes
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
literal|"Error writing on the socket "
operator|+
literal|"for the call:"
operator|+
name|call
operator|.
name|toShortString
argument_list|()
argument_list|)
throw|;
block|}
name|error
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|error
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
name|call
operator|.
name|toShortString
argument_list|()
operator|+
literal|": output error -- closing"
argument_list|)
expr_stmt|;
name|closeConnection
argument_list|(
name|call
operator|.
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|call
operator|.
name|response
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|call
operator|.
name|done
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
comment|// Socket can't take more, we will have to come back.
block|}
block|}
comment|/**      * Process all the responses for this connection      *      * @return true if all the calls were processed or that someone else is doing it.      * false if there * is still some work to do. In this case, we expect the caller to      * delay us.      * @throws IOException      */
specifier|private
name|boolean
name|processAllResponses
parameter_list|(
specifier|final
name|Connection
name|connection
parameter_list|)
throws|throws
name|IOException
block|{
comment|// We want only one writer on the channel for a connection at a time.
name|connection
operator|.
name|responseWriteLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
comment|// protection if some handlers manage to need all the responder
name|Call
name|call
init|=
name|connection
operator|.
name|responseQueue
operator|.
name|pollFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|processResponse
argument_list|(
name|call
argument_list|)
condition|)
block|{
name|connection
operator|.
name|responseQueue
operator|.
name|addFirst
argument_list|(
name|call
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
finally|finally
block|{
name|connection
operator|.
name|responseWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|connection
operator|.
name|responseQueue
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|//
comment|// Enqueue a response from the application.
comment|//
name|void
name|doRespond
parameter_list|(
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
comment|// If there is already a write in progress, we don't wait. This allows to free the handlers
comment|//  immediately for other tasks.
if|if
condition|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|call
operator|.
name|connection
operator|.
name|responseWriteLock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If we're alone, we can try to do a direct call to the socket. It's
comment|//  an optimisation to save on context switches and data transfer between cores..
if|if
condition|(
name|processResponse
argument_list|(
name|call
argument_list|)
condition|)
block|{
return|return;
comment|// we're done.
block|}
comment|// Too big to fit, putting ahead.
name|call
operator|.
name|connection
operator|.
name|responseQueue
operator|.
name|addFirst
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
comment|// We will register to the selector later, outside of the lock.
block|}
block|}
finally|finally
block|{
name|call
operator|.
name|connection
operator|.
name|responseWriteLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|call
operator|.
name|connection
operator|.
name|responseQueue
operator|.
name|addLast
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
name|call
operator|.
name|responder
operator|.
name|registerForWrite
argument_list|(
name|call
operator|.
name|connection
argument_list|)
expr_stmt|;
comment|// set the serve time when the response has to be sent later
name|call
operator|.
name|timestamp
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|public
specifier|static
class|class
name|CallQueueTooBigException
extends|extends
name|IOException
block|{
name|CallQueueTooBigException
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Reads calls from a connection and queues them for handling. */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"VO_VOLATILE_INCREMENT"
argument_list|,
name|justification
operator|=
literal|"False positive according to http://sourceforge.net/p/findbugs/bugs/1032/"
argument_list|)
specifier|public
class|class
name|Connection
block|{
comment|// If initial preamble with version and magic has been read or not.
specifier|private
name|boolean
name|connectionPreambleRead
init|=
literal|false
decl_stmt|;
comment|// If the connection header has been read or not.
specifier|private
name|boolean
name|connectionHeaderRead
init|=
literal|false
decl_stmt|;
specifier|protected
name|SocketChannel
name|channel
decl_stmt|;
specifier|private
name|ByteBuffer
name|data
decl_stmt|;
specifier|private
name|ByteBuffer
name|dataLengthBuffer
decl_stmt|;
specifier|protected
specifier|final
name|ConcurrentLinkedDeque
argument_list|<
name|Call
argument_list|>
name|responseQueue
init|=
operator|new
name|ConcurrentLinkedDeque
argument_list|<
name|Call
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|responseWriteLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
name|Counter
name|rpcCount
init|=
operator|new
name|Counter
argument_list|()
decl_stmt|;
comment|// number of outstanding rpcs
specifier|private
name|long
name|lastContact
decl_stmt|;
specifier|private
name|InetAddress
name|addr
decl_stmt|;
specifier|protected
name|Socket
name|socket
decl_stmt|;
comment|// Cache the remote host& port info so that even if the socket is
comment|// disconnected, we can say where it used to connect to.
specifier|protected
name|String
name|hostAddress
decl_stmt|;
specifier|protected
name|int
name|remotePort
decl_stmt|;
name|ConnectionHeader
name|connectionHeader
decl_stmt|;
comment|/**      * Codec the client asked use.      */
specifier|private
name|Codec
name|codec
decl_stmt|;
comment|/**      * Compression codec the client asked us use.      */
specifier|private
name|CompressionCodec
name|compressionCodec
decl_stmt|;
name|BlockingService
name|service
decl_stmt|;
specifier|protected
name|UserGroupInformation
name|user
init|=
literal|null
decl_stmt|;
specifier|private
name|AuthMethod
name|authMethod
decl_stmt|;
specifier|private
name|boolean
name|saslContextEstablished
decl_stmt|;
specifier|private
name|boolean
name|skipInitialSaslHandshake
decl_stmt|;
specifier|private
name|ByteBuffer
name|unwrappedData
decl_stmt|;
comment|// When is this set?  FindBugs wants to know!  Says NP
specifier|private
name|ByteBuffer
name|unwrappedDataLengthBuffer
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|boolean
name|useSasl
decl_stmt|;
name|SaslServer
name|saslServer
decl_stmt|;
specifier|private
name|boolean
name|useWrap
init|=
literal|false
decl_stmt|;
comment|// Fake 'call' for failed authorization response
specifier|private
specifier|static
specifier|final
name|int
name|AUTHORIZATION_FAILED_CALLID
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
name|Call
name|authFailedCall
init|=
operator|new
name|Call
argument_list|(
name|AUTHORIZATION_FAILED_CALLID
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|private
name|ByteArrayOutputStream
name|authFailedResponse
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
comment|// Fake 'call' for SASL context setup
specifier|private
specifier|static
specifier|final
name|int
name|SASL_CALLID
init|=
operator|-
literal|33
decl_stmt|;
specifier|private
specifier|final
name|Call
name|saslCall
init|=
operator|new
name|Call
argument_list|(
name|SASL_CALLID
argument_list|,
name|this
operator|.
name|service
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|public
name|UserGroupInformation
name|attemptingUser
init|=
literal|null
decl_stmt|;
comment|// user name before auth
specifier|public
name|Connection
parameter_list|(
name|SocketChannel
name|channel
parameter_list|,
name|long
name|lastContact
parameter_list|)
block|{
name|this
operator|.
name|channel
operator|=
name|channel
expr_stmt|;
name|this
operator|.
name|lastContact
operator|=
name|lastContact
expr_stmt|;
name|this
operator|.
name|data
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|dataLengthBuffer
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|=
name|channel
operator|.
name|socket
argument_list|()
expr_stmt|;
name|this
operator|.
name|addr
operator|=
name|socket
operator|.
name|getInetAddress
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|hostAddress
operator|=
literal|"*Unknown*"
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|hostAddress
operator|=
name|addr
operator|.
name|getHostAddress
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|remotePort
operator|=
name|socket
operator|.
name|getPort
argument_list|()
expr_stmt|;
if|if
condition|(
name|socketSendBufferSize
operator|!=
literal|0
condition|)
block|{
try|try
block|{
name|socket
operator|.
name|setSendBufferSize
argument_list|(
name|socketSendBufferSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Connection: unable to set socket send buffer size to "
operator|+
name|socketSendBufferSize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getHostAddress
argument_list|()
operator|+
literal|":"
operator|+
name|remotePort
return|;
block|}
specifier|public
name|String
name|getHostAddress
parameter_list|()
block|{
return|return
name|hostAddress
return|;
block|}
specifier|public
name|InetAddress
name|getHostInetAddress
parameter_list|()
block|{
return|return
name|addr
return|;
block|}
specifier|public
name|int
name|getRemotePort
parameter_list|()
block|{
return|return
name|remotePort
return|;
block|}
specifier|public
name|void
name|setLastContact
parameter_list|(
name|long
name|lastContact
parameter_list|)
block|{
name|this
operator|.
name|lastContact
operator|=
name|lastContact
expr_stmt|;
block|}
specifier|public
name|VersionInfo
name|getVersionInfo
parameter_list|()
block|{
if|if
condition|(
name|connectionHeader
operator|.
name|hasVersionInfo
argument_list|()
condition|)
block|{
return|return
name|connectionHeader
operator|.
name|getVersionInfo
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/* Return true if the connection has no outstanding rpc */
specifier|private
name|boolean
name|isIdle
parameter_list|()
block|{
return|return
name|rpcCount
operator|.
name|get
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/* Decrement the outstanding RPC count */
specifier|protected
name|void
name|decRpcCount
parameter_list|()
block|{
name|rpcCount
operator|.
name|decrement
argument_list|()
expr_stmt|;
block|}
comment|/* Increment the outstanding RPC count */
specifier|protected
name|void
name|incRpcCount
parameter_list|()
block|{
name|rpcCount
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|boolean
name|timedOut
parameter_list|(
name|long
name|currentTime
parameter_list|)
block|{
return|return
name|isIdle
argument_list|()
operator|&&
name|currentTime
operator|-
name|lastContact
operator|>
name|maxIdleTime
return|;
block|}
specifier|private
name|UserGroupInformation
name|getAuthorizedUgi
parameter_list|(
name|String
name|authorizedId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|DIGEST
condition|)
block|{
name|TokenIdentifier
name|tokenId
init|=
name|HBaseSaslRpcServer
operator|.
name|getIdentifier
argument_list|(
name|authorizedId
argument_list|,
name|secretManager
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|tokenId
operator|.
name|getUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|ugi
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"Can't retrieve username from tokenIdentifier."
argument_list|)
throw|;
block|}
name|ugi
operator|.
name|addTokenIdentifier
argument_list|(
name|tokenId
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
else|else
block|{
return|return
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|authorizedId
argument_list|)
return|;
block|}
block|}
specifier|private
name|void
name|saslReadAndProcess
parameter_list|(
name|byte
index|[]
name|saslToken
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|saslContextEstablished
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"Have read input token of size "
operator|+
name|saslToken
operator|.
name|length
operator|+
literal|" for processing by saslServer.unwrap()"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|useWrap
condition|)
block|{
name|processOneRpc
argument_list|(
name|saslToken
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|plaintextData
init|=
name|saslServer
operator|.
name|unwrap
argument_list|(
name|saslToken
argument_list|,
literal|0
argument_list|,
name|saslToken
operator|.
name|length
argument_list|)
decl_stmt|;
name|processUnwrappedData
argument_list|(
name|plaintextData
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|byte
index|[]
name|replyToken
decl_stmt|;
try|try
block|{
if|if
condition|(
name|saslServer
operator|==
literal|null
condition|)
block|{
switch|switch
condition|(
name|authMethod
condition|)
block|{
case|case
name|DIGEST
case|:
if|if
condition|(
name|secretManager
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"Server is not configured to do DIGEST authentication."
argument_list|)
throw|;
block|}
name|saslServer
operator|=
name|Sasl
operator|.
name|createSaslServer
argument_list|(
name|AuthMethod
operator|.
name|DIGEST
operator|.
name|getMechanismName
argument_list|()
argument_list|,
literal|null
argument_list|,
name|SaslUtil
operator|.
name|SASL_DEFAULT_REALM
argument_list|,
name|SaslUtil
operator|.
name|SASL_PROPS
argument_list|,
operator|new
name|SaslDigestCallbackHandler
argument_list|(
name|secretManager
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UserGroupInformation
name|current
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|String
name|fullName
init|=
name|current
operator|.
name|getUserName
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Kerberos principal name is "
operator|+
name|fullName
argument_list|)
expr_stmt|;
block|}
specifier|final
name|String
name|names
index|[]
init|=
name|SaslUtil
operator|.
name|splitKerberosName
argument_list|(
name|fullName
argument_list|)
decl_stmt|;
if|if
condition|(
name|names
operator|.
name|length
operator|!=
literal|3
condition|)
block|{
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"Kerberos principal name does NOT have the expected "
operator|+
literal|"hostname part: "
operator|+
name|fullName
argument_list|)
throw|;
block|}
name|current
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|SaslException
block|{
name|saslServer
operator|=
name|Sasl
operator|.
name|createSaslServer
argument_list|(
name|AuthMethod
operator|.
name|KERBEROS
operator|.
name|getMechanismName
argument_list|()
argument_list|,
name|names
index|[
literal|0
index|]
argument_list|,
name|names
index|[
literal|1
index|]
argument_list|,
name|SaslUtil
operator|.
name|SASL_PROPS
argument_list|,
operator|new
name|SaslGssCallbackHandler
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saslServer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"Unable to find SASL server implementation for "
operator|+
name|authMethod
operator|.
name|getMechanismName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created SASL server with mechanism = "
operator|+
name|authMethod
operator|.
name|getMechanismName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Have read input token of size "
operator|+
name|saslToken
operator|.
name|length
operator|+
literal|" for processing by saslServer.evaluateResponse()"
argument_list|)
expr_stmt|;
block|}
name|replyToken
operator|=
name|saslServer
operator|.
name|evaluateResponse
argument_list|(
name|saslToken
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOException
name|sendToClient
init|=
name|e
decl_stmt|;
name|Throwable
name|cause
init|=
name|e
decl_stmt|;
while|while
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cause
operator|instanceof
name|InvalidToken
condition|)
block|{
name|sendToClient
operator|=
operator|(
name|InvalidToken
operator|)
name|cause
expr_stmt|;
break|break;
block|}
name|cause
operator|=
name|cause
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
name|doRawSaslReply
argument_list|(
name|SaslStatus
operator|.
name|ERROR
argument_list|,
literal|null
argument_list|,
name|sendToClient
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|sendToClient
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|authenticationFailure
argument_list|()
expr_stmt|;
name|String
name|clientIP
init|=
name|this
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// attempting user could be null
name|AUDITLOG
operator|.
name|warn
argument_list|(
name|AUTH_FAILED_FOR
operator|+
name|clientIP
operator|+
literal|":"
operator|+
name|attemptingUser
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
name|replyToken
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Will send token of size "
operator|+
name|replyToken
operator|.
name|length
operator|+
literal|" from saslServer."
argument_list|)
expr_stmt|;
block|}
name|doRawSaslReply
argument_list|(
name|SaslStatus
operator|.
name|SUCCESS
argument_list|,
operator|new
name|BytesWritable
argument_list|(
name|replyToken
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saslServer
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|String
name|qop
init|=
operator|(
name|String
operator|)
name|saslServer
operator|.
name|getNegotiatedProperty
argument_list|(
name|Sasl
operator|.
name|QOP
argument_list|)
decl_stmt|;
name|useWrap
operator|=
name|qop
operator|!=
literal|null
operator|&&
operator|!
literal|"auth"
operator|.
name|equalsIgnoreCase
argument_list|(
name|qop
argument_list|)
expr_stmt|;
name|user
operator|=
name|getAuthorizedUgi
argument_list|(
name|saslServer
operator|.
name|getAuthorizationID
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"SASL server context established. Authenticated client: "
operator|+
name|user
operator|+
literal|". Negotiated QoP is "
operator|+
name|saslServer
operator|.
name|getNegotiatedProperty
argument_list|(
name|Sasl
operator|.
name|QOP
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|metrics
operator|.
name|authenticationSuccess
argument_list|()
expr_stmt|;
name|AUDITLOG
operator|.
name|info
argument_list|(
name|AUTH_SUCCESSFUL_FOR
operator|+
name|user
argument_list|)
expr_stmt|;
name|saslContextEstablished
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|/**      * No protobuf encoding of raw sasl messages      */
specifier|private
name|void
name|doRawSaslReply
parameter_list|(
name|SaslStatus
name|status
parameter_list|,
name|Writable
name|rv
parameter_list|,
name|String
name|errorClass
parameter_list|,
name|String
name|error
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteBufferOutputStream
name|saslResponse
init|=
literal|null
decl_stmt|;
name|DataOutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// In my testing, have noticed that sasl messages are usually
comment|// in the ballpark of 100-200. That's why the initial capacity is 256.
name|saslResponse
operator|=
operator|new
name|ByteBufferOutputStream
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|saslResponse
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|status
operator|.
name|state
argument_list|)
expr_stmt|;
comment|// write status
if|if
condition|(
name|status
operator|==
name|SaslStatus
operator|.
name|SUCCESS
condition|)
block|{
name|rv
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WritableUtils
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|errorClass
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|saslCall
operator|.
name|setSaslTokenResponse
argument_list|(
name|saslResponse
operator|.
name|getByteBuffer
argument_list|()
argument_list|)
expr_stmt|;
name|saslCall
operator|.
name|responder
operator|=
name|responder
expr_stmt|;
name|saslCall
operator|.
name|sendResponseIfReady
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|saslResponse
operator|!=
literal|null
condition|)
block|{
name|saslResponse
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|disposeSasl
parameter_list|()
block|{
if|if
condition|(
name|saslServer
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|saslServer
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|saslServer
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SaslException
name|ignored
parameter_list|)
block|{
comment|// Ignored. This is being disposed of anyway.
block|}
block|}
block|}
specifier|private
name|int
name|readPreamble
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|count
decl_stmt|;
comment|// Check for 'HBas' magic.
name|this
operator|.
name|dataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|HConstants
operator|.
name|RPC_HEADER
argument_list|,
name|dataLengthBuffer
operator|.
name|array
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|doBadPreambleHandling
argument_list|(
literal|"Expected HEADER="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|HConstants
operator|.
name|RPC_HEADER
argument_list|)
operator|+
literal|" but received HEADER="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|dataLengthBuffer
operator|.
name|array
argument_list|()
argument_list|)
operator|+
literal|" from "
operator|+
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|// Now read the next two bytes, the version and the auth to use.
name|ByteBuffer
name|versionAndAuthBytes
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|count
operator|=
name|channelRead
argument_list|(
name|channel
argument_list|,
name|versionAndAuthBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
argument_list|<
literal|0
operator|||
name|versionAndAuthBytes
operator|.
name|remaining
operator|(
operator|)
argument_list|>
literal|0
condition|)
block|{
return|return
name|count
return|;
block|}
name|int
name|version
init|=
name|versionAndAuthBytes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|byte
name|authbyte
init|=
name|versionAndAuthBytes
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|this
operator|.
name|authMethod
operator|=
name|AuthMethod
operator|.
name|valueOf
argument_list|(
name|authbyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|CURRENT_VERSION
condition|)
block|{
name|String
name|msg
init|=
name|getFatalConnectionString
argument_list|(
name|version
argument_list|,
name|authbyte
argument_list|)
decl_stmt|;
return|return
name|doBadPreambleHandling
argument_list|(
name|msg
argument_list|,
operator|new
name|WrongVersionException
argument_list|(
name|msg
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|authMethod
operator|==
literal|null
condition|)
block|{
name|String
name|msg
init|=
name|getFatalConnectionString
argument_list|(
name|version
argument_list|,
name|authbyte
argument_list|)
decl_stmt|;
return|return
name|doBadPreambleHandling
argument_list|(
name|msg
argument_list|,
operator|new
name|BadAuthException
argument_list|(
name|msg
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|isSecurityEnabled
operator|&&
name|authMethod
operator|==
name|AuthMethod
operator|.
name|SIMPLE
condition|)
block|{
name|AccessDeniedException
name|ae
init|=
operator|new
name|AccessDeniedException
argument_list|(
literal|"Authentication is required"
argument_list|)
decl_stmt|;
name|setupResponse
argument_list|(
name|authFailedResponse
argument_list|,
name|authFailedCall
argument_list|,
name|ae
argument_list|,
name|ae
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|responder
operator|.
name|doRespond
argument_list|(
name|authFailedCall
argument_list|)
expr_stmt|;
throw|throw
name|ae
throw|;
block|}
if|if
condition|(
operator|!
name|isSecurityEnabled
operator|&&
name|authMethod
operator|!=
name|AuthMethod
operator|.
name|SIMPLE
condition|)
block|{
name|doRawSaslReply
argument_list|(
name|SaslStatus
operator|.
name|SUCCESS
argument_list|,
operator|new
name|IntWritable
argument_list|(
name|SaslUtil
operator|.
name|SWITCH_TO_SIMPLE_AUTH
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|authMethod
operator|=
name|AuthMethod
operator|.
name|SIMPLE
expr_stmt|;
comment|// client has already sent the initial Sasl message and we
comment|// should ignore it. Both client and server should fall back
comment|// to simple auth from now on.
name|skipInitialSaslHandshake
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|authMethod
operator|!=
name|AuthMethod
operator|.
name|SIMPLE
condition|)
block|{
name|useSasl
operator|=
literal|true
expr_stmt|;
block|}
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|connectionPreambleRead
operator|=
literal|true
expr_stmt|;
return|return
name|count
return|;
block|}
specifier|private
name|int
name|read4Bytes
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|dataLengthBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
name|channelRead
argument_list|(
name|channel
argument_list|,
name|this
operator|.
name|dataLengthBuffer
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/**      * Read off the wire. If there is not enough data to read, update the connection state with      *  what we have and returns.      * @return Returns -1 if failure (and caller will close connection), else zero or more.      * @throws IOException      * @throws InterruptedException      */
specifier|public
name|int
name|readAndProcess
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// Try and read in an int.  If new connection, the int will hold the 'HBas' HEADER.  If it
comment|// does, read in the rest of the connection preamble, the version and the auth method.
comment|// Else it will be length of the data to read (or -1 if a ping).  We catch the integer
comment|// length into the 4-byte this.dataLengthBuffer.
name|int
name|count
init|=
name|read4Bytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
argument_list|<
literal|0
operator|||
name|dataLengthBuffer
operator|.
name|remaining
operator|(
operator|)
argument_list|>
literal|0
condition|)
block|{
return|return
name|count
return|;
block|}
comment|// If we have not read the connection setup preamble, look to see if that is on the wire.
if|if
condition|(
operator|!
name|connectionPreambleRead
condition|)
block|{
name|count
operator|=
name|readPreamble
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|connectionPreambleRead
condition|)
block|{
return|return
name|count
return|;
block|}
name|count
operator|=
name|read4Bytes
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
argument_list|<
literal|0
operator|||
name|dataLengthBuffer
operator|.
name|remaining
operator|(
operator|)
argument_list|>
literal|0
condition|)
block|{
return|return
name|count
return|;
block|}
block|}
comment|// We have read a length and we have read the preamble.  It is either the connection header
comment|// or it is a request.
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|dataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|int
name|dataLength
init|=
name|dataLengthBuffer
operator|.
name|getInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataLength
operator|==
name|RpcClient
operator|.
name|PING_CALL_ID
condition|)
block|{
if|if
condition|(
operator|!
name|useWrap
condition|)
block|{
comment|//covers the !useSasl too
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
comment|//ping message
block|}
block|}
if|if
condition|(
name|dataLength
operator|<
literal|0
condition|)
block|{
comment|// A data length of zero is legal.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected data length "
operator|+
name|dataLength
operator|+
literal|"!! from "
operator|+
name|getHostAddress
argument_list|()
argument_list|)
throw|;
block|}
name|data
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|dataLength
argument_list|)
expr_stmt|;
comment|// Increment the rpc count. This counter will be decreased when we write
comment|//  the response.  If we want the connection to be detected as idle properly, we
comment|//  need to keep the inc / dec correct.
name|incRpcCount
argument_list|()
expr_stmt|;
block|}
name|count
operator|=
name|channelRead
argument_list|(
name|channel
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|0
operator|&&
name|data
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// count==0 if dataLength == 0
name|process
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**      * Process the data buffer and clean the connection state for the next call.      */
specifier|private
name|void
name|process
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|data
operator|.
name|flip
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|skipInitialSaslHandshake
condition|)
block|{
name|skipInitialSaslHandshake
operator|=
literal|false
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|useSasl
condition|)
block|{
name|saslReadAndProcess
argument_list|(
name|data
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|processOneRpc
argument_list|(
name|data
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Clean for the next call
name|data
operator|=
literal|null
expr_stmt|;
comment|// For the GC
block|}
block|}
specifier|private
name|String
name|getFatalConnectionString
parameter_list|(
specifier|final
name|int
name|version
parameter_list|,
specifier|final
name|byte
name|authByte
parameter_list|)
block|{
return|return
literal|"serverVersion="
operator|+
name|CURRENT_VERSION
operator|+
literal|", clientVersion="
operator|+
name|version
operator|+
literal|", authMethod="
operator|+
name|authByte
operator|+
literal|", authSupported="
operator|+
operator|(
name|authMethod
operator|!=
literal|null
operator|)
operator|+
literal|" from "
operator|+
name|toString
argument_list|()
return|;
block|}
specifier|private
name|int
name|doBadPreambleHandling
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|doBadPreambleHandling
argument_list|(
name|msg
argument_list|,
operator|new
name|FatalConnectionException
argument_list|(
name|msg
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|int
name|doBadPreambleHandling
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|,
specifier|final
name|Exception
name|e
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|Call
name|fakeCall
init|=
operator|new
name|Call
argument_list|(
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
name|responder
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|setupResponse
argument_list|(
literal|null
argument_list|,
name|fakeCall
argument_list|,
name|e
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|responder
operator|.
name|doRespond
argument_list|(
name|fakeCall
argument_list|)
expr_stmt|;
comment|// Returning -1 closes out the connection.
return|return
operator|-
literal|1
return|;
block|}
comment|// Reads the connection header following version
specifier|private
name|void
name|processConnectionHeader
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|connectionHeader
operator|=
name|ConnectionHeader
operator|.
name|parseFrom
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|String
name|serviceName
init|=
name|connectionHeader
operator|.
name|getServiceName
argument_list|()
decl_stmt|;
if|if
condition|(
name|serviceName
operator|==
literal|null
condition|)
throw|throw
operator|new
name|EmptyServiceNameException
argument_list|()
throw|;
name|this
operator|.
name|service
operator|=
name|getService
argument_list|(
name|services
argument_list|,
name|serviceName
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|service
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnknownServiceException
argument_list|(
name|serviceName
argument_list|)
throw|;
name|setupCellBlockCodecs
argument_list|(
name|this
operator|.
name|connectionHeader
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|protocolUser
init|=
name|createUser
argument_list|(
name|connectionHeader
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|useSasl
condition|)
block|{
name|user
operator|=
name|protocolUser
expr_stmt|;
if|if
condition|(
name|user
operator|!=
literal|null
condition|)
block|{
name|user
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthMethod
operator|.
name|SIMPLE
operator|.
name|authenticationMethod
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// user is authenticated
name|user
operator|.
name|setAuthenticationMethod
argument_list|(
name|authMethod
operator|.
name|authenticationMethod
argument_list|)
expr_stmt|;
comment|//Now we check if this is a proxy user case. If the protocol user is
comment|//different from the 'user', it is a proxy user scenario. However,
comment|//this is not allowed if user authenticated with DIGEST.
if|if
condition|(
operator|(
name|protocolUser
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|protocolUser
operator|.
name|getUserName
argument_list|()
operator|.
name|equals
argument_list|(
name|user
operator|.
name|getUserName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|DIGEST
condition|)
block|{
comment|// Not allowed to doAs if token authentication is used
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"Authenticated user ("
operator|+
name|user
operator|+
literal|") doesn't match what the client claims to be ("
operator|+
name|protocolUser
operator|+
literal|")"
argument_list|)
throw|;
block|}
else|else
block|{
comment|// Effective user can be different from authenticated user
comment|// for simple auth or kerberos auth
comment|// The user is the real user. Now we create a proxy user
name|UserGroupInformation
name|realUser
init|=
name|user
decl_stmt|;
name|user
operator|=
name|UserGroupInformation
operator|.
name|createProxyUser
argument_list|(
name|protocolUser
operator|.
name|getUserName
argument_list|()
argument_list|,
name|realUser
argument_list|)
expr_stmt|;
comment|// Now the user is a proxy user, set Authentication method Proxy.
name|user
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|PROXY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|connectionHeader
operator|.
name|hasVersionInfo
argument_list|()
condition|)
block|{
name|AUDITLOG
operator|.
name|info
argument_list|(
literal|"Connection from "
operator|+
name|this
operator|.
name|hostAddress
operator|+
literal|" port: "
operator|+
name|this
operator|.
name|remotePort
operator|+
literal|" with version info: "
operator|+
name|TextFormat
operator|.
name|shortDebugString
argument_list|(
name|connectionHeader
operator|.
name|getVersionInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AUDITLOG
operator|.
name|info
argument_list|(
literal|"Connection from "
operator|+
name|this
operator|.
name|hostAddress
operator|+
literal|" port: "
operator|+
name|this
operator|.
name|remotePort
operator|+
literal|" with unknown version info"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Set up cell block codecs      * @throws FatalConnectionException      */
specifier|private
name|void
name|setupCellBlockCodecs
parameter_list|(
specifier|final
name|ConnectionHeader
name|header
parameter_list|)
throws|throws
name|FatalConnectionException
block|{
comment|// TODO: Plug in other supported decoders.
if|if
condition|(
operator|!
name|header
operator|.
name|hasCellBlockCodecClass
argument_list|()
condition|)
return|return;
name|String
name|className
init|=
name|header
operator|.
name|getCellBlockCodecClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|className
operator|==
literal|null
operator|||
name|className
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return;
try|try
block|{
name|this
operator|.
name|codec
operator|=
operator|(
name|Codec
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedCellCodecException
argument_list|(
name|className
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|header
operator|.
name|hasCellBlockCompressorClass
argument_list|()
condition|)
return|return;
name|className
operator|=
name|header
operator|.
name|getCellBlockCompressorClass
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|compressionCodec
operator|=
operator|(
name|CompressionCodec
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedCompressionCodecException
argument_list|(
name|className
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|processUnwrappedData
parameter_list|(
name|byte
index|[]
name|inBuf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ReadableByteChannel
name|ch
init|=
name|Channels
operator|.
name|newChannel
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|inBuf
argument_list|)
argument_list|)
decl_stmt|;
comment|// Read all RPCs contained in the inBuf, even partial ones
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|unwrappedDataLengthBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
name|count
operator|=
name|channelRead
argument_list|(
name|ch
argument_list|,
name|unwrappedDataLengthBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
operator|||
name|unwrappedDataLengthBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|unwrappedData
operator|==
literal|null
condition|)
block|{
name|unwrappedDataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|int
name|unwrappedDataLength
init|=
name|unwrappedDataLengthBuffer
operator|.
name|getInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|unwrappedDataLength
operator|==
name|RpcClient
operator|.
name|PING_CALL_ID
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Received ping message"
argument_list|)
expr_stmt|;
name|unwrappedDataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
continue|continue;
comment|// ping message
block|}
name|unwrappedData
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|unwrappedDataLength
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|channelRead
argument_list|(
name|ch
argument_list|,
name|unwrappedData
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
operator|||
name|unwrappedData
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|unwrappedData
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
block|{
name|unwrappedDataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|unwrappedData
operator|.
name|flip
argument_list|()
expr_stmt|;
name|processOneRpc
argument_list|(
name|unwrappedData
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
name|unwrappedData
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|processOneRpc
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|connectionHeaderRead
condition|)
block|{
name|processRequest
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|processConnectionHeader
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|this
operator|.
name|connectionHeaderRead
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|authorizeConnection
argument_list|()
condition|)
block|{
comment|// Throw FatalConnectionException wrapping ACE so client does right thing and closes
comment|// down the connection instead of trying to read non-existent retun.
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"Connection from "
operator|+
name|this
operator|+
literal|" for service "
operator|+
name|connectionHeader
operator|.
name|getServiceName
argument_list|()
operator|+
literal|" is unauthorized for user: "
operator|+
name|user
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * @param buf Has the request header and the request param and optionally encoded data buffer      * all in this one array.      * @throws IOException      * @throws InterruptedException      */
specifier|protected
name|void
name|processRequest
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|long
name|totalRequestSize
init|=
name|buf
operator|.
name|length
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|// Here we read in the header.  We avoid having pb
comment|// do its default 4k allocation for CodedInputStream.  We force it to use backing array.
name|CodedInputStream
name|cis
init|=
name|CodedInputStream
operator|.
name|newInstance
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|headerSize
init|=
name|cis
operator|.
name|readRawVarint32
argument_list|()
decl_stmt|;
name|offset
operator|=
name|cis
operator|.
name|getTotalBytesRead
argument_list|()
expr_stmt|;
name|RequestHeader
name|header
init|=
name|RequestHeader
operator|.
name|newBuilder
argument_list|()
operator|.
name|mergeFrom
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|headerSize
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|offset
operator|+=
name|headerSize
expr_stmt|;
name|int
name|id
init|=
name|header
operator|.
name|getCallId
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"RequestHeader "
operator|+
name|TextFormat
operator|.
name|shortDebugString
argument_list|(
name|header
argument_list|)
operator|+
literal|" totalRequestSize: "
operator|+
name|totalRequestSize
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
block|}
comment|// Enforcing the call queue size, this triggers a retry in the client
comment|// This is a bit late to be doing this check - we have already read in the total request.
if|if
condition|(
operator|(
name|totalRequestSize
operator|+
name|callQueueSize
operator|.
name|get
argument_list|()
operator|)
operator|>
name|maxQueueSize
condition|)
block|{
specifier|final
name|Call
name|callTooBig
init|=
operator|new
name|Call
argument_list|(
name|id
argument_list|,
name|this
operator|.
name|service
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
name|responder
argument_list|,
name|totalRequestSize
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|responseBuffer
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|metrics
operator|.
name|exception
argument_list|(
name|CALL_QUEUE_TOO_BIG_EXCEPTION
argument_list|)
expr_stmt|;
name|setupResponse
argument_list|(
name|responseBuffer
argument_list|,
name|callTooBig
argument_list|,
name|CALL_QUEUE_TOO_BIG_EXCEPTION
argument_list|,
literal|"Call queue is full on "
operator|+
name|getListenerAddress
argument_list|()
operator|+
literal|", is hbase.ipc.server.max.callqueue.size too small?"
argument_list|)
expr_stmt|;
name|responder
operator|.
name|doRespond
argument_list|(
name|callTooBig
argument_list|)
expr_stmt|;
return|return;
block|}
name|MethodDescriptor
name|md
init|=
literal|null
decl_stmt|;
name|Message
name|param
init|=
literal|null
decl_stmt|;
name|CellScanner
name|cellScanner
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|header
operator|.
name|hasRequestParam
argument_list|()
operator|&&
name|header
operator|.
name|getRequestParam
argument_list|()
condition|)
block|{
name|md
operator|=
name|this
operator|.
name|service
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|findMethodByName
argument_list|(
name|header
operator|.
name|getMethodName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|header
operator|.
name|getMethodName
argument_list|()
argument_list|)
throw|;
name|Builder
name|builder
init|=
name|this
operator|.
name|service
operator|.
name|getRequestPrototype
argument_list|(
name|md
argument_list|)
operator|.
name|newBuilderForType
argument_list|()
decl_stmt|;
comment|// To read the varint, I need an inputstream; might as well be a CIS.
name|cis
operator|=
name|CodedInputStream
operator|.
name|newInstance
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|paramSize
init|=
name|cis
operator|.
name|readRawVarint32
argument_list|()
decl_stmt|;
name|offset
operator|+=
name|cis
operator|.
name|getTotalBytesRead
argument_list|()
expr_stmt|;
if|if
condition|(
name|builder
operator|!=
literal|null
condition|)
block|{
name|param
operator|=
name|builder
operator|.
name|mergeFrom
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|paramSize
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|offset
operator|+=
name|paramSize
expr_stmt|;
block|}
if|if
condition|(
name|header
operator|.
name|hasCellBlockMeta
argument_list|()
condition|)
block|{
name|cellScanner
operator|=
name|ipcUtil
operator|.
name|createCellScanner
argument_list|(
name|this
operator|.
name|codec
argument_list|,
name|this
operator|.
name|compressionCodec
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|String
name|msg
init|=
name|getListenerAddress
argument_list|()
operator|+
literal|" is unable to read call parameter from client "
operator|+
name|getHostAddress
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|exception
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|// probably the hbase hadoop version does not match the running hadoop version
if|if
condition|(
name|t
operator|instanceof
name|LinkageError
condition|)
block|{
name|t
operator|=
operator|new
name|DoNotRetryIOException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|// If the method is not present on the server, do not retry.
if|if
condition|(
name|t
operator|instanceof
name|UnsupportedOperationException
condition|)
block|{
name|t
operator|=
operator|new
name|DoNotRetryIOException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Call
name|readParamsFailedCall
init|=
operator|new
name|Call
argument_list|(
name|id
argument_list|,
name|this
operator|.
name|service
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
name|responder
argument_list|,
name|totalRequestSize
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|responseBuffer
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|setupResponse
argument_list|(
name|responseBuffer
argument_list|,
name|readParamsFailedCall
argument_list|,
name|t
argument_list|,
name|msg
operator|+
literal|"; "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|responder
operator|.
name|doRespond
argument_list|(
name|readParamsFailedCall
argument_list|)
expr_stmt|;
return|return;
block|}
name|TraceInfo
name|traceInfo
init|=
name|header
operator|.
name|hasTraceInfo
argument_list|()
condition|?
operator|new
name|TraceInfo
argument_list|(
name|header
operator|.
name|getTraceInfo
argument_list|()
operator|.
name|getTraceId
argument_list|()
argument_list|,
name|header
operator|.
name|getTraceInfo
argument_list|()
operator|.
name|getParentId
argument_list|()
argument_list|)
else|:
literal|null
decl_stmt|;
name|Call
name|call
init|=
operator|new
name|Call
argument_list|(
name|id
argument_list|,
name|this
operator|.
name|service
argument_list|,
name|md
argument_list|,
name|header
argument_list|,
name|param
argument_list|,
name|cellScanner
argument_list|,
name|this
argument_list|,
name|responder
argument_list|,
name|totalRequestSize
argument_list|,
name|traceInfo
argument_list|,
name|RpcServer
operator|.
name|getRemoteIp
argument_list|()
argument_list|)
decl_stmt|;
name|scheduler
operator|.
name|dispatch
argument_list|(
operator|new
name|CallRunner
argument_list|(
name|RpcServer
operator|.
name|this
argument_list|,
name|call
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|authorizeConnection
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
comment|// If auth method is DIGEST, the token was obtained by the
comment|// real user for the effective user, therefore not required to
comment|// authorize real user. doAs is allowed only for simple or kerberos
comment|// authentication
if|if
condition|(
name|user
operator|!=
literal|null
operator|&&
name|user
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthMethod
operator|.
name|DIGEST
operator|)
condition|)
block|{
name|ProxyUsers
operator|.
name|authorize
argument_list|(
name|user
argument_list|,
name|this
operator|.
name|getHostAddress
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
name|authorize
argument_list|(
name|user
argument_list|,
name|connectionHeader
argument_list|,
name|getHostInetAddress
argument_list|()
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|authorizationSuccess
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AuthorizationException
name|ae
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Connection authorization failed: "
operator|+
name|ae
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ae
argument_list|)
expr_stmt|;
block|}
name|metrics
operator|.
name|authorizationFailure
argument_list|()
expr_stmt|;
name|setupResponse
argument_list|(
name|authFailedResponse
argument_list|,
name|authFailedCall
argument_list|,
operator|new
name|AccessDeniedException
argument_list|(
name|ae
argument_list|)
argument_list|,
name|ae
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|responder
operator|.
name|doRespond
argument_list|(
name|authFailedCall
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|protected
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
name|disposeSasl
argument_list|()
expr_stmt|;
name|data
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|dataLengthBuffer
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
return|return;
try|try
block|{
name|socket
operator|.
name|shutdownOutput
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
comment|// FindBugs DE_MIGHT_IGNORE
if|if
condition|(
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
block|{
try|try
block|{
name|channel
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
block|}
try|try
block|{
name|socket
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
block|}
specifier|private
name|UserGroupInformation
name|createUser
parameter_list|(
name|ConnectionHeader
name|head
parameter_list|)
block|{
name|UserGroupInformation
name|ugi
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|head
operator|.
name|hasUserInfo
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|UserInformation
name|userInfoProto
init|=
name|head
operator|.
name|getUserInfo
argument_list|()
decl_stmt|;
name|String
name|effectiveUser
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|userInfoProto
operator|.
name|hasEffectiveUser
argument_list|()
condition|)
block|{
name|effectiveUser
operator|=
name|userInfoProto
operator|.
name|getEffectiveUser
argument_list|()
expr_stmt|;
block|}
name|String
name|realUser
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|userInfoProto
operator|.
name|hasRealUser
argument_list|()
condition|)
block|{
name|realUser
operator|=
name|userInfoProto
operator|.
name|getRealUser
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|effectiveUser
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|realUser
operator|!=
literal|null
condition|)
block|{
name|UserGroupInformation
name|realUserUgi
init|=
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|realUser
argument_list|)
decl_stmt|;
name|ugi
operator|=
name|UserGroupInformation
operator|.
name|createProxyUser
argument_list|(
name|effectiveUser
argument_list|,
name|realUserUgi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ugi
operator|=
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|effectiveUser
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ugi
return|;
block|}
block|}
comment|/**    * Datastructure for passing a {@link BlockingService} and its associated class of    * protobuf service interface.  For example, a server that fielded what is defined    * in the client protobuf service would pass in an implementation of the client blocking service    * and then its ClientService.BlockingInterface.class.  Used checking connection setup.    */
specifier|public
specifier|static
class|class
name|BlockingServiceAndInterface
block|{
specifier|private
specifier|final
name|BlockingService
name|service
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|serviceInterface
decl_stmt|;
specifier|public
name|BlockingServiceAndInterface
parameter_list|(
specifier|final
name|BlockingService
name|service
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|serviceInterface
parameter_list|)
block|{
name|this
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|serviceInterface
operator|=
name|serviceInterface
expr_stmt|;
block|}
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getServiceInterface
parameter_list|()
block|{
return|return
name|this
operator|.
name|serviceInterface
return|;
block|}
specifier|public
name|BlockingService
name|getBlockingService
parameter_list|()
block|{
return|return
name|this
operator|.
name|service
return|;
block|}
block|}
comment|/**    * Constructs a server listening on the named port and address.    * @param server hosting instance of {@link Server}. We will do authentications if an    * instance else pass null for no authentication check.    * @param name Used keying this rpc servers' metrics and for naming the Listener thread.    * @param services A list of services.    * @param bindAddress Where to listen    * @param conf    * @param scheduler    */
specifier|public
name|RpcServer
parameter_list|(
specifier|final
name|Server
name|server
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|InetSocketAddress
name|bindAddress
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|RpcScheduler
name|scheduler
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|reservoir
operator|=
operator|new
name|BoundedByteBufferPool
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.reservoir.max.buffer.size"
argument_list|,
literal|1024
operator|*
literal|1024
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.reservoir.initial.buffer.size"
argument_list|,
literal|16
operator|*
literal|1024
argument_list|)
argument_list|,
comment|// Make the max twice the number of handlers to be safe.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.reservoir.initial.max"
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|REGION_SERVER_HANDLER_COUNT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_REGION_SERVER_HANDLER_COUNT
argument_list|)
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
name|this
operator|.
name|services
operator|=
name|services
expr_stmt|;
name|this
operator|.
name|bindAddress
operator|=
name|bindAddress
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|socketSendBufferSize
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|maxQueueSize
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.max.callqueue.size"
argument_list|,
name|DEFAULT_MAX_CALLQUEUE_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|readThreads
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.server.read.threadpool.size"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxIdleTime
operator|=
literal|2
operator|*
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.connection.maxidletime"
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxConnectionsToNuke
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.kill.max"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|thresholdIdleConnections
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.idlethreshold"
argument_list|,
literal|4000
argument_list|)
expr_stmt|;
name|this
operator|.
name|purgeTimeout
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.ipc.client.call.purge.timeout"
argument_list|,
literal|2
operator|*
name|HConstants
operator|.
name|DEFAULT_HBASE_RPC_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|warnResponseTime
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|WARN_RESPONSE_TIME
argument_list|,
name|DEFAULT_WARN_RESPONSE_TIME
argument_list|)
expr_stmt|;
name|this
operator|.
name|warnResponseSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|WARN_RESPONSE_SIZE
argument_list|,
name|DEFAULT_WARN_RESPONSE_SIZE
argument_list|)
expr_stmt|;
comment|// Start the listener here and let it bind to the port
name|listener
operator|=
operator|new
name|Listener
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|port
operator|=
name|listener
operator|.
name|getAddress
argument_list|()
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
operator|new
name|MetricsHBaseServer
argument_list|(
name|name
argument_list|,
operator|new
name|MetricsHBaseServerWrapperImpl
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpNoDelay
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.ipc.server.tcpnodelay"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpKeepAlive
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.ipc.server.tcpkeepalive"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|warnDelayedCalls
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|WARN_DELAYED_CALLS
argument_list|,
name|DEFAULT_WARN_DELAYED_CALLS
argument_list|)
expr_stmt|;
name|this
operator|.
name|delayedCalls
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|ipcUtil
operator|=
operator|new
name|IPCUtil
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Create the responder here
name|responder
operator|=
operator|new
name|Responder
argument_list|()
expr_stmt|;
name|this
operator|.
name|authorize
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HADOOP_SECURITY_AUTHORIZATION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|userProvider
operator|=
name|UserProvider
operator|.
name|instantiate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|isSecurityEnabled
operator|=
name|userProvider
operator|.
name|isHBaseSecurityEnabled
argument_list|()
expr_stmt|;
if|if
condition|(
name|isSecurityEnabled
condition|)
block|{
name|HBaseSaslRpcServer
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|scheduler
operator|=
name|scheduler
expr_stmt|;
name|this
operator|.
name|scheduler
operator|.
name|init
argument_list|(
operator|new
name|RpcSchedulerContext
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Subclasses of HBaseServer can override this to provide their own    * Connection implementations.    */
specifier|protected
name|Connection
name|getConnection
parameter_list|(
name|SocketChannel
name|channel
parameter_list|,
name|long
name|time
parameter_list|)
block|{
return|return
operator|new
name|Connection
argument_list|(
name|channel
argument_list|,
name|time
argument_list|)
return|;
block|}
comment|/**    * Setup response for the RPC Call.    *    * @param response buffer to serialize the response into    * @param call {@link Call} to which we are setting up the response    * @param error error message, if the call failed    * @throws IOException    */
specifier|private
name|void
name|setupResponse
parameter_list|(
name|ByteArrayOutputStream
name|response
parameter_list|,
name|Call
name|call
parameter_list|,
name|Throwable
name|t
parameter_list|,
name|String
name|error
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|response
operator|!=
literal|null
condition|)
name|response
operator|.
name|reset
argument_list|()
expr_stmt|;
name|call
operator|.
name|setResponse
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|t
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|closeConnection
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
synchronized|synchronized
init|(
name|connectionList
init|)
block|{
if|if
condition|(
name|connectionList
operator|.
name|remove
argument_list|(
name|connection
argument_list|)
condition|)
block|{
name|numConnections
operator|--
expr_stmt|;
block|}
block|}
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|/** Sets the socket buffer size used for responding to RPCs.    * @param size send size    */
annotation|@
name|Override
specifier|public
name|void
name|setSocketSendBufSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|socketSendBufferSize
operator|=
name|size
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStarted
parameter_list|()
block|{
return|return
name|this
operator|.
name|started
return|;
block|}
comment|/** Starts the service.  Must be called before any calls will be handled. */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|start
parameter_list|()
block|{
if|if
condition|(
name|started
condition|)
return|return;
name|AuthenticationTokenSecretManager
name|mgr
init|=
name|createSecretManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|mgr
operator|!=
literal|null
condition|)
block|{
name|setSecretManager
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|mgr
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|authManager
operator|=
operator|new
name|ServiceAuthorizationManager
argument_list|()
expr_stmt|;
name|HBasePolicyProvider
operator|.
name|init
argument_list|(
name|conf
argument_list|,
name|authManager
argument_list|)
expr_stmt|;
name|responder
operator|.
name|start
argument_list|()
expr_stmt|;
name|listener
operator|.
name|start
argument_list|()
expr_stmt|;
name|scheduler
operator|.
name|start
argument_list|()
expr_stmt|;
name|started
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|refreshAuthManager
parameter_list|(
name|PolicyProvider
name|pp
parameter_list|)
block|{
comment|// Ignore warnings that this should be accessed in a static way instead of via an instance;
comment|// it'll break if you go via static route.
name|this
operator|.
name|authManager
operator|.
name|refresh
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
specifier|private
name|AuthenticationTokenSecretManager
name|createSecretManager
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|Configuration
name|conf
init|=
name|server
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|long
name|keyUpdateInterval
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.auth.key.update.interval"
argument_list|,
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
literal|1000
argument_list|)
decl_stmt|;
name|long
name|maxAge
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.auth.token.max.lifetime"
argument_list|,
literal|7
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
literal|1000
argument_list|)
decl_stmt|;
return|return
operator|new
name|AuthenticationTokenSecretManager
argument_list|(
name|conf
argument_list|,
name|server
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|keyUpdateInterval
argument_list|,
name|maxAge
argument_list|)
return|;
block|}
specifier|public
name|SecretManager
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|getSecretManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|secretManager
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|setSecretManager
parameter_list|(
name|SecretManager
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|secretManager
parameter_list|)
block|{
name|this
operator|.
name|secretManager
operator|=
operator|(
name|SecretManager
argument_list|<
name|TokenIdentifier
argument_list|>
operator|)
name|secretManager
expr_stmt|;
block|}
comment|/**    * This is a server side method, which is invoked over RPC. On success    * the return response has protobuf response payload. On failure, the    * exception name and the stack trace are returned in the protobuf response.    */
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
name|call
parameter_list|(
name|BlockingService
name|service
parameter_list|,
name|MethodDescriptor
name|md
parameter_list|,
name|Message
name|param
parameter_list|,
name|CellScanner
name|cellScanner
parameter_list|,
name|long
name|receiveTime
parameter_list|,
name|MonitoredRPCHandler
name|status
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|status
operator|.
name|setRPC
argument_list|(
name|md
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|Object
index|[]
block|{
name|param
block|}
argument_list|,
name|receiveTime
argument_list|)
expr_stmt|;
comment|// TODO: Review after we add in encoded data blocks.
name|status
operator|.
name|setRPCPacket
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|status
operator|.
name|resume
argument_list|(
literal|"Servicing call"
argument_list|)
expr_stmt|;
comment|//get an instance of the method arg type
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|PayloadCarryingRpcController
name|controller
init|=
operator|new
name|PayloadCarryingRpcController
argument_list|(
name|cellScanner
argument_list|)
decl_stmt|;
name|Message
name|result
init|=
name|service
operator|.
name|callBlockingMethod
argument_list|(
name|md
argument_list|,
name|controller
argument_list|,
name|param
argument_list|)
decl_stmt|;
name|long
name|endTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|processingTime
init|=
call|(
name|int
call|)
argument_list|(
name|endTime
operator|-
name|startTime
argument_list|)
decl_stmt|;
name|int
name|qTime
init|=
call|(
name|int
call|)
argument_list|(
name|startTime
operator|-
name|receiveTime
argument_list|)
decl_stmt|;
name|int
name|totalTime
init|=
call|(
name|int
call|)
argument_list|(
name|endTime
operator|-
name|receiveTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|CurCall
operator|.
name|get
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|", response "
operator|+
name|TextFormat
operator|.
name|shortDebugString
argument_list|(
name|result
argument_list|)
operator|+
literal|" queueTime: "
operator|+
name|qTime
operator|+
literal|" processingTime: "
operator|+
name|processingTime
operator|+
literal|" totalTime: "
operator|+
name|totalTime
argument_list|)
expr_stmt|;
block|}
name|metrics
operator|.
name|dequeuedCall
argument_list|(
name|qTime
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|processedCall
argument_list|(
name|processingTime
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|totalCall
argument_list|(
name|totalTime
argument_list|)
expr_stmt|;
name|long
name|responseSize
init|=
name|result
operator|.
name|getSerializedSize
argument_list|()
decl_stmt|;
comment|// log any RPC responses that are slower than the configured warn
comment|// response time or larger than configured warning size
name|boolean
name|tooSlow
init|=
operator|(
name|processingTime
operator|>
name|warnResponseTime
operator|&&
name|warnResponseTime
operator|>
operator|-
literal|1
operator|)
decl_stmt|;
name|boolean
name|tooLarge
init|=
operator|(
name|responseSize
operator|>
name|warnResponseSize
operator|&&
name|warnResponseSize
operator|>
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|tooSlow
operator|||
name|tooLarge
condition|)
block|{
comment|// when tagging, we let TooLarge trump TooSmall to keep output simple
comment|// note that large responses will often also be slow.
name|logResponse
argument_list|(
operator|new
name|Object
index|[]
block|{
name|param
block|}
argument_list|,
name|md
operator|.
name|getName
argument_list|()
argument_list|,
name|md
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
name|param
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")"
argument_list|,
operator|(
name|tooLarge
condition|?
literal|"TooLarge"
else|:
literal|"TooSlow"
operator|)
argument_list|,
name|status
operator|.
name|getClient
argument_list|()
argument_list|,
name|startTime
argument_list|,
name|processingTime
argument_list|,
name|qTime
argument_list|,
name|responseSize
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
argument_list|(
name|result
argument_list|,
name|controller
operator|.
name|cellScanner
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// The above callBlockingMethod will always return a SE.  Strip the SE wrapper before
comment|// putting it on the wire.  Its needed to adhere to the pb Service Interface but we don't
comment|// need to pass it over the wire.
if|if
condition|(
name|e
operator|instanceof
name|ServiceException
condition|)
name|e
operator|=
name|e
operator|.
name|getCause
argument_list|()
expr_stmt|;
comment|// increment the number of requests that were exceptions.
name|metrics
operator|.
name|exception
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|LinkageError
condition|)
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
name|e
argument_list|)
throw|;
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
throw|throw
operator|(
name|IOException
operator|)
name|e
throw|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected throwable object "
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Logs an RPC response to the LOG file, producing valid JSON objects for    * client Operations.    * @param params The parameters received in the call.    * @param methodName The name of the method invoked    * @param call The string representation of the call    * @param tag  The tag that will be used to indicate this event in the log.    * @param clientAddress   The address of the client who made this call.    * @param startTime       The time that the call was initiated, in ms.    * @param processingTime  The duration that the call took to run, in ms.    * @param qTime           The duration that the call spent on the queue    *                        prior to being initiated, in ms.    * @param responseSize    The size in bytes of the response buffer.    */
name|void
name|logResponse
parameter_list|(
name|Object
index|[]
name|params
parameter_list|,
name|String
name|methodName
parameter_list|,
name|String
name|call
parameter_list|,
name|String
name|tag
parameter_list|,
name|String
name|clientAddress
parameter_list|,
name|long
name|startTime
parameter_list|,
name|int
name|processingTime
parameter_list|,
name|int
name|qTime
parameter_list|,
name|long
name|responseSize
parameter_list|)
throws|throws
name|IOException
block|{
comment|// base information that is reported regardless of type of call
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|responseInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"starttimems"
argument_list|,
name|startTime
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"processingtimems"
argument_list|,
name|processingTime
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"queuetimems"
argument_list|,
name|qTime
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"responsesize"
argument_list|,
name|responseSize
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"client"
argument_list|,
name|clientAddress
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"class"
argument_list|,
name|server
operator|==
literal|null
condition|?
literal|""
else|:
name|server
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"method"
argument_list|,
name|methodName
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|length
operator|==
literal|2
operator|&&
name|server
operator|instanceof
name|HRegionServer
operator|&&
name|params
index|[
literal|0
index|]
operator|instanceof
name|byte
index|[]
operator|&&
name|params
index|[
literal|1
index|]
operator|instanceof
name|Operation
condition|)
block|{
comment|// if the slow process is a query, we want to log its table as well
comment|// as its own fingerprint
name|TableName
name|tableName
init|=
name|TableName
operator|.
name|valueOf
argument_list|(
name|HRegionInfo
operator|.
name|parseRegionName
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|params
index|[
literal|0
index|]
argument_list|)
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"table"
argument_list|,
name|tableName
operator|.
name|getNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// annotate the response map with operation details
name|responseInfo
operator|.
name|putAll
argument_list|(
operator|(
operator|(
name|Operation
operator|)
name|params
index|[
literal|1
index|]
operator|)
operator|.
name|toMap
argument_list|()
argument_list|)
expr_stmt|;
comment|// report to the log file
name|LOG
operator|.
name|warn
argument_list|(
literal|"(operation"
operator|+
name|tag
operator|+
literal|"): "
operator|+
name|MAPPER
operator|.
name|writeValueAsString
argument_list|(
name|responseInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|params
operator|.
name|length
operator|==
literal|1
operator|&&
name|server
operator|instanceof
name|HRegionServer
operator|&&
name|params
index|[
literal|0
index|]
operator|instanceof
name|Operation
condition|)
block|{
comment|// annotate the response map with operation details
name|responseInfo
operator|.
name|putAll
argument_list|(
operator|(
operator|(
name|Operation
operator|)
name|params
index|[
literal|0
index|]
operator|)
operator|.
name|toMap
argument_list|()
argument_list|)
expr_stmt|;
comment|// report to the log file
name|LOG
operator|.
name|warn
argument_list|(
literal|"(operation"
operator|+
name|tag
operator|+
literal|"): "
operator|+
name|MAPPER
operator|.
name|writeValueAsString
argument_list|(
name|responseInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// can't get JSON details, so just report call.toString() along with
comment|// a more generic tag.
name|responseInfo
operator|.
name|put
argument_list|(
literal|"call"
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"(response"
operator|+
name|tag
operator|+
literal|"): "
operator|+
name|MAPPER
operator|.
name|writeValueAsString
argument_list|(
name|responseInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Stops the service.  No new calls will be handled after this is called. */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|stop
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping server on "
operator|+
name|port
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
name|listener
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|listener
operator|.
name|doStop
argument_list|()
expr_stmt|;
name|responder
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|scheduler
operator|.
name|stop
argument_list|()
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/** Wait for the server to be stopped.    * Does not wait for all subthreads to finish.    *  See {@link #stop()}.    * @throws InterruptedException e    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|join
parameter_list|()
throws|throws
name|InterruptedException
block|{
while|while
condition|(
name|running
condition|)
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Return the socket (ip+port) on which the RPC server is listening to.    * @return the socket (ip+port) on which the RPC server is listening to.    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|InetSocketAddress
name|getListenerAddress
parameter_list|()
block|{
return|return
name|listener
operator|.
name|getAddress
argument_list|()
return|;
block|}
comment|/**    * Set the handler for calling out of RPC for error conditions.    * @param handler the handler implementation    */
annotation|@
name|Override
specifier|public
name|void
name|setErrorHandler
parameter_list|(
name|HBaseRPCErrorHandler
name|handler
parameter_list|)
block|{
name|this
operator|.
name|errorHandler
operator|=
name|handler
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|HBaseRPCErrorHandler
name|getErrorHandler
parameter_list|()
block|{
return|return
name|this
operator|.
name|errorHandler
return|;
block|}
comment|/**    * Returns the metrics instance for reporting RPC call statistics    */
annotation|@
name|Override
specifier|public
name|MetricsHBaseServer
name|getMetrics
parameter_list|()
block|{
return|return
name|metrics
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addCallSize
parameter_list|(
specifier|final
name|long
name|diff
parameter_list|)
block|{
name|this
operator|.
name|callQueueSize
operator|.
name|add
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/**    * Authorize the incoming client connection.    *    * @param user client user    * @param connection incoming connection    * @param addr InetAddress of incoming connection    * @throws org.apache.hadoop.security.authorize.AuthorizationException when the client isn't authorized to talk the protocol    */
specifier|public
name|void
name|authorize
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|,
name|ConnectionHeader
name|connection
parameter_list|,
name|InetAddress
name|addr
parameter_list|)
throws|throws
name|AuthorizationException
block|{
if|if
condition|(
name|authorize
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|c
init|=
name|getServiceInterface
argument_list|(
name|services
argument_list|,
name|connection
operator|.
name|getServiceName
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|authManager
operator|.
name|authorize
argument_list|(
name|user
operator|!=
literal|null
condition|?
name|user
else|:
literal|null
argument_list|,
name|c
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * When the read or write buffer size is larger than this limit, i/o will be    * done in chunks of this size. Most RPC requests and responses would be    * be smaller.    */
specifier|private
specifier|static
name|int
name|NIO_BUFFER_LIMIT
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
comment|//should not be more than 64KB.
comment|/**    * This is a wrapper around {@link java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)}.    * If the amount of data is large, it writes to channel in smaller chunks.    * This is to avoid jdk from creating many direct buffers as the size of    * buffer increases. This also minimizes extra copies in NIO layer    * as a result of multiple write operations required to write a large    * buffer.    *    * @param channel writable byte channel to write to    * @param bufferChain Chain of buffers to write    * @return number of bytes written    * @throws java.io.IOException e    * @see java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)    */
specifier|protected
name|long
name|channelWrite
parameter_list|(
name|GatheringByteChannel
name|channel
parameter_list|,
name|BufferChain
name|bufferChain
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|count
init|=
name|bufferChain
operator|.
name|write
argument_list|(
name|channel
argument_list|,
name|NIO_BUFFER_LIMIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|this
operator|.
name|metrics
operator|.
name|sentBytes
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
comment|/**    * This is a wrapper around {@link java.nio.channels.ReadableByteChannel#read(java.nio.ByteBuffer)}.    * If the amount of data is large, it writes to channel in smaller chunks.    * This is to avoid jdk from creating many direct buffers as the size of    * ByteBuffer increases. There should not be any performance degredation.    *    * @param channel writable byte channel to write on    * @param buffer buffer to write    * @return number of bytes written    * @throws java.io.IOException e    * @see java.nio.channels.ReadableByteChannel#read(java.nio.ByteBuffer)    */
specifier|protected
name|int
name|channelRead
parameter_list|(
name|ReadableByteChannel
name|channel
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|count
init|=
operator|(
name|buffer
operator|.
name|remaining
argument_list|()
operator|<=
name|NIO_BUFFER_LIMIT
operator|)
condition|?
name|channel
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
else|:
name|channelIO
argument_list|(
name|channel
argument_list|,
literal|null
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|metrics
operator|.
name|receivedBytes
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * Helper for {@link #channelRead(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)}    * and {@link #channelWrite(GatheringByteChannel, BufferChain)}. Only    * one of readCh or writeCh should be non-null.    *    * @param readCh read channel    * @param writeCh write channel    * @param buf buffer to read or write into/out of    * @return bytes written    * @throws java.io.IOException e    * @see #channelRead(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)    * @see #channelWrite(GatheringByteChannel, BufferChain)    */
specifier|private
specifier|static
name|int
name|channelIO
parameter_list|(
name|ReadableByteChannel
name|readCh
parameter_list|,
name|WritableByteChannel
name|writeCh
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|originalLimit
init|=
name|buf
operator|.
name|limit
argument_list|()
decl_stmt|;
name|int
name|initialRemaining
init|=
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|int
name|ioSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|buf
operator|.
name|remaining
argument_list|()
argument_list|,
name|NIO_BUFFER_LIMIT
argument_list|)
decl_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|position
argument_list|()
operator|+
name|ioSize
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|readCh
operator|==
literal|null
operator|)
condition|?
name|writeCh
operator|.
name|write
argument_list|(
name|buf
argument_list|)
else|:
name|readCh
operator|.
name|read
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
name|ioSize
condition|)
block|{
break|break;
block|}
block|}
finally|finally
block|{
name|buf
operator|.
name|limit
argument_list|(
name|originalLimit
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|nBytes
init|=
name|initialRemaining
operator|-
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
return|return
operator|(
name|nBytes
operator|>
literal|0
operator|)
condition|?
name|nBytes
else|:
name|ret
return|;
block|}
comment|/**    * Needed for features such as delayed calls.  We need to be able to store the current call    * so that we can complete it later or ask questions of what is supported by the current ongoing    * call.    * @return An RpcCallContext backed by the currently ongoing call (gotten from a thread local)    */
specifier|public
specifier|static
name|RpcCallContext
name|getCurrentCall
parameter_list|()
block|{
return|return
name|CurCall
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isInRpcCallContext
parameter_list|()
block|{
return|return
name|CurCall
operator|.
name|get
argument_list|()
operator|!=
literal|null
return|;
block|}
comment|/**    * Returns the user credentials associated with the current RPC request or    *<code>null</code> if no credentials were provided.    * @return A User    */
specifier|public
specifier|static
name|User
name|getRequestUser
parameter_list|()
block|{
name|RpcCallContext
name|ctx
init|=
name|getCurrentCall
argument_list|()
decl_stmt|;
return|return
name|ctx
operator|==
literal|null
condition|?
literal|null
else|:
name|ctx
operator|.
name|getRequestUser
argument_list|()
return|;
block|}
comment|/**    * Returns the username for any user associated with the current RPC    * request or<code>null</code> if no user is set.    */
specifier|public
specifier|static
name|String
name|getRequestUserName
parameter_list|()
block|{
name|User
name|user
init|=
name|getRequestUser
argument_list|()
decl_stmt|;
return|return
name|user
operator|==
literal|null
condition|?
literal|null
else|:
name|user
operator|.
name|getShortName
argument_list|()
return|;
block|}
comment|/**    * @return Address of remote client if a request is ongoing, else null    */
specifier|public
specifier|static
name|InetAddress
name|getRemoteAddress
parameter_list|()
block|{
name|RpcCallContext
name|ctx
init|=
name|getCurrentCall
argument_list|()
decl_stmt|;
return|return
name|ctx
operator|==
literal|null
condition|?
literal|null
else|:
name|ctx
operator|.
name|getRemoteAddress
argument_list|()
return|;
block|}
comment|/**    * @param serviceName Some arbitrary string that represents a 'service'.    * @param services Available service instances    * @return Matching BlockingServiceAndInterface pair    */
specifier|static
name|BlockingServiceAndInterface
name|getServiceAndInterface
parameter_list|(
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|String
name|serviceName
parameter_list|)
block|{
for|for
control|(
name|BlockingServiceAndInterface
name|bs
range|:
name|services
control|)
block|{
if|if
condition|(
name|bs
operator|.
name|getBlockingService
argument_list|()
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|serviceName
argument_list|)
condition|)
block|{
return|return
name|bs
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @param serviceName Some arbitrary string that represents a 'service'.    * @param services Available services and their service interfaces.    * @return Service interface class for<code>serviceName</code>    */
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|getServiceInterface
parameter_list|(
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|String
name|serviceName
parameter_list|)
block|{
name|BlockingServiceAndInterface
name|bsasi
init|=
name|getServiceAndInterface
argument_list|(
name|services
argument_list|,
name|serviceName
argument_list|)
decl_stmt|;
return|return
name|bsasi
operator|==
literal|null
condition|?
literal|null
else|:
name|bsasi
operator|.
name|getServiceInterface
argument_list|()
return|;
block|}
comment|/**    * @param serviceName Some arbitrary string that represents a 'service'.    * @param services Available services and their service interfaces.    * @return BlockingService that goes with the passed<code>serviceName</code>    */
specifier|static
name|BlockingService
name|getService
parameter_list|(
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|String
name|serviceName
parameter_list|)
block|{
name|BlockingServiceAndInterface
name|bsasi
init|=
name|getServiceAndInterface
argument_list|(
name|services
argument_list|,
name|serviceName
argument_list|)
decl_stmt|;
return|return
name|bsasi
operator|==
literal|null
condition|?
literal|null
else|:
name|bsasi
operator|.
name|getBlockingService
argument_list|()
return|;
block|}
comment|/** Returns the remote side ip address when invoked inside an RPC    *  Returns null incase of an error.    *  @return InetAddress    */
specifier|public
specifier|static
name|InetAddress
name|getRemoteIp
parameter_list|()
block|{
name|Call
name|call
init|=
name|CurCall
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
operator|&&
name|call
operator|.
name|connection
operator|.
name|socket
operator|!=
literal|null
condition|)
block|{
return|return
name|call
operator|.
name|connection
operator|.
name|socket
operator|.
name|getInetAddress
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * A convenience method to bind to a given address and report    * better exceptions if the address is not a valid host.    * @param socket the socket to bind    * @param address the address to bind to    * @param backlog the number of connections allowed in the queue    * @throws BindException if the address can't be bound    * @throws UnknownHostException if the address isn't a valid host name    * @throws IOException other random errors from bind    */
specifier|public
specifier|static
name|void
name|bind
parameter_list|(
name|ServerSocket
name|socket
parameter_list|,
name|InetSocketAddress
name|address
parameter_list|,
name|int
name|backlog
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|socket
operator|.
name|bind
argument_list|(
name|address
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BindException
name|e
parameter_list|)
block|{
name|BindException
name|bindException
init|=
operator|new
name|BindException
argument_list|(
literal|"Problem binding to "
operator|+
name|address
operator|+
literal|" : "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|bindException
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|bindException
throw|;
block|}
catch|catch
parameter_list|(
name|SocketException
name|e
parameter_list|)
block|{
comment|// If they try to bind to a different host's address, give a better
comment|// error message.
if|if
condition|(
literal|"Unresolved address"
operator|.
name|equals
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnknownHostException
argument_list|(
literal|"Invalid hostname for server: "
operator|+
name|address
operator|.
name|getHostName
argument_list|()
argument_list|)
throw|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|RpcScheduler
name|getScheduler
parameter_list|()
block|{
return|return
name|scheduler
return|;
block|}
block|}
end_class

end_unit

