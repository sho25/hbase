begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|GeneralSecurityException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|LongAdder
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|Sasl
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|SaslServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|crypto
operator|.
name|cipher
operator|.
name|CryptoCipherFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|crypto
operator|.
name|random
operator|.
name|CryptoRandom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|crypto
operator|.
name|random
operator|.
name|CryptoRandomFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CallQueueTooBigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseInterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|codec
operator|.
name|Codec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|conf
operator|.
name|ConfigurationObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|RegionMovedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|RequestTooBigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ByteBufferListOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ByteBufferPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|crypto
operator|.
name|aes
operator|.
name|CryptoAES
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MonitoredRPCHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|TaskMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|ByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|MultiByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|SingleByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RSRpcServices
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|AuthMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|SaslUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|UserProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|token
operator|.
name|AuthenticationTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|BlockingService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|CodedOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|MethodDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ServiceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|TextFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|CellBlockMeta
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ConnectionHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ExceptionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|RequestHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ResponseHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|UserInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AuthorizationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|PolicyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ServiceAuthorizationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|TraceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * An RPC server that hosts protobuf described Services.  *  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
name|HBaseInterfaceAudience
operator|.
name|COPROC
block|,
name|HBaseInterfaceAudience
operator|.
name|PHOENIX
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
specifier|abstract
class|class
name|RpcServer
implements|implements
name|RpcServerInterface
implements|,
name|ConfigurationObserver
block|{
comment|// LOG is being used in CallRunner and the log level is being changed in tests
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|RpcServer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|CallQueueTooBigException
name|CALL_QUEUE_TOO_BIG_EXCEPTION
init|=
operator|new
name|CallQueueTooBigException
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|authorize
decl_stmt|;
specifier|protected
name|boolean
name|isSecurityEnabled
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|CURRENT_VERSION
init|=
literal|0
decl_stmt|;
comment|/**    * Whether we allow a fallback to SIMPLE auth for insecure clients when security is enabled.    */
specifier|public
specifier|static
specifier|final
name|String
name|FALLBACK_TO_INSECURE_CLIENT_AUTH
init|=
literal|"hbase.ipc.server.fallback-to-simple-auth-allowed"
decl_stmt|;
comment|/**    * How many calls/handler are allowed in the queue.    */
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_CALLQUEUE_LENGTH_PER_HANDLER
init|=
literal|10
decl_stmt|;
specifier|protected
specifier|final
name|CellBlockBuilder
name|cellBlockBuilder
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|AUTH_FAILED_FOR
init|=
literal|"Auth failed for "
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|AUTH_SUCCESSFUL_FOR
init|=
literal|"Auth successful for "
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|Log
name|AUDITLOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"SecurityLogger."
operator|+
name|Server
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
name|SecretManager
argument_list|<
name|TokenIdentifier
argument_list|>
name|secretManager
decl_stmt|;
specifier|protected
name|ServiceAuthorizationManager
name|authManager
decl_stmt|;
comment|/** This is set to Call object before Handler invokes an RPC and ybdie    * after the call returns.    */
specifier|protected
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|RpcCall
argument_list|>
name|CurCall
init|=
operator|new
name|ThreadLocal
argument_list|<
name|RpcCall
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Keeps MonitoredRPCHandler per handler thread. */
specifier|protected
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|MonitoredRPCHandler
argument_list|>
name|MONITORED_RPC
init|=
operator|new
name|ThreadLocal
argument_list|<
name|MonitoredRPCHandler
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|InetSocketAddress
name|bindAddress
decl_stmt|;
specifier|protected
name|MetricsHBaseServer
name|metrics
decl_stmt|;
specifier|protected
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|/**    * Maximum size in bytes of the currently queued and running Calls. If a new Call puts us over    * this size, then we will reject the call (after parsing it though). It will go back to the    * client and client will retry. Set this size with "hbase.ipc.server.max.callqueue.size". The    * call queue size gets incremented after we parse a call and before we add it to the queue of    * calls for the scheduler to use. It get decremented after we have 'run' the Call. The current    * size is kept in {@link #callQueueSizeInBytes}.    * @see #callQueueSizeInBytes    * @see #DEFAULT_MAX_CALLQUEUE_SIZE    */
specifier|protected
specifier|final
name|long
name|maxQueueSizeInBytes
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_CALLQUEUE_SIZE
init|=
literal|1024
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|/**    * This is a running count of the size in bytes of all outstanding calls whether currently    * executing or queued waiting to be run.    */
specifier|protected
specifier|final
name|LongAdder
name|callQueueSizeInBytes
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|tcpNoDelay
decl_stmt|;
comment|// if T then disable Nagle's Algorithm
specifier|protected
specifier|final
name|boolean
name|tcpKeepAlive
decl_stmt|;
comment|// if T then use keepalives
comment|/**    * This flag is used to indicate to sub threads when they should go down.  When we call    * {@link #start()}, all threads started will consult this flag on whether they should    * keep going.  It is set to false when {@link #stop()} is called.    */
specifier|volatile
name|boolean
name|running
init|=
literal|true
decl_stmt|;
comment|/**    * This flag is set to true after all threads are up and 'running' and the server is then opened    * for business by the call to {@link #start()}.    */
specifier|volatile
name|boolean
name|started
init|=
literal|false
decl_stmt|;
specifier|protected
name|AuthenticationTokenSecretManager
name|authTokenSecretMgr
init|=
literal|null
decl_stmt|;
specifier|protected
name|HBaseRPCErrorHandler
name|errorHandler
init|=
literal|null
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|MAX_REQUEST_SIZE
init|=
literal|"hbase.ipc.max.request.size"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|RequestTooBigException
name|REQUEST_TOO_BIG_EXCEPTION
init|=
operator|new
name|RequestTooBigException
argument_list|()
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|WARN_RESPONSE_TIME
init|=
literal|"hbase.ipc.warn.response.time"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|WARN_RESPONSE_SIZE
init|=
literal|"hbase.ipc.warn.response.size"
decl_stmt|;
comment|/**    * Minimum allowable timeout (in milliseconds) in rpc request's header. This    * configuration exists to prevent the rpc service regarding this request as timeout immediately.    */
specifier|protected
specifier|static
specifier|final
name|String
name|MIN_CLIENT_REQUEST_TIMEOUT
init|=
literal|"hbase.ipc.min.client.request.timeout"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_CLIENT_REQUEST_TIMEOUT
init|=
literal|20
decl_stmt|;
comment|/** Default value for above params */
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_REQUEST_SIZE
init|=
name|DEFAULT_MAX_CALLQUEUE_SIZE
operator|/
literal|4
decl_stmt|;
comment|// 256M
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_WARN_RESPONSE_TIME
init|=
literal|10000
decl_stmt|;
comment|// milliseconds
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_WARN_RESPONSE_SIZE
init|=
literal|100
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|ObjectMapper
name|MAPPER
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|int
name|maxRequestSize
decl_stmt|;
specifier|protected
specifier|final
name|int
name|warnResponseTime
decl_stmt|;
specifier|protected
specifier|final
name|int
name|warnResponseSize
decl_stmt|;
specifier|protected
specifier|final
name|int
name|minClientRequestTimeout
decl_stmt|;
specifier|protected
specifier|final
name|Server
name|server
decl_stmt|;
specifier|protected
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
decl_stmt|;
specifier|protected
specifier|final
name|RpcScheduler
name|scheduler
decl_stmt|;
specifier|protected
name|UserProvider
name|userProvider
decl_stmt|;
specifier|protected
specifier|final
name|ByteBufferPool
name|reservoir
decl_stmt|;
comment|// The requests and response will use buffers from ByteBufferPool, when the size of the
comment|// request/response is at least this size.
comment|// We make this to be 1/6th of the pool buffer size.
specifier|protected
specifier|final
name|int
name|minSizeForReservoirUse
decl_stmt|;
specifier|protected
specifier|volatile
name|boolean
name|allowFallbackToSimpleAuth
decl_stmt|;
comment|/**    * Used to get details for scan with a scanner_id<br/>    * TODO try to figure out a better way and remove reference from regionserver package later.    */
specifier|private
name|RSRpcServices
name|rsRpcServices
decl_stmt|;
comment|/**    * Datastructure that holds all necessary to a method invocation and then afterward, carries    * the result.    */
annotation|@
name|InterfaceStability
operator|.
name|Evolving
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|abstract
class|class
name|Call
implements|implements
name|RpcCall
block|{
specifier|protected
name|int
name|id
decl_stmt|;
comment|// the client's call id
specifier|protected
name|BlockingService
name|service
decl_stmt|;
specifier|protected
name|MethodDescriptor
name|md
decl_stmt|;
specifier|protected
name|RequestHeader
name|header
decl_stmt|;
specifier|protected
name|Message
name|param
decl_stmt|;
comment|// the parameter passed
comment|// Optional cell data passed outside of protobufs.
specifier|protected
name|CellScanner
name|cellScanner
decl_stmt|;
specifier|protected
name|Connection
name|connection
decl_stmt|;
comment|// connection to client
specifier|protected
name|long
name|timestamp
decl_stmt|;
comment|// the time received when response is null
comment|// the time served when response is not null
specifier|protected
name|int
name|timeout
decl_stmt|;
specifier|protected
name|long
name|startTime
decl_stmt|;
specifier|protected
name|long
name|deadline
decl_stmt|;
comment|// the deadline to handle this call, if exceed we can drop it.
comment|/**      * Chain of buffers to send as response.      */
specifier|protected
name|BufferChain
name|response
decl_stmt|;
specifier|protected
name|long
name|size
decl_stmt|;
comment|// size of current call
specifier|protected
name|boolean
name|isError
decl_stmt|;
specifier|protected
name|TraceInfo
name|tinfo
decl_stmt|;
specifier|protected
name|ByteBufferListOutputStream
name|cellBlockStream
init|=
literal|null
decl_stmt|;
specifier|protected
name|CallCleanup
name|reqCleanup
init|=
literal|null
decl_stmt|;
specifier|protected
name|User
name|user
decl_stmt|;
specifier|protected
name|InetAddress
name|remoteAddress
decl_stmt|;
specifier|protected
name|RpcCallback
name|rpcCallback
decl_stmt|;
specifier|private
name|long
name|responseCellSize
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|responseBlockSize
init|=
literal|0
decl_stmt|;
comment|// cumulative size of serialized exceptions
specifier|private
name|long
name|exceptionSize
init|=
literal|0
decl_stmt|;
specifier|private
name|boolean
name|retryImmediatelySupported
decl_stmt|;
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"NP_NULL_ON_SOME_PATH"
argument_list|,
name|justification
operator|=
literal|"Can't figure why this complaint is happening... see below"
argument_list|)
name|Call
parameter_list|(
name|int
name|id
parameter_list|,
specifier|final
name|BlockingService
name|service
parameter_list|,
specifier|final
name|MethodDescriptor
name|md
parameter_list|,
name|RequestHeader
name|header
parameter_list|,
name|Message
name|param
parameter_list|,
name|CellScanner
name|cellScanner
parameter_list|,
name|Connection
name|connection
parameter_list|,
name|long
name|size
parameter_list|,
name|TraceInfo
name|tinfo
parameter_list|,
specifier|final
name|InetAddress
name|remoteAddress
parameter_list|,
name|int
name|timeout
parameter_list|,
name|CallCleanup
name|reqCleanup
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|md
operator|=
name|md
expr_stmt|;
name|this
operator|.
name|header
operator|=
name|header
expr_stmt|;
name|this
operator|.
name|param
operator|=
name|param
expr_stmt|;
name|this
operator|.
name|cellScanner
operator|=
name|cellScanner
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|timestamp
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|this
operator|.
name|response
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|isError
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|tinfo
operator|=
name|tinfo
expr_stmt|;
name|this
operator|.
name|user
operator|=
name|connection
operator|==
literal|null
condition|?
literal|null
else|:
name|connection
operator|.
name|user
expr_stmt|;
comment|// FindBugs: NP_NULL_ON_SOME_PATH
name|this
operator|.
name|remoteAddress
operator|=
name|remoteAddress
expr_stmt|;
name|this
operator|.
name|retryImmediatelySupported
operator|=
name|connection
operator|==
literal|null
condition|?
literal|null
else|:
name|connection
operator|.
name|retryImmediatelySupported
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
name|this
operator|.
name|deadline
operator|=
name|this
operator|.
name|timeout
operator|>
literal|0
condition|?
name|this
operator|.
name|timestamp
operator|+
name|this
operator|.
name|timeout
else|:
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
name|this
operator|.
name|reqCleanup
operator|=
name|reqCleanup
expr_stmt|;
block|}
comment|/**      * Call is done. Execution happened and we returned results to client. It is      * now safe to cleanup.      */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"IS2_INCONSISTENT_SYNC"
argument_list|,
name|justification
operator|=
literal|"Presume the lock on processing request held by caller is protection enough"
argument_list|)
name|void
name|done
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|cellBlockStream
operator|!=
literal|null
condition|)
block|{
comment|// This will return back the BBs which we got from pool.
name|this
operator|.
name|cellBlockStream
operator|.
name|releaseResources
argument_list|()
expr_stmt|;
name|this
operator|.
name|cellBlockStream
operator|=
literal|null
expr_stmt|;
block|}
comment|// If the call was run successfuly, we might have already returned the BB
comment|// back to pool. No worries..Then inputCellBlock will be null
name|cleanup
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|reqCleanup
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|reqCleanup
operator|.
name|run
argument_list|()
expr_stmt|;
name|this
operator|.
name|reqCleanup
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toShortString
argument_list|()
operator|+
literal|" param: "
operator|+
operator|(
name|this
operator|.
name|param
operator|!=
literal|null
condition|?
name|ProtobufUtil
operator|.
name|getShortTextFormat
argument_list|(
name|this
operator|.
name|param
argument_list|)
else|:
literal|""
operator|)
operator|+
literal|" connection: "
operator|+
name|connection
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|RequestHeader
name|getHeader
parameter_list|()
block|{
return|return
name|this
operator|.
name|header
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getPriority
parameter_list|()
block|{
return|return
name|this
operator|.
name|header
operator|.
name|getPriority
argument_list|()
return|;
block|}
comment|/*      * Short string representation without param info because param itself could be huge depends on      * the payload of a command      */
annotation|@
name|Override
specifier|public
name|String
name|toShortString
parameter_list|()
block|{
name|String
name|serviceName
init|=
name|this
operator|.
name|connection
operator|.
name|service
operator|!=
literal|null
condition|?
name|this
operator|.
name|connection
operator|.
name|service
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|getName
argument_list|()
else|:
literal|"null"
decl_stmt|;
return|return
literal|"callId: "
operator|+
name|this
operator|.
name|id
operator|+
literal|" service: "
operator|+
name|serviceName
operator|+
literal|" methodName: "
operator|+
operator|(
operator|(
name|this
operator|.
name|md
operator|!=
literal|null
operator|)
condition|?
name|this
operator|.
name|md
operator|.
name|getName
argument_list|()
else|:
literal|"n/a"
operator|)
operator|+
literal|" size: "
operator|+
name|StringUtils
operator|.
name|TraditionalBinaryPrefix
operator|.
name|long2String
argument_list|(
name|this
operator|.
name|size
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|+
literal|" connection: "
operator|+
name|connection
operator|.
name|toString
argument_list|()
operator|+
literal|" deadline: "
operator|+
name|deadline
return|;
block|}
specifier|protected
specifier|synchronized
name|void
name|setSaslTokenResponse
parameter_list|(
name|ByteBuffer
name|response
parameter_list|)
block|{
name|ByteBuffer
index|[]
name|responseBufs
init|=
operator|new
name|ByteBuffer
index|[
literal|1
index|]
decl_stmt|;
name|responseBufs
index|[
literal|0
index|]
operator|=
name|response
expr_stmt|;
name|this
operator|.
name|response
operator|=
operator|new
name|BufferChain
argument_list|(
name|responseBufs
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|synchronized
name|void
name|setConnectionHeaderResponse
parameter_list|(
name|ByteBuffer
name|response
parameter_list|)
block|{
name|ByteBuffer
index|[]
name|responseBufs
init|=
operator|new
name|ByteBuffer
index|[
literal|1
index|]
decl_stmt|;
name|responseBufs
index|[
literal|0
index|]
operator|=
name|response
expr_stmt|;
name|this
operator|.
name|response
operator|=
operator|new
name|BufferChain
argument_list|(
name|responseBufs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|setResponse
parameter_list|(
name|Message
name|m
parameter_list|,
specifier|final
name|CellScanner
name|cells
parameter_list|,
name|Throwable
name|t
parameter_list|,
name|String
name|errorMsg
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|isError
condition|)
return|return;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|this
operator|.
name|isError
operator|=
literal|true
expr_stmt|;
name|BufferChain
name|bc
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ResponseHeader
operator|.
name|Builder
name|headerBuilder
init|=
name|ResponseHeader
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
comment|// Call id.
name|headerBuilder
operator|.
name|setCallId
argument_list|(
name|this
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|setExceptionResponse
argument_list|(
name|t
argument_list|,
name|errorMsg
argument_list|,
name|headerBuilder
argument_list|)
expr_stmt|;
block|}
comment|// Pass reservoir to buildCellBlock. Keep reference to returne so can add it back to the
comment|// reservoir when finished. This is hacky and the hack is not contained but benefits are
comment|// high when we can avoid a big buffer allocation on each rpc.
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|cellBlock
init|=
literal|null
decl_stmt|;
name|int
name|cellBlockSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reservoir
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cellBlockStream
operator|=
name|cellBlockBuilder
operator|.
name|buildCellBlockStream
argument_list|(
name|this
operator|.
name|connection
operator|.
name|codec
argument_list|,
name|this
operator|.
name|connection
operator|.
name|compressionCodec
argument_list|,
name|cells
argument_list|,
name|reservoir
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cellBlockStream
operator|!=
literal|null
condition|)
block|{
name|cellBlock
operator|=
name|this
operator|.
name|cellBlockStream
operator|.
name|getByteBuffers
argument_list|()
expr_stmt|;
name|cellBlockSize
operator|=
name|this
operator|.
name|cellBlockStream
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|ByteBuffer
name|b
init|=
name|cellBlockBuilder
operator|.
name|buildCellBlock
argument_list|(
name|this
operator|.
name|connection
operator|.
name|codec
argument_list|,
name|this
operator|.
name|connection
operator|.
name|compressionCodec
argument_list|,
name|cells
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|null
condition|)
block|{
name|cellBlockSize
operator|=
name|b
operator|.
name|remaining
argument_list|()
expr_stmt|;
name|cellBlock
operator|=
operator|new
name|ArrayList
argument_list|<
name|ByteBuffer
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cellBlock
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cellBlockSize
operator|>
literal|0
condition|)
block|{
name|CellBlockMeta
operator|.
name|Builder
name|cellBlockBuilder
init|=
name|CellBlockMeta
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
comment|// Presumes the cellBlock bytebuffer has been flipped so limit has total size in it.
name|cellBlockBuilder
operator|.
name|setLength
argument_list|(
name|cellBlockSize
argument_list|)
expr_stmt|;
name|headerBuilder
operator|.
name|setCellBlockMeta
argument_list|(
name|cellBlockBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Message
name|header
init|=
name|headerBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|ByteBuffer
name|headerBuf
init|=
name|createHeaderAndMessageBytes
argument_list|(
name|m
argument_list|,
name|header
argument_list|,
name|cellBlockSize
argument_list|,
name|cellBlock
argument_list|)
decl_stmt|;
name|ByteBuffer
index|[]
name|responseBufs
init|=
literal|null
decl_stmt|;
name|int
name|cellBlockBufferSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cellBlock
operator|!=
literal|null
condition|)
block|{
name|cellBlockBufferSize
operator|=
name|cellBlock
operator|.
name|size
argument_list|()
expr_stmt|;
name|responseBufs
operator|=
operator|new
name|ByteBuffer
index|[
literal|1
operator|+
name|cellBlockBufferSize
index|]
expr_stmt|;
block|}
else|else
block|{
name|responseBufs
operator|=
operator|new
name|ByteBuffer
index|[
literal|1
index|]
expr_stmt|;
block|}
name|responseBufs
index|[
literal|0
index|]
operator|=
name|headerBuf
expr_stmt|;
if|if
condition|(
name|cellBlock
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cellBlockBufferSize
condition|;
name|i
operator|++
control|)
block|{
name|responseBufs
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|cellBlock
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|bc
operator|=
operator|new
name|BufferChain
argument_list|(
name|responseBufs
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|.
name|useWrap
condition|)
block|{
name|bc
operator|=
name|wrapWithSasl
argument_list|(
name|bc
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while creating response "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|response
operator|=
name|bc
expr_stmt|;
comment|// Once a response message is created and set to this.response, this Call can be treated as
comment|// done. The Responder thread will do the n/w write of this message back to client.
if|if
condition|(
name|this
operator|.
name|rpcCallback
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|rpcCallback
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Don't allow any exception here to kill this handler thread.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while running the Rpc Callback."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|setExceptionResponse
parameter_list|(
name|Throwable
name|t
parameter_list|,
name|String
name|errorMsg
parameter_list|,
name|ResponseHeader
operator|.
name|Builder
name|headerBuilder
parameter_list|)
block|{
name|ExceptionResponse
operator|.
name|Builder
name|exceptionBuilder
init|=
name|ExceptionResponse
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|exceptionBuilder
operator|.
name|setExceptionClassName
argument_list|(
name|t
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|exceptionBuilder
operator|.
name|setStackTrace
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
name|exceptionBuilder
operator|.
name|setDoNotRetry
argument_list|(
name|t
operator|instanceof
name|DoNotRetryIOException
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|RegionMovedException
condition|)
block|{
comment|// Special casing for this exception.  This is only one carrying a payload.
comment|// Do this instead of build a generic system for allowing exceptions carry
comment|// any kind of payload.
name|RegionMovedException
name|rme
init|=
operator|(
name|RegionMovedException
operator|)
name|t
decl_stmt|;
name|exceptionBuilder
operator|.
name|setHostname
argument_list|(
name|rme
operator|.
name|getHostname
argument_list|()
argument_list|)
expr_stmt|;
name|exceptionBuilder
operator|.
name|setPort
argument_list|(
name|rme
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Set the exception as the result of the method invocation.
name|headerBuilder
operator|.
name|setException
argument_list|(
name|exceptionBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|ByteBuffer
name|createHeaderAndMessageBytes
parameter_list|(
name|Message
name|result
parameter_list|,
name|Message
name|header
parameter_list|,
name|int
name|cellBlockSize
parameter_list|,
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|cellBlock
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Organize the response as a set of bytebuffers rather than collect it all together inside
comment|// one big byte array; save on allocations.
comment|// for writing the header, we check if there is available space in the buffers
comment|// created for the cellblock itself. If there is space for the header, we reuse
comment|// the last buffer in the cellblock. This applies to the cellblock created from the
comment|// pool or even the onheap cellblock buffer in case there is no pool enabled.
comment|// Possible reuse would avoid creating a temporary array for storing the header every time.
name|ByteBuffer
name|possiblePBBuf
init|=
operator|(
name|cellBlockSize
operator|>
literal|0
operator|)
condition|?
name|cellBlock
operator|.
name|get
argument_list|(
name|cellBlock
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
else|:
literal|null
decl_stmt|;
name|int
name|headerSerializedSize
init|=
literal|0
decl_stmt|,
name|resultSerializedSize
init|=
literal|0
decl_stmt|,
name|headerVintSize
init|=
literal|0
decl_stmt|,
name|resultVintSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|header
operator|!=
literal|null
condition|)
block|{
name|headerSerializedSize
operator|=
name|header
operator|.
name|getSerializedSize
argument_list|()
expr_stmt|;
name|headerVintSize
operator|=
name|CodedOutputStream
operator|.
name|computeRawVarint32Size
argument_list|(
name|headerSerializedSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|resultSerializedSize
operator|=
name|result
operator|.
name|getSerializedSize
argument_list|()
expr_stmt|;
name|resultVintSize
operator|=
name|CodedOutputStream
operator|.
name|computeRawVarint32Size
argument_list|(
name|resultSerializedSize
argument_list|)
expr_stmt|;
block|}
comment|// calculate the total size
name|int
name|totalSize
init|=
name|headerSerializedSize
operator|+
name|headerVintSize
operator|+
operator|(
name|resultSerializedSize
operator|+
name|resultVintSize
operator|)
operator|+
name|cellBlockSize
decl_stmt|;
name|int
name|totalPBSize
init|=
name|headerSerializedSize
operator|+
name|headerVintSize
operator|+
name|resultSerializedSize
operator|+
name|resultVintSize
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
decl_stmt|;
comment|// Only if the last buffer has enough space for header use it. Else allocate
comment|// a new buffer. Assume they are all flipped
if|if
condition|(
name|possiblePBBuf
operator|!=
literal|null
operator|&&
name|possiblePBBuf
operator|.
name|limit
argument_list|()
operator|+
name|totalPBSize
operator|<=
name|possiblePBBuf
operator|.
name|capacity
argument_list|()
condition|)
block|{
comment|// duplicate the buffer. This is where the header is going to be written
name|ByteBuffer
name|pbBuf
init|=
name|possiblePBBuf
operator|.
name|duplicate
argument_list|()
decl_stmt|;
comment|// get the current limit
name|int
name|limit
init|=
name|pbBuf
operator|.
name|limit
argument_list|()
decl_stmt|;
comment|// Position such that we write the header to the end of the buffer
name|pbBuf
operator|.
name|position
argument_list|(
name|limit
argument_list|)
expr_stmt|;
comment|// limit to the header size
name|pbBuf
operator|.
name|limit
argument_list|(
name|totalPBSize
operator|+
name|limit
argument_list|)
expr_stmt|;
comment|// mark the current position
name|pbBuf
operator|.
name|mark
argument_list|()
expr_stmt|;
name|writeToCOS
argument_list|(
name|result
argument_list|,
name|header
argument_list|,
name|totalSize
argument_list|,
name|pbBuf
argument_list|)
expr_stmt|;
comment|// reset the buffer back to old position
name|pbBuf
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
name|pbBuf
return|;
block|}
else|else
block|{
return|return
name|createHeaderAndMessageBytes
argument_list|(
name|result
argument_list|,
name|header
argument_list|,
name|totalSize
argument_list|,
name|totalPBSize
argument_list|)
return|;
block|}
block|}
specifier|private
name|void
name|writeToCOS
parameter_list|(
name|Message
name|result
parameter_list|,
name|Message
name|header
parameter_list|,
name|int
name|totalSize
parameter_list|,
name|ByteBuffer
name|pbBuf
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteBufferUtils
operator|.
name|putInt
argument_list|(
name|pbBuf
argument_list|,
name|totalSize
argument_list|)
expr_stmt|;
comment|// create COS that works on BB
name|CodedOutputStream
name|cos
init|=
name|CodedOutputStream
operator|.
name|newInstance
argument_list|(
name|pbBuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|header
operator|!=
literal|null
condition|)
block|{
name|cos
operator|.
name|writeMessageNoTag
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|cos
operator|.
name|writeMessageNoTag
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|cos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|cos
operator|.
name|checkNoSpaceLeft
argument_list|()
expr_stmt|;
block|}
specifier|private
name|ByteBuffer
name|createHeaderAndMessageBytes
parameter_list|(
name|Message
name|result
parameter_list|,
name|Message
name|header
parameter_list|,
name|int
name|totalSize
parameter_list|,
name|int
name|totalPBSize
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteBuffer
name|pbBuf
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|totalPBSize
argument_list|)
decl_stmt|;
name|writeToCOS
argument_list|(
name|result
argument_list|,
name|header
argument_list|,
name|totalSize
argument_list|,
name|pbBuf
argument_list|)
expr_stmt|;
name|pbBuf
operator|.
name|flip
argument_list|()
expr_stmt|;
return|return
name|pbBuf
return|;
block|}
specifier|private
name|BufferChain
name|wrapWithSasl
parameter_list|(
name|BufferChain
name|bc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|connection
operator|.
name|useSasl
condition|)
return|return
name|bc
return|;
comment|// Looks like no way around this; saslserver wants a byte array.  I have to make it one.
comment|// THIS IS A BIG UGLY COPY.
name|byte
index|[]
name|responseBytes
init|=
name|bc
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|byte
index|[]
name|token
decl_stmt|;
comment|// synchronization may be needed since there can be multiple Handler
comment|// threads using saslServer or Crypto AES to wrap responses.
if|if
condition|(
name|connection
operator|.
name|useCryptoAesWrap
condition|)
block|{
comment|// wrap with Crypto AES
synchronized|synchronized
init|(
name|connection
operator|.
name|cryptoAES
init|)
block|{
name|token
operator|=
name|connection
operator|.
name|cryptoAES
operator|.
name|wrap
argument_list|(
name|responseBytes
argument_list|,
literal|0
argument_list|,
name|responseBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
synchronized|synchronized
init|(
name|connection
operator|.
name|saslServer
init|)
block|{
name|token
operator|=
name|connection
operator|.
name|saslServer
operator|.
name|wrap
argument_list|(
name|responseBytes
argument_list|,
literal|0
argument_list|,
name|responseBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Adding saslServer wrapped token of size "
operator|+
name|token
operator|.
name|length
operator|+
literal|" as call response."
argument_list|)
expr_stmt|;
block|}
name|ByteBuffer
index|[]
name|responseBufs
init|=
operator|new
name|ByteBuffer
index|[
literal|2
index|]
decl_stmt|;
name|responseBufs
index|[
literal|0
index|]
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|token
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|responseBufs
index|[
literal|1
index|]
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|token
argument_list|)
expr_stmt|;
return|return
operator|new
name|BufferChain
argument_list|(
name|responseBufs
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isClientCellBlockSupported
parameter_list|()
block|{
return|return
name|this
operator|.
name|connection
operator|!=
literal|null
operator|&&
name|this
operator|.
name|connection
operator|.
name|codec
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getResponseCellSize
parameter_list|()
block|{
return|return
name|responseCellSize
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|incrementResponseCellSize
parameter_list|(
name|long
name|cellSize
parameter_list|)
block|{
name|responseCellSize
operator|+=
name|cellSize
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getResponseBlockSize
parameter_list|()
block|{
return|return
name|responseBlockSize
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|incrementResponseBlockSize
parameter_list|(
name|long
name|blockSize
parameter_list|)
block|{
name|responseBlockSize
operator|+=
name|blockSize
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getResponseExceptionSize
parameter_list|()
block|{
return|return
name|exceptionSize
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|incrementResponseExceptionSize
parameter_list|(
name|long
name|exSize
parameter_list|)
block|{
name|exceptionSize
operator|+=
name|exSize
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|size
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getDeadline
parameter_list|()
block|{
return|return
name|deadline
return|;
block|}
annotation|@
name|Override
specifier|public
name|User
name|getRequestUser
parameter_list|()
block|{
return|return
name|user
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getRequestUserName
parameter_list|()
block|{
name|User
name|user
init|=
name|getRequestUser
argument_list|()
decl_stmt|;
return|return
name|user
operator|==
literal|null
condition|?
literal|null
else|:
name|user
operator|.
name|getShortName
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|InetAddress
name|getRemoteAddress
parameter_list|()
block|{
return|return
name|remoteAddress
return|;
block|}
annotation|@
name|Override
specifier|public
name|VersionInfo
name|getClientVersionInfo
parameter_list|()
block|{
return|return
name|connection
operator|.
name|getVersionInfo
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|setCallBack
parameter_list|(
name|RpcCallback
name|callback
parameter_list|)
block|{
name|this
operator|.
name|rpcCallback
operator|=
name|callback
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isRetryImmediatelySupported
parameter_list|()
block|{
return|return
name|retryImmediatelySupported
return|;
block|}
annotation|@
name|Override
specifier|public
name|BlockingService
name|getService
parameter_list|()
block|{
return|return
name|service
return|;
block|}
annotation|@
name|Override
specifier|public
name|MethodDescriptor
name|getMethod
parameter_list|()
block|{
return|return
name|md
return|;
block|}
annotation|@
name|Override
specifier|public
name|Message
name|getParam
parameter_list|()
block|{
return|return
name|param
return|;
block|}
annotation|@
name|Override
specifier|public
name|CellScanner
name|getCellScanner
parameter_list|()
block|{
return|return
name|cellScanner
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getReceiveTime
parameter_list|()
block|{
return|return
name|timestamp
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setReceiveTime
parameter_list|(
name|long
name|t
parameter_list|)
block|{
name|this
operator|.
name|timestamp
operator|=
name|t
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|startTime
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setStartTime
parameter_list|(
name|long
name|t
parameter_list|)
block|{
name|this
operator|.
name|startTime
operator|=
name|t
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getTimeout
parameter_list|()
block|{
return|return
name|timeout
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRemotePort
parameter_list|()
block|{
return|return
name|connection
operator|.
name|getRemotePort
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|TraceInfo
name|getTraceInfo
parameter_list|()
block|{
return|return
name|tinfo
return|;
block|}
block|}
annotation|@
name|FunctionalInterface
specifier|protected
specifier|static
interface|interface
name|CallCleanup
block|{
name|void
name|run
parameter_list|()
function_decl|;
block|}
comment|/** Reads calls from a connection and queues them for handling. */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"VO_VOLATILE_INCREMENT"
argument_list|,
name|justification
operator|=
literal|"False positive according to http://sourceforge.net/p/findbugs/bugs/1032/"
argument_list|)
specifier|public
specifier|abstract
class|class
name|Connection
block|{
comment|// If initial preamble with version and magic has been read or not.
specifier|protected
name|boolean
name|connectionPreambleRead
init|=
literal|false
decl_stmt|;
comment|// If the connection header has been read or not.
specifier|protected
name|boolean
name|connectionHeaderRead
init|=
literal|false
decl_stmt|;
specifier|protected
name|CallCleanup
name|callCleanup
decl_stmt|;
comment|// Cache the remote host& port info so that even if the socket is
comment|// disconnected, we can say where it used to connect to.
specifier|protected
name|String
name|hostAddress
decl_stmt|;
specifier|protected
name|int
name|remotePort
decl_stmt|;
specifier|protected
name|InetAddress
name|addr
decl_stmt|;
specifier|protected
name|ConnectionHeader
name|connectionHeader
decl_stmt|;
comment|/**      * Codec the client asked use.      */
specifier|protected
name|Codec
name|codec
decl_stmt|;
comment|/**      * Compression codec the client asked us use.      */
specifier|protected
name|CompressionCodec
name|compressionCodec
decl_stmt|;
specifier|protected
name|BlockingService
name|service
decl_stmt|;
specifier|protected
name|AuthMethod
name|authMethod
decl_stmt|;
specifier|protected
name|boolean
name|saslContextEstablished
decl_stmt|;
specifier|protected
name|boolean
name|skipInitialSaslHandshake
decl_stmt|;
specifier|protected
name|boolean
name|useSasl
decl_stmt|;
specifier|protected
name|SaslServer
name|saslServer
decl_stmt|;
specifier|protected
name|CryptoAES
name|cryptoAES
decl_stmt|;
specifier|protected
name|boolean
name|useWrap
init|=
literal|false
decl_stmt|;
specifier|protected
name|boolean
name|useCryptoAesWrap
init|=
literal|false
decl_stmt|;
comment|// Fake 'call' for failed authorization response
specifier|protected
specifier|static
specifier|final
name|int
name|AUTHORIZATION_FAILED_CALLID
init|=
operator|-
literal|1
decl_stmt|;
specifier|protected
name|ByteArrayOutputStream
name|authFailedResponse
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
comment|// Fake 'call' for SASL context setup
specifier|protected
specifier|static
specifier|final
name|int
name|SASL_CALLID
init|=
operator|-
literal|33
decl_stmt|;
comment|// Fake 'call' for connection header response
specifier|protected
specifier|static
specifier|final
name|int
name|CONNECTION_HEADER_RESPONSE_CALLID
init|=
operator|-
literal|34
decl_stmt|;
comment|// was authentication allowed with a fallback to simple auth
specifier|protected
name|boolean
name|authenticatedWithFallback
decl_stmt|;
specifier|protected
name|boolean
name|retryImmediatelySupported
init|=
literal|false
decl_stmt|;
specifier|public
name|UserGroupInformation
name|attemptingUser
init|=
literal|null
decl_stmt|;
comment|// user name before auth
specifier|protected
name|User
name|user
init|=
literal|null
decl_stmt|;
specifier|protected
name|UserGroupInformation
name|ugi
init|=
literal|null
decl_stmt|;
specifier|public
name|Connection
parameter_list|()
block|{
name|this
operator|.
name|callCleanup
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getHostAddress
argument_list|()
operator|+
literal|":"
operator|+
name|remotePort
return|;
block|}
specifier|public
name|String
name|getHostAddress
parameter_list|()
block|{
return|return
name|hostAddress
return|;
block|}
specifier|public
name|InetAddress
name|getHostInetAddress
parameter_list|()
block|{
return|return
name|addr
return|;
block|}
specifier|public
name|int
name|getRemotePort
parameter_list|()
block|{
return|return
name|remotePort
return|;
block|}
specifier|public
name|VersionInfo
name|getVersionInfo
parameter_list|()
block|{
if|if
condition|(
name|connectionHeader
operator|.
name|hasVersionInfo
argument_list|()
condition|)
block|{
return|return
name|connectionHeader
operator|.
name|getVersionInfo
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|protected
name|String
name|getFatalConnectionString
parameter_list|(
specifier|final
name|int
name|version
parameter_list|,
specifier|final
name|byte
name|authByte
parameter_list|)
block|{
return|return
literal|"serverVersion="
operator|+
name|CURRENT_VERSION
operator|+
literal|", clientVersion="
operator|+
name|version
operator|+
literal|", authMethod="
operator|+
name|authByte
operator|+
literal|", authSupported="
operator|+
operator|(
name|authMethod
operator|!=
literal|null
operator|)
operator|+
literal|" from "
operator|+
name|toString
argument_list|()
return|;
block|}
specifier|protected
name|UserGroupInformation
name|getAuthorizedUgi
parameter_list|(
name|String
name|authorizedId
parameter_list|)
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|authorizedUgi
decl_stmt|;
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|DIGEST
condition|)
block|{
name|TokenIdentifier
name|tokenId
init|=
name|HBaseSaslRpcServer
operator|.
name|getIdentifier
argument_list|(
name|authorizedId
argument_list|,
name|secretManager
argument_list|)
decl_stmt|;
name|authorizedUgi
operator|=
name|tokenId
operator|.
name|getUser
argument_list|()
expr_stmt|;
if|if
condition|(
name|authorizedUgi
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AccessDeniedException
argument_list|(
literal|"Can't retrieve username from tokenIdentifier."
argument_list|)
throw|;
block|}
name|authorizedUgi
operator|.
name|addTokenIdentifier
argument_list|(
name|tokenId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authorizedUgi
operator|=
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|authorizedId
argument_list|)
expr_stmt|;
block|}
name|authorizedUgi
operator|.
name|setAuthenticationMethod
argument_list|(
name|authMethod
operator|.
name|authenticationMethod
operator|.
name|getAuthMethod
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|authorizedUgi
return|;
block|}
comment|/**      * Set up cell block codecs      * @throws FatalConnectionException      */
specifier|protected
name|void
name|setupCellBlockCodecs
parameter_list|(
specifier|final
name|ConnectionHeader
name|header
parameter_list|)
throws|throws
name|FatalConnectionException
block|{
comment|// TODO: Plug in other supported decoders.
if|if
condition|(
operator|!
name|header
operator|.
name|hasCellBlockCodecClass
argument_list|()
condition|)
return|return;
name|String
name|className
init|=
name|header
operator|.
name|getCellBlockCodecClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|className
operator|==
literal|null
operator|||
name|className
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return;
try|try
block|{
name|this
operator|.
name|codec
operator|=
operator|(
name|Codec
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedCellCodecException
argument_list|(
name|className
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|header
operator|.
name|hasCellBlockCompressorClass
argument_list|()
condition|)
return|return;
name|className
operator|=
name|header
operator|.
name|getCellBlockCompressorClass
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|compressionCodec
operator|=
operator|(
name|CompressionCodec
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedCompressionCodecException
argument_list|(
name|className
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Set up cipher for rpc encryption with Apache Commons Crypto      *      * @throws FatalConnectionException      */
specifier|protected
name|void
name|setupCryptoCipher
parameter_list|(
specifier|final
name|ConnectionHeader
name|header
parameter_list|,
name|RPCProtos
operator|.
name|ConnectionHeaderResponse
operator|.
name|Builder
name|chrBuilder
parameter_list|)
throws|throws
name|FatalConnectionException
block|{
comment|// If simple auth, return
if|if
condition|(
name|saslServer
operator|==
literal|null
condition|)
return|return;
comment|// check if rpc encryption with Crypto AES
name|String
name|qop
init|=
operator|(
name|String
operator|)
name|saslServer
operator|.
name|getNegotiatedProperty
argument_list|(
name|Sasl
operator|.
name|QOP
argument_list|)
decl_stmt|;
name|boolean
name|isEncryption
init|=
name|SaslUtil
operator|.
name|QualityOfProtection
operator|.
name|PRIVACY
operator|.
name|getSaslQop
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|qop
argument_list|)
decl_stmt|;
name|boolean
name|isCryptoAesEncryption
init|=
name|isEncryption
operator|&&
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.rpc.crypto.encryption.aes.enabled"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isCryptoAesEncryption
condition|)
return|return;
if|if
condition|(
operator|!
name|header
operator|.
name|hasRpcCryptoCipherTransformation
argument_list|()
condition|)
return|return;
name|String
name|transformation
init|=
name|header
operator|.
name|getRpcCryptoCipherTransformation
argument_list|()
decl_stmt|;
if|if
condition|(
name|transformation
operator|==
literal|null
operator|||
name|transformation
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return;
comment|// Negotiates AES based on complete saslServer.
comment|// The Crypto metadata need to be encrypted and send to client.
name|Properties
name|properties
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
comment|// the property for SecureRandomFactory
name|properties
operator|.
name|setProperty
argument_list|(
name|CryptoRandomFactory
operator|.
name|CLASSES_KEY
argument_list|,
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.crypto.sasl.encryption.aes.crypto.random"
argument_list|,
literal|"org.apache.commons.crypto.random.JavaCryptoRandom"
argument_list|)
argument_list|)
expr_stmt|;
comment|// the property for cipher class
name|properties
operator|.
name|setProperty
argument_list|(
name|CryptoCipherFactory
operator|.
name|CLASSES_KEY
argument_list|,
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.rpc.crypto.encryption.aes.cipher.class"
argument_list|,
literal|"org.apache.commons.crypto.cipher.JceCipher"
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|cipherKeyBits
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.rpc.crypto.encryption.aes.cipher.keySizeBits"
argument_list|,
literal|128
argument_list|)
decl_stmt|;
comment|// generate key and iv
if|if
condition|(
name|cipherKeyBits
operator|%
literal|8
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The AES cipher key size in bits"
operator|+
literal|" should be a multiple of byte"
argument_list|)
throw|;
block|}
name|int
name|len
init|=
name|cipherKeyBits
operator|/
literal|8
decl_stmt|;
name|byte
index|[]
name|inKey
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
name|byte
index|[]
name|outKey
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
name|byte
index|[]
name|inIv
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
name|byte
index|[]
name|outIv
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
try|try
block|{
comment|// generate the cipher meta data with SecureRandom
name|CryptoRandom
name|secureRandom
init|=
name|CryptoRandomFactory
operator|.
name|getCryptoRandom
argument_list|(
name|properties
argument_list|)
decl_stmt|;
name|secureRandom
operator|.
name|nextBytes
argument_list|(
name|inKey
argument_list|)
expr_stmt|;
name|secureRandom
operator|.
name|nextBytes
argument_list|(
name|outKey
argument_list|)
expr_stmt|;
name|secureRandom
operator|.
name|nextBytes
argument_list|(
name|inIv
argument_list|)
expr_stmt|;
name|secureRandom
operator|.
name|nextBytes
argument_list|(
name|outIv
argument_list|)
expr_stmt|;
comment|// create CryptoAES for server
name|cryptoAES
operator|=
operator|new
name|CryptoAES
argument_list|(
name|transformation
argument_list|,
name|properties
argument_list|,
name|inKey
argument_list|,
name|outKey
argument_list|,
name|inIv
argument_list|,
name|outIv
argument_list|)
expr_stmt|;
comment|// create SaslCipherMeta and send to client,
comment|//  for client, the [inKey, outKey], [inIv, outIv] should be reversed
name|RPCProtos
operator|.
name|CryptoCipherMeta
operator|.
name|Builder
name|ccmBuilder
init|=
name|RPCProtos
operator|.
name|CryptoCipherMeta
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ccmBuilder
operator|.
name|setTransformation
argument_list|(
name|transformation
argument_list|)
expr_stmt|;
name|ccmBuilder
operator|.
name|setInIv
argument_list|(
name|getByteString
argument_list|(
name|outIv
argument_list|)
argument_list|)
expr_stmt|;
name|ccmBuilder
operator|.
name|setInKey
argument_list|(
name|getByteString
argument_list|(
name|outKey
argument_list|)
argument_list|)
expr_stmt|;
name|ccmBuilder
operator|.
name|setOutIv
argument_list|(
name|getByteString
argument_list|(
name|inIv
argument_list|)
argument_list|)
expr_stmt|;
name|ccmBuilder
operator|.
name|setOutKey
argument_list|(
name|getByteString
argument_list|(
name|inKey
argument_list|)
argument_list|)
expr_stmt|;
name|chrBuilder
operator|.
name|setCryptoCipherMeta
argument_list|(
name|ccmBuilder
argument_list|)
expr_stmt|;
name|useCryptoAesWrap
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|GeneralSecurityException
decl||
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedCryptoException
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
specifier|private
name|ByteString
name|getByteString
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
comment|// return singleton to reduce object allocation
return|return
operator|(
name|bytes
operator|.
name|length
operator|==
literal|0
operator|)
condition|?
name|ByteString
operator|.
name|EMPTY
else|:
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|bytes
argument_list|)
return|;
block|}
specifier|protected
name|UserGroupInformation
name|createUser
parameter_list|(
name|ConnectionHeader
name|head
parameter_list|)
block|{
name|UserGroupInformation
name|ugi
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|head
operator|.
name|hasUserInfo
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|UserInformation
name|userInfoProto
init|=
name|head
operator|.
name|getUserInfo
argument_list|()
decl_stmt|;
name|String
name|effectiveUser
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|userInfoProto
operator|.
name|hasEffectiveUser
argument_list|()
condition|)
block|{
name|effectiveUser
operator|=
name|userInfoProto
operator|.
name|getEffectiveUser
argument_list|()
expr_stmt|;
block|}
name|String
name|realUser
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|userInfoProto
operator|.
name|hasRealUser
argument_list|()
condition|)
block|{
name|realUser
operator|=
name|userInfoProto
operator|.
name|getRealUser
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|effectiveUser
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|realUser
operator|!=
literal|null
condition|)
block|{
name|UserGroupInformation
name|realUserUgi
init|=
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|realUser
argument_list|)
decl_stmt|;
name|ugi
operator|=
name|UserGroupInformation
operator|.
name|createProxyUser
argument_list|(
name|effectiveUser
argument_list|,
name|realUserUgi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ugi
operator|=
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|effectiveUser
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ugi
return|;
block|}
specifier|public
specifier|abstract
name|boolean
name|isConnectionOpen
parameter_list|()
function_decl|;
block|}
comment|/**    * Datastructure for passing a {@link BlockingService} and its associated class of    * protobuf service interface.  For example, a server that fielded what is defined    * in the client protobuf service would pass in an implementation of the client blocking service    * and then its ClientService.BlockingInterface.class.  Used checking connection setup.    */
specifier|public
specifier|static
class|class
name|BlockingServiceAndInterface
block|{
specifier|private
specifier|final
name|BlockingService
name|service
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|serviceInterface
decl_stmt|;
specifier|public
name|BlockingServiceAndInterface
parameter_list|(
specifier|final
name|BlockingService
name|service
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|serviceInterface
parameter_list|)
block|{
name|this
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|serviceInterface
operator|=
name|serviceInterface
expr_stmt|;
block|}
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getServiceInterface
parameter_list|()
block|{
return|return
name|this
operator|.
name|serviceInterface
return|;
block|}
specifier|public
name|BlockingService
name|getBlockingService
parameter_list|()
block|{
return|return
name|this
operator|.
name|service
return|;
block|}
block|}
comment|/**    * Constructs a server listening on the named port and address.    * @param server hosting instance of {@link Server}. We will do authentications if an    * instance else pass null for no authentication check.    * @param name Used keying this rpc servers' metrics and for naming the Listener thread.    * @param services A list of services.    * @param bindAddress Where to listen    * @param conf    * @param scheduler    */
specifier|public
name|RpcServer
parameter_list|(
specifier|final
name|Server
name|server
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|InetSocketAddress
name|bindAddress
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|RpcScheduler
name|scheduler
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.ipc.server.reservoir.enabled"
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|int
name|poolBufSize
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|ByteBufferPool
operator|.
name|BUFFER_SIZE_KEY
argument_list|,
name|ByteBufferPool
operator|.
name|DEFAULT_BUFFER_SIZE
argument_list|)
decl_stmt|;
comment|// The max number of buffers to be pooled in the ByteBufferPool. The default value been
comment|// selected based on the #handlers configured. When it is read request, 2 MB is the max size
comment|// at which we will send back one RPC request. Means max we need 2 MB for creating the
comment|// response cell block. (Well it might be much lesser than this because in 2 MB size calc, we
comment|// include the heap size overhead of each cells also.) Considering 2 MB, we will need
comment|// (2 * 1024 * 1024) / poolBufSize buffers to make the response cell block. Pool buffer size
comment|// is by default 64 KB.
comment|// In case of read request, at the end of the handler process, we will make the response
comment|// cellblock and add the Call to connection's response Q and a single Responder thread takes
comment|// connections and responses from that one by one and do the socket write. So there is chances
comment|// that by the time a handler originated response is actually done writing to socket and so
comment|// released the BBs it used, the handler might have processed one more read req. On an avg 2x
comment|// we consider and consider that also for the max buffers to pool
name|int
name|bufsForTwoMB
init|=
operator|(
literal|2
operator|*
literal|1024
operator|*
literal|1024
operator|)
operator|/
name|poolBufSize
decl_stmt|;
name|int
name|maxPoolSize
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|ByteBufferPool
operator|.
name|MAX_POOL_SIZE_KEY
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|REGION_SERVER_HANDLER_COUNT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_REGION_SERVER_HANDLER_COUNT
argument_list|)
operator|*
name|bufsForTwoMB
operator|*
literal|2
argument_list|)
decl_stmt|;
name|this
operator|.
name|reservoir
operator|=
operator|new
name|ByteBufferPool
argument_list|(
name|poolBufSize
argument_list|,
name|maxPoolSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|minSizeForReservoirUse
operator|=
name|getMinSizeForReservoirUse
argument_list|(
name|this
operator|.
name|reservoir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reservoir
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|minSizeForReservoirUse
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
comment|// reservoir itself not in place.
block|}
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
name|this
operator|.
name|services
operator|=
name|services
expr_stmt|;
name|this
operator|.
name|bindAddress
operator|=
name|bindAddress
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
comment|// See declaration above for documentation on what this size is.
name|this
operator|.
name|maxQueueSizeInBytes
operator|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.ipc.server.max.callqueue.size"
argument_list|,
name|DEFAULT_MAX_CALLQUEUE_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|warnResponseTime
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|WARN_RESPONSE_TIME
argument_list|,
name|DEFAULT_WARN_RESPONSE_TIME
argument_list|)
expr_stmt|;
name|this
operator|.
name|warnResponseSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|WARN_RESPONSE_SIZE
argument_list|,
name|DEFAULT_WARN_RESPONSE_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|minClientRequestTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|MIN_CLIENT_REQUEST_TIMEOUT
argument_list|,
name|DEFAULT_MIN_CLIENT_REQUEST_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxRequestSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|MAX_REQUEST_SIZE
argument_list|,
name|DEFAULT_MAX_REQUEST_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
operator|new
name|MetricsHBaseServer
argument_list|(
name|name
argument_list|,
operator|new
name|MetricsHBaseServerWrapperImpl
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpNoDelay
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.ipc.server.tcpnodelay"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpKeepAlive
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.ipc.server.tcpkeepalive"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|cellBlockBuilder
operator|=
operator|new
name|CellBlockBuilder
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|authorize
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HADOOP_SECURITY_AUTHORIZATION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|userProvider
operator|=
name|UserProvider
operator|.
name|instantiate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|isSecurityEnabled
operator|=
name|userProvider
operator|.
name|isHBaseSecurityEnabled
argument_list|()
expr_stmt|;
if|if
condition|(
name|isSecurityEnabled
condition|)
block|{
name|HBaseSaslRpcServer
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|scheduler
operator|=
name|scheduler
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|getMinSizeForReservoirUse
parameter_list|(
name|ByteBufferPool
name|pool
parameter_list|)
block|{
return|return
name|pool
operator|.
name|getBufferSize
argument_list|()
operator|/
literal|6
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onConfigurationChange
parameter_list|(
name|Configuration
name|newConf
parameter_list|)
block|{
name|initReconfigurable
argument_list|(
name|newConf
argument_list|)
expr_stmt|;
if|if
condition|(
name|scheduler
operator|instanceof
name|ConfigurationObserver
condition|)
block|{
operator|(
operator|(
name|ConfigurationObserver
operator|)
name|scheduler
operator|)
operator|.
name|onConfigurationChange
argument_list|(
name|newConf
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|initReconfigurable
parameter_list|(
name|Configuration
name|confToLoad
parameter_list|)
block|{
name|this
operator|.
name|allowFallbackToSimpleAuth
operator|=
name|confToLoad
operator|.
name|getBoolean
argument_list|(
name|FALLBACK_TO_INSECURE_CLIENT_AUTH
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSecurityEnabled
operator|&&
name|allowFallbackToSimpleAuth
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"********* WARNING! *********"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"This server is configured to allow connections from INSECURE clients"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"("
operator|+
name|FALLBACK_TO_INSECURE_CLIENT_AUTH
operator|+
literal|" = true)."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"While this option is enabled, client identities cannot be secured, and user"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"impersonation is possible!"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"For secure operation, please disable SIMPLE authentication as soon as possible,"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"by setting "
operator|+
name|FALLBACK_TO_INSECURE_CLIENT_AUTH
operator|+
literal|" = false in hbase-site.xml"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"****************************"
argument_list|)
expr_stmt|;
block|}
block|}
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStarted
parameter_list|()
block|{
return|return
name|this
operator|.
name|started
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|refreshAuthManager
parameter_list|(
name|PolicyProvider
name|pp
parameter_list|)
block|{
comment|// Ignore warnings that this should be accessed in a static way instead of via an instance;
comment|// it'll break if you go via static route.
name|this
operator|.
name|authManager
operator|.
name|refresh
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|AuthenticationTokenSecretManager
name|createSecretManager
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|Configuration
name|conf
init|=
name|server
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|long
name|keyUpdateInterval
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.auth.key.update.interval"
argument_list|,
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
literal|1000
argument_list|)
decl_stmt|;
name|long
name|maxAge
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.auth.token.max.lifetime"
argument_list|,
literal|7
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
literal|1000
argument_list|)
decl_stmt|;
return|return
operator|new
name|AuthenticationTokenSecretManager
argument_list|(
name|conf
argument_list|,
name|server
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|keyUpdateInterval
argument_list|,
name|maxAge
argument_list|)
return|;
block|}
specifier|public
name|SecretManager
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|getSecretManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|secretManager
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|setSecretManager
parameter_list|(
name|SecretManager
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|secretManager
parameter_list|)
block|{
name|this
operator|.
name|secretManager
operator|=
operator|(
name|SecretManager
argument_list|<
name|TokenIdentifier
argument_list|>
operator|)
name|secretManager
expr_stmt|;
block|}
comment|/**    * This is a server side method, which is invoked over RPC. On success    * the return response has protobuf response payload. On failure, the    * exception name and the stack trace are returned in the protobuf response.    */
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
name|call
parameter_list|(
name|RpcCall
name|call
parameter_list|,
name|MonitoredRPCHandler
name|status
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|MethodDescriptor
name|md
init|=
name|call
operator|.
name|getMethod
argument_list|()
decl_stmt|;
name|Message
name|param
init|=
name|call
operator|.
name|getParam
argument_list|()
decl_stmt|;
name|status
operator|.
name|setRPC
argument_list|(
name|md
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|Object
index|[]
block|{
name|param
block|}
argument_list|,
name|call
operator|.
name|getReceiveTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: Review after we add in encoded data blocks.
name|status
operator|.
name|setRPCPacket
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|status
operator|.
name|resume
argument_list|(
literal|"Servicing call"
argument_list|)
expr_stmt|;
comment|//get an instance of the method arg type
name|HBaseRpcController
name|controller
init|=
operator|new
name|HBaseRpcControllerImpl
argument_list|(
name|call
operator|.
name|getCellScanner
argument_list|()
argument_list|)
decl_stmt|;
name|controller
operator|.
name|setCallTimeout
argument_list|(
name|call
operator|.
name|getTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|Message
name|result
init|=
name|call
operator|.
name|getService
argument_list|()
operator|.
name|callBlockingMethod
argument_list|(
name|md
argument_list|,
name|controller
argument_list|,
name|param
argument_list|)
decl_stmt|;
name|long
name|receiveTime
init|=
name|call
operator|.
name|getReceiveTime
argument_list|()
decl_stmt|;
name|long
name|startTime
init|=
name|call
operator|.
name|getStartTime
argument_list|()
decl_stmt|;
name|long
name|endTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|processingTime
init|=
call|(
name|int
call|)
argument_list|(
name|endTime
operator|-
name|startTime
argument_list|)
decl_stmt|;
name|int
name|qTime
init|=
call|(
name|int
call|)
argument_list|(
name|startTime
operator|-
name|receiveTime
argument_list|)
decl_stmt|;
name|int
name|totalTime
init|=
call|(
name|int
call|)
argument_list|(
name|endTime
operator|-
name|receiveTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|CurCall
operator|.
name|get
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|", response "
operator|+
name|TextFormat
operator|.
name|shortDebugString
argument_list|(
name|result
argument_list|)
operator|+
literal|" queueTime: "
operator|+
name|qTime
operator|+
literal|" processingTime: "
operator|+
name|processingTime
operator|+
literal|" totalTime: "
operator|+
name|totalTime
argument_list|)
expr_stmt|;
block|}
comment|// Use the raw request call size for now.
name|long
name|requestSize
init|=
name|call
operator|.
name|getSize
argument_list|()
decl_stmt|;
name|long
name|responseSize
init|=
name|result
operator|.
name|getSerializedSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|isClientCellBlockSupported
argument_list|()
condition|)
block|{
comment|// Include the payload size in HBaseRpcController
name|responseSize
operator|+=
name|call
operator|.
name|getResponseCellSize
argument_list|()
expr_stmt|;
block|}
name|metrics
operator|.
name|dequeuedCall
argument_list|(
name|qTime
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|processedCall
argument_list|(
name|processingTime
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|totalCall
argument_list|(
name|totalTime
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|receivedRequest
argument_list|(
name|requestSize
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|sentResponse
argument_list|(
name|responseSize
argument_list|)
expr_stmt|;
comment|// log any RPC responses that are slower than the configured warn
comment|// response time or larger than configured warning size
name|boolean
name|tooSlow
init|=
operator|(
name|processingTime
operator|>
name|warnResponseTime
operator|&&
name|warnResponseTime
operator|>
operator|-
literal|1
operator|)
decl_stmt|;
name|boolean
name|tooLarge
init|=
operator|(
name|responseSize
operator|>
name|warnResponseSize
operator|&&
name|warnResponseSize
operator|>
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|tooSlow
operator|||
name|tooLarge
condition|)
block|{
comment|// when tagging, we let TooLarge trump TooSmall to keep output simple
comment|// note that large responses will often also be slow.
name|logResponse
argument_list|(
name|param
argument_list|,
name|md
operator|.
name|getName
argument_list|()
argument_list|,
name|md
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
name|param
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")"
argument_list|,
operator|(
name|tooLarge
condition|?
literal|"TooLarge"
else|:
literal|"TooSlow"
operator|)
argument_list|,
name|status
operator|.
name|getClient
argument_list|()
argument_list|,
name|startTime
argument_list|,
name|processingTime
argument_list|,
name|qTime
argument_list|,
name|responseSize
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
argument_list|(
name|result
argument_list|,
name|controller
operator|.
name|cellScanner
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// The above callBlockingMethod will always return a SE.  Strip the SE wrapper before
comment|// putting it on the wire.  Its needed to adhere to the pb Service Interface but we don't
comment|// need to pass it over the wire.
if|if
condition|(
name|e
operator|instanceof
name|ServiceException
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Caught a ServiceException with null cause"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|e
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
block|}
comment|// increment the number of requests that were exceptions.
name|metrics
operator|.
name|exception
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|LinkageError
condition|)
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
name|e
argument_list|)
throw|;
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
throw|throw
operator|(
name|IOException
operator|)
name|e
throw|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected throwable object "
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Logs an RPC response to the LOG file, producing valid JSON objects for    * client Operations.    * @param param The parameters received in the call.    * @param methodName The name of the method invoked    * @param call The string representation of the call    * @param tag  The tag that will be used to indicate this event in the log.    * @param clientAddress   The address of the client who made this call.    * @param startTime       The time that the call was initiated, in ms.    * @param processingTime  The duration that the call took to run, in ms.    * @param qTime           The duration that the call spent on the queue    *                        prior to being initiated, in ms.    * @param responseSize    The size in bytes of the response buffer.    */
name|void
name|logResponse
parameter_list|(
name|Message
name|param
parameter_list|,
name|String
name|methodName
parameter_list|,
name|String
name|call
parameter_list|,
name|String
name|tag
parameter_list|,
name|String
name|clientAddress
parameter_list|,
name|long
name|startTime
parameter_list|,
name|int
name|processingTime
parameter_list|,
name|int
name|qTime
parameter_list|,
name|long
name|responseSize
parameter_list|)
throws|throws
name|IOException
block|{
comment|// base information that is reported regardless of type of call
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|responseInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"starttimems"
argument_list|,
name|startTime
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"processingtimems"
argument_list|,
name|processingTime
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"queuetimems"
argument_list|,
name|qTime
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"responsesize"
argument_list|,
name|responseSize
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"client"
argument_list|,
name|clientAddress
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"class"
argument_list|,
name|server
operator|==
literal|null
condition|?
literal|""
else|:
name|server
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"method"
argument_list|,
name|methodName
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"call"
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"param"
argument_list|,
name|ProtobufUtil
operator|.
name|getShortTextFormat
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|instanceof
name|ClientProtos
operator|.
name|ScanRequest
operator|&&
name|rsRpcServices
operator|!=
literal|null
condition|)
block|{
name|ClientProtos
operator|.
name|ScanRequest
name|request
init|=
operator|(
operator|(
name|ClientProtos
operator|.
name|ScanRequest
operator|)
name|param
operator|)
decl_stmt|;
if|if
condition|(
name|request
operator|.
name|hasScannerId
argument_list|()
condition|)
block|{
name|long
name|scannerId
init|=
name|request
operator|.
name|getScannerId
argument_list|()
decl_stmt|;
name|String
name|scanDetails
init|=
name|rsRpcServices
operator|.
name|getScanDetailsWithId
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|scanDetails
operator|!=
literal|null
condition|)
block|{
name|responseInfo
operator|.
name|put
argument_list|(
literal|"scandetails"
argument_list|,
name|scanDetails
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"(response"
operator|+
name|tag
operator|+
literal|"): "
operator|+
name|MAPPER
operator|.
name|writeValueAsString
argument_list|(
name|responseInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the handler for calling out of RPC for error conditions.    * @param handler the handler implementation    */
annotation|@
name|Override
specifier|public
name|void
name|setErrorHandler
parameter_list|(
name|HBaseRPCErrorHandler
name|handler
parameter_list|)
block|{
name|this
operator|.
name|errorHandler
operator|=
name|handler
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|HBaseRPCErrorHandler
name|getErrorHandler
parameter_list|()
block|{
return|return
name|this
operator|.
name|errorHandler
return|;
block|}
comment|/**    * Returns the metrics instance for reporting RPC call statistics    */
annotation|@
name|Override
specifier|public
name|MetricsHBaseServer
name|getMetrics
parameter_list|()
block|{
return|return
name|metrics
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addCallSize
parameter_list|(
specifier|final
name|long
name|diff
parameter_list|)
block|{
name|this
operator|.
name|callQueueSizeInBytes
operator|.
name|add
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/**    * Authorize the incoming client connection.    *    * @param user client user    * @param connection incoming connection    * @param addr InetAddress of incoming connection    * @throws org.apache.hadoop.security.authorize.AuthorizationException    *         when the client isn't authorized to talk the protocol    */
specifier|public
specifier|synchronized
name|void
name|authorize
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|,
name|ConnectionHeader
name|connection
parameter_list|,
name|InetAddress
name|addr
parameter_list|)
throws|throws
name|AuthorizationException
block|{
if|if
condition|(
name|authorize
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|c
init|=
name|getServiceInterface
argument_list|(
name|services
argument_list|,
name|connection
operator|.
name|getServiceName
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|authManager
operator|.
name|authorize
argument_list|(
name|user
operator|!=
literal|null
condition|?
name|user
else|:
literal|null
argument_list|,
name|c
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This is extracted to a static method for better unit testing. We try to get buffer(s) from pool    * as much as possible.    *    * @param pool The ByteBufferPool to use    * @param minSizeForPoolUse Only for buffer size above this, we will try to use pool. Any buffer    *           need of size below this, create on heap ByteBuffer.    * @param reqLen Bytes count in request    */
annotation|@
name|VisibleForTesting
specifier|static
name|Pair
argument_list|<
name|ByteBuff
argument_list|,
name|CallCleanup
argument_list|>
name|allocateByteBuffToReadInto
parameter_list|(
name|ByteBufferPool
name|pool
parameter_list|,
name|int
name|minSizeForPoolUse
parameter_list|,
name|int
name|reqLen
parameter_list|)
block|{
name|ByteBuff
name|resultBuf
decl_stmt|;
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|bbs
init|=
operator|new
name|ArrayList
argument_list|<
name|ByteBuffer
argument_list|>
argument_list|(
operator|(
name|reqLen
operator|/
name|pool
operator|.
name|getBufferSize
argument_list|()
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|remain
init|=
name|reqLen
decl_stmt|;
name|ByteBuffer
name|buf
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|remain
operator|>=
name|minSizeForPoolUse
operator|&&
operator|(
name|buf
operator|=
name|pool
operator|.
name|getBuffer
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|bbs
operator|.
name|add
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|remain
operator|-=
name|pool
operator|.
name|getBufferSize
argument_list|()
expr_stmt|;
block|}
name|ByteBuffer
index|[]
name|bufsFromPool
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|bbs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|bufsFromPool
operator|=
operator|new
name|ByteBuffer
index|[
name|bbs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|bbs
operator|.
name|toArray
argument_list|(
name|bufsFromPool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remain
operator|>
literal|0
condition|)
block|{
name|bbs
operator|.
name|add
argument_list|(
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|remain
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bbs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ByteBuffer
index|[]
name|items
init|=
operator|new
name|ByteBuffer
index|[
name|bbs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|bbs
operator|.
name|toArray
argument_list|(
name|items
argument_list|)
expr_stmt|;
name|resultBuf
operator|=
operator|new
name|MultiByteBuff
argument_list|(
name|items
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We are backed by single BB
name|resultBuf
operator|=
operator|new
name|SingleByteBuff
argument_list|(
name|bbs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|resultBuf
operator|.
name|limit
argument_list|(
name|reqLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufsFromPool
operator|!=
literal|null
condition|)
block|{
specifier|final
name|ByteBuffer
index|[]
name|bufsFromPoolFinal
init|=
name|bufsFromPool
decl_stmt|;
return|return
operator|new
name|Pair
argument_list|<
name|ByteBuff
argument_list|,
name|RpcServer
operator|.
name|CallCleanup
argument_list|>
argument_list|(
name|resultBuf
argument_list|,
parameter_list|()
lambda|->
block|{
comment|// Return back all the BBs to pool
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bufsFromPoolFinal
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|pool
operator|.
name|putbackBuffer
argument_list|(
name|bufsFromPoolFinal
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
return|return
operator|new
name|Pair
argument_list|<
name|ByteBuff
argument_list|,
name|RpcServer
operator|.
name|CallCleanup
argument_list|>
argument_list|(
name|resultBuf
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Needed for features such as delayed calls.  We need to be able to store the current call    * so that we can complete it later or ask questions of what is supported by the current ongoing    * call.    * @return An RpcCallContext backed by the currently ongoing call (gotten from a thread local)    */
specifier|public
specifier|static
name|RpcCallContext
name|getCurrentCall
parameter_list|()
block|{
return|return
name|CurCall
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isInRpcCallContext
parameter_list|()
block|{
return|return
name|CurCall
operator|.
name|get
argument_list|()
operator|!=
literal|null
return|;
block|}
comment|/**    * Returns the user credentials associated with the current RPC request or    *<code>null</code> if no credentials were provided.    * @return A User    */
specifier|public
specifier|static
name|User
name|getRequestUser
parameter_list|()
block|{
name|RpcCallContext
name|ctx
init|=
name|getCurrentCall
argument_list|()
decl_stmt|;
return|return
name|ctx
operator|==
literal|null
condition|?
literal|null
else|:
name|ctx
operator|.
name|getRequestUser
argument_list|()
return|;
block|}
comment|/**    * The number of open RPC conections    * @return the number of open rpc connections    */
specifier|abstract
specifier|public
name|int
name|getNumOpenConnections
parameter_list|()
function_decl|;
comment|/**    * Returns the username for any user associated with the current RPC    * request or<code>null</code> if no user is set.    */
specifier|public
specifier|static
name|String
name|getRequestUserName
parameter_list|()
block|{
name|User
name|user
init|=
name|getRequestUser
argument_list|()
decl_stmt|;
return|return
name|user
operator|==
literal|null
condition|?
literal|null
else|:
name|user
operator|.
name|getShortName
argument_list|()
return|;
block|}
comment|/**    * @return Address of remote client if a request is ongoing, else null    */
specifier|public
specifier|static
name|InetAddress
name|getRemoteAddress
parameter_list|()
block|{
name|RpcCallContext
name|ctx
init|=
name|getCurrentCall
argument_list|()
decl_stmt|;
return|return
name|ctx
operator|==
literal|null
condition|?
literal|null
else|:
name|ctx
operator|.
name|getRemoteAddress
argument_list|()
return|;
block|}
comment|/**    * @param serviceName Some arbitrary string that represents a 'service'.    * @param services Available service instances    * @return Matching BlockingServiceAndInterface pair    */
specifier|protected
specifier|static
name|BlockingServiceAndInterface
name|getServiceAndInterface
parameter_list|(
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|String
name|serviceName
parameter_list|)
block|{
for|for
control|(
name|BlockingServiceAndInterface
name|bs
range|:
name|services
control|)
block|{
if|if
condition|(
name|bs
operator|.
name|getBlockingService
argument_list|()
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|serviceName
argument_list|)
condition|)
block|{
return|return
name|bs
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @param serviceName Some arbitrary string that represents a 'service'.    * @param services Available services and their service interfaces.    * @return Service interface class for<code>serviceName</code>    */
specifier|protected
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|getServiceInterface
parameter_list|(
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|String
name|serviceName
parameter_list|)
block|{
name|BlockingServiceAndInterface
name|bsasi
init|=
name|getServiceAndInterface
argument_list|(
name|services
argument_list|,
name|serviceName
argument_list|)
decl_stmt|;
return|return
name|bsasi
operator|==
literal|null
condition|?
literal|null
else|:
name|bsasi
operator|.
name|getServiceInterface
argument_list|()
return|;
block|}
comment|/**    * @param serviceName Some arbitrary string that represents a 'service'.    * @param services Available services and their service interfaces.    * @return BlockingService that goes with the passed<code>serviceName</code>    */
specifier|protected
specifier|static
name|BlockingService
name|getService
parameter_list|(
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|String
name|serviceName
parameter_list|)
block|{
name|BlockingServiceAndInterface
name|bsasi
init|=
name|getServiceAndInterface
argument_list|(
name|services
argument_list|,
name|serviceName
argument_list|)
decl_stmt|;
return|return
name|bsasi
operator|==
literal|null
condition|?
literal|null
else|:
name|bsasi
operator|.
name|getBlockingService
argument_list|()
return|;
block|}
specifier|protected
specifier|static
name|MonitoredRPCHandler
name|getStatus
parameter_list|()
block|{
comment|// It is ugly the way we park status up in RpcServer.  Let it be for now.  TODO.
name|MonitoredRPCHandler
name|status
init|=
name|RpcServer
operator|.
name|MONITORED_RPC
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|null
condition|)
block|{
return|return
name|status
return|;
block|}
name|status
operator|=
name|TaskMonitor
operator|.
name|get
argument_list|()
operator|.
name|createRPCStatus
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|pause
argument_list|(
literal|"Waiting for a call"
argument_list|)
expr_stmt|;
name|RpcServer
operator|.
name|MONITORED_RPC
operator|.
name|set
argument_list|(
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/** Returns the remote side ip address when invoked inside an RPC    *  Returns null incase of an error.    *  @return InetAddress    */
specifier|public
specifier|static
name|InetAddress
name|getRemoteIp
parameter_list|()
block|{
name|RpcCall
name|call
init|=
name|CurCall
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
return|return
name|call
operator|.
name|getRemoteAddress
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|RpcScheduler
name|getScheduler
parameter_list|()
block|{
return|return
name|scheduler
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setRsRpcServices
parameter_list|(
name|RSRpcServices
name|rsRpcServices
parameter_list|)
block|{
name|this
operator|.
name|rsRpcServices
operator|=
name|rsRpcServices
expr_stmt|;
block|}
specifier|protected
specifier|static
class|class
name|ByteBuffByteInput
extends|extends
name|ByteInput
block|{
specifier|private
name|ByteBuff
name|buf
decl_stmt|;
specifier|private
name|int
name|offset
decl_stmt|;
specifier|private
name|int
name|length
decl_stmt|;
name|ByteBuffByteInput
parameter_list|(
name|ByteBuff
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|this
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|read
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
return|return
name|this
operator|.
name|buf
operator|.
name|get
argument_list|(
name|getAbsoluteOffset
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|int
name|getAbsoluteOffset
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
return|return
name|this
operator|.
name|offset
operator|+
name|offset
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|int
name|offset
parameter_list|,
name|byte
index|[]
name|out
parameter_list|,
name|int
name|outOffset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|this
operator|.
name|buf
operator|.
name|get
argument_list|(
name|getAbsoluteOffset
argument_list|(
name|offset
argument_list|)
argument_list|,
name|out
argument_list|,
name|outOffset
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|int
name|offset
parameter_list|,
name|ByteBuffer
name|out
parameter_list|)
block|{
name|int
name|len
init|=
name|out
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|this
operator|.
name|buf
operator|.
name|get
argument_list|(
name|out
argument_list|,
name|getAbsoluteOffset
argument_list|(
name|offset
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|this
operator|.
name|length
return|;
block|}
block|}
block|}
end_class

end_unit

