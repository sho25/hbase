begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ReadableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|WritableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|LongAdder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CallQueueTooBigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|conf
operator|.
name|ConfigurationObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|RequestTooBigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ByteBufferPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MonitoredRPCHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|TaskMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|ByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|MultiByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|SingleByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RSRpcServices
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|SaslUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|SaslUtil
operator|.
name|QualityOfProtection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|UserProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|token
operator|.
name|AuthenticationTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AuthorizationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|PolicyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ServiceAuthorizationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|BlockingService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|MethodDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ServiceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|TextFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ConnectionHeader
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|databind
operator|.
name|ObjectMapper
import|;
end_import

begin_comment
comment|/**  * An RPC server that hosts protobuf described Services.  *  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|abstract
class|class
name|RpcServer
implements|implements
name|RpcServerInterface
implements|,
name|ConfigurationObserver
block|{
comment|// LOG is being used in CallRunner and the log level is being changed in tests
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RpcServer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|CallQueueTooBigException
name|CALL_QUEUE_TOO_BIG_EXCEPTION
init|=
operator|new
name|CallQueueTooBigException
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|authorize
decl_stmt|;
specifier|protected
name|boolean
name|isSecurityEnabled
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|CURRENT_VERSION
init|=
literal|0
decl_stmt|;
comment|/**    * Whether we allow a fallback to SIMPLE auth for insecure clients when security is enabled.    */
specifier|public
specifier|static
specifier|final
name|String
name|FALLBACK_TO_INSECURE_CLIENT_AUTH
init|=
literal|"hbase.ipc.server.fallback-to-simple-auth-allowed"
decl_stmt|;
comment|/**    * How many calls/handler are allowed in the queue.    */
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_CALLQUEUE_LENGTH_PER_HANDLER
init|=
literal|10
decl_stmt|;
specifier|protected
specifier|final
name|CellBlockBuilder
name|cellBlockBuilder
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|AUTH_FAILED_FOR
init|=
literal|"Auth failed for "
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|AUTH_SUCCESSFUL_FOR
init|=
literal|"Auth successful for "
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|Logger
name|AUDITLOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
literal|"SecurityLogger."
operator|+
name|Server
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
name|SecretManager
argument_list|<
name|TokenIdentifier
argument_list|>
name|secretManager
decl_stmt|;
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|saslProps
decl_stmt|;
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"IS2_INCONSISTENT_SYNC"
argument_list|,
name|justification
operator|=
literal|"Start is synchronized so authManager creation is single-threaded"
argument_list|)
specifier|protected
name|ServiceAuthorizationManager
name|authManager
decl_stmt|;
comment|/** This is set to Call object before Handler invokes an RPC and ybdie    * after the call returns.    */
specifier|protected
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|RpcCall
argument_list|>
name|CurCall
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Keeps MonitoredRPCHandler per handler thread. */
specifier|protected
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|MonitoredRPCHandler
argument_list|>
name|MONITORED_RPC
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|InetSocketAddress
name|bindAddress
decl_stmt|;
specifier|protected
name|MetricsHBaseServer
name|metrics
decl_stmt|;
specifier|protected
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|/**    * Maximum size in bytes of the currently queued and running Calls. If a new Call puts us over    * this size, then we will reject the call (after parsing it though). It will go back to the    * client and client will retry. Set this size with "hbase.ipc.server.max.callqueue.size". The    * call queue size gets incremented after we parse a call and before we add it to the queue of    * calls for the scheduler to use. It get decremented after we have 'run' the Call. The current    * size is kept in {@link #callQueueSizeInBytes}.    * @see #callQueueSizeInBytes    * @see #DEFAULT_MAX_CALLQUEUE_SIZE    */
specifier|protected
specifier|final
name|long
name|maxQueueSizeInBytes
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_CALLQUEUE_SIZE
init|=
literal|1024
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|/**    * This is a running count of the size in bytes of all outstanding calls whether currently    * executing or queued waiting to be run.    */
specifier|protected
specifier|final
name|LongAdder
name|callQueueSizeInBytes
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|tcpNoDelay
decl_stmt|;
comment|// if T then disable Nagle's Algorithm
specifier|protected
specifier|final
name|boolean
name|tcpKeepAlive
decl_stmt|;
comment|// if T then use keepalives
comment|/**    * This flag is used to indicate to sub threads when they should go down.  When we call    * {@link #start()}, all threads started will consult this flag on whether they should    * keep going.  It is set to false when {@link #stop()} is called.    */
specifier|volatile
name|boolean
name|running
init|=
literal|true
decl_stmt|;
comment|/**    * This flag is set to true after all threads are up and 'running' and the server is then opened    * for business by the call to {@link #start()}.    */
specifier|volatile
name|boolean
name|started
init|=
literal|false
decl_stmt|;
specifier|protected
name|AuthenticationTokenSecretManager
name|authTokenSecretMgr
init|=
literal|null
decl_stmt|;
specifier|protected
name|HBaseRPCErrorHandler
name|errorHandler
init|=
literal|null
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|MAX_REQUEST_SIZE
init|=
literal|"hbase.ipc.max.request.size"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|RequestTooBigException
name|REQUEST_TOO_BIG_EXCEPTION
init|=
operator|new
name|RequestTooBigException
argument_list|()
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|WARN_RESPONSE_TIME
init|=
literal|"hbase.ipc.warn.response.time"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|WARN_RESPONSE_SIZE
init|=
literal|"hbase.ipc.warn.response.size"
decl_stmt|;
comment|/**    * Minimum allowable timeout (in milliseconds) in rpc request's header. This    * configuration exists to prevent the rpc service regarding this request as timeout immediately.    */
specifier|protected
specifier|static
specifier|final
name|String
name|MIN_CLIENT_REQUEST_TIMEOUT
init|=
literal|"hbase.ipc.min.client.request.timeout"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_CLIENT_REQUEST_TIMEOUT
init|=
literal|20
decl_stmt|;
comment|/** Default value for above params */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_REQUEST_SIZE
init|=
name|DEFAULT_MAX_CALLQUEUE_SIZE
operator|/
literal|4
decl_stmt|;
comment|// 256M
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_WARN_RESPONSE_TIME
init|=
literal|10000
decl_stmt|;
comment|// milliseconds
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_WARN_RESPONSE_SIZE
init|=
literal|100
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|ObjectMapper
name|MAPPER
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|int
name|maxRequestSize
decl_stmt|;
specifier|protected
specifier|final
name|int
name|warnResponseTime
decl_stmt|;
specifier|protected
specifier|final
name|int
name|warnResponseSize
decl_stmt|;
specifier|protected
specifier|final
name|int
name|minClientRequestTimeout
decl_stmt|;
specifier|protected
specifier|final
name|Server
name|server
decl_stmt|;
specifier|protected
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
decl_stmt|;
specifier|protected
specifier|final
name|RpcScheduler
name|scheduler
decl_stmt|;
specifier|protected
name|UserProvider
name|userProvider
decl_stmt|;
specifier|protected
specifier|final
name|ByteBufferPool
name|reservoir
decl_stmt|;
comment|// The requests and response will use buffers from ByteBufferPool, when the size of the
comment|// request/response is at least this size.
comment|// We make this to be 1/6th of the pool buffer size.
specifier|protected
specifier|final
name|int
name|minSizeForReservoirUse
decl_stmt|;
specifier|protected
specifier|volatile
name|boolean
name|allowFallbackToSimpleAuth
decl_stmt|;
comment|/**    * Used to get details for scan with a scanner_id<br/>    * TODO try to figure out a better way and remove reference from regionserver package later.    */
specifier|private
name|RSRpcServices
name|rsRpcServices
decl_stmt|;
annotation|@
name|FunctionalInterface
specifier|protected
specifier|static
interface|interface
name|CallCleanup
block|{
name|void
name|run
parameter_list|()
function_decl|;
block|}
comment|/**    * Datastructure for passing a {@link BlockingService} and its associated class of    * protobuf service interface.  For example, a server that fielded what is defined    * in the client protobuf service would pass in an implementation of the client blocking service    * and then its ClientService.BlockingInterface.class.  Used checking connection setup.    */
specifier|public
specifier|static
class|class
name|BlockingServiceAndInterface
block|{
specifier|private
specifier|final
name|BlockingService
name|service
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|serviceInterface
decl_stmt|;
specifier|public
name|BlockingServiceAndInterface
parameter_list|(
specifier|final
name|BlockingService
name|service
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|serviceInterface
parameter_list|)
block|{
name|this
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|serviceInterface
operator|=
name|serviceInterface
expr_stmt|;
block|}
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getServiceInterface
parameter_list|()
block|{
return|return
name|this
operator|.
name|serviceInterface
return|;
block|}
specifier|public
name|BlockingService
name|getBlockingService
parameter_list|()
block|{
return|return
name|this
operator|.
name|service
return|;
block|}
block|}
comment|/**    * Constructs a server listening on the named port and address.    * @param server hosting instance of {@link Server}. We will do authentications if an    * instance else pass null for no authentication check.    * @param name Used keying this rpc servers' metrics and for naming the Listener thread.    * @param services A list of services.    * @param bindAddress Where to listen    * @param conf    * @param scheduler    * @param reservoirEnabled Enable ByteBufferPool or not.    */
specifier|public
name|RpcServer
parameter_list|(
specifier|final
name|Server
name|server
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|InetSocketAddress
name|bindAddress
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|RpcScheduler
name|scheduler
parameter_list|,
name|boolean
name|reservoirEnabled
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|reservoirEnabled
condition|)
block|{
name|int
name|poolBufSize
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|ByteBufferPool
operator|.
name|BUFFER_SIZE_KEY
argument_list|,
name|ByteBufferPool
operator|.
name|DEFAULT_BUFFER_SIZE
argument_list|)
decl_stmt|;
comment|// The max number of buffers to be pooled in the ByteBufferPool. The default value been
comment|// selected based on the #handlers configured. When it is read request, 2 MB is the max size
comment|// at which we will send back one RPC request. Means max we need 2 MB for creating the
comment|// response cell block. (Well it might be much lesser than this because in 2 MB size calc, we
comment|// include the heap size overhead of each cells also.) Considering 2 MB, we will need
comment|// (2 * 1024 * 1024) / poolBufSize buffers to make the response cell block. Pool buffer size
comment|// is by default 64 KB.
comment|// In case of read request, at the end of the handler process, we will make the response
comment|// cellblock and add the Call to connection's response Q and a single Responder thread takes
comment|// connections and responses from that one by one and do the socket write. So there is chances
comment|// that by the time a handler originated response is actually done writing to socket and so
comment|// released the BBs it used, the handler might have processed one more read req. On an avg 2x
comment|// we consider and consider that also for the max buffers to pool
name|int
name|bufsForTwoMB
init|=
operator|(
literal|2
operator|*
literal|1024
operator|*
literal|1024
operator|)
operator|/
name|poolBufSize
decl_stmt|;
name|int
name|maxPoolSize
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|ByteBufferPool
operator|.
name|MAX_POOL_SIZE_KEY
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|REGION_SERVER_HANDLER_COUNT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_REGION_SERVER_HANDLER_COUNT
argument_list|)
operator|*
name|bufsForTwoMB
operator|*
literal|2
argument_list|)
decl_stmt|;
name|this
operator|.
name|reservoir
operator|=
operator|new
name|ByteBufferPool
argument_list|(
name|poolBufSize
argument_list|,
name|maxPoolSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|minSizeForReservoirUse
operator|=
name|getMinSizeForReservoirUse
argument_list|(
name|this
operator|.
name|reservoir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reservoir
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|minSizeForReservoirUse
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
comment|// reservoir itself not in place.
block|}
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
name|this
operator|.
name|services
operator|=
name|services
expr_stmt|;
name|this
operator|.
name|bindAddress
operator|=
name|bindAddress
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
comment|// See declaration above for documentation on what this size is.
name|this
operator|.
name|maxQueueSizeInBytes
operator|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.ipc.server.max.callqueue.size"
argument_list|,
name|DEFAULT_MAX_CALLQUEUE_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|warnResponseTime
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|WARN_RESPONSE_TIME
argument_list|,
name|DEFAULT_WARN_RESPONSE_TIME
argument_list|)
expr_stmt|;
name|this
operator|.
name|warnResponseSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|WARN_RESPONSE_SIZE
argument_list|,
name|DEFAULT_WARN_RESPONSE_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|minClientRequestTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|MIN_CLIENT_REQUEST_TIMEOUT
argument_list|,
name|DEFAULT_MIN_CLIENT_REQUEST_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxRequestSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|MAX_REQUEST_SIZE
argument_list|,
name|DEFAULT_MAX_REQUEST_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
operator|new
name|MetricsHBaseServer
argument_list|(
name|name
argument_list|,
operator|new
name|MetricsHBaseServerWrapperImpl
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpNoDelay
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.ipc.server.tcpnodelay"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpKeepAlive
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.ipc.server.tcpkeepalive"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|cellBlockBuilder
operator|=
operator|new
name|CellBlockBuilder
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|authorize
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HADOOP_SECURITY_AUTHORIZATION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|userProvider
operator|=
name|UserProvider
operator|.
name|instantiate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|isSecurityEnabled
operator|=
name|userProvider
operator|.
name|isHBaseSecurityEnabled
argument_list|()
expr_stmt|;
if|if
condition|(
name|isSecurityEnabled
condition|)
block|{
name|saslProps
operator|=
name|SaslUtil
operator|.
name|initSaslProperties
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.rpc.protection"
argument_list|,
name|QualityOfProtection
operator|.
name|AUTHENTICATION
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saslProps
operator|=
name|Collections
operator|.
name|emptyMap
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|scheduler
operator|=
name|scheduler
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|getMinSizeForReservoirUse
parameter_list|(
name|ByteBufferPool
name|pool
parameter_list|)
block|{
return|return
name|pool
operator|.
name|getBufferSize
argument_list|()
operator|/
literal|6
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onConfigurationChange
parameter_list|(
name|Configuration
name|newConf
parameter_list|)
block|{
name|initReconfigurable
argument_list|(
name|newConf
argument_list|)
expr_stmt|;
if|if
condition|(
name|scheduler
operator|instanceof
name|ConfigurationObserver
condition|)
block|{
operator|(
operator|(
name|ConfigurationObserver
operator|)
name|scheduler
operator|)
operator|.
name|onConfigurationChange
argument_list|(
name|newConf
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|initReconfigurable
parameter_list|(
name|Configuration
name|confToLoad
parameter_list|)
block|{
name|this
operator|.
name|allowFallbackToSimpleAuth
operator|=
name|confToLoad
operator|.
name|getBoolean
argument_list|(
name|FALLBACK_TO_INSECURE_CLIENT_AUTH
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSecurityEnabled
operator|&&
name|allowFallbackToSimpleAuth
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"********* WARNING! *********"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"This server is configured to allow connections from INSECURE clients"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"("
operator|+
name|FALLBACK_TO_INSECURE_CLIENT_AUTH
operator|+
literal|" = true)."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"While this option is enabled, client identities cannot be secured, and user"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"impersonation is possible!"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"For secure operation, please disable SIMPLE authentication as soon as possible,"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"by setting "
operator|+
name|FALLBACK_TO_INSECURE_CLIENT_AUTH
operator|+
literal|" = false in hbase-site.xml"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"****************************"
argument_list|)
expr_stmt|;
block|}
block|}
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStarted
parameter_list|()
block|{
return|return
name|this
operator|.
name|started
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|refreshAuthManager
parameter_list|(
name|PolicyProvider
name|pp
parameter_list|)
block|{
comment|// Ignore warnings that this should be accessed in a static way instead of via an instance;
comment|// it'll break if you go via static route.
synchronized|synchronized
init|(
name|authManager
init|)
block|{
name|authManager
operator|.
name|refresh
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|AuthenticationTokenSecretManager
name|createSecretManager
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|Configuration
name|conf
init|=
name|server
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|long
name|keyUpdateInterval
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.auth.key.update.interval"
argument_list|,
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
literal|1000
argument_list|)
decl_stmt|;
name|long
name|maxAge
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.auth.token.max.lifetime"
argument_list|,
literal|7
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
literal|1000
argument_list|)
decl_stmt|;
return|return
operator|new
name|AuthenticationTokenSecretManager
argument_list|(
name|conf
argument_list|,
name|server
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|keyUpdateInterval
argument_list|,
name|maxAge
argument_list|)
return|;
block|}
specifier|public
name|SecretManager
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|getSecretManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|secretManager
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|setSecretManager
parameter_list|(
name|SecretManager
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|secretManager
parameter_list|)
block|{
name|this
operator|.
name|secretManager
operator|=
operator|(
name|SecretManager
argument_list|<
name|TokenIdentifier
argument_list|>
operator|)
name|secretManager
expr_stmt|;
block|}
comment|/**    * This is a server side method, which is invoked over RPC. On success    * the return response has protobuf response payload. On failure, the    * exception name and the stack trace are returned in the protobuf response.    */
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
name|call
parameter_list|(
name|RpcCall
name|call
parameter_list|,
name|MonitoredRPCHandler
name|status
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|MethodDescriptor
name|md
init|=
name|call
operator|.
name|getMethod
argument_list|()
decl_stmt|;
name|Message
name|param
init|=
name|call
operator|.
name|getParam
argument_list|()
decl_stmt|;
name|status
operator|.
name|setRPC
argument_list|(
name|md
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|Object
index|[]
block|{
name|param
block|}
argument_list|,
name|call
operator|.
name|getReceiveTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: Review after we add in encoded data blocks.
name|status
operator|.
name|setRPCPacket
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|status
operator|.
name|resume
argument_list|(
literal|"Servicing call"
argument_list|)
expr_stmt|;
comment|//get an instance of the method arg type
name|HBaseRpcController
name|controller
init|=
operator|new
name|HBaseRpcControllerImpl
argument_list|(
name|call
operator|.
name|getCellScanner
argument_list|()
argument_list|)
decl_stmt|;
name|controller
operator|.
name|setCallTimeout
argument_list|(
name|call
operator|.
name|getTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|Message
name|result
init|=
name|call
operator|.
name|getService
argument_list|()
operator|.
name|callBlockingMethod
argument_list|(
name|md
argument_list|,
name|controller
argument_list|,
name|param
argument_list|)
decl_stmt|;
name|long
name|receiveTime
init|=
name|call
operator|.
name|getReceiveTime
argument_list|()
decl_stmt|;
name|long
name|startTime
init|=
name|call
operator|.
name|getStartTime
argument_list|()
decl_stmt|;
name|long
name|endTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|processingTime
init|=
call|(
name|int
call|)
argument_list|(
name|endTime
operator|-
name|startTime
argument_list|)
decl_stmt|;
name|int
name|qTime
init|=
call|(
name|int
call|)
argument_list|(
name|startTime
operator|-
name|receiveTime
argument_list|)
decl_stmt|;
name|int
name|totalTime
init|=
call|(
name|int
call|)
argument_list|(
name|endTime
operator|-
name|receiveTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|CurCall
operator|.
name|get
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|", response "
operator|+
name|TextFormat
operator|.
name|shortDebugString
argument_list|(
name|result
argument_list|)
operator|+
literal|" queueTime: "
operator|+
name|qTime
operator|+
literal|" processingTime: "
operator|+
name|processingTime
operator|+
literal|" totalTime: "
operator|+
name|totalTime
argument_list|)
expr_stmt|;
block|}
comment|// Use the raw request call size for now.
name|long
name|requestSize
init|=
name|call
operator|.
name|getSize
argument_list|()
decl_stmt|;
name|long
name|responseSize
init|=
name|result
operator|.
name|getSerializedSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|isClientCellBlockSupported
argument_list|()
condition|)
block|{
comment|// Include the payload size in HBaseRpcController
name|responseSize
operator|+=
name|call
operator|.
name|getResponseCellSize
argument_list|()
expr_stmt|;
block|}
name|metrics
operator|.
name|dequeuedCall
argument_list|(
name|qTime
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|processedCall
argument_list|(
name|processingTime
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|totalCall
argument_list|(
name|totalTime
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|receivedRequest
argument_list|(
name|requestSize
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|sentResponse
argument_list|(
name|responseSize
argument_list|)
expr_stmt|;
comment|// log any RPC responses that are slower than the configured warn
comment|// response time or larger than configured warning size
name|boolean
name|tooSlow
init|=
operator|(
name|processingTime
operator|>
name|warnResponseTime
operator|&&
name|warnResponseTime
operator|>
operator|-
literal|1
operator|)
decl_stmt|;
name|boolean
name|tooLarge
init|=
operator|(
name|responseSize
operator|>
name|warnResponseSize
operator|&&
name|warnResponseSize
operator|>
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|tooSlow
operator|||
name|tooLarge
condition|)
block|{
comment|// when tagging, we let TooLarge trump TooSmall to keep output simple
comment|// note that large responses will often also be slow.
name|logResponse
argument_list|(
name|param
argument_list|,
name|md
operator|.
name|getName
argument_list|()
argument_list|,
name|md
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
name|param
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")"
argument_list|,
operator|(
name|tooLarge
condition|?
literal|"TooLarge"
else|:
literal|"TooSlow"
operator|)
argument_list|,
name|status
operator|.
name|getClient
argument_list|()
argument_list|,
name|startTime
argument_list|,
name|processingTime
argument_list|,
name|qTime
argument_list|,
name|responseSize
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Pair
argument_list|<>
argument_list|(
name|result
argument_list|,
name|controller
operator|.
name|cellScanner
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// The above callBlockingMethod will always return a SE.  Strip the SE wrapper before
comment|// putting it on the wire.  Its needed to adhere to the pb Service Interface but we don't
comment|// need to pass it over the wire.
if|if
condition|(
name|e
operator|instanceof
name|ServiceException
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Caught a ServiceException with null cause"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|e
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
block|}
comment|// increment the number of requests that were exceptions.
name|metrics
operator|.
name|exception
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|LinkageError
condition|)
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
name|e
argument_list|)
throw|;
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
throw|throw
operator|(
name|IOException
operator|)
name|e
throw|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected throwable object "
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Logs an RPC response to the LOG file, producing valid JSON objects for    * client Operations.    * @param param The parameters received in the call.    * @param methodName The name of the method invoked    * @param call The string representation of the call    * @param tag  The tag that will be used to indicate this event in the log.    * @param clientAddress   The address of the client who made this call.    * @param startTime       The time that the call was initiated, in ms.    * @param processingTime  The duration that the call took to run, in ms.    * @param qTime           The duration that the call spent on the queue    *                        prior to being initiated, in ms.    * @param responseSize    The size in bytes of the response buffer.    */
name|void
name|logResponse
parameter_list|(
name|Message
name|param
parameter_list|,
name|String
name|methodName
parameter_list|,
name|String
name|call
parameter_list|,
name|String
name|tag
parameter_list|,
name|String
name|clientAddress
parameter_list|,
name|long
name|startTime
parameter_list|,
name|int
name|processingTime
parameter_list|,
name|int
name|qTime
parameter_list|,
name|long
name|responseSize
parameter_list|)
throws|throws
name|IOException
block|{
comment|// base information that is reported regardless of type of call
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|responseInfo
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"starttimems"
argument_list|,
name|startTime
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"processingtimems"
argument_list|,
name|processingTime
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"queuetimems"
argument_list|,
name|qTime
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"responsesize"
argument_list|,
name|responseSize
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"client"
argument_list|,
name|clientAddress
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"class"
argument_list|,
name|server
operator|==
literal|null
condition|?
literal|""
else|:
name|server
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"method"
argument_list|,
name|methodName
argument_list|)
expr_stmt|;
name|responseInfo
operator|.
name|put
argument_list|(
literal|"call"
argument_list|,
name|call
argument_list|)
expr_stmt|;
comment|// The params could be really big, make sure they don't kill us at WARN
name|String
name|stringifiedParam
init|=
name|ProtobufUtil
operator|.
name|getShortTextFormat
argument_list|(
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
name|stringifiedParam
operator|.
name|length
argument_list|()
operator|>
literal|150
condition|)
block|{
comment|// Truncate to 1000 chars if TRACE is on, else to 150 chars
name|stringifiedParam
operator|=
name|stringifiedParam
operator|.
name|subSequence
argument_list|(
literal|0
argument_list|,
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|?
literal|1000
else|:
literal|150
argument_list|)
operator|+
literal|"<TRUNCATED>"
expr_stmt|;
block|}
name|responseInfo
operator|.
name|put
argument_list|(
literal|"param"
argument_list|,
name|stringifiedParam
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|instanceof
name|ClientProtos
operator|.
name|ScanRequest
operator|&&
name|rsRpcServices
operator|!=
literal|null
condition|)
block|{
name|ClientProtos
operator|.
name|ScanRequest
name|request
init|=
operator|(
operator|(
name|ClientProtos
operator|.
name|ScanRequest
operator|)
name|param
operator|)
decl_stmt|;
if|if
condition|(
name|request
operator|.
name|hasScannerId
argument_list|()
condition|)
block|{
name|long
name|scannerId
init|=
name|request
operator|.
name|getScannerId
argument_list|()
decl_stmt|;
name|String
name|scanDetails
init|=
name|rsRpcServices
operator|.
name|getScanDetailsWithId
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|scanDetails
operator|!=
literal|null
condition|)
block|{
name|responseInfo
operator|.
name|put
argument_list|(
literal|"scandetails"
argument_list|,
name|scanDetails
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"(response"
operator|+
name|tag
operator|+
literal|"): "
operator|+
name|MAPPER
operator|.
name|writeValueAsString
argument_list|(
name|responseInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the handler for calling out of RPC for error conditions.    * @param handler the handler implementation    */
annotation|@
name|Override
specifier|public
name|void
name|setErrorHandler
parameter_list|(
name|HBaseRPCErrorHandler
name|handler
parameter_list|)
block|{
name|this
operator|.
name|errorHandler
operator|=
name|handler
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|HBaseRPCErrorHandler
name|getErrorHandler
parameter_list|()
block|{
return|return
name|this
operator|.
name|errorHandler
return|;
block|}
comment|/**    * Returns the metrics instance for reporting RPC call statistics    */
annotation|@
name|Override
specifier|public
name|MetricsHBaseServer
name|getMetrics
parameter_list|()
block|{
return|return
name|metrics
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addCallSize
parameter_list|(
specifier|final
name|long
name|diff
parameter_list|)
block|{
name|this
operator|.
name|callQueueSizeInBytes
operator|.
name|add
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/**    * Authorize the incoming client connection.    * @param user client user    * @param connection incoming connection    * @param addr InetAddress of incoming connection    * @throws AuthorizationException when the client isn't authorized to talk the protocol    */
specifier|public
name|void
name|authorize
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|,
name|ConnectionHeader
name|connection
parameter_list|,
name|InetAddress
name|addr
parameter_list|)
throws|throws
name|AuthorizationException
block|{
if|if
condition|(
name|authorize
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|c
init|=
name|getServiceInterface
argument_list|(
name|services
argument_list|,
name|connection
operator|.
name|getServiceName
argument_list|()
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|authManager
init|)
block|{
name|authManager
operator|.
name|authorize
argument_list|(
name|user
argument_list|,
name|c
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * When the read or write buffer size is larger than this limit, i/o will be    * done in chunks of this size. Most RPC requests and responses would be    * be smaller.    */
specifier|protected
specifier|static
specifier|final
name|int
name|NIO_BUFFER_LIMIT
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
comment|//should not be more than 64KB.
comment|/**    * This is a wrapper around {@link java.nio.channels.ReadableByteChannel#read(java.nio.ByteBuffer)}.    * If the amount of data is large, it writes to channel in smaller chunks.    * This is to avoid jdk from creating many direct buffers as the size of    * ByteBuffer increases. There should not be any performance degredation.    *    * @param channel writable byte channel to write on    * @param buffer buffer to write    * @return number of bytes written    * @throws java.io.IOException e    * @see java.nio.channels.ReadableByteChannel#read(java.nio.ByteBuffer)    */
specifier|protected
name|int
name|channelRead
parameter_list|(
name|ReadableByteChannel
name|channel
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|count
init|=
operator|(
name|buffer
operator|.
name|remaining
argument_list|()
operator|<=
name|NIO_BUFFER_LIMIT
operator|)
condition|?
name|channel
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
else|:
name|channelIO
argument_list|(
name|channel
argument_list|,
literal|null
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|metrics
operator|.
name|receivedBytes
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * Helper for {@link #channelRead(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)}.    * Only one of readCh or writeCh should be non-null.    *    * @param readCh read channel    * @param writeCh write channel    * @param buf buffer to read or write into/out of    * @return bytes written    * @throws java.io.IOException e    * @see #channelRead(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)    */
specifier|private
specifier|static
name|int
name|channelIO
parameter_list|(
name|ReadableByteChannel
name|readCh
parameter_list|,
name|WritableByteChannel
name|writeCh
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|originalLimit
init|=
name|buf
operator|.
name|limit
argument_list|()
decl_stmt|;
name|int
name|initialRemaining
init|=
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|int
name|ioSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|buf
operator|.
name|remaining
argument_list|()
argument_list|,
name|NIO_BUFFER_LIMIT
argument_list|)
decl_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|position
argument_list|()
operator|+
name|ioSize
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|readCh
operator|==
literal|null
operator|)
condition|?
name|writeCh
operator|.
name|write
argument_list|(
name|buf
argument_list|)
else|:
name|readCh
operator|.
name|read
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
name|ioSize
condition|)
block|{
break|break;
block|}
block|}
finally|finally
block|{
name|buf
operator|.
name|limit
argument_list|(
name|originalLimit
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|nBytes
init|=
name|initialRemaining
operator|-
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
return|return
operator|(
name|nBytes
operator|>
literal|0
operator|)
condition|?
name|nBytes
else|:
name|ret
return|;
block|}
comment|/**    * This is extracted to a static method for better unit testing. We try to get buffer(s) from pool    * as much as possible.    *    * @param pool The ByteBufferPool to use    * @param minSizeForPoolUse Only for buffer size above this, we will try to use pool. Any buffer    *           need of size below this, create on heap ByteBuffer.    * @param reqLen Bytes count in request    */
annotation|@
name|VisibleForTesting
specifier|static
name|Pair
argument_list|<
name|ByteBuff
argument_list|,
name|CallCleanup
argument_list|>
name|allocateByteBuffToReadInto
parameter_list|(
name|ByteBufferPool
name|pool
parameter_list|,
name|int
name|minSizeForPoolUse
parameter_list|,
name|int
name|reqLen
parameter_list|)
block|{
name|ByteBuff
name|resultBuf
decl_stmt|;
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|bbs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
operator|(
name|reqLen
operator|/
name|pool
operator|.
name|getBufferSize
argument_list|()
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|remain
init|=
name|reqLen
decl_stmt|;
name|ByteBuffer
name|buf
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|remain
operator|>=
name|minSizeForPoolUse
operator|&&
operator|(
name|buf
operator|=
name|pool
operator|.
name|getBuffer
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|bbs
operator|.
name|add
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|remain
operator|-=
name|pool
operator|.
name|getBufferSize
argument_list|()
expr_stmt|;
block|}
name|ByteBuffer
index|[]
name|bufsFromPool
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|bbs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|bufsFromPool
operator|=
operator|new
name|ByteBuffer
index|[
name|bbs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|bbs
operator|.
name|toArray
argument_list|(
name|bufsFromPool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remain
operator|>
literal|0
condition|)
block|{
name|bbs
operator|.
name|add
argument_list|(
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|remain
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bbs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ByteBuffer
index|[]
name|items
init|=
operator|new
name|ByteBuffer
index|[
name|bbs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|bbs
operator|.
name|toArray
argument_list|(
name|items
argument_list|)
expr_stmt|;
name|resultBuf
operator|=
operator|new
name|MultiByteBuff
argument_list|(
name|items
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We are backed by single BB
name|resultBuf
operator|=
operator|new
name|SingleByteBuff
argument_list|(
name|bbs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|resultBuf
operator|.
name|limit
argument_list|(
name|reqLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufsFromPool
operator|!=
literal|null
condition|)
block|{
specifier|final
name|ByteBuffer
index|[]
name|bufsFromPoolFinal
init|=
name|bufsFromPool
decl_stmt|;
return|return
operator|new
name|Pair
argument_list|<>
argument_list|(
name|resultBuf
argument_list|,
parameter_list|()
lambda|->
block|{
comment|// Return back all the BBs to pool
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bufsFromPoolFinal
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|pool
operator|.
name|putbackBuffer
argument_list|(
name|bufsFromPoolFinal
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
return|return
operator|new
name|Pair
argument_list|<>
argument_list|(
name|resultBuf
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Needed for features such as delayed calls.  We need to be able to store the current call    * so that we can complete it later or ask questions of what is supported by the current ongoing    * call.    * @return An RpcCallContext backed by the currently ongoing call (gotten from a thread local)    */
specifier|public
specifier|static
name|Optional
argument_list|<
name|RpcCall
argument_list|>
name|getCurrentCall
parameter_list|()
block|{
return|return
name|Optional
operator|.
name|ofNullable
argument_list|(
name|CurCall
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isInRpcCallContext
parameter_list|()
block|{
return|return
name|CurCall
operator|.
name|get
argument_list|()
operator|!=
literal|null
return|;
block|}
comment|/**    * Returns the user credentials associated with the current RPC request or not present if no    * credentials were provided.    * @return A User    */
specifier|public
specifier|static
name|Optional
argument_list|<
name|User
argument_list|>
name|getRequestUser
parameter_list|()
block|{
name|Optional
argument_list|<
name|RpcCall
argument_list|>
name|ctx
init|=
name|getCurrentCall
argument_list|()
decl_stmt|;
return|return
name|ctx
operator|.
name|isPresent
argument_list|()
condition|?
name|ctx
operator|.
name|get
argument_list|()
operator|.
name|getRequestUser
argument_list|()
else|:
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/**    * The number of open RPC conections    * @return the number of open rpc connections    */
specifier|abstract
specifier|public
name|int
name|getNumOpenConnections
parameter_list|()
function_decl|;
comment|/**    * Returns the username for any user associated with the current RPC    * request or not present if no user is set.    */
specifier|public
specifier|static
name|Optional
argument_list|<
name|String
argument_list|>
name|getRequestUserName
parameter_list|()
block|{
return|return
name|getRequestUser
argument_list|()
operator|.
name|map
argument_list|(
name|User
operator|::
name|getShortName
argument_list|)
return|;
block|}
comment|/**    * @return Address of remote client if a request is ongoing, else null    */
specifier|public
specifier|static
name|Optional
argument_list|<
name|InetAddress
argument_list|>
name|getRemoteAddress
parameter_list|()
block|{
return|return
name|getCurrentCall
argument_list|()
operator|.
name|map
argument_list|(
name|RpcCall
operator|::
name|getRemoteAddress
argument_list|)
return|;
block|}
comment|/**    * @param serviceName Some arbitrary string that represents a 'service'.    * @param services Available service instances    * @return Matching BlockingServiceAndInterface pair    */
specifier|protected
specifier|static
name|BlockingServiceAndInterface
name|getServiceAndInterface
parameter_list|(
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|String
name|serviceName
parameter_list|)
block|{
for|for
control|(
name|BlockingServiceAndInterface
name|bs
range|:
name|services
control|)
block|{
if|if
condition|(
name|bs
operator|.
name|getBlockingService
argument_list|()
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|serviceName
argument_list|)
condition|)
block|{
return|return
name|bs
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @param serviceName Some arbitrary string that represents a 'service'.    * @param services Available services and their service interfaces.    * @return Service interface class for<code>serviceName</code>    */
specifier|protected
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|getServiceInterface
parameter_list|(
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|String
name|serviceName
parameter_list|)
block|{
name|BlockingServiceAndInterface
name|bsasi
init|=
name|getServiceAndInterface
argument_list|(
name|services
argument_list|,
name|serviceName
argument_list|)
decl_stmt|;
return|return
name|bsasi
operator|==
literal|null
condition|?
literal|null
else|:
name|bsasi
operator|.
name|getServiceInterface
argument_list|()
return|;
block|}
comment|/**    * @param serviceName Some arbitrary string that represents a 'service'.    * @param services Available services and their service interfaces.    * @return BlockingService that goes with the passed<code>serviceName</code>    */
specifier|protected
specifier|static
name|BlockingService
name|getService
parameter_list|(
specifier|final
name|List
argument_list|<
name|BlockingServiceAndInterface
argument_list|>
name|services
parameter_list|,
specifier|final
name|String
name|serviceName
parameter_list|)
block|{
name|BlockingServiceAndInterface
name|bsasi
init|=
name|getServiceAndInterface
argument_list|(
name|services
argument_list|,
name|serviceName
argument_list|)
decl_stmt|;
return|return
name|bsasi
operator|==
literal|null
condition|?
literal|null
else|:
name|bsasi
operator|.
name|getBlockingService
argument_list|()
return|;
block|}
specifier|protected
specifier|static
name|MonitoredRPCHandler
name|getStatus
parameter_list|()
block|{
comment|// It is ugly the way we park status up in RpcServer.  Let it be for now.  TODO.
name|MonitoredRPCHandler
name|status
init|=
name|RpcServer
operator|.
name|MONITORED_RPC
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|null
condition|)
block|{
return|return
name|status
return|;
block|}
name|status
operator|=
name|TaskMonitor
operator|.
name|get
argument_list|()
operator|.
name|createRPCStatus
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|pause
argument_list|(
literal|"Waiting for a call"
argument_list|)
expr_stmt|;
name|RpcServer
operator|.
name|MONITORED_RPC
operator|.
name|set
argument_list|(
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/** Returns the remote side ip address when invoked inside an RPC    *  Returns null incase of an error.    *  @return InetAddress    */
specifier|public
specifier|static
name|InetAddress
name|getRemoteIp
parameter_list|()
block|{
name|RpcCall
name|call
init|=
name|CurCall
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
return|return
name|call
operator|.
name|getRemoteAddress
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|RpcScheduler
name|getScheduler
parameter_list|()
block|{
return|return
name|scheduler
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setRsRpcServices
parameter_list|(
name|RSRpcServices
name|rsRpcServices
parameter_list|)
block|{
name|this
operator|.
name|rsRpcServices
operator|=
name|rsRpcServices
expr_stmt|;
block|}
block|}
end_class

end_unit

