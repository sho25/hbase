begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_comment
comment|/**  * Utility class that can be used to implement  * queues with limited capacity (in terms of memory).  * It maintains internal counter and provides  * two operations: increase and decrease.  * Increase blocks until internal counter is lower than  * given threshold and then increases internal counter.  * Decrease decreases internal counter and wakes up  * waiting threads if counter is lower than threshold.  *  * This implementation allows you to set the value of internal  * counter to be greater than threshold. It happens  * when internal counter is lower than threshold and  * increase method is called with parameter 'delta' big enough  * so that sum of delta and internal counter is greater than  * threshold. This is not a bug, this is a feature.  * It solves some problems:  *   - thread calling increase with big parameter will not be  *     starved by other threads calling increase with small  *     arguments.  *   - thread calling increase with argument greater than  *     threshold won't deadlock. This is useful when throttling  *     queues - you can submit object that is bigger than limit.  *  * This implementation introduces small costs in terms of  * synchronization (no synchronization in most cases at all), but is  * vulnerable to races. For details see documentation of  * increase method.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|SizeBasedThrottler
block|{
specifier|private
specifier|final
name|long
name|threshold
decl_stmt|;
specifier|private
specifier|final
name|AtomicLong
name|currentSize
decl_stmt|;
comment|/**    * Creates SizeBoundary with provided threshold    *    * @param threshold threshold used by instance    */
specifier|public
name|SizeBasedThrottler
parameter_list|(
name|long
name|threshold
parameter_list|)
block|{
if|if
condition|(
name|threshold
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Treshold must be greater than 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
name|this
operator|.
name|currentSize
operator|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Blocks until internal counter is lower than threshold    * and then increases value of internal counter.    *    * THIS METHOD IS VULNERABLE TO RACES.    * It may happen that increment operation will    * succeed immediately, even if it should block. This happens when    * at least two threads call increase at the some moment. The decision    * whether to block is made at the beginning, without synchronization.    * If value of currentSize is lower than threshold at that time, call    * will succeed immediately. It is possible, that 2 threads will make    * decision not to block, even if one of them should block.    *    * @param delta increase internal counter by this value    * @return new value of internal counter    * @throws InterruptedException when interrupted during waiting    */
specifier|public
specifier|synchronized
name|long
name|increase
parameter_list|(
name|long
name|delta
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|currentSize
operator|.
name|get
argument_list|()
operator|>=
name|threshold
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
while|while
condition|(
name|currentSize
operator|.
name|get
argument_list|()
operator|>=
name|threshold
condition|)
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|currentSize
operator|.
name|addAndGet
argument_list|(
name|delta
argument_list|)
return|;
block|}
comment|/**    * Decreases value of internal counter. Wakes up waiting threads if required.    *    * @param delta decrease internal counter by this value    * @return new value of internal counter    */
specifier|public
specifier|synchronized
name|long
name|decrease
parameter_list|(
name|long
name|delta
parameter_list|)
block|{
specifier|final
name|long
name|newSize
init|=
name|currentSize
operator|.
name|addAndGet
argument_list|(
operator|-
name|delta
argument_list|)
decl_stmt|;
if|if
condition|(
name|newSize
operator|<
name|threshold
operator|&&
name|newSize
operator|+
name|delta
operator|>=
name|threshold
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|newSize
return|;
block|}
comment|/**    *    * @return current value of internal counter    */
specifier|public
specifier|synchronized
name|long
name|getCurrentValue
parameter_list|()
block|{
return|return
name|currentSize
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * @return threshold    */
specifier|public
name|long
name|getThreshold
parameter_list|()
block|{
return|return
name|threshold
return|;
block|}
block|}
end_class

end_unit

