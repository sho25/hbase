begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|backup
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonGenerationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|JsonMappingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|ObjectMapper
import|;
end_import

begin_comment
comment|/**  * Backup manifest Contains all the meta data of a backup image. The manifest info will be bundled  * as manifest file together with data. So that each backup image will contain all the info needed  * for restore.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|BackupManifest
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BackupManifest
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// manifest file name
specifier|public
specifier|static
specifier|final
name|String
name|FILE_NAME
init|=
literal|".backup.manifest"
decl_stmt|;
comment|// manifest file version, current is 1.0
specifier|public
specifier|static
specifier|final
name|String
name|MANIFEST_VERSION
init|=
literal|"1.0"
decl_stmt|;
comment|// tags of fields for manifest file
specifier|public
specifier|static
specifier|final
name|String
name|TAG_VERSION
init|=
literal|"Manifest-Version"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG_BACKUPID
init|=
literal|"Backup-Id"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG_BACKUPTYPE
init|=
literal|"Backup-Type"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG_TABLESET
init|=
literal|"Table-Set"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG_STARTTS
init|=
literal|"Start-Timestamp"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG_COMPLETETS
init|=
literal|"Complete-Timestamp"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG_TABLEBYTES
init|=
literal|"Total-Table-Bytes"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG_LOGBYTES
init|=
literal|"Total-Log-Bytes"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG_INCRTIMERANGE
init|=
literal|"Incremental-Time-Range"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG_DEPENDENCY
init|=
literal|"Dependency"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG_IMAGESTATE
init|=
literal|"Image-State"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG_COMPACTION
init|=
literal|"Compaction"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ERROR_DEPENDENCY
init|=
literal|"DEPENDENCY_ERROR"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DELETE_SUCCESS
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DELETE_FAILED
init|=
operator|-
literal|1
decl_stmt|;
comment|// currently only one state, will have CONVERTED, and MERGED in future JIRA
specifier|public
specifier|static
specifier|final
name|String
name|IMAGE_STATE_ORIG
init|=
literal|"ORIGINAL"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|IMAGE_STATE_CONVERT
init|=
literal|"CONVERTED"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|IMAGE_STATE_MERGE
init|=
literal|"MERGED"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|IMAGE_STATE_CONVERT_MERGE
init|=
literal|"CONVERTED,MERGED"
decl_stmt|;
comment|// backup image, the dependency graph is made up by series of backup images
specifier|public
specifier|static
class|class
name|BackupImage
implements|implements
name|Comparable
argument_list|<
name|BackupImage
argument_list|>
block|{
specifier|private
name|String
name|backupId
decl_stmt|;
specifier|private
name|String
name|type
decl_stmt|;
specifier|private
name|String
name|rootDir
decl_stmt|;
specifier|private
name|String
name|tableSet
decl_stmt|;
specifier|private
name|long
name|startTs
decl_stmt|;
specifier|private
name|long
name|completeTs
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
name|ancestors
decl_stmt|;
specifier|public
name|BackupImage
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|BackupImage
parameter_list|(
name|String
name|backupId
parameter_list|,
name|String
name|type
parameter_list|,
name|String
name|rootDir
parameter_list|,
name|String
name|tableSet
parameter_list|,
name|long
name|startTs
parameter_list|,
name|long
name|completeTs
parameter_list|)
block|{
name|this
operator|.
name|backupId
operator|=
name|backupId
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|rootDir
operator|=
name|rootDir
expr_stmt|;
name|this
operator|.
name|tableSet
operator|=
name|tableSet
expr_stmt|;
name|this
operator|.
name|startTs
operator|=
name|startTs
expr_stmt|;
name|this
operator|.
name|completeTs
operator|=
name|completeTs
expr_stmt|;
block|}
specifier|public
name|String
name|getBackupId
parameter_list|()
block|{
return|return
name|backupId
return|;
block|}
specifier|public
name|void
name|setBackupId
parameter_list|(
name|String
name|backupId
parameter_list|)
block|{
name|this
operator|.
name|backupId
operator|=
name|backupId
expr_stmt|;
block|}
specifier|public
name|String
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
specifier|public
name|void
name|setType
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
specifier|public
name|String
name|getRootDir
parameter_list|()
block|{
return|return
name|rootDir
return|;
block|}
specifier|public
name|void
name|setRootDir
parameter_list|(
name|String
name|rootDir
parameter_list|)
block|{
name|this
operator|.
name|rootDir
operator|=
name|rootDir
expr_stmt|;
block|}
specifier|public
name|String
name|getTableSet
parameter_list|()
block|{
return|return
name|tableSet
return|;
block|}
specifier|public
name|void
name|setTableSet
parameter_list|(
name|String
name|tableSet
parameter_list|)
block|{
name|this
operator|.
name|tableSet
operator|=
name|tableSet
expr_stmt|;
block|}
specifier|public
name|long
name|getStartTs
parameter_list|()
block|{
return|return
name|startTs
return|;
block|}
specifier|public
name|void
name|setStartTs
parameter_list|(
name|long
name|startTs
parameter_list|)
block|{
name|this
operator|.
name|startTs
operator|=
name|startTs
expr_stmt|;
block|}
specifier|public
name|long
name|getCompleteTs
parameter_list|()
block|{
return|return
name|completeTs
return|;
block|}
specifier|public
name|void
name|setCompleteTs
parameter_list|(
name|long
name|completeTs
parameter_list|)
block|{
name|this
operator|.
name|completeTs
operator|=
name|completeTs
expr_stmt|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
name|getAncestors
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|ancestors
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|ancestors
operator|=
operator|new
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
argument_list|()
expr_stmt|;
block|}
return|return
name|this
operator|.
name|ancestors
return|;
block|}
specifier|public
name|void
name|addAncestor
parameter_list|(
name|BackupImage
name|backupImage
parameter_list|)
block|{
name|this
operator|.
name|getAncestors
argument_list|()
operator|.
name|add
argument_list|(
name|backupImage
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasAncestor
parameter_list|(
name|String
name|token
parameter_list|)
block|{
for|for
control|(
name|BackupImage
name|image
range|:
name|this
operator|.
name|getAncestors
argument_list|()
control|)
block|{
if|if
condition|(
name|image
operator|.
name|getBackupId
argument_list|()
operator|.
name|equals
argument_list|(
name|token
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|hasTable
parameter_list|(
name|String
name|table
parameter_list|)
block|{
name|String
index|[]
name|tables
init|=
name|this
operator|.
name|getTableSet
argument_list|()
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|t
range|:
name|tables
control|)
block|{
if|if
condition|(
name|t
operator|.
name|equals
argument_list|(
name|table
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|BackupImage
name|other
parameter_list|)
block|{
name|String
name|thisBackupId
init|=
name|this
operator|.
name|getBackupId
argument_list|()
decl_stmt|;
name|String
name|otherBackupId
init|=
name|other
operator|.
name|getBackupId
argument_list|()
decl_stmt|;
name|Long
name|thisTS
init|=
operator|new
name|Long
argument_list|(
name|thisBackupId
operator|.
name|substring
argument_list|(
name|thisBackupId
operator|.
name|lastIndexOf
argument_list|(
literal|"_"
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|Long
name|otherTS
init|=
operator|new
name|Long
argument_list|(
name|otherBackupId
operator|.
name|substring
argument_list|(
name|otherBackupId
operator|.
name|lastIndexOf
argument_list|(
literal|"_"
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|thisTS
operator|.
name|compareTo
argument_list|(
name|otherTS
argument_list|)
return|;
block|}
block|}
comment|// manifest version
specifier|private
name|String
name|version
init|=
name|MANIFEST_VERSION
decl_stmt|;
comment|// hadoop hbase configuration
specifier|protected
name|Configuration
name|config
init|=
literal|null
decl_stmt|;
comment|// backup root directory
specifier|private
name|String
name|rootDir
init|=
literal|null
decl_stmt|;
comment|// backup image directory
specifier|private
name|String
name|tableBackupDir
init|=
literal|null
decl_stmt|;
comment|// backup log directory if this is an incremental backup
specifier|private
name|String
name|logBackupDir
init|=
literal|null
decl_stmt|;
comment|// backup token
specifier|private
name|String
name|token
decl_stmt|;
comment|// backup type, full or incremental
specifier|private
name|String
name|type
decl_stmt|;
comment|// the table set for the backup
specifier|private
name|ArrayList
argument_list|<
name|String
argument_list|>
name|tableSet
decl_stmt|;
comment|// actual start timestamp of the backup process
specifier|private
name|long
name|startTs
decl_stmt|;
comment|// actual complete timestamp of the backup process
specifier|private
name|long
name|completeTs
decl_stmt|;
comment|// total bytes for table backup image
specifier|private
name|long
name|tableBytes
decl_stmt|;
comment|// total bytes for the backed-up logs for incremental backup
specifier|private
name|long
name|logBytes
decl_stmt|;
comment|// the region server timestamp for tables:
comment|//<table,<rs, timestamp>>
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|incrTimeRanges
decl_stmt|;
comment|// dependency of this backup, including all the dependent images to do PIT recovery
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|BackupImage
argument_list|>
name|dependency
decl_stmt|;
comment|// the state of backup image
specifier|private
name|String
name|imageState
decl_stmt|;
comment|// the indicator of the image compaction
specifier|private
name|boolean
name|isCompacted
init|=
literal|false
decl_stmt|;
comment|// the merge chain of the original backups, null if not a merged backup
specifier|private
name|LinkedList
argument_list|<
name|String
argument_list|>
name|mergeChain
decl_stmt|;
comment|/**    * Construct manifest for a ongoing backup.    * @param backupCtx The ongoing backup context    */
specifier|public
name|BackupManifest
parameter_list|(
name|BackupContext
name|backupCtx
parameter_list|)
block|{
name|this
operator|.
name|token
operator|=
name|backupCtx
operator|.
name|getBackupId
argument_list|()
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|backupCtx
operator|.
name|getType
argument_list|()
expr_stmt|;
name|this
operator|.
name|rootDir
operator|=
name|backupCtx
operator|.
name|getTargetRootDir
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|type
operator|.
name|equals
argument_list|(
name|BackupRestoreConstants
operator|.
name|BACKUP_TYPE_INCR
argument_list|)
condition|)
block|{
name|this
operator|.
name|logBackupDir
operator|=
name|backupCtx
operator|.
name|getHLogTargetDir
argument_list|()
expr_stmt|;
name|this
operator|.
name|logBytes
operator|=
name|backupCtx
operator|.
name|getTotalBytesCopied
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|startTs
operator|=
name|backupCtx
operator|.
name|getStartTs
argument_list|()
expr_stmt|;
name|this
operator|.
name|completeTs
operator|=
name|backupCtx
operator|.
name|getEndTs
argument_list|()
expr_stmt|;
name|this
operator|.
name|loadTableSet
argument_list|(
name|backupCtx
operator|.
name|getTableListAsString
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|setImageOriginal
argument_list|()
expr_stmt|;
block|}
comment|/**    * Construct a table level manifest for a backup of the named table.    * @param backupCtx The ongoing backup context    */
specifier|public
name|BackupManifest
parameter_list|(
name|BackupContext
name|backupCtx
parameter_list|,
name|String
name|table
parameter_list|)
block|{
name|this
operator|.
name|token
operator|=
name|backupCtx
operator|.
name|getBackupId
argument_list|()
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|backupCtx
operator|.
name|getType
argument_list|()
expr_stmt|;
name|this
operator|.
name|rootDir
operator|=
name|backupCtx
operator|.
name|getTargetRootDir
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableBackupDir
operator|=
name|backupCtx
operator|.
name|getBackupStatus
argument_list|(
name|table
argument_list|)
operator|.
name|getTargetDir
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|type
operator|.
name|equals
argument_list|(
name|BackupRestoreConstants
operator|.
name|BACKUP_TYPE_INCR
argument_list|)
condition|)
block|{
name|this
operator|.
name|logBackupDir
operator|=
name|backupCtx
operator|.
name|getHLogTargetDir
argument_list|()
expr_stmt|;
name|this
operator|.
name|logBytes
operator|=
name|backupCtx
operator|.
name|getTotalBytesCopied
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|startTs
operator|=
name|backupCtx
operator|.
name|getStartTs
argument_list|()
expr_stmt|;
name|this
operator|.
name|completeTs
operator|=
name|backupCtx
operator|.
name|getEndTs
argument_list|()
expr_stmt|;
name|this
operator|.
name|loadTableSet
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|this
operator|.
name|setImageOriginal
argument_list|()
expr_stmt|;
block|}
comment|/**    * Construct manifest from a backup directory.    * @param conf configuration    * @param backupPath backup path    * @throws BackupException exception    */
specifier|public
name|BackupManifest
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Path
name|backupPath
parameter_list|)
throws|throws
name|BackupException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loading manifest from: "
operator|+
name|backupPath
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// The input backupDir may not exactly be the backup table dir.
comment|// It could be the backup log dir where there is also a manifest file stored.
comment|// This variable's purpose is to keep the correct and original location so
comment|// that we can store/persist it.
name|this
operator|.
name|tableBackupDir
operator|=
name|backupPath
operator|.
name|toString
argument_list|()
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|conf
expr_stmt|;
try|try
block|{
name|FileSystem
name|fs
init|=
name|backupPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|subFiles
init|=
name|FSUtils
operator|.
name|listStatus
argument_list|(
name|fs
argument_list|,
name|backupPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|subFiles
operator|==
literal|null
condition|)
block|{
name|String
name|errorMsg
init|=
name|backupPath
operator|.
name|toString
argument_list|()
operator|+
literal|" does not exist"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|errorMsg
argument_list|)
throw|;
block|}
for|for
control|(
name|FileStatus
name|subFile
range|:
name|subFiles
control|)
block|{
if|if
condition|(
name|subFile
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|FILE_NAME
argument_list|)
condition|)
block|{
comment|// load and set manifest field from file content
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|subFile
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
try|try
block|{
name|props
operator|.
name|load
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error when loading from manifest file!"
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|version
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|TAG_VERSION
argument_list|)
expr_stmt|;
name|this
operator|.
name|token
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|TAG_BACKUPID
argument_list|)
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|TAG_BACKUPTYPE
argument_list|)
expr_stmt|;
comment|// Here the parameter backupDir is where the manifest file is.
comment|// There should always be a manifest file under:
comment|// backupRootDir/namespace/table/backupId/.backup.manifest
name|this
operator|.
name|rootDir
operator|=
name|backupPath
operator|.
name|getParent
argument_list|()
operator|.
name|getParent
argument_list|()
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|Path
name|p
init|=
name|backupPath
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|HConstants
operator|.
name|HREGION_LOGDIR_NAME
argument_list|)
condition|)
block|{
name|this
operator|.
name|rootDir
operator|=
name|p
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|rootDir
operator|=
name|p
operator|.
name|getParent
argument_list|()
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|loadTableSet
argument_list|(
name|props
operator|.
name|getProperty
argument_list|(
name|TAG_TABLESET
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|startTs
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|props
operator|.
name|getProperty
argument_list|(
name|TAG_STARTTS
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|completeTs
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|props
operator|.
name|getProperty
argument_list|(
name|TAG_COMPLETETS
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableBytes
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|props
operator|.
name|getProperty
argument_list|(
name|TAG_TABLEBYTES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|type
operator|.
name|equals
argument_list|(
name|BackupRestoreConstants
operator|.
name|BACKUP_TYPE_INCR
argument_list|)
condition|)
block|{
name|this
operator|.
name|logBytes
operator|=
operator|(
name|Long
operator|.
name|parseLong
argument_list|(
name|props
operator|.
name|getProperty
argument_list|(
name|TAG_LOGBYTES
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"convert will be implemented by future jira"
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|loadIncrementalTimeRanges
argument_list|(
name|props
operator|.
name|getProperty
argument_list|(
name|TAG_INCRTIMERANGE
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadDependency
argument_list|(
name|props
operator|.
name|getProperty
argument_list|(
name|TAG_DEPENDENCY
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|imageState
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|TAG_IMAGESTATE
argument_list|)
expr_stmt|;
name|this
operator|.
name|isCompacted
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|TAG_COMPACTION
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"TRUE"
argument_list|)
condition|?
literal|true
else|:
literal|false
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"merge and from existing snapshot will be implemented by future jira"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loaded manifest instance from manifest file: "
operator|+
name|FSUtils
operator|.
name|getPath
argument_list|(
name|subFile
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|String
name|errorMsg
init|=
literal|"No manifest file found in: "
operator|+
name|backupPath
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|errorMsg
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BackupException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|public
name|String
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
specifier|public
name|void
name|setType
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
comment|/**    * Load table set from a table set list string (t1;t2;t3;...).    * @param tableSetStr Table set list string    */
specifier|private
name|void
name|loadTableSet
parameter_list|(
name|String
name|tableSetStr
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loading table set: "
operator|+
name|tableSetStr
argument_list|)
expr_stmt|;
name|String
index|[]
name|tableSet
init|=
name|tableSetStr
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
name|this
operator|.
name|tableSet
operator|=
name|this
operator|.
name|getTableSet
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|tableSet
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|tableSet
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableSet
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|.
name|tableSet
operator|.
name|add
argument_list|(
name|tableSet
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|tableSet
operator|.
name|length
operator|+
literal|" tables exist in table set."
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setImageOriginal
parameter_list|()
block|{
name|this
operator|.
name|imageState
operator|=
name|IMAGE_STATE_ORIG
expr_stmt|;
block|}
comment|/**    * Get the table set of this image.    * @return The table set list    */
specifier|public
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getTableSet
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|tableSet
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|tableSet
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
return|return
name|this
operator|.
name|tableSet
return|;
block|}
comment|/**    * Persist the manifest file.    * @throws IOException IOException when storing the manifest file.    */
specifier|public
name|void
name|store
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|BackupException
block|{
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
name|TAG_VERSION
argument_list|,
name|this
operator|.
name|version
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
name|TAG_BACKUPID
argument_list|,
name|this
operator|.
name|token
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
name|TAG_BACKUPTYPE
argument_list|,
name|this
operator|.
name|type
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
name|TAG_TABLESET
argument_list|,
name|this
operator|.
name|getTableSetStr
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"convert will be supported in future jira"
argument_list|)
expr_stmt|;
comment|// String convertedTables = this.getConvertedTableSetStr();
comment|// if (convertedTables != null )
comment|// props.setProperty(TAG_CONVERTEDTABLESET, convertedTables);
name|props
operator|.
name|setProperty
argument_list|(
name|TAG_STARTTS
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|this
operator|.
name|startTs
argument_list|)
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
name|TAG_COMPLETETS
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|this
operator|.
name|completeTs
argument_list|)
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
name|TAG_TABLEBYTES
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|this
operator|.
name|tableBytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|type
operator|.
name|equals
argument_list|(
name|BackupRestoreConstants
operator|.
name|BACKUP_TYPE_INCR
argument_list|)
condition|)
block|{
name|props
operator|.
name|setProperty
argument_list|(
name|TAG_LOGBYTES
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|this
operator|.
name|logBytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|props
operator|.
name|setProperty
argument_list|(
name|TAG_INCRTIMERANGE
argument_list|,
name|this
operator|.
name|getIncrTimestampStr
argument_list|()
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
name|TAG_DEPENDENCY
argument_list|,
name|this
operator|.
name|getDependencyStr
argument_list|()
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
name|TAG_IMAGESTATE
argument_list|,
name|this
operator|.
name|getImageState
argument_list|()
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
name|TAG_COMPACTION
argument_list|,
name|this
operator|.
name|isCompacted
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"merge will be supported in future jira"
argument_list|)
expr_stmt|;
comment|// props.setProperty(TAG_MERGECHAIN, this.getMergeChainStr());
name|LOG
operator|.
name|debug
argument_list|(
literal|"backup from existing snapshot will be supported in future jira"
argument_list|)
expr_stmt|;
comment|// props.setProperty(TAG_FROMSNAPSHOT, this.isFromSnapshot() ? "TRUE" : "FALSE");
comment|// write the file, overwrite if already exist
name|Path
name|manifestFilePath
init|=
operator|new
name|Path
argument_list|(
operator|(
name|this
operator|.
name|tableBackupDir
operator|!=
literal|null
condition|?
name|this
operator|.
name|tableBackupDir
else|:
name|this
operator|.
name|logBackupDir
operator|)
operator|+
name|File
operator|.
name|separator
operator|+
name|FILE_NAME
argument_list|)
decl_stmt|;
try|try
block|{
name|FSDataOutputStream
name|out
init|=
name|manifestFilePath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
operator|.
name|create
argument_list|(
name|manifestFilePath
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|props
operator|.
name|store
argument_list|(
name|out
argument_list|,
literal|"HBase backup manifest."
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BackupException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Manifest file stored to "
operator|+
name|this
operator|.
name|tableBackupDir
operator|!=
literal|null
condition|?
name|this
operator|.
name|tableBackupDir
else|:
name|this
operator|.
name|logBackupDir
operator|+
name|File
operator|.
name|separator
operator|+
name|FILE_NAME
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the table set string in the format of t1;t2;t3...    */
specifier|private
name|String
name|getTableSetStr
parameter_list|()
block|{
return|return
name|BackupUtil
operator|.
name|concat
argument_list|(
name|getTableSet
argument_list|()
argument_list|,
literal|";"
argument_list|)
return|;
block|}
specifier|public
name|String
name|getImageState
parameter_list|()
block|{
return|return
name|imageState
return|;
block|}
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
comment|/**    * Get this backup image.    * @return the backup image.    */
specifier|public
name|BackupImage
name|getBackupImage
parameter_list|()
block|{
return|return
name|this
operator|.
name|getDependency
argument_list|()
operator|.
name|get
argument_list|(
name|this
operator|.
name|token
argument_list|)
return|;
block|}
comment|/**    * Add dependent backup image for this backup.    * @param image The direct dependent backup image    */
specifier|public
name|void
name|addDependentImage
parameter_list|(
name|BackupImage
name|image
parameter_list|)
block|{
name|this
operator|.
name|getDependency
argument_list|()
operator|.
name|get
argument_list|(
name|this
operator|.
name|token
argument_list|)
operator|.
name|addAncestor
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDependencyMap
argument_list|(
name|this
operator|.
name|getDependency
argument_list|()
argument_list|,
name|image
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the dependency' string in the json format.    */
specifier|private
name|String
name|getDependencyStr
parameter_list|()
block|{
name|BackupImage
name|thisImage
init|=
name|this
operator|.
name|getDependency
argument_list|()
operator|.
name|get
argument_list|(
name|this
operator|.
name|token
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisImage
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"There is no dependency set yet."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|mapper
operator|.
name|writeValueAsString
argument_list|(
name|thisImage
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JsonGenerationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error when generating dependency string from backup image."
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|ERROR_DEPENDENCY
return|;
block|}
catch|catch
parameter_list|(
name|JsonMappingException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error when generating dependency string from backup image."
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|ERROR_DEPENDENCY
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error when generating dependency string from backup image."
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|ERROR_DEPENDENCY
return|;
block|}
block|}
comment|/**    * Get all dependent backup images. The image of this backup is also contained.    * @return The dependent backup images map    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|BackupImage
argument_list|>
name|getDependency
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|dependency
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|dependency
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BackupImage
argument_list|>
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|this
operator|.
name|rootDir
operator|+
literal|" "
operator|+
name|this
operator|.
name|token
operator|+
literal|" "
operator|+
name|this
operator|.
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|dependency
operator|.
name|put
argument_list|(
name|this
operator|.
name|token
argument_list|,
operator|new
name|BackupImage
argument_list|(
name|this
operator|.
name|token
argument_list|,
name|this
operator|.
name|type
argument_list|,
name|this
operator|.
name|rootDir
argument_list|,
name|this
operator|.
name|getTableSetStr
argument_list|()
argument_list|,
name|this
operator|.
name|startTs
argument_list|,
name|this
operator|.
name|completeTs
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|dependency
return|;
block|}
comment|/**    * Set the incremental timestamp map directly.    * @param incrTimestampMap timestamp map    */
specifier|public
name|void
name|setIncrTimestampMap
parameter_list|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|incrTimestampMap
parameter_list|)
block|{
name|this
operator|.
name|incrTimeRanges
operator|=
name|incrTimestampMap
expr_stmt|;
block|}
comment|/**    * Get the incremental time range string in the format of:    * t1,rs1:ts,rs2:ts,...;t2,rs1:ts,rs2:ts,...;t3,rs1:ts,rs2:ts,...    */
specifier|private
name|String
name|getIncrTimestampStr
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|tableEntry
range|:
name|this
operator|.
name|getIncrTimestamps
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|tableEntry
operator|.
name|getKey
argument_list|()
operator|+
literal|","
argument_list|)
expr_stmt|;
comment|// table
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|rsEntry
range|:
name|tableEntry
operator|.
name|getValue
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|rsEntry
operator|.
name|getKey
argument_list|()
operator|+
literal|":"
argument_list|)
expr_stmt|;
comment|// region server
name|sb
operator|.
name|append
argument_list|(
name|rsEntry
operator|.
name|getValue
argument_list|()
operator|+
literal|","
argument_list|)
expr_stmt|;
comment|// timestamp
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|','
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|';'
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|getIncrTimestamps
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|incrTimeRanges
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|incrTimeRanges
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
block|}
return|return
name|this
operator|.
name|incrTimeRanges
return|;
block|}
comment|/**    * Load incremental timestamps from a given string, and store them in the collection. The    * timestamps in string is in the format of    * t1,rs1:ts,rs2:ts,...;t2,rs1:ts,rs2:ts,...;t3,rs1:ts,rs2:ts,...    * @param timeRangesInStr Incremental time ranges in string    */
specifier|private
name|void
name|loadIncrementalTimeRanges
parameter_list|(
name|String
name|timeRangesStr
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loading table's incremental time ranges of region servers from string in manifest: "
operator|+
name|timeRangesStr
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|timeRangeMap
init|=
name|this
operator|.
name|getIncrTimestamps
argument_list|()
decl_stmt|;
name|String
index|[]
name|entriesOfTables
init|=
name|timeRangesStr
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entriesOfTables
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
index|[]
name|itemsForTable
init|=
name|entriesOfTables
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
comment|// validate the incremental timestamps string format for a table:
comment|// t1,rs1:ts,rs2:ts,...
if|if
condition|(
name|itemsForTable
operator|.
name|length
operator|<
literal|1
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"Wrong incremental time range format: "
operator|+
name|timeRangesStr
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|errorMsg
argument_list|)
throw|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|rsTimestampMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|itemsForTable
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|String
index|[]
name|rsTsEntry
init|=
name|itemsForTable
index|[
name|j
index|]
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
comment|// validate the incremental timestamps string format for a region server:
comment|// rs1:ts
if|if
condition|(
name|rsTsEntry
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"Wrong incremental timestamp format: "
operator|+
name|itemsForTable
index|[
name|j
index|]
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|errorMsg
argument_list|)
throw|;
block|}
comment|// an entry for timestamp of a region server
name|rsTimestampMap
operator|.
name|put
argument_list|(
name|rsTsEntry
index|[
literal|0
index|]
argument_list|,
name|rsTsEntry
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|timeRangeMap
operator|.
name|put
argument_list|(
name|itemsForTable
index|[
literal|0
index|]
argument_list|,
name|rsTimestampMap
argument_list|)
expr_stmt|;
block|}
comment|// all entries have been loaded
name|LOG
operator|.
name|debug
argument_list|(
name|entriesOfTables
operator|.
name|length
operator|+
literal|" tables' incremental time ranges have been loaded."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the image list of this backup for restore in time order.    * @param reverse If true, then output in reverse order, otherwise in time order from old to new    * @return the backup image list for restore in time order    */
specifier|public
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
name|getRestoreDependentList
parameter_list|(
name|boolean
name|reverse
parameter_list|)
block|{
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|BackupImage
argument_list|>
name|restoreImages
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|BackupImage
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BackupImage
name|image
range|:
name|this
operator|.
name|getDependency
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|restoreImages
operator|.
name|put
argument_list|(
name|Long
operator|.
name|valueOf
argument_list|(
name|image
operator|.
name|startTs
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
argument_list|(
name|reverse
condition|?
operator|(
name|restoreImages
operator|.
name|descendingMap
argument_list|()
operator|.
name|values
argument_list|()
operator|)
else|:
operator|(
name|restoreImages
operator|.
name|values
argument_list|()
operator|)
argument_list|)
return|;
block|}
comment|/**    * Get the dependent image list for a specific table of this backup in time order from old to new    * if want to restore to this backup image level.    * @param table table    * @return the backup image list for a table in time order    */
specifier|public
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
name|getDependentListByTable
parameter_list|(
name|String
name|table
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
name|tableImageList
init|=
operator|new
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
name|imageList
init|=
name|getRestoreDependentList
argument_list|(
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|BackupImage
name|image
range|:
name|imageList
control|)
block|{
if|if
condition|(
name|image
operator|.
name|hasTable
argument_list|(
name|table
argument_list|)
condition|)
block|{
name|tableImageList
operator|.
name|add
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|BackupRestoreConstants
operator|.
name|BACKUP_TYPE_FULL
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
name|Collections
operator|.
name|reverse
argument_list|(
name|tableImageList
argument_list|)
expr_stmt|;
return|return
name|tableImageList
return|;
block|}
comment|/**    * Get the full dependent image list in the whole dependency scope for a specific table of this    * backup in time order from old to new.    * @param table table    * @return the full backup image list for a table in time order in the whole scope of the    *         dependency of this image    */
specifier|public
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
name|getAllDependentListByTable
parameter_list|(
name|String
name|table
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
name|tableImageList
init|=
operator|new
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
name|imageList
init|=
name|getRestoreDependentList
argument_list|(
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|BackupImage
name|image
range|:
name|imageList
control|)
block|{
if|if
condition|(
name|image
operator|.
name|hasTable
argument_list|(
name|table
argument_list|)
condition|)
block|{
name|tableImageList
operator|.
name|add
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tableImageList
return|;
block|}
comment|/**    * Load dependency from a dependency json string.    * @param dependencyStr The dependency string    * @throws IOException exception    */
specifier|private
name|void
name|loadDependency
parameter_list|(
name|String
name|dependencyStr
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loading dependency: "
operator|+
name|dependencyStr
argument_list|)
expr_stmt|;
name|String
name|msg
init|=
literal|"Dependency is broken in the manifest."
decl_stmt|;
if|if
condition|(
name|dependencyStr
operator|.
name|equals
argument_list|(
name|ERROR_DEPENDENCY
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
name|BackupImage
name|image
init|=
literal|null
decl_stmt|;
try|try
block|{
name|image
operator|=
name|mapper
operator|.
name|readValue
argument_list|(
name|dependencyStr
argument_list|,
name|BackupImage
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|JsonParseException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|JsonMappingException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Manifest's current backup image information:"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"  Token: "
operator|+
name|image
operator|.
name|getBackupId
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"  Backup directory: "
operator|+
name|image
operator|.
name|getRootDir
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDependencyMap
argument_list|(
name|this
operator|.
name|getDependency
argument_list|()
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Dependent images map:"
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|BackupImage
argument_list|>
name|entry
range|:
name|this
operator|.
name|getDependency
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"  "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|" : "
operator|+
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getBackupId
argument_list|()
operator|+
literal|" -- "
operator|+
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getRootDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Dependency has been loaded."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Recursively set the dependency map of the backup images.    * @param map The dependency map    * @param image The backup image    */
specifier|private
name|void
name|setDependencyMap
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|BackupImage
argument_list|>
name|map
parameter_list|,
name|BackupImage
name|image
parameter_list|)
block|{
if|if
condition|(
name|image
operator|==
literal|null
condition|)
block|{
return|return;
block|}
else|else
block|{
name|map
operator|.
name|put
argument_list|(
name|image
operator|.
name|getBackupId
argument_list|()
argument_list|,
name|image
argument_list|)
expr_stmt|;
for|for
control|(
name|BackupImage
name|img
range|:
name|image
operator|.
name|getAncestors
argument_list|()
control|)
block|{
name|setDependencyMap
argument_list|(
name|map
argument_list|,
name|img
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Check whether backup image1 could cover backup image2 or not.    * @param image1 backup image 1    * @param image2 backup image 2    * @return true if image1 can cover image2, otherwise false    */
specifier|public
specifier|static
name|boolean
name|canCoverImage
parameter_list|(
name|BackupImage
name|image1
parameter_list|,
name|BackupImage
name|image2
parameter_list|)
block|{
comment|// image1 can cover image2 only when the following conditions are satisfied:
comment|// - image1 must not be an incremental image;
comment|// - image1 must be taken after image2 has been taken;
comment|// - table set of image1 must cover the table set of image2.
if|if
condition|(
name|image1
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|BackupRestoreConstants
operator|.
name|BACKUP_TYPE_INCR
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|image1
operator|.
name|getStartTs
argument_list|()
operator|<
name|image2
operator|.
name|getStartTs
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
index|[]
name|image1TableSet
init|=
name|image1
operator|.
name|getTableSet
argument_list|()
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
name|String
index|[]
name|image2TableSet
init|=
name|image2
operator|.
name|getTableSet
argument_list|()
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|image2TableSet
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|found
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|image1TableSet
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|image2TableSet
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|image1TableSet
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Backup image "
operator|+
name|image1
operator|.
name|getBackupId
argument_list|()
operator|+
literal|" can cover "
operator|+
name|image2
operator|.
name|getBackupId
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Check whether backup image set could cover a backup image or not.    * @param fullImages The backup image set    * @param image The target backup image    * @return true if fullImages can cover image, otherwise false    */
specifier|public
specifier|static
name|boolean
name|canCoverImage
parameter_list|(
name|ArrayList
argument_list|<
name|BackupImage
argument_list|>
name|fullImages
parameter_list|,
name|BackupImage
name|image
parameter_list|)
block|{
comment|// fullImages can cover image only when the following conditions are satisfied:
comment|// - each image of fullImages must not be an incremental image;
comment|// - each image of fullImages must be taken after image has been taken;
comment|// - sum table set of fullImages must cover the table set of image.
for|for
control|(
name|BackupImage
name|image1
range|:
name|fullImages
control|)
block|{
if|if
condition|(
name|image1
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|BackupRestoreConstants
operator|.
name|BACKUP_TYPE_INCR
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|image1
operator|.
name|getStartTs
argument_list|()
operator|<
name|image
operator|.
name|getStartTs
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|image1TableSet
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BackupImage
name|image1
range|:
name|fullImages
control|)
block|{
name|String
index|[]
name|tableSet
init|=
name|image1
operator|.
name|getTableSet
argument_list|()
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|table
range|:
name|tableSet
control|)
block|{
name|image1TableSet
operator|.
name|add
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|image2TableSet
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
index|[]
name|tableSet
init|=
name|image
operator|.
name|getTableSet
argument_list|()
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|table
range|:
name|tableSet
control|)
block|{
name|image2TableSet
operator|.
name|add
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|image2TableSet
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|image1TableSet
operator|.
name|contains
argument_list|(
name|image2TableSet
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Full image set can cover image "
operator|+
name|image
operator|.
name|getBackupId
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
end_class

end_unit

