begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|Thread
operator|.
name|UncaughtExceptionHandler
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Chore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionTransition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Stoppable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|CatalogTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|EventHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|EventHandler
operator|.
name|EventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|ServerNotRunningYetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|AssignmentManager
operator|.
name|RegionState
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|ClosedRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|DisableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|EnableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|OpenedRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|ServerShutdownHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|SplitRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|metrics
operator|.
name|MasterMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionAlreadyInTransitionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionOpeningState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionServerStoppedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Writables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RootRegionTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKAssign
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|NoNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|NodeExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_comment
comment|/**  * Manages and performs region assignment.  *<p>  * Monitors ZooKeeper for events related to regions in transition.  *<p>  * Handles existing regions in transition during master failover.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|AssignmentManager
extends|extends
name|ZooKeeperListener
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AssignmentManager
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|ServerName
name|HBCK_CODE_SERVERNAME
init|=
operator|new
name|ServerName
argument_list|(
name|HConstants
operator|.
name|HBCK_CODE_NAME
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1L
argument_list|)
decl_stmt|;
specifier|protected
name|Server
name|master
decl_stmt|;
specifier|private
name|ServerManager
name|serverManager
decl_stmt|;
specifier|private
name|CatalogTracker
name|catalogTracker
decl_stmt|;
specifier|private
name|TimeoutMonitor
name|timeoutMonitor
decl_stmt|;
specifier|private
name|TimerUpdater
name|timerUpdater
decl_stmt|;
specifier|private
name|LoadBalancer
name|balancer
decl_stmt|;
comment|/**    * Map of regions to reopen after the schema of a table is changed. Key -    * encoded region name, value - HRegionInfo    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HRegionInfo
argument_list|>
name|regionsToReopen
decl_stmt|;
comment|/*    * Maximum times we recurse an assignment.  See below in {@link #assign()}.    */
specifier|private
specifier|final
name|int
name|maximumAssignmentAttempts
decl_stmt|;
comment|/**    * Regions currently in transition.  Map of encoded region names to the master    * in-memory state for that region.    */
specifier|final
name|ConcurrentSkipListMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|regionsInTransition
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Plans for region movement. Key is the encoded version of a region name*/
comment|// TODO: When do plans get cleaned out?  Ever? In server open and in server
comment|// shutdown processing -- St.Ack
comment|// All access to this Map must be synchronized.
specifier|final
name|NavigableMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|regionPlans
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ZKTable
name|zkTable
decl_stmt|;
comment|// store all the table names in disabling state
name|Set
argument_list|<
name|String
argument_list|>
name|disablingTables
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// store all the enabling state tablenames.
name|Set
argument_list|<
name|String
argument_list|>
name|enablingTables
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**    * Server to regions assignment map.    * Contains the set of regions currently assigned to a given server.    * This Map and {@link #regions} are tied.  Always update this in tandem    * with the other under a lock on {@link #regions}.    * @see #regions    */
specifier|private
specifier|final
name|NavigableMap
argument_list|<
name|ServerName
argument_list|,
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|servers
init|=
operator|new
name|TreeMap
argument_list|<
name|ServerName
argument_list|,
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Contains the server which need to update timer, these servers will be    * handled by {@link TimerUpdater}    */
specifier|private
specifier|final
name|ConcurrentSkipListSet
argument_list|<
name|ServerName
argument_list|>
name|serversInUpdatingTimer
init|=
operator|new
name|ConcurrentSkipListSet
argument_list|<
name|ServerName
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Region to server assignment map.    * Contains the server a given region is currently assigned to.    * This Map and {@link #servers} are tied.  Always update this in tandem    * with the other under a lock on {@link #regions}.    * @see #servers    */
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regions
init|=
operator|new
name|TreeMap
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ExecutorService
name|executorService
decl_stmt|;
comment|//Thread pool executor service for timeout monitor
specifier|private
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
name|threadPoolExecutorService
decl_stmt|;
specifier|private
name|List
argument_list|<
name|EventType
argument_list|>
name|ignoreStatesRSOffline
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|EventType
index|[]
block|{
name|EventType
operator|.
name|RS_ZK_REGION_FAILED_OPEN
block|,
name|EventType
operator|.
name|RS_ZK_REGION_CLOSED
block|}
argument_list|)
decl_stmt|;
comment|/**    * Set when we are doing master failover processing; cleared when failover    * completes.    */
specifier|private
specifier|volatile
name|boolean
name|failover
init|=
literal|false
decl_stmt|;
comment|// Set holding all the regions which got processed while RIT was not
comment|// populated during master failover.
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|HRegionInfo
argument_list|>
name|failoverProcessedRegions
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// metrics instance to send metrics for RITs
name|MasterMetrics
name|masterMetrics
decl_stmt|;
comment|/**    * Constructs a new assignment manager.    *    * @param master    * @param serverManager    * @param catalogTracker    * @param service    * @throws KeeperException    * @throws IOException     */
specifier|public
name|AssignmentManager
parameter_list|(
name|Server
name|master
parameter_list|,
name|ServerManager
name|serverManager
parameter_list|,
name|CatalogTracker
name|catalogTracker
parameter_list|,
specifier|final
name|LoadBalancer
name|balancer
parameter_list|,
specifier|final
name|ExecutorService
name|service
parameter_list|,
name|MasterMetrics
name|metrics
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
name|super
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
name|serverManager
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|=
name|catalogTracker
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|regionsToReopen
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HRegionInfo
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|this
operator|.
name|timeoutMonitor
operator|=
operator|new
name|TimeoutMonitor
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.assignment.timeoutmonitor.period"
argument_list|,
literal|10000
argument_list|)
argument_list|,
name|master
argument_list|,
name|serverManager
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.assignment.timeoutmonitor.timeout"
argument_list|,
literal|1800000
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|timerUpdater
operator|=
operator|new
name|TimerUpdater
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.assignment.timerupdater.period"
argument_list|,
literal|10000
argument_list|)
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|timerUpdater
operator|.
name|getThread
argument_list|()
argument_list|,
name|master
operator|.
name|getServerName
argument_list|()
operator|+
literal|".timerUpdater"
argument_list|)
expr_stmt|;
name|this
operator|.
name|zkTable
operator|=
operator|new
name|ZKTable
argument_list|(
name|this
operator|.
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|maximumAssignmentAttempts
operator|=
name|this
operator|.
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.assignment.maximum.attempts"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|=
name|balancer
expr_stmt|;
name|this
operator|.
name|threadPoolExecutorService
operator|=
name|Executors
operator|.
name|newCachedThreadPool
argument_list|()
expr_stmt|;
name|this
operator|.
name|masterMetrics
operator|=
name|metrics
expr_stmt|;
comment|// can be null only with tests.
block|}
name|void
name|startTimeOutMonitor
parameter_list|()
block|{
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|timeoutMonitor
operator|.
name|getThread
argument_list|()
argument_list|,
name|master
operator|.
name|getServerName
argument_list|()
operator|+
literal|".timeoutMonitor"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compute the average load across all region servers.    * Currently, this uses a very naive computation - just uses the number of    * regions being served, ignoring stats about number of requests.    * @return the average load    */
name|double
name|getAverageLoad
parameter_list|()
block|{
name|int
name|totalLoad
init|=
literal|0
decl_stmt|;
name|int
name|numServers
init|=
literal|0
decl_stmt|;
comment|// Sync on this.regions because access to this.servers always synchronizes
comment|// in this order.
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|e
range|:
name|servers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|numServers
operator|++
expr_stmt|;
name|totalLoad
operator|+=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|(
name|double
operator|)
name|totalLoad
operator|/
operator|(
name|double
operator|)
name|numServers
return|;
block|}
comment|/**    * @return Instance of ZKTable.    */
specifier|public
name|ZKTable
name|getZKTable
parameter_list|()
block|{
comment|// These are 'expensive' to make involving trip to zk ensemble so allow
comment|// sharing.
return|return
name|this
operator|.
name|zkTable
return|;
block|}
comment|/**    * Returns the RegionServer to which hri is assigned.    *    * @param hri    *          HRegion for which this function returns the region server    * @return HServerInfo The region server to which hri belongs    */
specifier|public
name|ServerName
name|getRegionServerOfRegion
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
return|return
name|regions
operator|.
name|get
argument_list|(
name|hri
argument_list|)
return|;
block|}
block|}
comment|/**    * Add a regionPlan for the specified region.    * @param encodedName     * @param plan     */
specifier|public
name|void
name|addPlan
parameter_list|(
name|String
name|encodedName
parameter_list|,
name|RegionPlan
name|plan
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regionPlans
init|)
block|{
name|regionPlans
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|plan
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add a map of region plans.    */
specifier|public
name|void
name|addPlans
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|plans
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regionPlans
init|)
block|{
name|regionPlans
operator|.
name|putAll
argument_list|(
name|plans
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the list of regions that will be reopened    * because of an update in table schema    *    * @param regions    *          list of regions that should be tracked for reopen    */
specifier|public
name|void
name|setRegionsToReopen
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|regions
control|)
block|{
name|regionsToReopen
operator|.
name|put
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Used by the client to identify if all regions have the schema updates    *    * @param tableName    * @return Pair indicating the status of the alter command    * @throws IOException    */
specifier|public
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|getReopenStatus
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|hris
init|=
name|MetaReader
operator|.
name|getTableRegions
argument_list|(
name|this
operator|.
name|master
operator|.
name|getCatalogTracker
argument_list|()
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|Integer
name|pending
init|=
literal|0
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|hris
control|)
block|{
name|String
name|name
init|=
name|hri
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionsToReopen
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
operator|||
name|regionsInTransition
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|pending
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|pending
argument_list|,
name|hris
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Reset all unassigned znodes.  Called on startup of master.    * Call {@link #assignAllUserRegions()} after root and meta have been assigned.    * @throws IOException    * @throws KeeperException    */
name|void
name|cleanoutUnassigned
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
comment|// Cleanup any existing ZK nodes and start watching
name|ZKAssign
operator|.
name|deleteAllNodes
argument_list|(
name|watcher
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|this
operator|.
name|watcher
argument_list|,
name|this
operator|.
name|watcher
operator|.
name|assignmentZNode
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called on startup.    * Figures whether a fresh cluster start of we are joining extant running cluster.    * @param onlineServers onlined servers when master started    * @throws IOException    * @throws KeeperException    * @throws InterruptedException    */
name|void
name|joinCluster
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
comment|// Concurrency note: In the below the accesses on regionsInTransition are
comment|// outside of a synchronization block where usually all accesses to RIT are
comment|// synchronized.  The presumption is that in this case it is safe since this
comment|// method is being played by a single thread on startup.
comment|// TODO: Regions that have a null location and are not in regionsInTransitions
comment|// need to be handled.
comment|// Scan META to build list of existing regions, servers, and assignment
comment|// Returns servers who have not checked in (assumed dead) and their regions
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|deadServers
init|=
name|rebuildUserRegions
argument_list|()
decl_stmt|;
comment|// This method will assign all user regions if a clean server startup or
comment|// it will reconstitute master state and cleanup any leftovers from
comment|// previous master process.
name|processDeadServersAndRegionsInTransition
argument_list|(
name|deadServers
argument_list|)
expr_stmt|;
comment|// Recover the tables that were not fully moved to DISABLED state.
comment|// These tables are in DISABLING state when the master restarted/switched.
name|boolean
name|isWatcherCreated
init|=
name|recoverTableInDisablingState
argument_list|(
name|this
operator|.
name|disablingTables
argument_list|)
decl_stmt|;
name|recoverTableInEnablingState
argument_list|(
name|this
operator|.
name|enablingTables
argument_list|,
name|isWatcherCreated
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process all regions that are in transition up in zookeeper.  Used by    * master joining an already running cluster.    * @throws KeeperException    * @throws IOException    * @throws InterruptedException    */
name|void
name|processDeadServersAndRegionsInTransition
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|IOException
throws|,
name|InterruptedException
block|{
comment|// Pass null to signify no dead servers in this context.
name|processDeadServersAndRegionsInTransition
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process all regions that are in transition in zookeeper and also    * processes the list of dead servers by scanning the META.     * Used by master joining an cluster.  If we figure this is a clean cluster    * startup, will assign all user regions.    * @param deadServers    *          Map of dead servers and their regions. Can be null.    * @throws KeeperException    * @throws IOException    * @throws InterruptedException    */
name|void
name|processDeadServersAndRegionsInTransition
parameter_list|(
specifier|final
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|deadServers
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
throws|,
name|InterruptedException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|nodes
init|=
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|assignmentZNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|==
literal|null
condition|)
block|{
name|String
name|errorMessage
init|=
literal|"Failed to get the children from ZK"
decl_stmt|;
name|master
operator|.
name|abort
argument_list|(
name|errorMessage
argument_list|,
operator|new
name|IOException
argument_list|(
name|errorMessage
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Run through all regions.  If they are not assigned and not in RIT, then
comment|// its a clean cluster startup, else its a failover.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|e
range|:
name|this
operator|.
name|regions
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|isMetaTable
argument_list|()
operator|&&
name|e
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|e
operator|+
literal|" out on cluster"
argument_list|)
expr_stmt|;
name|this
operator|.
name|failover
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nodes
operator|.
name|contains
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" in RITs"
argument_list|)
expr_stmt|;
comment|// Could be a meta region.
name|this
operator|.
name|failover
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// Remove regions in RIT, they are possibly being processed by
comment|// ServerShutdownHandler.
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
name|nodes
operator|.
name|removeAll
argument_list|(
name|regionsInTransition
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// If we found user regions out on cluster, its a failover.
if|if
condition|(
name|this
operator|.
name|failover
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found regions out on cluster or in RIT; failover"
argument_list|)
expr_stmt|;
comment|// Process list of dead servers and regions in RIT.
comment|// See HBASE-4580 for more information.
name|processDeadServersAndRecoverLostRegions
argument_list|(
name|deadServers
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
name|this
operator|.
name|failover
operator|=
literal|false
expr_stmt|;
name|failoverProcessedRegions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Fresh cluster startup.
name|LOG
operator|.
name|info
argument_list|(
literal|"Clean cluster startup. Assigning userregions"
argument_list|)
expr_stmt|;
name|cleanoutUnassigned
argument_list|()
expr_stmt|;
name|assignAllUserRegions
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * If region is up in zk in transition, then do fixup and block and wait until    * the region is assigned and out of transition.  Used on startup for    * catalog regions.    * @param hri Region to look for.    * @return True if we processed a region in transition else false if region    * was not up in zk in transition.    * @throws InterruptedException    * @throws KeeperException    * @throws IOException    */
name|boolean
name|processRegionInTransitionAndBlockUntilAssigned
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|KeeperException
throws|,
name|IOException
block|{
name|boolean
name|intransistion
init|=
name|processRegionInTransition
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|hri
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|intransistion
condition|)
return|return
name|intransistion
return|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting on "
operator|+
name|HRegionInfo
operator|.
name|prettyPrint
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
while|while
condition|(
operator|!
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
name|this
operator|.
name|regionsInTransition
operator|.
name|containsKey
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
condition|)
block|{
comment|// We expect a notify, but by security we set a timout
name|this
operator|.
name|regionsInTransition
operator|.
name|wait
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|intransistion
return|;
block|}
comment|/**    * Process failover of new master for region<code>encodedRegionName</code>    * up in zookeeper.    * @param encodedRegionName Region to process failover for.    * @param regionInfo If null we'll go get it from meta table.    * @param deadServers Can be null     * @return True if we processed<code>regionInfo</code> as a RIT.    * @throws KeeperException    * @throws IOException    */
name|boolean
name|processRegionInTransition
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|deadServers
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getDataAndWatch
argument_list|(
name|watcher
argument_list|,
name|encodedRegionName
argument_list|,
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|RegionTransition
name|rt
decl_stmt|;
try|try
block|{
name|rt
operator|=
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed parse znode data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|HRegionInfo
name|hri
init|=
name|regionInfo
decl_stmt|;
if|if
condition|(
name|hri
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|hri
operator|=
name|getHRegionInfo
argument_list|(
name|rt
operator|.
name|getRegionName
argument_list|()
argument_list|)
operator|)
operator|==
literal|null
condition|)
return|return
literal|false
return|;
block|}
name|processRegionsInTransition
argument_list|(
name|rt
argument_list|,
name|hri
argument_list|,
name|deadServers
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|void
name|processRegionsInTransition
parameter_list|(
specifier|final
name|RegionTransition
name|rt
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|deadServers
parameter_list|,
name|int
name|expectedVersion
parameter_list|)
throws|throws
name|KeeperException
block|{
name|EventType
name|et
init|=
name|rt
operator|.
name|getEventType
argument_list|()
decl_stmt|;
comment|// Get ServerName.  Could be null.
name|ServerName
name|sn
init|=
name|rt
operator|.
name|getServerName
argument_list|()
decl_stmt|;
name|String
name|encodedRegionName
init|=
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" in state "
operator|+
name|et
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
name|RegionState
name|regionState
init|=
name|regionsInTransition
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
operator|||
name|failoverProcessedRegions
operator|.
name|containsKey
argument_list|(
name|encodedRegionName
argument_list|)
condition|)
block|{
comment|// Just return
return|return;
block|}
switch|switch
condition|(
name|et
condition|)
block|{
case|case
name|M_ZK_REGION_CLOSING
case|:
comment|// If zk node of the region was updated by a live server skip this
comment|// region and just add it into RIT.
if|if
condition|(
name|isOnDeadServer
argument_list|(
name|regionInfo
argument_list|,
name|deadServers
argument_list|)
operator|&&
operator|(
name|sn
operator|==
literal|null
operator|||
operator|!
name|isServerOnline
argument_list|(
name|sn
argument_list|)
operator|)
condition|)
block|{
comment|// If was on dead server, its closed now. Force to OFFLINE and this
comment|// will get it reassigned if appropriate
name|forceOffline
argument_list|(
name|regionInfo
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Just insert region into RIT.
comment|// If this never updates the timeout will trigger new assignment
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|getRegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|CLOSING
argument_list|,
name|rt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|failoverProcessedRegions
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_CLOSED
case|:
case|case
name|RS_ZK_REGION_FAILED_OPEN
case|:
comment|// Region is closed, insert into RIT and handle it
name|addToRITandCallClose
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|CLOSED
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|failoverProcessedRegions
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ZK_REGION_OFFLINE
case|:
comment|// If zk node of the region was updated by a live server skip this
comment|// region and just add it into RIT.
if|if
condition|(
name|isOnDeadServer
argument_list|(
name|regionInfo
argument_list|,
name|deadServers
argument_list|)
operator|&&
operator|(
name|sn
operator|==
literal|null
operator|||
operator|!
name|isServerOnline
argument_list|(
name|sn
argument_list|)
operator|)
condition|)
block|{
comment|// Region is offline, insert into RIT and handle it like a closed
name|addToRITandCallClose
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sn
operator|!=
literal|null
operator|&&
operator|!
name|isServerOnline
argument_list|(
name|sn
argument_list|)
condition|)
block|{
comment|// to handle cases where offline node is created but sendRegionOpen
comment|// RPC is not yet sent
name|addToRITandCallClose
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|getRegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|PENDING_OPEN
argument_list|,
name|rt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|failoverProcessedRegions
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENING
case|:
comment|// TODO: Could check if it was on deadServers.  If it was, then we could
comment|// do what happens in TimeoutMonitor when it sees this condition.
comment|// Just insert region into RIT
comment|// If this never updates the timeout will trigger new assignment
if|if
condition|(
name|regionInfo
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|getRegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OPENING
argument_list|,
name|rt
argument_list|)
argument_list|)
expr_stmt|;
comment|// If ROOT or .META. table is waiting for timeout monitor to assign
comment|// it may take lot of time when the assignment.timeout.period is
comment|// the default value which may be very long.  We will not be able
comment|// to serve any request during this time.
comment|// So we will assign the ROOT and .META. region immediately.
name|processOpeningState
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|deadServers
operator|.
name|keySet
argument_list|()
operator|.
name|contains
argument_list|(
name|sn
argument_list|)
condition|)
block|{
comment|// if the region is found on a dead server, we can assign
comment|// it to a new RS. (HBASE-5882)
name|processOpeningState
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
block|}
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|getRegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OPENING
argument_list|,
name|rt
argument_list|)
argument_list|)
expr_stmt|;
name|failoverProcessedRegions
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENED
case|:
comment|// Region is opened, insert into RIT and handle it
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|getRegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OPEN
argument_list|,
name|rt
argument_list|)
argument_list|)
expr_stmt|;
comment|// sn could be null if this server is no longer online.  If
comment|// that is the case, just let this RIT timeout; it'll be assigned
comment|// to new server then.
if|if
condition|(
name|sn
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region in transition "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" references a null server; letting RIT timeout so will be "
operator|+
literal|"assigned elsewhere"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
operator|&&
operator|(
name|isOnDeadServer
argument_list|(
name|regionInfo
argument_list|,
name|deadServers
argument_list|)
operator|||
name|regionInfo
operator|.
name|isMetaRegion
argument_list|()
operator|||
name|regionInfo
operator|.
name|isRootRegion
argument_list|()
operator|)
condition|)
block|{
name|forceOffline
argument_list|(
name|regionInfo
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|new
name|OpenedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionInfo
argument_list|,
name|sn
argument_list|,
name|expectedVersion
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
name|failoverProcessedRegions
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_SPLITTING
case|:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processed region in state : "
operator|+
name|et
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_SPLIT
case|:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processed region in state : "
operator|+
name|et
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Received region in state :"
operator|+
name|et
operator|+
literal|" is not valid"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Put the region<code>hri</code> into an offline state up in zk.    * @param hri    * @param oldRt    * @throws KeeperException    */
specifier|private
name|void
name|forceOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
specifier|final
name|RegionTransition
name|oldRt
parameter_list|)
throws|throws
name|KeeperException
block|{
comment|// If was on dead server, its closed now.  Force to OFFLINE and then
comment|// handle it like a close; this will get it reassigned if appropriate
name|LOG
operator|.
name|debug
argument_list|(
literal|"RIT "
operator|+
name|hri
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" in state="
operator|+
name|oldRt
operator|.
name|getEventType
argument_list|()
operator|+
literal|" was on deadserver; forcing offline"
argument_list|)
expr_stmt|;
name|ZKAssign
operator|.
name|createOrForceNodeOffline
argument_list|(
name|this
operator|.
name|watcher
argument_list|,
name|hri
argument_list|,
name|this
operator|.
name|master
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
name|addToRITandCallClose
argument_list|(
name|hri
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|,
name|oldRt
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add to the in-memory copy of regions in transition and then call close    * handler on passed region<code>hri</code>    * @param hri    * @param state    * @param oldData    */
specifier|private
name|void
name|addToRITandCallClose
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
specifier|final
name|RegionState
operator|.
name|State
name|state
parameter_list|,
specifier|final
name|RegionTransition
name|oldData
parameter_list|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|put
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|getRegionState
argument_list|(
name|hri
argument_list|,
name|state
argument_list|,
name|oldData
argument_list|)
argument_list|)
expr_stmt|;
operator|new
name|ClosedRegionHandler
argument_list|(
name|this
operator|.
name|master
argument_list|,
name|this
argument_list|,
name|hri
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
comment|/**    * @param hri    * @param state    * @param rt    * @return A new {@link RegionState} instance made of the passed arguments    */
name|RegionState
name|getRegionState
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
specifier|final
name|RegionState
operator|.
name|State
name|state
parameter_list|,
specifier|final
name|RegionTransition
name|rt
parameter_list|)
block|{
return|return
operator|new
name|RegionState
argument_list|(
name|hri
argument_list|,
name|state
argument_list|,
name|rt
operator|.
name|getCreateTime
argument_list|()
argument_list|,
name|rt
operator|.
name|getServerName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * When a region is closed, it should be removed from the regionsToReopen    * @param hri HRegionInfo of the region which was closed    */
specifier|public
name|void
name|removeClosedRegion
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
if|if
condition|(
operator|!
name|regionsToReopen
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|regionsToReopen
operator|.
name|remove
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed region from reopening regions because it was closed"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @param regionInfo    * @param deadServers Map of deadServers and the regions they were carrying;    * can be null.    * @return True if the passed regionInfo in the passed map of deadServers?    */
specifier|private
name|boolean
name|isOnDeadServer
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|deadServers
parameter_list|)
block|{
if|if
condition|(
name|deadServers
operator|==
literal|null
condition|)
return|return
literal|false
return|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|deadServer
range|:
name|deadServers
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
name|e
range|:
name|deadServer
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getFirst
argument_list|()
operator|.
name|equals
argument_list|(
name|regionInfo
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Handles various states an unassigned node can be in.    *<p>    * Method is called when a state change is suspected for an unassigned node.    *<p>    * This deals with skipped transitions (we got a CLOSED but didn't see CLOSING    * yet).    * @param rt    * @param expectedVersion    */
specifier|private
name|void
name|handleRegion
parameter_list|(
specifier|final
name|RegionTransition
name|rt
parameter_list|,
name|int
name|expectedVersion
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
name|HRegionInfo
name|hri
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rt
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected NULL input "
operator|+
name|rt
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|ServerName
name|sn
init|=
name|rt
operator|.
name|getServerName
argument_list|()
decl_stmt|;
if|if
condition|(
name|sn
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Null servername: "
operator|+
name|rt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Check if this is a special HBCK transition
if|if
condition|(
name|sn
operator|.
name|equals
argument_list|(
name|HBCK_CODE_SERVERNAME
argument_list|)
condition|)
block|{
name|handleHBCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|long
name|createTime
init|=
name|rt
operator|.
name|getCreateTime
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|regionName
init|=
name|rt
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|String
name|encodedName
init|=
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|String
name|prettyPrintedRegionName
init|=
name|HRegionInfo
operator|.
name|prettyPrint
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
comment|// Verify this is a known server
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
operator|&&
operator|!
name|this
operator|.
name|master
operator|.
name|getServerName
argument_list|()
operator|.
name|equals
argument_list|(
name|sn
argument_list|)
operator|&&
operator|!
name|ignoreStatesRSOffline
operator|.
name|contains
argument_list|(
name|rt
operator|.
name|getEventType
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempted to handle region transition for server but "
operator|+
literal|"server is not online: "
operator|+
name|prettyPrintedRegionName
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Printing if the event was created a long time ago helps debugging
name|boolean
name|lateEvent
init|=
name|createTime
operator|<
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
literal|15000
operator|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling transition="
operator|+
name|rt
operator|.
name|getEventType
argument_list|()
operator|+
literal|", server="
operator|+
name|sn
operator|+
literal|", region="
operator|+
operator|(
name|prettyPrintedRegionName
operator|==
literal|null
condition|?
literal|"null"
else|:
name|prettyPrintedRegionName
operator|)
operator|+
operator|(
name|lateEvent
condition|?
literal|", which is more than 15 seconds late"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|RegionState
name|regionState
init|=
name|regionsInTransition
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rt
operator|.
name|getEventType
argument_list|()
condition|)
block|{
case|case
name|M_ZK_REGION_OFFLINE
case|:
comment|// Nothing to do.
break|break;
case|case
name|RS_ZK_REGION_SPLITTING
case|:
if|if
condition|(
operator|!
name|isInStateForSplitting
argument_list|(
name|regionState
argument_list|)
condition|)
break|break;
name|addSplittingToRIT
argument_list|(
name|sn
argument_list|,
name|encodedName
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_SPLIT
case|:
comment|// RegionState must be null, or SPLITTING or PENDING_CLOSE.
if|if
condition|(
operator|!
name|isInStateForSplitting
argument_list|(
name|regionState
argument_list|)
condition|)
break|break;
comment|// If null, add SPLITTING state before going to SPLIT
if|if
condition|(
name|regionState
operator|==
literal|null
condition|)
block|{
name|regionState
operator|=
name|addSplittingToRIT
argument_list|(
name|sn
argument_list|,
name|encodedName
argument_list|)
expr_stmt|;
name|String
name|message
init|=
literal|"Received SPLIT for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|sn
decl_stmt|;
comment|// If still null, it means we cannot find it and it was already processed
if|if
condition|(
name|regionState
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|message
operator|+
literal|" but it doesn't exist anymore,"
operator|+
literal|" probably already processed its split"
argument_list|)
expr_stmt|;
break|break;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|message
operator|+
literal|" but region was not first in SPLITTING state; continuing"
argument_list|)
expr_stmt|;
block|}
comment|// Check it has daughters.
name|byte
index|[]
name|payload
init|=
name|rt
operator|.
name|getPayload
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|daughters
init|=
literal|null
decl_stmt|;
try|try
block|{
name|daughters
operator|=
name|Writables
operator|.
name|getHRegionInfos
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
name|payload
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Dropped split! Failed reading split payload for "
operator|+
name|prettyPrintedRegionName
argument_list|)
expr_stmt|;
break|break;
block|}
assert|assert
name|daughters
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
comment|// Assert that we can get a serverinfo for this server.
if|if
condition|(
operator|!
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Dropped split! ServerName="
operator|+
name|sn
operator|+
literal|" unknown."
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Run handler to do the rest of the SPLIT handling.
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|SplitRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|,
name|sn
argument_list|,
name|daughters
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ZK_REGION_CLOSING
case|:
name|hri
operator|=
name|checkIfInFailover
argument_list|(
name|regionState
argument_list|,
name|encodedName
argument_list|,
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hri
operator|!=
literal|null
condition|)
block|{
name|regionState
operator|=
operator|new
name|RegionState
argument_list|(
name|hri
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|CLOSING
argument_list|,
name|createTime
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|regionState
argument_list|)
expr_stmt|;
name|failoverProcessedRegions
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|hri
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Should see CLOSING after we have asked it to CLOSE or additional
comment|// times after already being in state of CLOSING
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingClose
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isClosing
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received CLOSING for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|sn
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not "
operator|+
literal|"in expected PENDING_CLOSE or CLOSING states"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Transition to CLOSING (or update stamp if already CLOSING)
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|CLOSING
argument_list|,
name|createTime
argument_list|,
name|sn
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_CLOSED
case|:
name|hri
operator|=
name|checkIfInFailover
argument_list|(
name|regionState
argument_list|,
name|encodedName
argument_list|,
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hri
operator|!=
literal|null
condition|)
block|{
name|regionState
operator|=
operator|new
name|RegionState
argument_list|(
name|hri
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|CLOSED
argument_list|,
name|createTime
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|regionState
argument_list|)
expr_stmt|;
name|removeClosedRegion
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
operator|new
name|ClosedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
name|failoverProcessedRegions
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|hri
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Should see CLOSED after CLOSING but possible after PENDING_CLOSE
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingClose
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isClosing
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received CLOSED for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|sn
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not "
operator|+
literal|"in expected PENDING_CLOSE or CLOSING states"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Handle CLOSED by assigning elsewhere or stopping if a disable
comment|// If we got here all is good.  Need to update RegionState -- else
comment|// what follows will fail because not in expected state.
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|CLOSED
argument_list|,
name|createTime
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|removeClosedRegion
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|ClosedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_FAILED_OPEN
case|:
name|hri
operator|=
name|checkIfInFailover
argument_list|(
name|regionState
argument_list|,
name|encodedName
argument_list|,
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hri
operator|!=
literal|null
condition|)
block|{
name|regionState
operator|=
operator|new
name|RegionState
argument_list|(
name|hri
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|CLOSED
argument_list|,
name|createTime
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|regionState
argument_list|)
expr_stmt|;
operator|new
name|ClosedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
name|failoverProcessedRegions
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|hri
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingOpen
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isOpening
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received FAILED_OPEN for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|sn
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not in PENDING_OPEN or OPENING"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Handle this the same as if it were opened and then closed.
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|CLOSED
argument_list|,
name|createTime
argument_list|,
name|sn
argument_list|)
expr_stmt|;
comment|// When there are more than one region server a new RS is selected as the
comment|// destination and the same is updated in the regionplan. (HBASE-5546)
name|getRegionPlan
argument_list|(
name|regionState
argument_list|,
name|sn
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|ClosedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENING
case|:
name|hri
operator|=
name|checkIfInFailover
argument_list|(
name|regionState
argument_list|,
name|encodedName
argument_list|,
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hri
operator|!=
literal|null
condition|)
block|{
name|regionState
operator|=
operator|new
name|RegionState
argument_list|(
name|hri
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OPENING
argument_list|,
name|createTime
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|regionState
argument_list|)
expr_stmt|;
name|failoverProcessedRegions
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|hri
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Should see OPENING after we have asked it to OPEN or additional
comment|// times after already being in state of OPENING
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingOpen
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isOpening
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received OPENING for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|sn
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not "
operator|+
literal|"in expected PENDING_OPEN or OPENING states"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Transition to OPENING (or update stamp if already OPENING)
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OPENING
argument_list|,
name|createTime
argument_list|,
name|sn
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENED
case|:
name|hri
operator|=
name|checkIfInFailover
argument_list|(
name|regionState
argument_list|,
name|encodedName
argument_list|,
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hri
operator|!=
literal|null
condition|)
block|{
name|regionState
operator|=
operator|new
name|RegionState
argument_list|(
name|hri
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OPEN
argument_list|,
name|createTime
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|regionState
argument_list|)
expr_stmt|;
operator|new
name|OpenedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|,
name|sn
argument_list|,
name|expectedVersion
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
name|failoverProcessedRegions
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|hri
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Should see OPENED after OPENING but possible after PENDING_OPEN
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingOpen
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isOpening
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received OPENED for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|sn
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not "
operator|+
literal|"in expected PENDING_OPEN or OPENING states"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Handle OPENED by removing from transition and deleted zk node
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OPEN
argument_list|,
name|createTime
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|OpenedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|,
name|sn
argument_list|,
name|expectedVersion
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Received event is not valid."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Checks whether the callback came while RIT was not yet populated during    * master failover.    * @param regionState    * @param encodedName    * @param data    * @return hri    */
specifier|private
name|HRegionInfo
name|checkIfInFailover
parameter_list|(
name|RegionState
name|regionState
parameter_list|,
name|String
name|encodedName
parameter_list|,
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
if|if
condition|(
name|regionState
operator|==
literal|null
operator|&&
name|this
operator|.
name|failover
operator|&&
operator|(
name|failoverProcessedRegions
operator|.
name|containsKey
argument_list|(
name|encodedName
argument_list|)
operator|==
literal|false
operator|||
name|failoverProcessedRegions
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
operator|==
literal|null
operator|)
condition|)
block|{
name|HRegionInfo
name|hri
init|=
name|this
operator|.
name|failoverProcessedRegions
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|hri
operator|==
literal|null
condition|)
name|hri
operator|=
name|getHRegionInfo
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
return|return
name|hri
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Gets the HRegionInfo from the META table    * @param  regionName    * @return HRegionInfo hri for the region     */
specifier|private
name|HRegionInfo
name|getHRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|p
init|=
literal|null
decl_stmt|;
try|try
block|{
name|p
operator|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|catalogTracker
argument_list|,
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|p
operator|.
name|getFirst
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Aborting because error occoured while reading "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
operator|+
literal|" from .META."
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * @return Returns true if this RegionState is splittable; i.e. the    * RegionState is currently in splitting state or pending_close or    * null (Anything else will return false). (Anything else will return false).    */
specifier|private
name|boolean
name|isInStateForSplitting
parameter_list|(
specifier|final
name|RegionState
name|rs
parameter_list|)
block|{
if|if
condition|(
name|rs
operator|==
literal|null
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|rs
operator|.
name|isSplitting
argument_list|()
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|convertPendingCloseToSplitting
argument_list|(
name|rs
argument_list|)
condition|)
return|return
literal|true
return|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Dropped region split! Not in state good for SPLITTING; rs="
operator|+
name|rs
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/**    * If the passed regionState is in PENDING_CLOSE, clean up PENDING_CLOSE    * state and convert it to SPLITTING instead.    * This can happen in case where master wants to close a region at same time    * a regionserver starts a split.  The split won.  Clean out old PENDING_CLOSE    * state.    * @param rs    * @return True if we converted from PENDING_CLOSE to SPLITTING    */
specifier|private
name|boolean
name|convertPendingCloseToSplitting
parameter_list|(
specifier|final
name|RegionState
name|rs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs
operator|.
name|isPendingClose
argument_list|()
condition|)
return|return
literal|false
return|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Converting PENDING_CLOSE to SPLITING; rs="
operator|+
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|SPLITTING
argument_list|)
expr_stmt|;
comment|// Clean up existing state.  Clear from region plans seems all we
comment|// have to do here by way of clean up of PENDING_CLOSE.
name|clearRegionPlan
argument_list|(
name|rs
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * @param serverName    * @param encodedName    * @return The SPLITTING RegionState we added to RIT for the passed region    *<code>encodedName</code>    */
specifier|private
name|RegionState
name|addSplittingToRIT
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|String
name|encodedName
parameter_list|)
block|{
name|RegionState
name|regionState
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|regionState
operator|=
name|findHRegionInfoThenAddToRIT
argument_list|(
name|serverName
argument_list|,
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
condition|)
block|{
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|SPLITTING
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|regionState
return|;
block|}
comment|/**    * Caller must hold lock on<code>this.regions</code>.    * @param serverName    * @param encodedName    * @return The instance of RegionState that was added to RIT or null if error.    */
specifier|private
name|RegionState
name|findHRegionInfoThenAddToRIT
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|String
name|encodedName
parameter_list|)
block|{
name|HRegionInfo
name|hri
init|=
name|findHRegionInfo
argument_list|(
name|serverName
argument_list|,
name|encodedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|hri
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region "
operator|+
name|encodedName
operator|+
literal|" not found on server "
operator|+
name|serverName
operator|+
literal|"; failed processing"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Add to regions in transition, then update state to SPLITTING.
return|return
name|addToRegionsInTransition
argument_list|(
name|hri
argument_list|)
return|;
block|}
comment|/**    * Caller must hold lock on<code>this.regions</code>.    * @param serverName    * @param encodedName    * @return Found HRegionInfo or null.    */
specifier|private
name|HRegionInfo
name|findHRegionInfo
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|String
name|encodedName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
condition|)
return|return
literal|null
return|;
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|hris
init|=
name|this
operator|.
name|servers
operator|.
name|get
argument_list|(
name|sn
argument_list|)
decl_stmt|;
name|HRegionInfo
name|foundHri
init|=
literal|null
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|hris
control|)
block|{
if|if
condition|(
name|hri
operator|.
name|getEncodedName
argument_list|()
operator|.
name|equals
argument_list|(
name|encodedName
argument_list|)
condition|)
block|{
name|foundHri
operator|=
name|hri
expr_stmt|;
break|break;
block|}
block|}
return|return
name|foundHri
return|;
block|}
comment|/**    * Handle a ZK unassigned node transition triggered by HBCK repair tool.    *<p>    * This is handled in a separate code path because it breaks the normal rules.    * @param rt    */
specifier|private
name|void
name|handleHBCK
parameter_list|(
name|RegionTransition
name|rt
parameter_list|)
block|{
name|String
name|encodedName
init|=
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|rt
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Handling HBCK triggered transition="
operator|+
name|rt
operator|.
name|getEventType
argument_list|()
operator|+
literal|", server="
operator|+
name|rt
operator|.
name|getServerName
argument_list|()
operator|+
literal|", region="
operator|+
name|HRegionInfo
operator|.
name|prettyPrint
argument_list|(
name|encodedName
argument_list|)
argument_list|)
expr_stmt|;
name|RegionState
name|regionState
init|=
name|regionsInTransition
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rt
operator|.
name|getEventType
argument_list|()
condition|)
block|{
case|case
name|M_ZK_REGION_OFFLINE
case|:
name|HRegionInfo
name|regionInfo
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
condition|)
block|{
name|regionInfo
operator|=
name|regionState
operator|.
name|getRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|byte
index|[]
name|name
init|=
name|rt
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|p
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|catalogTracker
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|regionInfo
operator|=
name|p
operator|.
name|getFirst
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Exception reading META doing HBCK repair operation"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"HBCK repair is triggering assignment of region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// trigger assign, node is already in OFFLINE so don't need to update ZK
name|assign
argument_list|(
name|regionInfo
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received unexpected region state from HBCK: "
operator|+
name|rt
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// ZooKeeper events
comment|/**    * New unassigned node has been created.    *    *<p>This happens when an RS begins the OPENING or CLOSING of a region by    * creating an unassigned node.    *    *<p>When this happens we must:    *<ol>    *<li>Watch the node for further events</li>    *<li>Read and handle the state in the node</li>    *</ol>    */
annotation|@
name|Override
specifier|public
name|void
name|nodeCreated
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|handleAssignmentEvent
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/**    * Existing unassigned node has had data changed.    *    *<p>This happens when an RS transitions from OFFLINE to OPENING, or between    * OPENING/OPENED and CLOSING/CLOSED.    *    *<p>When this happens we must:    *<ol>    *<li>Watch the node for further events</li>    *<li>Read and handle the state in the node</li>    *</ol>    */
annotation|@
name|Override
specifier|public
name|void
name|nodeDataChanged
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|handleAssignmentEvent
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|handleAssignmentEvent
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
operator|!
name|path
operator|.
name|startsWith
argument_list|(
name|watcher
operator|.
name|assignmentZNode
argument_list|)
condition|)
return|return;
try|try
block|{
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getDataAndWatch
argument_list|(
name|watcher
argument_list|,
name|path
argument_list|,
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
return|return;
name|RegionTransition
name|rt
init|=
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|handleRegion
argument_list|(
name|rt
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception reading unassigned node data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected exception deserializing node data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|nodeDeleted
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|this
operator|.
name|watcher
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
name|String
name|regionName
init|=
name|ZKAssign
operator|.
name|getRegionName
argument_list|(
name|this
operator|.
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|RegionState
name|rs
init|=
name|this
operator|.
name|regionsInTransition
operator|.
name|get
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|!=
literal|null
condition|)
block|{
name|HRegionInfo
name|regionInfo
init|=
name|rs
operator|.
name|getRegion
argument_list|()
decl_stmt|;
if|if
condition|(
name|rs
operator|.
name|isSplit
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ephemeral node deleted, regionserver crashed?, "
operator|+
literal|"clearing from RIT; rs="
operator|+
name|rs
argument_list|)
expr_stmt|;
name|regionOffline
argument_list|(
name|rs
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The znode of region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" has been deleted."
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|.
name|isOpened
argument_list|()
condition|)
block|{
name|makeRegionOnline
argument_list|(
name|rs
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|private
name|void
name|makeRegionOnline
parameter_list|(
name|RegionState
name|rs
parameter_list|,
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|rs
operator|.
name|serverName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"The master has opened the region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" that was online on "
operator|+
name|rs
operator|.
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|getZKTable
argument_list|()
operator|.
name|isDisablingOrDisabledTable
argument_list|(
name|regionInfo
operator|.
name|getTableNameAsString
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Opened region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but "
operator|+
literal|"this table is disabled, triggering close of region"
argument_list|)
expr_stmt|;
name|unassign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * New unassigned node has been created.    *    *<p>This happens when an RS begins the OPENING, SPLITTING or CLOSING of a    * region by creating a znode.    *    *<p>When this happens we must:    *<ol>    *<li>Watch the node for further children changed events</li>    *<li>Watch all new children for changed events</li>    *</ol>    */
annotation|@
name|Override
specifier|public
name|void
name|nodeChildrenChanged
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
name|watcher
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
try|try
block|{
comment|// Just make sure we see the changes for the new znodes
name|ZKUtil
operator|.
name|listChildrenAndWatchThem
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|assignmentZNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception reading unassigned children"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Marks the region as online.  Removes it from regions in transition and    * updates the in-memory assignment information.    *<p>    * Used when a region has been successfully opened on a region server.    * @param regionInfo    * @param sn    */
name|void
name|regionOnline
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|ServerName
name|sn
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
name|RegionState
name|rs
init|=
name|this
operator|.
name|regionsInTransition
operator|.
name|remove
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
comment|// Add check
name|ServerName
name|oldSn
init|=
name|this
operator|.
name|regions
operator|.
name|get
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldSn
operator|!=
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Overwriting "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" on "
operator|+
name|oldSn
operator|+
literal|" with "
operator|+
name|sn
argument_list|)
expr_stmt|;
if|if
condition|(
name|isServerOnline
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|this
operator|.
name|regions
operator|.
name|put
argument_list|(
name|regionInfo
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|addToServers
argument_list|(
name|sn
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|regions
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The server is not in online servers, ServerName="
operator|+
name|sn
operator|.
name|getServerName
argument_list|()
operator|+
literal|", region="
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remove plan if one.
name|clearRegionPlan
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
comment|// Add the server to serversInUpdatingTimer
name|addToServersInUpdatingTimer
argument_list|(
name|sn
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the server to the set serversInUpdatingTimer, then {@link TimerUpdater}    * will update timers for this server in background    * @param sn    */
specifier|private
name|void
name|addToServersInUpdatingTimer
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
name|this
operator|.
name|serversInUpdatingTimer
operator|.
name|add
argument_list|(
name|sn
argument_list|)
expr_stmt|;
block|}
comment|/**    * Touch timers for all regions in transition that have the passed    *<code>sn</code> in common.    * Call this method whenever a server checks in.  Doing so helps the case where    * a new regionserver has joined the cluster and its been given 1k regions to    * open.  If this method is tickled every time the region reports in a    * successful open then the 1k-th region won't be timed out just because its    * sitting behind the open of 999 other regions.  This method is NOT used    * as part of bulk assign -- there we have a different mechanism for extending    * the regions in transition timer (we turn it off temporarily -- because    * there is no regionplan involved when bulk assigning.    * @param sn    */
specifier|private
name|void
name|updateTimers
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
comment|// This loop could be expensive.
comment|// First make a copy of current regionPlan rather than hold sync while
comment|// looping because holding sync can cause deadlock.  Its ok in this loop
comment|// if the Map we're going against is a little stale
name|Map
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|copy
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|copy
operator|.
name|putAll
argument_list|(
name|this
operator|.
name|regionPlans
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|e
range|:
name|copy
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|==
literal|null
operator|||
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getDestination
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
operator|!
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getDestination
argument_list|()
operator|.
name|equals
argument_list|(
name|sn
argument_list|)
condition|)
continue|continue;
name|RegionState
name|rs
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
name|rs
operator|=
name|this
operator|.
name|regionsInTransition
operator|.
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rs
operator|==
literal|null
condition|)
continue|continue;
name|rs
operator|.
name|updateTimestampToNow
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Marks the region as offline.  Removes it from regions in transition and    * removes in-memory assignment information.    *<p>    * Used when a region has been closed and should remain closed.    * @param regionInfo    */
specifier|public
name|void
name|regionOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
if|if
condition|(
name|this
operator|.
name|regionsInTransition
operator|.
name|remove
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|// remove the region plan as well just in case.
name|clearRegionPlan
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|setOffline
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets the region as offline by removing in-memory assignment information but    * retaining transition information.    *<p>    * Used when a region has been closed but should be reassigned.    * @param regionInfo    */
specifier|public
name|void
name|setOffline
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|ServerName
name|sn
init|=
name|this
operator|.
name|regions
operator|.
name|remove
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|==
literal|null
condition|)
return|return;
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|serverRegions
init|=
name|this
operator|.
name|servers
operator|.
name|get
argument_list|(
name|sn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|serverRegions
operator|.
name|remove
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No "
operator|+
name|regionInfo
operator|+
literal|" on "
operator|+
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|offlineDisabledRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
comment|// Disabling so should not be reassigned, just delete the CLOSED node
name|LOG
operator|.
name|debug
argument_list|(
literal|"Table being disabled so deleting ZK node and removing from "
operator|+
literal|"regions in transition, skipping assignment of region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|ZKAssign
operator|.
name|deleteClosedNode
argument_list|(
name|watcher
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
condition|)
block|{
comment|// Could also be in OFFLINE mode
name|ZKAssign
operator|.
name|deleteOfflineNode
argument_list|(
name|watcher
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Tried to delete closed node for "
operator|+
name|regionInfo
operator|+
literal|" but it "
operator|+
literal|"does not exist so just offlining"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|this
operator|.
name|master
operator|.
name|abort
argument_list|(
literal|"Error deleting CLOSED node in ZK"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|regionOffline
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|// Assignment methods
comment|/**    * Assigns the specified region.    *<p>    * If a RegionPlan is available with a valid destination then it will be used    * to determine what server region is assigned to.  If no RegionPlan is    * available, region will be assigned to a random available server.    *<p>    * Updates the RegionState and sends the OPEN RPC.    *<p>    * This will only succeed if the region is in transition and in a CLOSED or    * OFFLINE state or not in transition (in-memory not zk), and of course, the    * chosen server is up and running (It may have just crashed!).  If the    * in-memory checks pass, the zk node is forced to OFFLINE before assigning.    *    * @param region server to be assigned    * @param setOfflineInZK whether ZK node should be created/transitioned to an    *                       OFFLINE state before assigning the region    */
specifier|public
name|void
name|assign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|setOfflineInZK
parameter_list|)
block|{
name|assign
argument_list|(
name|region
argument_list|,
name|setOfflineInZK
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|assign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|setOfflineInZK
parameter_list|,
name|boolean
name|forceNewPlan
parameter_list|)
block|{
name|assign
argument_list|(
name|region
argument_list|,
name|setOfflineInZK
argument_list|,
name|forceNewPlan
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param region    * @param setOfflineInZK    * @param forceNewPlan    * @param hijack True if new assignment is needed, false otherwise    */
specifier|public
name|void
name|assign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|setOfflineInZK
parameter_list|,
name|boolean
name|forceNewPlan
parameter_list|,
name|boolean
name|hijack
parameter_list|)
block|{
comment|// If hijack is true do not call disableRegionIfInRIT as
comment|// we have not yet moved the znode to OFFLINE state.
if|if
condition|(
operator|!
name|hijack
operator|&&
name|isDisabledorDisablingRegionInRIT
argument_list|(
name|region
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|.
name|isClusterShutdown
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cluster shutdown is set; skipping assign of "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|RegionState
name|state
init|=
name|addToRegionsInTransition
argument_list|(
name|region
argument_list|,
name|hijack
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|state
init|)
block|{
name|assign
argument_list|(
name|region
argument_list|,
name|state
argument_list|,
name|setOfflineInZK
argument_list|,
name|forceNewPlan
argument_list|,
name|hijack
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Bulk assign regions to<code>destination</code>.    * @param destination    * @param regions Regions to assign.    * @return true if successful    */
name|boolean
name|assign
parameter_list|(
specifier|final
name|ServerName
name|destination
parameter_list|,
specifier|final
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
if|if
condition|(
name|regions
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bulk assigning "
operator|+
name|regions
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) to "
operator|+
name|destination
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RegionState
argument_list|>
name|states
init|=
operator|new
name|ArrayList
argument_list|<
name|RegionState
argument_list|>
argument_list|(
name|regions
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
name|states
operator|.
name|add
argument_list|(
name|forceRegionStateToOffline
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add region plans, so we can updateTimers when one region is opened so
comment|// that unnecessary timeout on RIT is reduced.
name|Map
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|plans
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
name|plans
operator|.
name|put
argument_list|(
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|,
operator|new
name|RegionPlan
argument_list|(
name|region
argument_list|,
literal|null
argument_list|,
name|destination
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|addPlans
argument_list|(
name|plans
argument_list|)
expr_stmt|;
comment|// Presumption is that only this thread will be updating the state at this
comment|// time; i.e. handlers on backend won't be trying to set it to OPEN, etc.
name|AtomicInteger
name|counter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|CreateUnassignedAsyncCallback
name|cb
init|=
operator|new
name|CreateUnassignedAsyncCallback
argument_list|(
name|this
operator|.
name|watcher
argument_list|,
name|destination
argument_list|,
name|counter
argument_list|)
decl_stmt|;
for|for
control|(
name|RegionState
name|state
range|:
name|states
control|)
block|{
if|if
condition|(
operator|!
name|asyncSetOfflineInZooKeeper
argument_list|(
name|state
argument_list|,
name|cb
argument_list|,
name|state
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// Wait until all unassigned nodes have been put up and watchers set.
name|int
name|total
init|=
name|regions
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|oldCounter
init|=
literal|0
init|;
literal|true
condition|;
control|)
block|{
name|int
name|count
init|=
name|counter
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldCounter
operator|!=
name|count
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|destination
operator|.
name|toString
argument_list|()
operator|+
literal|" unassigned znodes="
operator|+
name|count
operator|+
literal|" of total="
operator|+
name|total
argument_list|)
expr_stmt|;
name|oldCounter
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
name|total
condition|)
break|break;
name|Threads
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Move on to open regions.
try|try
block|{
comment|// Send OPEN RPC. If it fails on a IOE or RemoteException, the
comment|// TimeoutMonitor will pick up the pieces.
name|long
name|maxWaitTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|this
operator|.
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.rpc.startup.waittime"
argument_list|,
literal|60000
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
condition|)
block|{
try|try
block|{
name|this
operator|.
name|serverManager
operator|.
name|sendRegionOpen
argument_list|(
name|destination
argument_list|,
name|regions
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|IOException
name|decodedException
init|=
name|e
operator|.
name|unwrapRemoteException
argument_list|()
decl_stmt|;
if|if
condition|(
name|decodedException
operator|instanceof
name|RegionServerStoppedException
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The region server was shut down, "
argument_list|,
name|decodedException
argument_list|)
expr_stmt|;
comment|// No need to retry, the region server is a goner.
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|decodedException
operator|instanceof
name|ServerNotRunningYetException
condition|)
block|{
comment|// This is the one exception to retry.  For all else we should just fail
comment|// the startup.
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|>
name|maxWaitTime
condition|)
throw|throw
name|e
throw|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server is not yet up; waiting up to "
operator|+
operator|(
name|maxWaitTime
operator|-
name|now
operator|)
operator|+
literal|"ms"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
throw|throw
name|decodedException
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Can be a socket timeout, EOF, NoRouteToHost, etc
name|LOG
operator|.
name|info
argument_list|(
literal|"Unable to communicate with the region server in order"
operator|+
literal|" to assign regions"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bulk assigning done for "
operator|+
name|destination
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Bulk assign regions to available servers if any with retry, else assign    * region singly.    *     * @param regions all regions to assign    * @param servers all available servers    */
specifier|public
name|void
name|assign
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Quickly assigning "
operator|+
name|regions
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) across "
operator|+
name|servers
operator|.
name|size
argument_list|()
operator|+
literal|" server(s)"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
init|=
name|balancer
operator|.
name|roundRobinAssignment
argument_list|(
name|regions
argument_list|,
name|servers
argument_list|)
decl_stmt|;
if|if
condition|(
name|bulkPlan
operator|==
literal|null
operator|||
name|bulkPlan
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed getting bulk plan, assigning region singly"
argument_list|)
expr_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
name|assign
argument_list|(
name|region
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|failedPlans
init|=
operator|new
name|HashMap
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|e
range|:
name|bulkPlan
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|assign
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|failedPlans
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|failedPlans
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|failedPlans
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|servers
operator|.
name|removeAll
argument_list|(
name|failedPlans
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|reassigningRegions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|e
range|:
name|failedPlans
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed assigning "
operator|+
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" regions to server "
operator|+
name|e
operator|.
name|getKey
argument_list|()
operator|+
literal|", reassigning them"
argument_list|)
expr_stmt|;
name|reassigningRegions
operator|.
name|addAll
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assign
argument_list|(
name|reassigningRegions
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Callback handler for create unassigned znodes used during bulk assign.    */
specifier|static
class|class
name|CreateUnassignedAsyncCallback
implements|implements
name|AsyncCallback
operator|.
name|StringCallback
block|{
specifier|private
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|CreateUnassignedAsyncCallback
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ZooKeeperWatcher
name|zkw
decl_stmt|;
specifier|private
specifier|final
name|ServerName
name|destination
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|counter
decl_stmt|;
name|CreateUnassignedAsyncCallback
parameter_list|(
specifier|final
name|ZooKeeperWatcher
name|zkw
parameter_list|,
specifier|final
name|ServerName
name|destination
parameter_list|,
specifier|final
name|AtomicInteger
name|counter
parameter_list|)
block|{
name|this
operator|.
name|zkw
operator|=
name|zkw
expr_stmt|;
name|this
operator|.
name|destination
operator|=
name|destination
expr_stmt|;
name|this
operator|.
name|counter
operator|=
name|counter
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|processResult
parameter_list|(
name|int
name|rc
parameter_list|,
name|String
name|path
parameter_list|,
name|Object
name|ctx
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|// Thisis resultcode.  If non-zero, need to resubmit.
name|LOG
operator|.
name|warn
argument_list|(
literal|"rc != 0 for "
operator|+
name|path
operator|+
literal|" -- retryable connectionloss -- "
operator|+
literal|"FIX see http://wiki.apache.org/hadoop/ZooKeeper/FAQ#A2"
argument_list|)
expr_stmt|;
name|this
operator|.
name|zkw
operator|.
name|abort
argument_list|(
literal|"Connectionloss writing unassigned at "
operator|+
name|path
operator|+
literal|", rc="
operator|+
name|rc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"rs="
operator|+
operator|(
name|RegionState
operator|)
name|ctx
operator|+
literal|", server="
operator|+
name|this
operator|.
name|destination
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Async exists to set a watcher so we'll get triggered when
comment|// unassigned node changes.
name|this
operator|.
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getZooKeeper
argument_list|()
operator|.
name|exists
argument_list|(
name|path
argument_list|,
name|this
operator|.
name|zkw
argument_list|,
operator|new
name|ExistsUnassignedAsyncCallback
argument_list|(
name|this
operator|.
name|counter
argument_list|,
name|destination
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Callback handler for the exists call that sets watcher on unassigned znodes.    * Used during bulk assign on startup.    */
specifier|static
class|class
name|ExistsUnassignedAsyncCallback
implements|implements
name|AsyncCallback
operator|.
name|StatCallback
block|{
specifier|private
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ExistsUnassignedAsyncCallback
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|counter
decl_stmt|;
specifier|private
name|ServerName
name|destination
decl_stmt|;
name|ExistsUnassignedAsyncCallback
parameter_list|(
specifier|final
name|AtomicInteger
name|counter
parameter_list|,
name|ServerName
name|destination
parameter_list|)
block|{
name|this
operator|.
name|counter
operator|=
name|counter
expr_stmt|;
name|this
operator|.
name|destination
operator|=
name|destination
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|processResult
parameter_list|(
name|int
name|rc
parameter_list|,
name|String
name|path
parameter_list|,
name|Object
name|ctx
parameter_list|,
name|Stat
name|stat
parameter_list|)
block|{
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|// Thisis resultcode.  If non-zero, need to resubmit.
name|LOG
operator|.
name|warn
argument_list|(
literal|"rc != 0 for "
operator|+
name|path
operator|+
literal|" -- retryable connectionloss -- "
operator|+
literal|"FIX see http://wiki.apache.org/hadoop/ZooKeeper/FAQ#A2"
argument_list|)
expr_stmt|;
return|return;
block|}
name|RegionState
name|state
init|=
operator|(
name|RegionState
operator|)
name|ctx
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"rs="
operator|+
name|state
argument_list|)
expr_stmt|;
comment|// Transition RegionState to PENDING_OPEN here in master; means we've
comment|// sent the open.  We're a little ahead of ourselves here since we've not
comment|// yet sent out the actual open but putting this state change after the
comment|// call to open risks our writing PENDING_OPEN after state has been moved
comment|// to OPENING by the regionserver.
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|PENDING_OPEN
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|destination
argument_list|)
expr_stmt|;
name|this
operator|.
name|counter
operator|.
name|addAndGet
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @param region    * @return The current RegionState    */
specifier|private
name|RegionState
name|addToRegionsInTransition
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|)
block|{
return|return
name|addToRegionsInTransition
argument_list|(
name|region
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * @param region    * @param hijack    * @return The current RegionState    */
specifier|private
name|RegionState
name|addToRegionsInTransition
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|hijack
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
return|return
name|forceRegionStateToOffline
argument_list|(
name|region
argument_list|,
name|hijack
argument_list|)
return|;
block|}
block|}
comment|/**    * Sets regions {@link RegionState} to {@link RegionState.State#OFFLINE}.    * Caller must hold lock on this.regionsInTransition.    * @param region    * @return Amended RegionState.    */
specifier|private
name|RegionState
name|forceRegionStateToOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|)
block|{
return|return
name|forceRegionStateToOffline
argument_list|(
name|region
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Sets regions {@link RegionState} to {@link RegionState.State#OFFLINE}.    * Caller must hold lock on this.regionsInTransition.    * @param region    * @param hijack    * @return Amended RegionState.    */
specifier|private
name|RegionState
name|forceRegionStateToOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|hijack
parameter_list|)
block|{
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|RegionState
name|state
init|=
name|this
operator|.
name|regionsInTransition
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|state
operator|=
operator|new
name|RegionState
argument_list|(
name|region
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If we are reassigning the node do not force in-memory state to OFFLINE.
comment|// Based on the znode state we will decide if to change in-memory state to
comment|// OFFLINE or not. It will be done before setting znode to OFFLINE state.
comment|// We often get here with state == CLOSED because ClosedRegionHandler will
comment|// assign on its tail as part of the handling of a region close.
if|if
condition|(
operator|!
name|hijack
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Forcing OFFLINE; was="
operator|+
name|state
argument_list|)
expr_stmt|;
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|state
return|;
block|}
comment|/**    * Caller must hold lock on the passed<code>state</code> object.    * @param state    * @param setOfflineInZK    * @param forceNewPlan    * @param hijack    */
specifier|private
name|void
name|assign
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|RegionState
name|state
parameter_list|,
specifier|final
name|boolean
name|setOfflineInZK
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|,
name|boolean
name|hijack
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|maximumAssignmentAttempts
condition|;
name|i
operator|++
control|)
block|{
name|int
name|versionOfOfflineNode
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|setOfflineInZK
condition|)
block|{
comment|// get the version of the znode after setting it to OFFLINE.
comment|// versionOfOfflineNode will be -1 if the znode was not set to OFFLINE
name|versionOfOfflineNode
operator|=
name|setOfflineInZooKeeper
argument_list|(
name|state
argument_list|,
name|hijack
argument_list|)
expr_stmt|;
if|if
condition|(
name|versionOfOfflineNode
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|isDisabledorDisablingRegionInRIT
argument_list|(
name|region
argument_list|)
condition|)
block|{
return|return;
block|}
name|setEnabledTable
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|setOfflineInZK
operator|&&
name|versionOfOfflineNode
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server stopped; skipping assign of "
operator|+
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
name|RegionPlan
name|plan
init|=
name|getRegionPlan
argument_list|(
name|state
argument_list|,
name|forceNewPlan
argument_list|)
decl_stmt|;
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to determine a plan to assign "
operator|+
name|state
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeoutMonitor
operator|.
name|setAllRegionServersOffline
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
comment|// Should get reassigned later when RIT times out.
block|}
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Assigning region "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Transition RegionState to PENDING_OPEN
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|PENDING_OPEN
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
comment|// Send OPEN RPC. This can fail if the server on other end is is not up.
comment|// Pass the version that was obtained while setting the node to OFFLINE.
name|RegionOpeningState
name|regionOpenState
init|=
name|serverManager
operator|.
name|sendRegionOpen
argument_list|(
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
name|versionOfOfflineNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionOpenState
operator|==
name|RegionOpeningState
operator|.
name|ALREADY_OPENED
condition|)
block|{
comment|// Remove region from in-memory transition and unassigned node from ZK
comment|// While trying to enable the table the regions of the table were
comment|// already enabled.
name|LOG
operator|.
name|debug
argument_list|(
literal|"ALREADY_OPENED region "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|encodedRegionName
init|=
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
try|try
block|{
name|ZKAssign
operator|.
name|deleteOfflineNode
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|encodedRegionName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The unassigned node "
operator|+
name|encodedRegionName
operator|+
literal|" doesnot exist."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Error deleting OFFLINED node in ZK for transition ZK node ("
operator|+
name|encodedRegionName
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|remove
argument_list|(
name|plan
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|this
operator|.
name|regions
operator|.
name|put
argument_list|(
name|plan
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
name|addToServers
argument_list|(
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|,
name|plan
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|RemoteException
condition|)
block|{
name|t
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|t
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|RegionAlreadyInTransitionException
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"Failed assignment in: "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
operator|+
literal|" due to "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed assignment of "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
operator|+
literal|", trying to assign elsewhere instead; "
operator|+
literal|"retry="
operator|+
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// Clean out plan we failed execute and one that doesn't look like it'll
comment|// succeed anyways; we need a new plan!
comment|// Transition back to OFFLINE
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
comment|// Force a new plan and reassign.  Will return null if no servers.
if|if
condition|(
name|getRegionPlan
argument_list|(
name|state
argument_list|,
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|timeoutMonitor
operator|.
name|setAllRegionServersOffline
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to find a viable location to assign region "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
specifier|private
name|boolean
name|isDisabledorDisablingRegionInRIT
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|)
block|{
name|String
name|tableName
init|=
name|region
operator|.
name|getTableNameAsString
argument_list|()
decl_stmt|;
name|boolean
name|disabled
init|=
name|this
operator|.
name|zkTable
operator|.
name|isDisabledTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|disabled
operator|||
name|this
operator|.
name|zkTable
operator|.
name|isDisablingTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Table "
operator|+
name|tableName
operator|+
operator|(
name|disabled
condition|?
literal|" disabled;"
else|:
literal|" disabling;"
operator|)
operator|+
literal|" skipping assign of "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|offlineDisabledRegion
argument_list|(
name|region
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Set region as OFFLINED up in zookeeper    *     * @param state    * @param hijack    *          - true if needs to be hijacked and reassigned, false otherwise.    * @return the version of the offline node if setting of the OFFLINE node was    *         successful, -1 otherwise.    */
name|int
name|setOfflineInZooKeeper
parameter_list|(
specifier|final
name|RegionState
name|state
parameter_list|,
name|boolean
name|hijack
parameter_list|)
block|{
comment|// In case of reassignment the current state in memory need not be
comment|// OFFLINE.
if|if
condition|(
operator|!
name|hijack
operator|&&
operator|!
name|state
operator|.
name|isClosed
argument_list|()
operator|&&
operator|!
name|state
operator|.
name|isOffline
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"Unexpected state : "
operator|+
name|state
operator|+
literal|" .. Cannot transit it to OFFLINE."
decl_stmt|;
name|this
operator|.
name|master
operator|.
name|abort
argument_list|(
name|msg
argument_list|,
operator|new
name|IllegalStateException
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|boolean
name|allowZNodeCreation
init|=
literal|false
decl_stmt|;
comment|// Under reassignment if the current state is PENDING_OPEN
comment|// or OPENING then refresh the in-memory state to PENDING_OPEN. This is
comment|// important because if the region was in
comment|// RS_OPENING state for a long time the master will try to force the znode
comment|// to OFFLINE state meanwhile the RS could have opened the corresponding
comment|// region and the state in znode will be RS_ZK_REGION_OPENED.
comment|// For all other cases we can change the in-memory state to OFFLINE.
if|if
condition|(
name|hijack
operator|&&
operator|(
name|state
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|PENDING_OPEN
argument_list|)
operator|||
name|state
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OPENING
argument_list|)
operator|)
condition|)
block|{
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|PENDING_OPEN
argument_list|)
expr_stmt|;
name|allowZNodeCreation
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
name|allowZNodeCreation
operator|=
literal|true
expr_stmt|;
block|}
name|int
name|versionOfOfflineNode
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
comment|// get the version after setting the znode to OFFLINE
name|versionOfOfflineNode
operator|=
name|ZKAssign
operator|.
name|createOrForceNodeOffline
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
name|this
operator|.
name|master
operator|.
name|getServerName
argument_list|()
argument_list|,
name|hijack
argument_list|,
name|allowZNodeCreation
argument_list|)
expr_stmt|;
if|if
condition|(
name|versionOfOfflineNode
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempted to create/force node into OFFLINE state before "
operator|+
literal|"completing assignment but failed to do so for "
operator|+
name|state
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception creating/setting node OFFLINE"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|versionOfOfflineNode
return|;
block|}
comment|/**    * Set region as OFFLINED up in zookeeper asynchronously.    * @param state    * @return True if we succeeded, false otherwise (State was incorrect or failed    * updating zk).    */
name|boolean
name|asyncSetOfflineInZooKeeper
parameter_list|(
specifier|final
name|RegionState
name|state
parameter_list|,
specifier|final
name|AsyncCallback
operator|.
name|StringCallback
name|cb
parameter_list|,
specifier|final
name|Object
name|ctx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
operator|.
name|isClosed
argument_list|()
operator|&&
operator|!
name|state
operator|.
name|isOffline
argument_list|()
condition|)
block|{
name|this
operator|.
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected state trying to OFFLINE; "
operator|+
name|state
argument_list|,
operator|new
name|IllegalStateException
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
try|try
block|{
name|ZKAssign
operator|.
name|asyncCreateNodeOffline
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
name|this
operator|.
name|master
operator|.
name|getServerName
argument_list|()
argument_list|,
name|cb
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|NodeExistsException
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Node for "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|+
literal|" already exists"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception creating/setting node OFFLINE"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * @param state    * @return Plan for passed<code>state</code> (If none currently, it creates one or    * if no servers to assign, it returns null).    */
name|RegionPlan
name|getRegionPlan
parameter_list|(
specifier|final
name|RegionState
name|state
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
block|{
return|return
name|getRegionPlan
argument_list|(
name|state
argument_list|,
literal|null
argument_list|,
name|forceNewPlan
argument_list|)
return|;
block|}
comment|/**    * @param state    * @param serverToExclude Server to exclude (we know its bad). Pass null if    * all servers are thought to be assignable.    * @param forceNewPlan If true, then if an existing plan exists, a new plan    * will be generated.    * @return Plan for passed<code>state</code> (If none currently, it creates one or    * if no servers to assign, it returns null).    */
name|RegionPlan
name|getRegionPlan
parameter_list|(
specifier|final
name|RegionState
name|state
parameter_list|,
specifier|final
name|ServerName
name|serverToExclude
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
block|{
comment|// Pickup existing plan or make a new one
specifier|final
name|String
name|encodedName
init|=
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|destServers
init|=
name|serverManager
operator|.
name|createDestinationServersList
argument_list|(
name|serverToExclude
argument_list|)
decl_stmt|;
if|if
condition|(
name|destServers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can't move the region "
operator|+
name|encodedName
operator|+
literal|", there is no destination server available."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|RegionPlan
name|randomPlan
init|=
literal|null
decl_stmt|;
name|boolean
name|newPlan
init|=
literal|false
decl_stmt|;
name|RegionPlan
name|existingPlan
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|existingPlan
operator|=
name|this
operator|.
name|regionPlans
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|existingPlan
operator|!=
literal|null
operator|&&
name|existingPlan
operator|.
name|getDestination
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found an existing plan for "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" destination server is "
operator|+
name|existingPlan
operator|.
name|getDestination
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|forceNewPlan
operator|||
name|existingPlan
operator|==
literal|null
operator|||
name|existingPlan
operator|.
name|getDestination
argument_list|()
operator|==
literal|null
operator|||
operator|!
name|destServers
operator|.
name|contains
argument_list|(
name|existingPlan
operator|.
name|getDestination
argument_list|()
argument_list|)
condition|)
block|{
name|newPlan
operator|=
literal|true
expr_stmt|;
name|randomPlan
operator|=
operator|new
name|RegionPlan
argument_list|(
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
literal|null
argument_list|,
name|balancer
operator|.
name|randomAssignment
argument_list|(
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
name|destServers
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionPlans
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|randomPlan
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newPlan
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No previous transition plan was found (or we are ignoring "
operator|+
literal|"an existing plan) for "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" so generated a random one; "
operator|+
name|randomPlan
operator|+
literal|"; "
operator|+
name|serverManager
operator|.
name|countOfRegionServers
argument_list|()
operator|+
literal|" (online="
operator|+
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|", available="
operator|+
name|destServers
operator|.
name|size
argument_list|()
operator|+
literal|") available servers"
argument_list|)
expr_stmt|;
return|return
name|randomPlan
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using pre-existing plan for region "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|"; plan="
operator|+
name|existingPlan
argument_list|)
expr_stmt|;
return|return
name|existingPlan
return|;
block|}
comment|/**    * Loop through the deadNotExpired server list and remove them from the    * servers.    * @param servers    * @deprecated the method is now available in ServerManager - deprecated in 0.96    */
annotation|@
name|Deprecated
name|void
name|removeDeadNotExpiredServers
parameter_list|(
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|)
block|{
name|this
operator|.
name|serverManager
operator|.
name|removeDeadNotExpiredServers
argument_list|(
name|servers
argument_list|)
expr_stmt|;
block|}
comment|/**    * Unassign the list of regions. Configuration knobs:    * hbase.bulk.waitbetween.reopen indicates the number of milliseconds to    * wait before unassigning another region from this region server    *    * @param regions    * @throws InterruptedException    */
specifier|public
name|void
name|unassign
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
name|int
name|waitTime
init|=
name|this
operator|.
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.bulk.waitbetween.reopen"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
if|if
condition|(
name|isRegionInTransition
argument_list|(
name|region
argument_list|)
operator|!=
literal|null
condition|)
continue|continue;
name|unassign
argument_list|(
name|region
argument_list|,
literal|false
argument_list|)
expr_stmt|;
while|while
condition|(
name|isRegionInTransition
argument_list|(
name|region
argument_list|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Do nothing, continue
block|}
block|}
if|if
condition|(
name|waitTime
operator|>
literal|0
condition|)
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Do nothing, continue
block|}
block|}
block|}
comment|/**    * Unassigns the specified region.    *<p>    * Updates the RegionState and sends the CLOSE RPC unless region is being    * split by regionserver; then the unassign fails (silently) because we    * presume the region being unassigned no longer exists (its been split out    * of existence). TODO: What to do if split fails and is rolled back and    * parent is revivified?    *<p>    * If a RegionPlan is already set, it will remain.    *    * @param region server to be unassigned    */
specifier|public
name|void
name|unassign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
name|unassign
argument_list|(
name|region
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Unassigns the specified region.    *<p>    * Updates the RegionState and sends the CLOSE RPC unless region is being    * split by regionserver; then the unassign fails (silently) because we    * presume the region being unassigned no longer exists (its been split out    * of existence). TODO: What to do if split fails and is rolled back and    * parent is revivified?    *<p>    * If a RegionPlan is already set, it will remain.    *    * @param region server to be unassigned    * @param force if region should be closed even if already closing    */
specifier|public
name|void
name|unassign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|force
parameter_list|,
name|ServerName
name|dest
parameter_list|)
block|{
comment|// TODO: Method needs refactoring.  Ugly buried returns throughout.  Beware!
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting unassignment of region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" (offlining)"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
comment|// Check if this region is currently assigned
if|if
condition|(
operator|!
name|regions
operator|.
name|containsKey
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempted to unassign region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but it is not "
operator|+
literal|"currently assigned anywhere"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
comment|// Grab the state of this region and synchronize on it
name|RegionState
name|state
decl_stmt|;
name|int
name|versionOfClosingNode
init|=
operator|-
literal|1
decl_stmt|;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
name|state
operator|=
name|regionsInTransition
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
comment|// Create the znode in CLOSING state
try|try
block|{
name|versionOfClosingNode
operator|=
name|ZKAssign
operator|.
name|createNodeClosing
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|region
argument_list|,
name|master
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|versionOfClosingNode
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to unassign region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but ZK closing node "
operator|+
literal|"can't be created."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ee
parameter_list|)
block|{
name|Exception
name|e
init|=
name|ee
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|NodeExistsException
condition|)
block|{
comment|// Handle race between master initiated close and regionserver
comment|// orchestrated splitting. See if existing node is in a
comment|// SPLITTING or SPLIT state.  If so, the regionserver started
comment|// an op on node before we could get our CLOSING in.  Deal.
name|NodeExistsException
name|nee
init|=
operator|(
name|NodeExistsException
operator|)
name|e
decl_stmt|;
name|String
name|path
init|=
name|nee
operator|.
name|getPath
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isSplitOrSplitting
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|path
operator|+
literal|" is SPLIT or SPLITTING; "
operator|+
literal|"skipping unassign because region no longer exists -- its split"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|ke
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed getData on SPLITTING/SPLIT at "
operator|+
name|path
operator|+
literal|"; presuming split and that the region to unassign, "
operator|+
name|encodedName
operator|+
literal|", no longer exists -- confirm"
argument_list|,
name|ke
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected zk state"
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|de
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed parse"
argument_list|,
name|de
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If we get here, don't understand whats going on -- abort.
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception creating node CLOSING"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|state
operator|=
operator|new
name|RegionState
argument_list|(
name|region
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|PENDING_CLOSE
argument_list|)
expr_stmt|;
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force
operator|&&
operator|(
name|state
operator|.
name|isPendingClose
argument_list|()
operator|||
name|state
operator|.
name|isClosing
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to unassign region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" which is already "
operator|+
name|state
operator|.
name|getState
argument_list|()
operator|+
literal|" but forcing to send a CLOSE RPC again "
argument_list|)
expr_stmt|;
name|state
operator|.
name|update
argument_list|(
name|state
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to unassign region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but it is "
operator|+
literal|"already in transition ("
operator|+
name|state
operator|.
name|getState
argument_list|()
operator|+
literal|", force="
operator|+
name|force
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// Send CLOSE RPC
name|ServerName
name|server
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|server
operator|=
name|regions
operator|.
name|get
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
comment|// ClosedRegionhandler can remove the server from this.regions
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
comment|// Possibility of disable flow removing from RIT.
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
name|state
operator|=
name|regionsInTransition
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
comment|// remove only if the state is PENDING_CLOSE or CLOSING
name|State
name|presentState
init|=
name|state
operator|.
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
name|presentState
operator|==
name|State
operator|.
name|PENDING_CLOSE
operator|||
name|presentState
operator|==
name|State
operator|.
name|CLOSING
condition|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// delete the node. if no node exists need not bother.
name|deleteClosingOrClosedNode
argument_list|(
name|region
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
comment|// TODO: We should consider making this look more like it does for the
comment|// region open where we catch all throwables and never abort
if|if
condition|(
name|serverManager
operator|.
name|sendRegionClose
argument_list|(
name|server
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
name|versionOfClosingNode
argument_list|,
name|dest
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sent CLOSE to "
operator|+
name|server
operator|+
literal|" for region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// This never happens. Currently regionserver close always return true.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Server "
operator|+
name|server
operator|+
literal|" region CLOSE RPC returned false for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|RemoteException
condition|)
block|{
name|t
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|t
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|NotServingRegionException
condition|)
block|{
comment|// Presume that master has stale data.  Presume remote side just split.
comment|// Presume that the split message when it comes in will fix up the master's
comment|// in memory cluster state.
if|if
condition|(
name|checkIfRegionBelongsToDisabling
argument_list|(
name|region
argument_list|)
condition|)
block|{
comment|// Remove from the regionsinTransition map
name|LOG
operator|.
name|info
argument_list|(
literal|"While trying to recover the table "
operator|+
name|region
operator|.
name|getTableNameAsString
argument_list|()
operator|+
literal|" to DISABLED state the region "
operator|+
name|region
operator|+
literal|" was offlined but the table was in DISABLING state"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|remove
argument_list|(
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Remove from the regionsMap
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|this
operator|.
name|regions
operator|.
name|remove
argument_list|(
name|region
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|serverRegions
init|=
name|this
operator|.
name|servers
operator|.
name|get
argument_list|(
name|server
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|serverRegions
operator|.
name|remove
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No "
operator|+
name|region
operator|+
literal|" on "
operator|+
name|server
argument_list|)
expr_stmt|;
block|}
block|}
name|deleteClosingOrClosedNode
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|instanceof
name|RegionAlreadyInTransitionException
condition|)
block|{
comment|// RS is already processing this region, only need to update the timestamp
name|LOG
operator|.
name|debug
argument_list|(
literal|"update "
operator|+
name|state
operator|+
literal|" the timestamp."
argument_list|)
expr_stmt|;
name|state
operator|.
name|update
argument_list|(
name|state
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Server "
operator|+
name|server
operator|+
literal|" returned "
operator|+
name|t
operator|+
literal|" for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// Presume retry or server will expire.
block|}
block|}
specifier|public
name|void
name|unassign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
name|unassign
argument_list|(
name|region
argument_list|,
name|force
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    *     * @param region regioninfo of znode to be deleted.    */
specifier|public
name|void
name|deleteClosingOrClosedNode
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|ZKAssign
operator|.
name|deleteNode
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|EventHandler
operator|.
name|EventType
operator|.
name|M_ZK_REGION_CLOSING
argument_list|)
condition|)
block|{
name|boolean
name|deleteNode
init|=
name|ZKAssign
operator|.
name|deleteNode
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|EventHandler
operator|.
name|EventType
operator|.
name|RS_ZK_REGION_CLOSED
argument_list|)
decl_stmt|;
comment|// TODO : We don't abort if the delete node returns false. Is there any
comment|// such corner case?
if|if
condition|(
operator|!
name|deleteNode
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The deletion of the CLOSED node for the region "
operator|+
name|region
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" returned "
operator|+
name|deleteNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NoNodeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"CLOSING/CLOSED node for the region "
operator|+
name|region
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" already deleted"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception deleting node CLOSING/CLOSED for the region "
operator|+
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|ke
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/**    * @param path    * @return True if znode is in SPLIT or SPLITTING state.    * @throws KeeperException Can happen if the znode went away in meantime.    * @throws DeserializationException     */
specifier|private
name|boolean
name|isSplitOrSplitting
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|DeserializationException
block|{
name|boolean
name|result
init|=
literal|false
decl_stmt|;
comment|// This may fail if the SPLIT or SPLITTING znode gets cleaned up before we
comment|// can get data from it.
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|RegionTransition
name|rt
init|=
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rt
operator|.
name|getEventType
argument_list|()
condition|)
block|{
case|case
name|RS_ZK_REGION_SPLIT
case|:
case|case
name|RS_ZK_REGION_SPLITTING
case|:
name|result
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Waits until the specified region has completed assignment.    *<p>    * If the region is already assigned, returns immediately.  Otherwise, method    * blocks until the region is assigned.    * @param regionInfo region to wait on assignment for    * @throws InterruptedException    */
specifier|public
name|void
name|waitForAssignment
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|InterruptedException
block|{
synchronized|synchronized
init|(
name|regions
init|)
block|{
while|while
condition|(
operator|!
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
operator|!
name|regions
operator|.
name|containsKey
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
comment|// We should receive a notification, but it's
comment|//  better to have a timeout to recheck the condition here:
comment|//  it lowers the impact of a race condition if any
name|regions
operator|.
name|wait
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Assigns the ROOT region.    *<p>    * Assumes that ROOT is currently closed and is not being actively served by    * any RegionServer.    *<p>    * Forcibly unsets the current root region location in ZooKeeper and assigns    * ROOT to a random RegionServer.    * @throws KeeperException    */
specifier|public
name|void
name|assignRoot
parameter_list|()
throws|throws
name|KeeperException
block|{
name|RootRegionTracker
operator|.
name|deleteRootLocation
argument_list|(
name|this
operator|.
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assigns the META region.    *<p>    * Assumes that META is currently closed and is not being actively served by    * any RegionServer.    *<p>    * Forcibly assigns META to a random RegionServer.    */
specifier|public
name|void
name|assignMeta
parameter_list|()
block|{
comment|// Force assignment to a random server
name|assign
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assigns all user regions to online servers. Use round-robin assignment.    *     * @param regions    * @throws IOException    * @throws InterruptedException    */
specifier|public
name|void
name|assignUserRegionsToOnlineServers
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|destServers
init|=
name|serverManager
operator|.
name|createDestinationServersList
argument_list|()
decl_stmt|;
name|assignUserRegions
argument_list|(
name|regions
argument_list|,
name|destServers
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assigns all user regions, if any.  Used during cluster startup.    *<p>    * This is a synchronous call and will return once every region has been    * assigned.  If anything fails, an exception is thrown    * @throws InterruptedException    * @throws IOException    */
specifier|public
name|void
name|assignUserRegions
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|regions
operator|==
literal|null
condition|)
return|return;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
init|=
literal|null
decl_stmt|;
comment|// Generate a round-robin bulk assignment plan
name|bulkPlan
operator|=
name|balancer
operator|.
name|roundRobinAssignment
argument_list|(
name|regions
argument_list|,
name|servers
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Bulk assigning "
operator|+
name|regions
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) round-robin across "
operator|+
name|servers
operator|.
name|size
argument_list|()
operator|+
literal|" server(s)"
argument_list|)
expr_stmt|;
comment|// Use fixed count thread pool assigning.
name|BulkAssigner
name|ba
init|=
operator|new
name|StartupBulkAssigner
argument_list|(
name|this
operator|.
name|master
argument_list|,
name|bulkPlan
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|ba
operator|.
name|bulkAssign
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Bulk assigning done"
argument_list|)
expr_stmt|;
block|}
comment|// TODO: This method seems way wrong.  Why would we mark a table enabled based
comment|// off a single region?  We seem to call this on bulk assign on startup which
comment|// isn't too bad but then its also called in assign.  It makes the enabled
comment|// flag up in zk meaningless.  St.Ack
specifier|private
name|void
name|setEnabledTable
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|String
name|tableName
init|=
name|hri
operator|.
name|getTableNameAsString
argument_list|()
decl_stmt|;
name|boolean
name|isTableEnabled
init|=
name|this
operator|.
name|zkTable
operator|.
name|isEnabledTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isTableEnabled
condition|)
block|{
name|setEnabledTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Assigns all user regions, if any exist.  Used during cluster startup.    *<p>    * This is a synchronous call and will return once every region has been    * assigned.  If anything fails, an exception is thrown and the cluster    * should be shutdown.    * @throws InterruptedException    * @throws IOException    */
specifier|public
name|void
name|assignAllUserRegions
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// Get all available servers
name|List
argument_list|<
name|ServerName
argument_list|>
name|destServers
init|=
name|serverManager
operator|.
name|createDestinationServersList
argument_list|()
decl_stmt|;
comment|// If there are no servers we need not proceed with region assignment.
if|if
condition|(
name|destServers
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// Scan META for all user regions, skipping any disabled tables
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|allRegions
init|=
name|MetaReader
operator|.
name|fullScan
argument_list|(
name|catalogTracker
argument_list|,
name|this
operator|.
name|zkTable
operator|.
name|getDisabledTables
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|allRegions
operator|==
literal|null
operator|||
name|allRegions
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// Determine what type of assignment to do on startup
name|boolean
name|retainAssignment
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.startup.retainassign"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|retainAssignment
condition|)
block|{
comment|// Reuse existing assignment info
name|bulkPlan
operator|=
name|balancer
operator|.
name|retainAssignment
argument_list|(
name|allRegions
argument_list|,
name|destServers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// assign regions in round-robin fashion
name|assignUserRegions
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|allRegions
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|,
name|destServers
argument_list|)
expr_stmt|;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|allRegions
operator|.
name|keySet
argument_list|()
control|)
block|{
name|setEnabledTable
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Bulk assigning "
operator|+
name|allRegions
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) across "
operator|+
name|destServers
operator|.
name|size
argument_list|()
operator|+
literal|" server(s), retainAssignment="
operator|+
name|retainAssignment
argument_list|)
expr_stmt|;
comment|// Use fixed count thread pool assigning.
name|BulkAssigner
name|ba
init|=
operator|new
name|StartupBulkAssigner
argument_list|(
name|this
operator|.
name|master
argument_list|,
name|bulkPlan
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|ba
operator|.
name|bulkAssign
argument_list|()
expr_stmt|;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|allRegions
operator|.
name|keySet
argument_list|()
control|)
block|{
name|setEnabledTable
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Bulk assigning done"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run bulk assign on startup.  Does one RCP per regionserver passing a    * batch of reginons using {@link SingleServerBulkAssigner}.    * Uses default {@link #getUncaughtExceptionHandler()}    * which will abort the Server if exception.    */
specifier|static
class|class
name|StartupBulkAssigner
extends|extends
name|BulkAssigner
block|{
specifier|final
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
decl_stmt|;
specifier|final
name|AssignmentManager
name|assignmentManager
decl_stmt|;
name|StartupBulkAssigner
parameter_list|(
specifier|final
name|Server
name|server
parameter_list|,
specifier|final
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
parameter_list|,
specifier|final
name|AssignmentManager
name|am
parameter_list|)
block|{
name|super
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|this
operator|.
name|bulkPlan
operator|=
name|bulkPlan
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|=
name|am
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|bulkAssign
parameter_list|(
name|boolean
name|sync
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
comment|// Disable timing out regions in transition up in zk while bulk assigning.
name|this
operator|.
name|assignmentManager
operator|.
name|timeoutMonitor
operator|.
name|bulkAssign
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|bulkAssign
argument_list|(
name|sync
argument_list|)
return|;
block|}
finally|finally
block|{
comment|// Reenable timing out regions in transition up in zi.
name|this
operator|.
name|assignmentManager
operator|.
name|timeoutMonitor
operator|.
name|bulkAssign
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getThreadNamePrefix
parameter_list|()
block|{
return|return
name|this
operator|.
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|"-StartupBulkAssigner"
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|populatePool
parameter_list|(
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
name|pool
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|e
range|:
name|this
operator|.
name|bulkPlan
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|pool
operator|.
name|execute
argument_list|(
operator|new
name|SingleServerBulkAssigner
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
name|this
operator|.
name|assignmentManager
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|boolean
name|waitUntilDone
parameter_list|(
specifier|final
name|long
name|timeout
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|regionSet
init|=
operator|new
name|HashSet
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regionList
range|:
name|bulkPlan
operator|.
name|values
argument_list|()
control|)
block|{
name|regionSet
operator|.
name|addAll
argument_list|(
name|regionList
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|assignmentManager
operator|.
name|waitUntilNoRegionsInTransition
argument_list|(
name|timeout
argument_list|,
name|regionSet
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|long
name|getTimeoutOnRIT
parameter_list|()
block|{
comment|// Guess timeout.  Multiply the number of regions on a random server
comment|// by how long we thing one region takes opening.
name|long
name|perRegionOpenTimeGuesstimate
init|=
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"hbase.bulk.assignment.perregion.open.time"
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|int
name|regionsPerServer
init|=
name|this
operator|.
name|bulkPlan
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|long
name|timeout
init|=
name|perRegionOpenTimeGuesstimate
operator|*
name|regionsPerServer
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Timeout-on-RIT="
operator|+
name|timeout
argument_list|)
expr_stmt|;
return|return
name|timeout
return|;
block|}
block|}
comment|/**    * Bulk user region assigner.    * If failed assign, lets timeout in RIT do cleanup.    */
specifier|static
class|class
name|GeneralBulkAssigner
extends|extends
name|StartupBulkAssigner
block|{
name|GeneralBulkAssigner
parameter_list|(
specifier|final
name|Server
name|server
parameter_list|,
specifier|final
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
parameter_list|,
specifier|final
name|AssignmentManager
name|am
parameter_list|)
block|{
name|super
argument_list|(
name|server
argument_list|,
name|bulkPlan
argument_list|,
name|am
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|UncaughtExceptionHandler
name|getUncaughtExceptionHandler
parameter_list|()
block|{
return|return
operator|new
name|UncaughtExceptionHandler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|uncaughtException
parameter_list|(
name|Thread
name|t
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Assigning regions in "
operator|+
name|t
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
comment|/**    * Manage bulk assigning to a server.    */
specifier|static
class|class
name|SingleServerBulkAssigner
implements|implements
name|Runnable
block|{
specifier|private
specifier|final
name|ServerName
name|regionserver
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
decl_stmt|;
specifier|private
specifier|final
name|AssignmentManager
name|assignmentManager
decl_stmt|;
name|SingleServerBulkAssigner
parameter_list|(
specifier|final
name|ServerName
name|regionserver
parameter_list|,
specifier|final
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|,
specifier|final
name|AssignmentManager
name|am
parameter_list|)
block|{
name|this
operator|.
name|regionserver
operator|=
name|regionserver
expr_stmt|;
name|this
operator|.
name|regions
operator|=
name|regions
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|=
name|am
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|assign
argument_list|(
name|this
operator|.
name|regionserver
argument_list|,
name|this
operator|.
name|regions
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Wait until no regions in transition.    * @param timeout How long to wait.    * @return True if nothing in regions in transition.    * @throws InterruptedException    */
name|boolean
name|waitUntilNoRegionsInTransition
parameter_list|(
specifier|final
name|long
name|timeout
parameter_list|)
throws|throws
name|InterruptedException
block|{
comment|// Blocks until there are no regions in transition. It is possible that
comment|// there
comment|// are regions in transition immediately after this returns but guarantees
comment|// that if it returns without an exception that there was a period of time
comment|// with no regions in transition from the point-of-view of the in-memory
comment|// state of the Master.
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|remaining
init|=
name|timeout
decl_stmt|;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
while|while
condition|(
name|regionsInTransition
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
name|remaining
operator|>
literal|0
condition|)
block|{
name|regionsInTransition
operator|.
name|wait
argument_list|(
name|remaining
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|timeout
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
expr_stmt|;
block|}
block|}
return|return
name|regionsInTransition
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Wait until no regions from set regions are in transition.    * @param timeout How long to wait.    * @param regions set of regions to wait for    * @return True if nothing in regions in transition.    * @throws InterruptedException    */
name|boolean
name|waitUntilNoRegionsInTransition
parameter_list|(
specifier|final
name|long
name|timeout
parameter_list|,
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
throws|throws
name|InterruptedException
block|{
comment|// Blocks until there are no regions in transition.
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|remaining
init|=
name|timeout
decl_stmt|;
name|boolean
name|stillInTransition
init|=
literal|true
decl_stmt|;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
while|while
condition|(
name|regionsInTransition
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
name|remaining
operator|>
literal|0
operator|&&
name|stillInTransition
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RegionState
name|rs
range|:
name|regionsInTransition
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|regions
operator|.
name|contains
argument_list|(
name|rs
operator|.
name|getRegion
argument_list|()
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|stillInTransition
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|regionsInTransition
operator|.
name|wait
argument_list|(
name|remaining
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|timeout
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
expr_stmt|;
block|}
block|}
return|return
name|stillInTransition
return|;
block|}
comment|/**    * Rebuild the list of user regions and assignment information.    *<p>    * Returns a map of servers that are not found to be online and the regions    * they were hosting.    * @param onlineServers if one region's location belongs to onlineServers, it    *          doesn't need to be assigned.    * @return map of servers not online to their assigned regions, as stored    *         in META    * @throws IOException    */
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|rebuildUserRegions
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
comment|// Region assignment from META
name|List
argument_list|<
name|Result
argument_list|>
name|results
init|=
name|MetaReader
operator|.
name|fullScan
argument_list|(
name|this
operator|.
name|catalogTracker
argument_list|)
decl_stmt|;
comment|// Get any new but slow to checkin region server that joined the cluster
name|Set
argument_list|<
name|ServerName
argument_list|>
name|onlineServers
init|=
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|keySet
argument_list|()
decl_stmt|;
comment|// Map of offline servers and their regions to be returned
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|offlineServers
init|=
operator|new
name|TreeMap
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// Iterate regions in META
for|for
control|(
name|Result
name|result
range|:
name|results
control|)
block|{
name|boolean
name|disabled
init|=
literal|false
decl_stmt|;
name|boolean
name|disablingOrEnabling
init|=
literal|false
decl_stmt|;
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|region
init|=
name|MetaReader
operator|.
name|parseCatalogResult
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
continue|continue;
name|HRegionInfo
name|regionInfo
init|=
name|region
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|ServerName
name|regionLocation
init|=
name|region
operator|.
name|getSecond
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionInfo
operator|==
literal|null
condition|)
continue|continue;
name|String
name|tableName
init|=
name|regionInfo
operator|.
name|getTableNameAsString
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionLocation
operator|==
literal|null
condition|)
block|{
comment|// regionLocation could be null if createTable didn't finish properly.
comment|// When createTable is in progress, HMaster restarts.
comment|// Some regions have been added to .META., but have not been assigned.
comment|// When this happens, the region's table must be in ENABLING state.
comment|// It can't be in ENABLED state as that is set when all regions are
comment|// assigned.
comment|// It can't be in DISABLING state, because DISABLING state transitions
comment|// from ENABLED state when application calls disableTable.
comment|// It can't be in DISABLED state, because DISABLED states transitions
comment|// from DISABLING state.
if|if
condition|(
literal|false
operator|==
name|checkIfRegionsBelongsToEnabling
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" has null regionLocation."
operator|+
literal|" But its table "
operator|+
name|tableName
operator|+
literal|" isn't in ENABLING state."
argument_list|)
expr_stmt|;
block|}
name|addTheTablesInPartialState
argument_list|(
name|this
operator|.
name|disablingTables
argument_list|,
name|this
operator|.
name|enablingTables
argument_list|,
name|regionInfo
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|onlineServers
operator|.
name|contains
argument_list|(
name|regionLocation
argument_list|)
condition|)
block|{
comment|// Region is located on a server that isn't online
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
name|offlineRegions
init|=
name|offlineServers
operator|.
name|get
argument_list|(
name|regionLocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|offlineRegions
operator|==
literal|null
condition|)
block|{
name|offlineRegions
operator|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|offlineServers
operator|.
name|put
argument_list|(
name|regionLocation
argument_list|,
name|offlineRegions
argument_list|)
expr_stmt|;
block|}
name|offlineRegions
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|(
name|regionInfo
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|disabled
operator|=
name|checkIfRegionBelongsToDisabled
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|disablingOrEnabling
operator|=
name|addTheTablesInPartialState
argument_list|(
name|this
operator|.
name|disablingTables
argument_list|,
name|this
operator|.
name|enablingTables
argument_list|,
name|regionInfo
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
comment|// need to enable the table if not disabled or disabling or enabling
comment|// this will be used in rolling restarts
name|enableTableIfNotDisabledOrDisablingOrEnabling
argument_list|(
name|disabled
argument_list|,
name|disablingOrEnabling
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If region is in offline and split state check the ZKNode
if|if
condition|(
name|regionInfo
operator|.
name|isOffline
argument_list|()
operator|&&
name|regionInfo
operator|.
name|isSplit
argument_list|()
condition|)
block|{
name|String
name|node
init|=
name|ZKAssign
operator|.
name|getNodeName
argument_list|(
name|this
operator|.
name|watcher
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|ZKUtil
operator|.
name|getDataNoWatch
argument_list|(
name|this
operator|.
name|watcher
argument_list|,
name|node
argument_list|,
name|stat
argument_list|)
decl_stmt|;
comment|// If znode does not exist dont consider this region
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" split is completed. Hence need not add to regions list"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|// Region is being served and on an active server
comment|// add only if region not in disabled and enabling table
if|if
condition|(
literal|false
operator|==
name|checkIfRegionBelongsToDisabled
argument_list|(
name|regionInfo
argument_list|)
operator|&&
literal|false
operator|==
name|checkIfRegionsBelongsToEnabling
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
name|regions
operator|.
name|put
argument_list|(
name|regionInfo
argument_list|,
name|regionLocation
argument_list|)
expr_stmt|;
name|addToServers
argument_list|(
name|regionLocation
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
block|}
name|disablingOrEnabling
operator|=
name|addTheTablesInPartialState
argument_list|(
name|this
operator|.
name|disablingTables
argument_list|,
name|this
operator|.
name|enablingTables
argument_list|,
name|regionInfo
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|disabled
operator|=
name|checkIfRegionBelongsToDisabled
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
comment|// need to enable the table if not disabled or disabling or enabling
comment|// this will be used in rolling restarts
name|enableTableIfNotDisabledOrDisablingOrEnabling
argument_list|(
name|disabled
argument_list|,
name|disablingOrEnabling
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|offlineServers
return|;
block|}
specifier|private
name|void
name|enableTableIfNotDisabledOrDisablingOrEnabling
parameter_list|(
name|boolean
name|disabled
parameter_list|,
name|boolean
name|disablingOrEnabling
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|disabled
operator|&&
operator|!
name|disablingOrEnabling
operator|&&
operator|!
name|getZKTable
argument_list|()
operator|.
name|isEnabledTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|setEnabledTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Boolean
name|addTheTablesInPartialState
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|disablingTables
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|enablingTables
parameter_list|,
name|HRegionInfo
name|regionInfo
parameter_list|,
name|String
name|disablingTableName
parameter_list|)
block|{
if|if
condition|(
name|checkIfRegionBelongsToDisabling
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
name|disablingTables
operator|.
name|add
argument_list|(
name|disablingTableName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|checkIfRegionsBelongsToEnabling
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
name|enablingTables
operator|.
name|add
argument_list|(
name|disablingTableName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Recover the tables that were not fully moved to DISABLED state. These    * tables are in DISABLING state when the master restarted/switched.    *     * @param disablingTables    * @return    * @throws KeeperException    * @throws TableNotFoundException    * @throws IOException    */
specifier|private
name|boolean
name|recoverTableInDisablingState
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|disablingTables
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|TableNotFoundException
throws|,
name|IOException
block|{
name|boolean
name|isWatcherCreated
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|disablingTables
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// Create a watcher on the zookeeper node
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|assignmentZNode
argument_list|)
expr_stmt|;
name|isWatcherCreated
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|String
name|tableName
range|:
name|disablingTables
control|)
block|{
comment|// Recover by calling DisableTableHandler
name|LOG
operator|.
name|info
argument_list|(
literal|"The table "
operator|+
name|tableName
operator|+
literal|" is in DISABLING state.  Hence recovering by moving the table"
operator|+
literal|" to DISABLED state."
argument_list|)
expr_stmt|;
operator|new
name|DisableTableHandler
argument_list|(
name|this
operator|.
name|master
argument_list|,
name|tableName
operator|.
name|getBytes
argument_list|()
argument_list|,
name|catalogTracker
argument_list|,
name|this
argument_list|,
literal|true
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|isWatcherCreated
return|;
block|}
comment|/**    * Recover the tables that are not fully moved to ENABLED state. These tables    * are in ENABLING state when the master restarted/switched    *     * @param enablingTables    * @param isWatcherCreated    * @throws KeeperException    * @throws TableNotFoundException    * @throws IOException    */
specifier|private
name|void
name|recoverTableInEnablingState
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|enablingTables
parameter_list|,
name|boolean
name|isWatcherCreated
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|TableNotFoundException
throws|,
name|IOException
block|{
if|if
condition|(
name|enablingTables
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
literal|false
operator|==
name|isWatcherCreated
condition|)
block|{
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|assignmentZNode
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|tableName
range|:
name|enablingTables
control|)
block|{
comment|// Recover by calling EnableTableHandler
name|LOG
operator|.
name|info
argument_list|(
literal|"The table "
operator|+
name|tableName
operator|+
literal|" is in ENABLING state.  Hence recovering by moving the table"
operator|+
literal|" to ENABLED state."
argument_list|)
expr_stmt|;
comment|// enableTable in sync way during master startup,
comment|// no need to invoke coprocessor
operator|new
name|EnableTableHandler
argument_list|(
name|this
operator|.
name|master
argument_list|,
name|tableName
operator|.
name|getBytes
argument_list|()
argument_list|,
name|catalogTracker
argument_list|,
name|this
argument_list|,
literal|true
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|checkIfRegionsBelongsToEnabling
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|String
name|tableName
init|=
name|regionInfo
operator|.
name|getTableNameAsString
argument_list|()
decl_stmt|;
return|return
name|getZKTable
argument_list|()
operator|.
name|isEnablingTable
argument_list|(
name|tableName
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|checkIfRegionBelongsToDisabled
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|String
name|tableName
init|=
name|regionInfo
operator|.
name|getTableNameAsString
argument_list|()
decl_stmt|;
return|return
name|getZKTable
argument_list|()
operator|.
name|isDisabledTable
argument_list|(
name|tableName
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|checkIfRegionBelongsToDisabling
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|String
name|tableName
init|=
name|regionInfo
operator|.
name|getTableNameAsString
argument_list|()
decl_stmt|;
return|return
name|getZKTable
argument_list|()
operator|.
name|isDisablingTable
argument_list|(
name|tableName
argument_list|)
return|;
block|}
comment|/**    * Processes list of dead servers from result of META scan and regions in RIT    *<p>    * This is used for failover to recover the lost regions that belonged to    * RegionServers which failed while there was no active master or regions     * that were in RIT.    *<p>    *     * @param deadServers    *          The list of dead servers which failed while there was no active    *          master. Can be null.    * @param nodes    *          The regions in RIT    * @throws IOException    * @throws KeeperException    */
specifier|private
name|void
name|processDeadServersAndRecoverLostRegions
parameter_list|(
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|deadServers
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|nodes
parameter_list|)
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
name|processDeadServers
argument_list|(
name|deadServers
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|encodedRegionName
range|:
name|nodes
control|)
block|{
name|processRegionInTransition
argument_list|(
name|encodedRegionName
argument_list|,
literal|null
argument_list|,
name|deadServers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|processDeadServers
parameter_list|(
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|deadServers
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|nodes
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
if|if
condition|(
name|deadServers
operator|==
literal|null
condition|)
return|return;
name|Set
argument_list|<
name|ServerName
argument_list|>
name|actualDeadServers
init|=
name|this
operator|.
name|serverManager
operator|.
name|getDeadServers
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|deadServer
range|:
name|deadServers
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// skip regions of dead servers because SSH will process regions during rs expiration.
comment|// see HBASE-5916
if|if
condition|(
name|actualDeadServers
operator|.
name|contains
argument_list|(
name|deadServer
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
name|regions
init|=
name|deadServer
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
name|region
range|:
name|regions
control|)
block|{
name|HRegionInfo
name|regionInfo
init|=
name|region
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|Result
name|result
init|=
name|region
operator|.
name|getSecond
argument_list|()
decl_stmt|;
try|try
block|{
comment|// If region was in transition (was in zk) force it offline for reassign.  Check if node
comment|// up in zk at all first.
if|if
condition|(
name|ZKUtil
operator|.
name|checkExists
argument_list|(
name|this
operator|.
name|watcher
argument_list|,
name|ZKAssign
operator|.
name|getPath
argument_list|(
name|this
operator|.
name|watcher
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|watcher
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No data in znode for "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RegionTransition
name|rt
decl_stmt|;
try|try
block|{
name|rt
operator|=
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed parse of znode data for "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// If zk node of this region has been updated by a live server,
comment|// we consider that this region is being handled.
comment|// So we should skip it and process it in processRegionsInTransition.
name|ServerName
name|sn
init|=
name|rt
operator|.
name|getServerName
argument_list|()
decl_stmt|;
if|if
condition|(
name|isServerOnline
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The region "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|"is being handled on "
operator|+
name|sn
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|// Process with existing RS shutdown code
name|boolean
name|assign
init|=
name|ServerShutdownHandler
operator|.
name|processDeadRegion
argument_list|(
name|regionInfo
argument_list|,
name|result
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|catalogTracker
argument_list|)
decl_stmt|;
if|if
condition|(
name|assign
condition|)
block|{
name|ZKAssign
operator|.
name|createOrForceNodeOffline
argument_list|(
name|watcher
argument_list|,
name|regionInfo
argument_list|,
name|master
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nodes
operator|.
name|contains
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{
comment|// This is fine
block|}
block|}
block|}
block|}
comment|/*    * Presumes caller has taken care of necessary locking modifying servers Map.    * @param hsi    * @param hri    */
specifier|private
name|void
name|addToServers
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|hris
init|=
name|servers
operator|.
name|get
argument_list|(
name|sn
argument_list|)
decl_stmt|;
if|if
condition|(
name|hris
operator|==
literal|null
condition|)
block|{
name|hris
operator|=
operator|new
name|ConcurrentSkipListSet
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
expr_stmt|;
name|servers
operator|.
name|put
argument_list|(
name|sn
argument_list|,
name|hris
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hris
operator|.
name|contains
argument_list|(
name|hri
argument_list|)
condition|)
name|hris
operator|.
name|add
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return A copy of the Map of regions currently in transition.    */
specifier|public
name|NavigableMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|getRegionsInTransition
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
return|return
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
argument_list|(
name|this
operator|.
name|regionsInTransition
argument_list|)
return|;
block|}
block|}
comment|/**    * Set Regions in transitions metrics.    * This takes an iterator on the RegionInTransition map (CLSM), and is not synchronized.    * This iterator is not fail fast, wich may lead to stale read; but that's better than    * creating a copy of the map for metrics computation, as this method will be invoked    * on a frequent interval.    */
specifier|public
name|void
name|updateRegionsInTransitionMetrics
parameter_list|()
block|{
name|long
name|currentTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|totalRITs
init|=
literal|0
decl_stmt|;
name|int
name|totalRITsOverThreshold
init|=
literal|0
decl_stmt|;
name|long
name|oldestRITTime
init|=
literal|0
decl_stmt|;
name|int
name|ritThreshold
init|=
name|this
operator|.
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|METRICS_RIT_STUCK_WARNING_THRESHOLD
argument_list|,
literal|60000
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|e
range|:
name|this
operator|.
name|regionsInTransition
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|totalRITs
operator|++
expr_stmt|;
name|long
name|ritTime
init|=
name|currentTime
operator|-
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|ritTime
operator|>
name|ritThreshold
condition|)
block|{
comment|// more than the threshold
name|totalRITsOverThreshold
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|oldestRITTime
operator|<
name|ritTime
condition|)
block|{
name|oldestRITTime
operator|=
name|ritTime
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|masterMetrics
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|masterMetrics
operator|.
name|updateRITOldestAge
argument_list|(
name|oldestRITTime
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterMetrics
operator|.
name|updateRITCount
argument_list|(
name|totalRITs
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterMetrics
operator|.
name|updateRITCountOverThreshold
argument_list|(
name|totalRITsOverThreshold
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return True if regions in transition.    */
specifier|public
name|boolean
name|isRegionsInTransition
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
return|return
operator|!
name|this
operator|.
name|regionsInTransition
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
comment|/**    * @param hri Region to check.    * @return Returns null if passed region is not in transition else the current    * RegionState    */
specifier|public
name|RegionState
name|isRegionInTransition
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
return|return
name|this
operator|.
name|regionsInTransition
operator|.
name|get
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * @param region Region whose plan we are to clear.    */
name|void
name|clearRegionPlan
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|this
operator|.
name|regionPlans
operator|.
name|remove
argument_list|(
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Wait on region to clear regions-in-transition.    * @param hri Region to wait on.    * @throws IOException    */
specifier|public
name|void
name|waitOnRegionToClearRegionsInTransition
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isRegionInTransition
argument_list|(
name|hri
argument_list|)
operator|==
literal|null
condition|)
return|return;
name|RegionState
name|rs
init|=
literal|null
decl_stmt|;
comment|// There is already a timeout monitor on regions in transition so I
comment|// should not have to have one here too?
while|while
condition|(
operator|!
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
operator|(
name|rs
operator|=
name|isRegionInTransition
argument_list|(
name|hri
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|Threads
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting on "
operator|+
name|rs
operator|+
literal|" to clear regions-in-transition"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Giving up wait on regions in "
operator|+
literal|"transition because stoppable.isStopped is set"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Gets the online regions of the specified table.    * This method looks at the in-memory state.  It does not go to<code>.META.</code>.    * Only returns<em>online</em> regions.  If a region on this table has been    * closed during a disable, etc., it will be included in the returned list.    * So, the returned list may not necessarily be ALL regions in this table, its    * all the ONLINE regions in the table.    * @param tableName    * @return Online regions from<code>tableName</code>    */
specifier|public
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|getRegionsOfTable
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|tableRegions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// boundary needs to have table's name but regionID 0 so that it is sorted
comment|// before all table's regions.
name|HRegionInfo
name|boundary
init|=
operator|new
name|HRegionInfo
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
for|for
control|(
name|HRegionInfo
name|regionInfo
range|:
name|this
operator|.
name|regions
operator|.
name|tailMap
argument_list|(
name|boundary
argument_list|)
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|regionInfo
operator|.
name|getTableName
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
name|tableRegions
operator|.
name|add
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
return|return
name|tableRegions
return|;
block|}
comment|/**    * Update timers for all regions in transition going against the server in the    * serversInUpdatingTimer.    */
specifier|public
class|class
name|TimerUpdater
extends|extends
name|Chore
block|{
specifier|public
name|TimerUpdater
parameter_list|(
specifier|final
name|int
name|period
parameter_list|,
specifier|final
name|Stoppable
name|stopper
parameter_list|)
block|{
name|super
argument_list|(
literal|"AssignmentTimerUpdater"
argument_list|,
name|period
argument_list|,
name|stopper
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
name|ServerName
name|serverToUpdateTimer
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|!
name|serversInUpdatingTimer
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|stopper
operator|.
name|isStopped
argument_list|()
condition|)
block|{
if|if
condition|(
name|serverToUpdateTimer
operator|==
literal|null
condition|)
block|{
name|serverToUpdateTimer
operator|=
name|serversInUpdatingTimer
operator|.
name|first
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|serverToUpdateTimer
operator|=
name|serversInUpdatingTimer
operator|.
name|higher
argument_list|(
name|serverToUpdateTimer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serverToUpdateTimer
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|updateTimers
argument_list|(
name|serverToUpdateTimer
argument_list|)
expr_stmt|;
name|serversInUpdatingTimer
operator|.
name|remove
argument_list|(
name|serverToUpdateTimer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Monitor to check for time outs on region transition operations    */
specifier|public
class|class
name|TimeoutMonitor
extends|extends
name|Chore
block|{
specifier|private
specifier|final
name|int
name|timeout
decl_stmt|;
specifier|private
name|boolean
name|bulkAssign
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|allRegionServersOffline
init|=
literal|false
decl_stmt|;
specifier|private
name|ServerManager
name|serverManager
decl_stmt|;
comment|/**      * Creates a periodic monitor to check for time outs on region transition      * operations.  This will deal with retries if for some reason something      * doesn't happen within the specified timeout.      * @param period    * @param stopper When {@link Stoppable#isStopped()} is true, this thread will    * cleanup and exit cleanly.      * @param timeout      */
specifier|public
name|TimeoutMonitor
parameter_list|(
specifier|final
name|int
name|period
parameter_list|,
specifier|final
name|Stoppable
name|stopper
parameter_list|,
name|ServerManager
name|serverManager
parameter_list|,
specifier|final
name|int
name|timeout
parameter_list|)
block|{
name|super
argument_list|(
literal|"AssignmentTimeoutMonitor"
argument_list|,
name|period
argument_list|,
name|stopper
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
name|serverManager
expr_stmt|;
block|}
comment|/**      * @param bulkAssign If true, we'll suspend checking regions in transition      * up in zookeeper.  If false, will reenable check.      * @return Old setting for bulkAssign.      */
specifier|public
name|boolean
name|bulkAssign
parameter_list|(
specifier|final
name|boolean
name|bulkAssign
parameter_list|)
block|{
name|boolean
name|result
init|=
name|this
operator|.
name|bulkAssign
decl_stmt|;
name|this
operator|.
name|bulkAssign
operator|=
name|bulkAssign
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
specifier|synchronized
name|void
name|setAllRegionServersOffline
parameter_list|(
name|boolean
name|allRegionServersOffline
parameter_list|)
block|{
name|this
operator|.
name|allRegionServersOffline
operator|=
name|allRegionServersOffline
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
comment|// If bulkAssign in progress, suspend checks
if|if
condition|(
name|this
operator|.
name|bulkAssign
condition|)
return|return;
name|boolean
name|noRSAvailable
init|=
name|this
operator|.
name|serverManager
operator|.
name|createDestinationServersList
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
comment|// Iterate all regions in transition checking for time outs
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|RegionState
name|regionState
range|:
name|regionsInTransition
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|regionState
operator|.
name|getStamp
argument_list|()
operator|+
name|timeout
operator|<=
name|now
condition|)
block|{
comment|//decide on action upon timeout
name|actOnTimeOut
argument_list|(
name|regionState
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|allRegionServersOffline
operator|&&
operator|!
name|noRSAvailable
condition|)
block|{
comment|// if some RSs just came back online, we can start the
comment|// the assignment right away
name|actOnTimeOut
argument_list|(
name|regionState
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|setAllRegionServersOffline
argument_list|(
name|noRSAvailable
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|actOnTimeOut
parameter_list|(
name|RegionState
name|regionState
parameter_list|)
block|{
name|HRegionInfo
name|regionInfo
init|=
name|regionState
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Regions in transition timed out:  "
operator|+
name|regionState
argument_list|)
expr_stmt|;
comment|// Expired! Do a retry.
switch|switch
condition|(
name|regionState
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|CLOSED
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" has been CLOSED for too long, waiting on queued "
operator|+
literal|"ClosedRegionHandler to run or server shutdown"
argument_list|)
expr_stmt|;
comment|// Update our timestamp.
name|regionState
operator|.
name|updateTimestampToNow
argument_list|()
expr_stmt|;
break|break;
case|case
name|OFFLINE
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been OFFLINE for too long, "
operator|+
literal|"reassigning "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to a random server"
argument_list|)
expr_stmt|;
name|invokeAssign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|PENDING_OPEN
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been PENDING_OPEN for too "
operator|+
literal|"long, reassigning region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|invokeAssign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPENING
case|:
name|processOpeningState
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPEN
case|:
name|LOG
operator|.
name|error
argument_list|(
literal|"Region has been OPEN for too long, "
operator|+
literal|"we don't know where region was opened so can't do anything"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|regionState
init|)
block|{
name|regionState
operator|.
name|updateTimestampToNow
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|PENDING_CLOSE
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been PENDING_CLOSE for too "
operator|+
literal|"long, running forced unassign again on region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|invokeUnassign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOSING
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been CLOSING for too "
operator|+
literal|"long, this should eventually complete or the server will "
operator|+
literal|"expire, send RPC again"
argument_list|)
expr_stmt|;
name|invokeUnassign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Received event is not valid."
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|processOpeningState
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been OPENING for too "
operator|+
literal|"long, reassigning region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Should have a ZK node in OPENING state
try|try
block|{
name|String
name|node
init|=
name|ZKAssign
operator|.
name|getNodeName
argument_list|(
name|watcher
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getDataNoWatch
argument_list|(
name|watcher
argument_list|,
name|node
argument_list|,
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Data is null, node "
operator|+
name|node
operator|+
literal|" no longer exists"
argument_list|)
expr_stmt|;
return|return;
block|}
name|RegionTransition
name|rt
init|=
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|EventType
name|et
init|=
name|rt
operator|.
name|getEventType
argument_list|()
decl_stmt|;
if|if
condition|(
name|et
operator|==
name|EventType
operator|.
name|RS_ZK_REGION_OPENED
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Region has transitioned to OPENED, allowing "
operator|+
literal|"watched event handlers to process"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|et
operator|!=
name|EventType
operator|.
name|RS_ZK_REGION_OPENING
operator|&&
name|et
operator|!=
name|EventType
operator|.
name|RS_ZK_REGION_FAILED_OPEN
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"While timing out a region, found ZK node in unexpected state: "
operator|+
name|et
argument_list|)
expr_stmt|;
return|return;
block|}
name|invokeAssign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected ZK exception timing out CLOSING region"
argument_list|,
name|ke
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected exception parsing CLOSING region"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
specifier|private
name|void
name|invokeAssign
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|threadPoolExecutorService
operator|.
name|submit
argument_list|(
operator|new
name|AssignCallable
argument_list|(
name|this
argument_list|,
name|regionInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|invokeUnassign
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|threadPoolExecutorService
operator|.
name|submit
argument_list|(
operator|new
name|UnAssignCallable
argument_list|(
name|this
argument_list|,
name|regionInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isCarryingRoot
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
return|return
name|isCarryingRegion
argument_list|(
name|serverName
argument_list|,
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isCarryingMeta
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
return|return
name|isCarryingRegion
argument_list|(
name|serverName
argument_list|,
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
return|;
block|}
comment|/**    * Check if the shutdown server carries the specific region.    * We have a bunch of places that store region location    * Those values aren't consistent. There is a delay of notification.    * The location from zookeeper unassigned node has the most recent data;    * but the node could be deleted after the region is opened by AM.    * The AM's info could be old when OpenedRegionHandler    * processing hasn't finished yet when server shutdown occurs.    * @return whether the serverName currently hosts the region    */
specifier|public
name|boolean
name|isCarryingRegion
parameter_list|(
name|ServerName
name|serverName
parameter_list|,
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|RegionTransition
name|rt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
comment|// This call can legitimately come by null
name|rt
operator|=
name|data
operator|==
literal|null
condition|?
literal|null
else|:
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Exception reading unassigned node for region="
operator|+
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Exception parsing unassigned node for region="
operator|+
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|ServerName
name|addressFromZK
init|=
name|rt
operator|!=
literal|null
condition|?
name|rt
operator|.
name|getServerName
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|addressFromZK
operator|!=
literal|null
condition|)
block|{
comment|// if we get something from ZK, we will use the data
name|boolean
name|matchZK
init|=
operator|(
name|addressFromZK
operator|!=
literal|null
operator|&&
name|addressFromZK
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
operator|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"based on ZK, current region="
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" is on server="
operator|+
name|addressFromZK
operator|+
literal|" server being checked=: "
operator|+
name|serverName
argument_list|)
expr_stmt|;
return|return
name|matchZK
return|;
block|}
name|ServerName
name|addressFromAM
init|=
name|getRegionServerOfRegion
argument_list|(
name|hri
argument_list|)
decl_stmt|;
name|boolean
name|matchAM
init|=
operator|(
name|addressFromAM
operator|!=
literal|null
operator|&&
name|addressFromAM
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
operator|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"based on AM, current region="
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" is on server="
operator|+
operator|(
name|addressFromAM
operator|!=
literal|null
condition|?
name|addressFromAM
else|:
literal|"null"
operator|)
operator|+
literal|" server being checked: "
operator|+
name|serverName
argument_list|)
expr_stmt|;
return|return
name|matchAM
return|;
block|}
comment|/**    * Process shutdown server removing any assignments.    * @param sn Server that went down.    * @return list of regions in transition on this server    */
specifier|public
name|List
argument_list|<
name|RegionState
argument_list|>
name|processServerShutdown
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
comment|// Clean out any existing assignment plans for this server
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|>
name|i
init|=
name|this
operator|.
name|regionPlans
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|e
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|ServerName
name|otherSn
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getDestination
argument_list|()
decl_stmt|;
comment|// The name will be null if the region is planned for a random assign.
if|if
condition|(
name|otherSn
operator|!=
literal|null
operator|&&
name|otherSn
operator|.
name|equals
argument_list|(
name|sn
argument_list|)
condition|)
block|{
comment|// Use iterator's remove else we'll get CME
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: Do we want to sync on RIT here?
comment|// Remove this server from map of servers to regions, and remove all regions
comment|// of this server from online map of regions.
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|deadRegions
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|RegionState
argument_list|>
name|rits
init|=
operator|new
name|ArrayList
argument_list|<
name|RegionState
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|assignedRegions
init|=
name|this
operator|.
name|servers
operator|.
name|remove
argument_list|(
name|sn
argument_list|)
decl_stmt|;
if|if
condition|(
name|assignedRegions
operator|==
literal|null
operator|||
name|assignedRegions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No regions on this server, we are done, return empty list of RITs
return|return
name|rits
return|;
block|}
name|deadRegions
operator|=
operator|new
name|TreeSet
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|assignedRegions
argument_list|)
expr_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|deadRegions
control|)
block|{
name|this
operator|.
name|regions
operator|.
name|remove
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
comment|// See if any of the regions that were online on this server were in RIT
comment|// If they are, normal timeouts will deal with them appropriately so
comment|// let's skip a manual re-assignment.
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
for|for
control|(
name|RegionState
name|region
range|:
name|this
operator|.
name|regionsInTransition
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|deadRegions
operator|.
name|remove
argument_list|(
name|region
operator|.
name|getRegion
argument_list|()
argument_list|)
condition|)
block|{
name|rits
operator|.
name|add
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|rits
return|;
block|}
comment|/**    * Update inmemory structures.    * @param sn Server that reported the split    * @param parent Parent region that was split    * @param a Daughter region A    * @param b Daughter region B    */
specifier|public
name|void
name|handleSplitReport
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|parent
parameter_list|,
specifier|final
name|HRegionInfo
name|a
parameter_list|,
specifier|final
name|HRegionInfo
name|b
parameter_list|)
block|{
name|regionOffline
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|a
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|b
argument_list|,
name|sn
argument_list|)
expr_stmt|;
comment|// There's a possibility that the region was splitting while a user asked
comment|// the master to disable, we need to make sure we close those regions in
comment|// that case. This is not racing with the region server itself since RS
comment|// report is done after the split transaction completed.
if|if
condition|(
name|this
operator|.
name|zkTable
operator|.
name|isDisablingOrDisabledTable
argument_list|(
name|parent
operator|.
name|getTableNameAsString
argument_list|()
argument_list|)
condition|)
block|{
name|unassign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|unassign
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This is an EXPENSIVE clone.  Cloning though is the safest thing to do.    * Can't let out original since it can change and at least the loadbalancer    * wants to iterate this exported list.  We need to synchronize on regions    * since all access to this.servers is under a lock on this.regions.    *     * @return A clone of current assignments by table.    */
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|>
name|getAssignmentsByTable
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|>
name|result
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|result
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.loadbalance.bytable"
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
literal|"ensemble"
argument_list|,
name|getAssignments
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|e
range|:
name|this
operator|.
name|servers
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|e
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
name|hri
operator|.
name|isMetaRegion
argument_list|()
operator|||
name|hri
operator|.
name|isRootRegion
argument_list|()
condition|)
continue|continue;
name|String
name|tablename
init|=
name|hri
operator|.
name|getTableNameAsString
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|svrToRegions
init|=
name|result
operator|.
name|get
argument_list|(
name|tablename
argument_list|)
decl_stmt|;
if|if
condition|(
name|svrToRegions
operator|==
literal|null
condition|)
block|{
name|svrToRegions
operator|=
operator|new
name|HashMap
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|(
name|this
operator|.
name|servers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|put
argument_list|(
name|tablename
argument_list|,
name|svrToRegions
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|svrToRegions
operator|.
name|containsKey
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|regions
operator|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
expr_stmt|;
name|svrToRegions
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|regions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regions
operator|=
name|svrToRegions
operator|.
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|regions
operator|.
name|add
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Map
argument_list|<
name|ServerName
argument_list|,
name|ServerLoad
argument_list|>
name|onlineSvrs
init|=
name|this
operator|.
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
decl_stmt|;
comment|// Take care of servers w/o assignments.
for|for
control|(
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|map
range|:
name|result
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|ServerLoad
argument_list|>
name|svrEntry
range|:
name|onlineSvrs
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|map
operator|.
name|containsKey
argument_list|(
name|svrEntry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|svrEntry
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * @return A clone of current assignments. Note, this is assignments only.    * If a new server has come in and it has no regions, it will not be included    * in the returned Map.    */
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|getAssignments
parameter_list|()
block|{
comment|// This is an EXPENSIVE clone.  Cloning though is the safest thing to do.
comment|// Can't let out original since it can change and at least the loadbalancer
comment|// wants to iterate this exported list.  We need to synchronize on regions
comment|// since all access to this.servers is under a lock on this.regions.
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|result
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|result
operator|=
operator|new
name|HashMap
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|(
name|this
operator|.
name|servers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|e
range|:
name|this
operator|.
name|servers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|result
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * @param encodedRegionName Region encoded name.    * @return Null or a {@link Pair} instance that holds the full {@link HRegionInfo}    * and the hosting servers {@link ServerName}.    */
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|getAssignment
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|)
block|{
name|String
name|name
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|e
range|:
name|this
operator|.
name|regions
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getEncodedName
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
operator|new
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @param plan Plan to execute.    */
name|void
name|balance
parameter_list|(
specifier|final
name|RegionPlan
name|plan
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|this
operator|.
name|regionPlans
operator|.
name|put
argument_list|(
name|plan
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|plan
argument_list|)
expr_stmt|;
block|}
name|unassign
argument_list|(
name|plan
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
literal|false
argument_list|,
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run through remaining regionservers and unassign all catalog regions.    */
name|void
name|unassignCatalogRegions
parameter_list|()
block|{
name|this
operator|.
name|servers
operator|.
name|entrySet
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|e
range|:
name|this
operator|.
name|servers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|regions
operator|==
literal|null
operator|||
name|regions
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|regions
control|)
block|{
if|if
condition|(
name|hri
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|unassign
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * State of a Region while undergoing transitions.    */
specifier|public
specifier|static
class|class
name|RegionState
implements|implements
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
block|{
specifier|private
name|HRegionInfo
name|region
decl_stmt|;
specifier|public
enum|enum
name|State
block|{
name|OFFLINE
block|,
comment|// region is in an offline state
name|PENDING_OPEN
block|,
comment|// sent rpc to server to open but has not begun
name|OPENING
block|,
comment|// server has begun to open but not yet done
name|OPEN
block|,
comment|// server opened region and updated meta
name|PENDING_CLOSE
block|,
comment|// sent rpc to server to close but has not begun
name|CLOSING
block|,
comment|// server has begun to close but not yet done
name|CLOSED
block|,
comment|// server closed region and updated meta
name|SPLITTING
block|,
comment|// server started split of a region
name|SPLIT
comment|// server completed split of a region
block|}
specifier|private
name|State
name|state
decl_stmt|;
comment|// Many threads can update the state at the stamp at the same time
specifier|private
specifier|final
name|AtomicLong
name|stamp
decl_stmt|;
specifier|private
name|ServerName
name|serverName
decl_stmt|;
specifier|public
name|RegionState
parameter_list|()
block|{
name|this
operator|.
name|stamp
operator|=
operator|new
name|AtomicLong
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RegionState
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|State
name|state
parameter_list|)
block|{
name|this
argument_list|(
name|region
argument_list|,
name|state
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|RegionState
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|State
name|state
parameter_list|,
name|long
name|stamp
parameter_list|,
name|ServerName
name|serverName
parameter_list|)
block|{
name|this
operator|.
name|region
operator|=
name|region
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|this
operator|.
name|stamp
operator|=
operator|new
name|AtomicLong
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
block|}
specifier|public
name|void
name|update
parameter_list|(
name|State
name|state
parameter_list|,
name|long
name|stamp
parameter_list|,
name|ServerName
name|serverName
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|updateTimestamp
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
block|}
specifier|public
name|void
name|update
parameter_list|(
name|State
name|state
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|updateTimestampToNow
argument_list|()
expr_stmt|;
name|this
operator|.
name|serverName
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|void
name|updateTimestamp
parameter_list|(
name|long
name|stamp
parameter_list|)
block|{
name|this
operator|.
name|stamp
operator|.
name|set
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|updateTimestampToNow
parameter_list|()
block|{
name|this
operator|.
name|stamp
operator|.
name|set
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|State
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
specifier|public
name|long
name|getStamp
parameter_list|()
block|{
return|return
name|stamp
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|HRegionInfo
name|getRegion
parameter_list|()
block|{
return|return
name|region
return|;
block|}
specifier|public
name|ServerName
name|getServerName
parameter_list|()
block|{
return|return
name|serverName
return|;
block|}
specifier|public
name|boolean
name|isClosing
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|CLOSING
return|;
block|}
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|CLOSED
return|;
block|}
specifier|public
name|boolean
name|isPendingClose
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|PENDING_CLOSE
return|;
block|}
specifier|public
name|boolean
name|isOpening
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|OPENING
return|;
block|}
specifier|public
name|boolean
name|isOpened
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|OPEN
return|;
block|}
specifier|public
name|boolean
name|isPendingOpen
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|PENDING_OPEN
return|;
block|}
specifier|public
name|boolean
name|isOffline
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|OFFLINE
return|;
block|}
specifier|public
name|boolean
name|isSplitting
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|SPLITTING
return|;
block|}
specifier|public
name|boolean
name|isSplit
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|SPLIT
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" state="
operator|+
name|state
operator|+
literal|", ts="
operator|+
name|stamp
operator|+
literal|", server="
operator|+
name|serverName
return|;
block|}
comment|/**      * A slower (but more easy-to-read) stringification       */
specifier|public
name|String
name|toDescriptiveString
parameter_list|()
block|{
name|long
name|lstamp
init|=
name|stamp
operator|.
name|get
argument_list|()
decl_stmt|;
name|long
name|relTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lstamp
decl_stmt|;
return|return
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" state="
operator|+
name|state
operator|+
literal|", ts="
operator|+
operator|new
name|Date
argument_list|(
name|lstamp
argument_list|)
operator|+
literal|" ("
operator|+
operator|(
name|relTime
operator|/
literal|1000
operator|)
operator|+
literal|"s ago)"
operator|+
literal|", server="
operator|+
name|serverName
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|region
operator|=
operator|new
name|HRegionInfo
argument_list|()
expr_stmt|;
name|region
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|valueOf
argument_list|(
name|in
operator|.
name|readUTF
argument_list|()
argument_list|)
expr_stmt|;
name|stamp
operator|.
name|set
argument_list|(
name|in
operator|.
name|readLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|region
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeUTF
argument_list|(
name|state
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
name|stamp
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|this
operator|.
name|timeoutMonitor
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|this
operator|.
name|timerUpdater
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|/**    * Check whether the RegionServer is online.    * @param serverName     * @return True if online.    */
specifier|public
name|boolean
name|isServerOnline
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
return|return
name|serverName
operator|!=
literal|null
operator|&&
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|serverName
argument_list|)
return|;
block|}
comment|/**    * Shutdown the threadpool executor service    */
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|!=
name|threadPoolExecutorService
condition|)
block|{
name|this
operator|.
name|threadPoolExecutorService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|setEnabledTable
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|zkTable
operator|.
name|setEnabledTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
comment|// here we can abort as it is the start up flow
name|String
name|errorMsg
init|=
literal|"Unable to ensure that the table "
operator|+
name|tableName
operator|+
literal|" will be"
operator|+
literal|" enabled because of a ZooKeeper issue"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|abort
argument_list|(
name|errorMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

