begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CoordinatedStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaTableAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableStateManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionReplicaUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|EventHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|EventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcClient
operator|.
name|FailedServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|ServerNotRunningYetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|FavoredNodeAssignmentHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|FavoredNodeLoadBalancer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|DisableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|EnableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionStateTransition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionStateTransition
operator|.
name|TransitionCode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ZooKeeperProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionAlreadyInTransitionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionOpeningState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionServerStoppedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|HLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|HLogUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|KeyLocker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|PairOfSameType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Manages and performs region assignment.  * Related communications with regionserver are all done over RPC.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|AssignmentManager
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AssignmentManager
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|String
name|ALREADY_IN_TRANSITION_WAITTIME
init|=
literal|"hbase.assignment.already.intransition.waittime"
decl_stmt|;
specifier|static
specifier|final
name|int
name|DEFAULT_ALREADY_IN_TRANSITION_WAITTIME
init|=
literal|60000
decl_stmt|;
comment|// 1 minute
specifier|protected
specifier|final
name|Server
name|server
decl_stmt|;
specifier|private
name|ServerManager
name|serverManager
decl_stmt|;
specifier|private
name|boolean
name|shouldAssignRegionsWithFavoredNodes
decl_stmt|;
specifier|private
name|LoadBalancer
name|balancer
decl_stmt|;
specifier|private
specifier|final
name|MetricsAssignmentManager
name|metricsAssignmentManager
decl_stmt|;
specifier|private
specifier|final
name|TableLockManager
name|tableLockManager
decl_stmt|;
specifier|private
name|AtomicInteger
name|numRegionsOpened
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
specifier|private
name|KeyLocker
argument_list|<
name|String
argument_list|>
name|locker
init|=
operator|new
name|KeyLocker
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|replicasToClose
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Map of regions to reopen after the schema of a table is changed. Key -    * encoded region name, value - HRegionInfo    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HRegionInfo
argument_list|>
name|regionsToReopen
decl_stmt|;
comment|/*    * Maximum times we recurse an assignment/unassignment.    * See below in {@link #assign()} and {@link #unassign()}.    */
specifier|private
specifier|final
name|int
name|maximumAttempts
decl_stmt|;
comment|/**    * Map of two merging regions from the region to be created.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|PairOfSameType
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|mergingRegions
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|PairOfSameType
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * The sleep time for which the assignment will wait before retrying in case of hbase:meta assignment    * failure due to lack of availability of region plan    */
specifier|private
specifier|final
name|long
name|sleepTimeBeforeRetryingMetaAssignment
decl_stmt|;
comment|/** Plans for region movement. Key is the encoded version of a region name*/
comment|// TODO: When do plans get cleaned out?  Ever? In server open and in server
comment|// shutdown processing -- St.Ack
comment|// All access to this Map must be synchronized.
specifier|final
name|NavigableMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|regionPlans
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|TableStateManager
name|tableStateManager
decl_stmt|;
specifier|private
specifier|final
name|ExecutorService
name|executorService
decl_stmt|;
comment|// Thread pool executor service. TODO, consolidate with executorService?
specifier|private
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
name|threadPoolExecutorService
decl_stmt|;
specifier|private
specifier|final
name|RegionStates
name|regionStates
decl_stmt|;
comment|// The threshold to use bulk assigning. Using bulk assignment
comment|// only if assigning at least this many regions to at least this
comment|// many servers. If assigning fewer regions to fewer servers,
comment|// bulk assigning may be not as efficient.
specifier|private
specifier|final
name|int
name|bulkAssignThresholdRegions
decl_stmt|;
specifier|private
specifier|final
name|int
name|bulkAssignThresholdServers
decl_stmt|;
comment|// Should bulk assignment wait till all regions are assigned,
comment|// or it is timed out?  This is useful to measure bulk assignment
comment|// performance, but not needed in most use cases.
specifier|private
specifier|final
name|boolean
name|bulkAssignWaitTillAllAssigned
decl_stmt|;
comment|/**    * Indicator that AssignmentManager has recovered the region states so    * that ServerShutdownHandler can be fully enabled and re-assign regions    * of dead servers. So that when re-assignment happens, AssignmentManager    * has proper region states.    *    * Protected to ease testing.    */
specifier|protected
specifier|final
name|AtomicBoolean
name|failoverCleanupDone
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**    * A map to track the count a region fails to open in a row.    * So that we don't try to open a region forever if the failure is    * unrecoverable.  We don't put this information in region states    * because we don't expect this to happen frequently; we don't    * want to copy this information over during each state transition either.    */
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|failedOpenTracker
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
argument_list|()
decl_stmt|;
comment|// In case not using ZK for region assignment, region states
comment|// are persisted in meta with a state store
specifier|private
specifier|final
name|RegionStateStore
name|regionStateStore
decl_stmt|;
comment|/**    * For testing only!  Set to true to skip handling of split.    */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"MS_SHOULD_BE_FINAL"
argument_list|)
specifier|public
specifier|static
name|boolean
name|TEST_SKIP_SPLIT_HANDLING
init|=
literal|false
decl_stmt|;
comment|/** Listeners that are called on assignment events. */
specifier|private
name|List
argument_list|<
name|AssignmentListener
argument_list|>
name|listeners
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|AssignmentListener
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Constructs a new assignment manager.    *    * @param server instance of HMaster this AM running inside    * @param serverManager serverManager for associated HMaster    * @param balancer implementation of {@link LoadBalancer}    * @param service Executor service    * @param metricsMaster metrics manager    * @param tableLockManager TableLock manager    * @throws CoordinatedStateException    * @throws IOException    */
specifier|public
name|AssignmentManager
parameter_list|(
name|Server
name|server
parameter_list|,
name|ServerManager
name|serverManager
parameter_list|,
specifier|final
name|LoadBalancer
name|balancer
parameter_list|,
specifier|final
name|ExecutorService
name|service
parameter_list|,
name|MetricsMaster
name|metricsMaster
parameter_list|,
specifier|final
name|TableLockManager
name|tableLockManager
parameter_list|)
throws|throws
name|IOException
throws|,
name|CoordinatedStateException
block|{
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
name|serverManager
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|regionStateStore
operator|=
operator|new
name|RegionStateStore
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionsToReopen
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HRegionInfo
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|server
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
comment|// Only read favored nodes if using the favored nodes load balancer.
name|this
operator|.
name|shouldAssignRegionsWithFavoredNodes
operator|=
name|conf
operator|.
name|getClass
argument_list|(
name|HConstants
operator|.
name|HBASE_MASTER_LOADBALANCER_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
operator|.
name|equals
argument_list|(
name|FavoredNodeLoadBalancer
operator|.
name|class
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|server
operator|.
name|getCoordinatedStateManager
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|tableStateManager
operator|=
name|server
operator|.
name|getCoordinatedStateManager
argument_list|()
operator|.
name|getTableStateManager
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|tableStateManager
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
block|}
comment|// This is the max attempts, not retries, so it should be at least 1.
name|this
operator|.
name|maximumAttempts
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.assignment.maximum.attempts"
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|sleepTimeBeforeRetryingMetaAssignment
operator|=
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"hbase.meta.assignment.retry.sleeptime"
argument_list|,
literal|1000l
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|=
name|balancer
expr_stmt|;
name|int
name|maxThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.assignment.threads.max"
argument_list|,
literal|30
argument_list|)
decl_stmt|;
name|this
operator|.
name|threadPoolExecutorService
operator|=
name|Threads
operator|.
name|getBoundedCachedThreadPool
argument_list|(
name|maxThreads
argument_list|,
literal|60L
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|Threads
operator|.
name|newDaemonThreadFactory
argument_list|(
literal|"AM."
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionStates
operator|=
operator|new
name|RegionStates
argument_list|(
name|server
argument_list|,
name|tableStateManager
argument_list|,
name|serverManager
argument_list|,
name|regionStateStore
argument_list|)
expr_stmt|;
name|this
operator|.
name|bulkAssignWaitTillAllAssigned
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.bulk.assignment.waittillallassigned"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|bulkAssignThresholdRegions
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.bulk.assignment.threshold.regions"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|this
operator|.
name|bulkAssignThresholdServers
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.bulk.assignment.threshold.servers"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|this
operator|.
name|metricsAssignmentManager
operator|=
operator|new
name|MetricsAssignmentManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableLockManager
operator|=
name|tableLockManager
expr_stmt|;
block|}
comment|/**    * Add the listener to the notification list.    * @param listener The AssignmentListener to register    */
specifier|public
name|void
name|registerListener
parameter_list|(
specifier|final
name|AssignmentListener
name|listener
parameter_list|)
block|{
name|this
operator|.
name|listeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove the listener from the notification list.    * @param listener The AssignmentListener to unregister    */
specifier|public
name|boolean
name|unregisterListener
parameter_list|(
specifier|final
name|AssignmentListener
name|listener
parameter_list|)
block|{
return|return
name|this
operator|.
name|listeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
return|;
block|}
comment|/**    * @return Instance of ZKTableStateManager.    */
specifier|public
name|TableStateManager
name|getTableStateManager
parameter_list|()
block|{
comment|// These are 'expensive' to make involving trip to zk ensemble so allow
comment|// sharing.
return|return
name|this
operator|.
name|tableStateManager
return|;
block|}
comment|/**    * This SHOULD not be public. It is public now    * because of some unit tests.    *    * TODO: make it package private and keep RegionStates in the master package    */
specifier|public
name|RegionStates
name|getRegionStates
parameter_list|()
block|{
return|return
name|regionStates
return|;
block|}
comment|/**    * Used in some tests to mock up region state in meta    */
annotation|@
name|VisibleForTesting
name|RegionStateStore
name|getRegionStateStore
parameter_list|()
block|{
return|return
name|regionStateStore
return|;
block|}
specifier|public
name|RegionPlan
name|getRegionReopenPlan
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
return|return
operator|new
name|RegionPlan
argument_list|(
name|hri
argument_list|,
literal|null
argument_list|,
name|regionStates
operator|.
name|getRegionServerOfRegion
argument_list|(
name|hri
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Add a regionPlan for the specified region.    * @param encodedName    * @param plan    */
specifier|public
name|void
name|addPlan
parameter_list|(
name|String
name|encodedName
parameter_list|,
name|RegionPlan
name|plan
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regionPlans
init|)
block|{
name|regionPlans
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|plan
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add a map of region plans.    */
specifier|public
name|void
name|addPlans
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|plans
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regionPlans
init|)
block|{
name|regionPlans
operator|.
name|putAll
argument_list|(
name|plans
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the list of regions that will be reopened    * because of an update in table schema    *    * @param regions    *          list of regions that should be tracked for reopen    */
specifier|public
name|void
name|setRegionsToReopen
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|regions
control|)
block|{
name|regionsToReopen
operator|.
name|put
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Used by the client to identify if all regions have the schema updates    *    * @param tableName    * @return Pair indicating the status of the alter command    * @throws IOException    */
specifier|public
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|getReopenStatus
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|hris
init|=
name|MetaTableAccessor
operator|.
name|getTableRegions
argument_list|(
name|this
operator|.
name|server
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|this
operator|.
name|server
operator|.
name|getShortCircuitConnection
argument_list|()
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Integer
name|pending
init|=
literal|0
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|hris
control|)
block|{
name|String
name|name
init|=
name|hri
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
comment|// no lock concurrent access ok: sequential consistency respected.
if|if
condition|(
name|regionsToReopen
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
operator|||
name|regionStates
operator|.
name|isRegionInTransition
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|pending
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|pending
argument_list|,
name|hris
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Used by ServerShutdownHandler to make sure AssignmentManager has completed    * the failover cleanup before re-assigning regions of dead servers. So that    * when re-assignment happens, AssignmentManager has proper region states.    */
specifier|public
name|boolean
name|isFailoverCleanupDone
parameter_list|()
block|{
return|return
name|failoverCleanupDone
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * To avoid racing with AM, external entities may need to lock a region,    * for example, when SSH checks what regions to skip re-assigning.    */
specifier|public
name|Lock
name|acquireRegionLock
parameter_list|(
specifier|final
name|String
name|encodedName
parameter_list|)
block|{
return|return
name|locker
operator|.
name|acquireLock
argument_list|(
name|encodedName
argument_list|)
return|;
block|}
comment|/**    * Now, failover cleanup is completed. Notify server manager to    * process queued up dead servers processing, if any.    */
name|void
name|failoverCleanupDone
parameter_list|()
block|{
name|failoverCleanupDone
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|serverManager
operator|.
name|processQueuedDeadServers
argument_list|()
expr_stmt|;
block|}
comment|/**    * Called on startup.    * Figures whether a fresh cluster start of we are joining extant running cluster.    * @throws IOException    * @throws KeeperException    * @throws InterruptedException    * @throws CoordinatedStateException    */
name|void
name|joinCluster
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
throws|,
name|CoordinatedStateException
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// Concurrency note: In the below the accesses on regionsInTransition are
comment|// outside of a synchronization block where usually all accesses to RIT are
comment|// synchronized.  The presumption is that in this case it is safe since this
comment|// method is being played by a single thread on startup.
comment|// TODO: Regions that have a null location and are not in regionsInTransitions
comment|// need to be handled.
comment|// Scan hbase:meta to build list of existing regions, servers, and assignment
comment|// Returns servers who have not checked in (assumed dead) that some regions
comment|// were assigned to (according to the meta)
name|Set
argument_list|<
name|ServerName
argument_list|>
name|deadServers
init|=
name|rebuildUserRegions
argument_list|()
decl_stmt|;
comment|// This method will assign all user regions if a clean server startup or
comment|// it will reconstruct master state and cleanup any leftovers from
comment|// previous master process.
name|boolean
name|failover
init|=
name|processDeadServersAndRegionsInTransition
argument_list|(
name|deadServers
argument_list|)
decl_stmt|;
name|recoverTableInDisablingState
argument_list|()
expr_stmt|;
name|recoverTableInEnablingState
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Joined the cluster in "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
operator|+
literal|"ms, failover="
operator|+
name|failover
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process all regions that are in transition in zookeeper and also    * processes the list of dead servers by scanning the META.    * Used by master joining an cluster.  If we figure this is a clean cluster    * startup, will assign all user regions.    * @param deadServers    *          Map of dead servers and their regions. Can be null.    * @throws IOException    * @throws InterruptedException    * @throws CoordinatedStateException    */
name|boolean
name|processDeadServersAndRegionsInTransition
parameter_list|(
specifier|final
name|Set
argument_list|<
name|ServerName
argument_list|>
name|deadServers
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|CoordinatedStateException
block|{
name|boolean
name|failover
init|=
operator|!
name|serverManager
operator|.
name|getDeadServers
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|failover
condition|)
block|{
comment|// This may not be a failover actually, especially if meta is on this master.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found dead servers out on cluster "
operator|+
name|serverManager
operator|.
name|getDeadServers
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If any one region except meta is assigned, it's a failover.
name|Set
argument_list|<
name|ServerName
argument_list|>
name|onlineServers
init|=
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|en
range|:
name|regionStates
operator|.
name|getRegionAssignments
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HRegionInfo
name|hri
init|=
name|en
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hri
operator|.
name|isMetaTable
argument_list|()
operator|&&
name|onlineServers
operator|.
name|contains
argument_list|(
name|en
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|hri
operator|+
literal|" out on cluster"
argument_list|)
expr_stmt|;
name|failover
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|failover
condition|)
block|{
comment|// If any region except meta is in transition on a live server, it's a failover.
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|regionsInTransition
init|=
name|regionStates
operator|.
name|getRegionsInTransition
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|regionsInTransition
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|RegionState
name|regionState
range|:
name|regionsInTransition
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|regionState
operator|.
name|getRegion
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
operator|&&
name|onlineServers
operator|.
name|contains
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|regionState
operator|+
literal|" in RITs"
argument_list|)
expr_stmt|;
name|failover
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|failover
condition|)
block|{
comment|// If we get here, we have a full cluster restart. It is a failover only
comment|// if there are some HLogs are not split yet. For meta HLogs, they should have
comment|// been split already, if any. We can walk through those queued dead servers,
comment|// if they don't have any HLogs, this restart should be considered as a clean one
name|Set
argument_list|<
name|ServerName
argument_list|>
name|queuedDeadServers
init|=
name|serverManager
operator|.
name|getRequeuedDeadServers
argument_list|()
operator|.
name|keySet
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|queuedDeadServers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Configuration
name|conf
init|=
name|server
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|Path
name|rootdir
init|=
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|rootdir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|ServerName
name|serverName
range|:
name|queuedDeadServers
control|)
block|{
name|Path
name|logDir
init|=
operator|new
name|Path
argument_list|(
name|rootdir
argument_list|,
name|HLogUtil
operator|.
name|getHLogDirectoryName
argument_list|(
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|splitDir
init|=
name|logDir
operator|.
name|suffix
argument_list|(
name|HLog
operator|.
name|SPLITTING_EXT
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|logDir
argument_list|)
operator|||
name|fs
operator|.
name|exists
argument_list|(
name|splitDir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found queued dead server "
operator|+
name|serverName
argument_list|)
expr_stmt|;
name|failover
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|failover
condition|)
block|{
comment|// We figured that it's not a failover, so no need to
comment|// work on these re-queued dead servers any more.
name|LOG
operator|.
name|info
argument_list|(
literal|"AM figured that it's not a failover and cleaned up "
operator|+
name|queuedDeadServers
operator|.
name|size
argument_list|()
operator|+
literal|" queued dead servers"
argument_list|)
expr_stmt|;
name|serverManager
operator|.
name|removeRequeuedDeadServers
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|Set
argument_list|<
name|TableName
argument_list|>
name|disabledOrDisablingOrEnabling
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|allRegions
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|failover
condition|)
block|{
name|disabledOrDisablingOrEnabling
operator|=
name|tableStateManager
operator|.
name|getTablesInStates
argument_list|(
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|ENABLING
argument_list|)
expr_stmt|;
comment|// Clean re/start, mark all user regions closed before reassignment
name|allRegions
operator|=
name|regionStates
operator|.
name|closeAllUserRegions
argument_list|(
name|disabledOrDisablingOrEnabling
argument_list|)
expr_stmt|;
block|}
comment|// Now region states are restored
name|regionStateStore
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|failover
condition|)
block|{
if|if
condition|(
name|deadServers
operator|!=
literal|null
operator|&&
operator|!
name|deadServers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ServerName
name|serverName
range|:
name|deadServers
control|)
block|{
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerDead
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|serverManager
operator|.
name|expireServer
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
comment|// Let SSH do region re-assign
block|}
block|}
block|}
name|processRegionsInTransition
argument_list|(
name|regionStates
operator|.
name|getRegionsInTransition
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Now we can safely claim failover cleanup completed and enable
comment|// ServerShutdownHandler for further processing. The nodes (below)
comment|// in transition, if any, are for regions not related to those
comment|// dead servers at all, and can be done in parallel to SSH.
name|failoverCleanupDone
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|failover
condition|)
block|{
comment|// Fresh cluster startup.
name|LOG
operator|.
name|info
argument_list|(
literal|"Clean cluster startup. Assigning user regions"
argument_list|)
expr_stmt|;
name|assignAllUserRegions
argument_list|(
name|allRegions
argument_list|)
expr_stmt|;
block|}
comment|// unassign replicas of the split parents and the merged regions
comment|// the daughter replicas are opened in assignAllUserRegions if it was
comment|// not already opened.
for|for
control|(
name|HRegionInfo
name|h
range|:
name|replicasToClose
control|)
block|{
name|unassign
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
name|replicasToClose
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|failover
return|;
block|}
comment|/**    * When a region is closed, it should be removed from the regionsToReopen    * @param hri HRegionInfo of the region which was closed    */
specifier|public
name|void
name|removeClosedRegion
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
if|if
condition|(
name|regionsToReopen
operator|.
name|remove
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed region from reopening regions because it was closed"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: processFavoredNodes might throw an exception, for e.g., if the
comment|// meta could not be contacted/updated. We need to see how seriously to treat
comment|// this problem as. Should we fail the current assignment. We should be able
comment|// to recover from this problem eventually (if the meta couldn't be updated
comment|// things should work normally and eventually get fixed up).
name|void
name|processFavoredNodes
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|shouldAssignRegionsWithFavoredNodes
condition|)
return|return;
comment|// The AM gets the favored nodes info for each region and updates the meta
comment|// table with that info
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
name|regionToFavoredNodes
init|=
operator|new
name|HashMap
argument_list|<
name|HRegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
name|regionToFavoredNodes
operator|.
name|put
argument_list|(
name|region
argument_list|,
operator|(
operator|(
name|FavoredNodeLoadBalancer
operator|)
name|this
operator|.
name|balancer
operator|)
operator|.
name|getFavoredNodes
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FavoredNodeAssignmentHelper
operator|.
name|updateMetaWithFavoredNodesInfo
argument_list|(
name|regionToFavoredNodes
argument_list|,
name|this
operator|.
name|server
operator|.
name|getShortCircuitConnection
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Marks the region as online.  Removes it from regions in transition and    * updates the in-memory assignment information.    *<p>    * Used when a region has been successfully opened on a region server.    * @param regionInfo    * @param sn    */
name|void
name|regionOnline
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|ServerName
name|sn
parameter_list|)
block|{
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|sn
argument_list|,
name|HConstants
operator|.
name|NO_SEQNUM
argument_list|)
expr_stmt|;
block|}
name|void
name|regionOnline
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|ServerName
name|sn
parameter_list|,
name|long
name|openSeqNum
parameter_list|)
block|{
name|numRegionsOpened
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|regionStates
operator|.
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|sn
argument_list|,
name|openSeqNum
argument_list|)
expr_stmt|;
comment|// Remove plan if one.
name|clearRegionPlan
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|balancer
operator|.
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|sn
argument_list|)
expr_stmt|;
comment|// Tell our listeners that a region was opened
name|sendRegionOpenedNotification
argument_list|(
name|regionInfo
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
comment|/**    * Marks the region as offline.  Removes it from regions in transition and    * removes in-memory assignment information.    *<p>    * Used when a region has been closed and should remain closed.    * @param regionInfo    */
specifier|public
name|void
name|regionOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|regionOffline
argument_list|(
name|regionInfo
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|offlineDisabledRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|replicasToClose
operator|.
name|remove
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|regionOffline
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|// Assignment methods
comment|/**    * Assigns the specified region.    *<p>    * If a RegionPlan is available with a valid destination then it will be used    * to determine what server region is assigned to.  If no RegionPlan is    * available, region will be assigned to a random available server.    *<p>    * Updates the RegionState and sends the OPEN RPC.    *<p>    * This will only succeed if the region is in transition and in a CLOSED or    * OFFLINE state or not in transition, and of course, the    * chosen server is up and running (It may have just crashed!).    *    * @param region server to be assigned    */
specifier|public
name|void
name|assign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
name|assign
argument_list|(
name|region
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Use care with forceNewPlan. It could cause double assignment.    */
specifier|public
name|void
name|assign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|forceNewPlan
parameter_list|)
block|{
if|if
condition|(
name|isDisabledorDisablingRegionInRIT
argument_list|(
name|region
argument_list|)
condition|)
block|{
return|return;
block|}
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|Lock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
try|try
block|{
name|RegionState
name|state
init|=
name|forceRegionStateToOffline
argument_list|(
name|region
argument_list|,
name|forceNewPlan
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|regionStates
operator|.
name|wasRegionOnDeadServer
argument_list|(
name|encodedName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip assigning "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", it's host "
operator|+
name|regionStates
operator|.
name|getLastRegionServerOfRegion
argument_list|(
name|encodedName
argument_list|)
operator|+
literal|" is dead but not processed yet"
argument_list|)
expr_stmt|;
return|return;
block|}
name|assign
argument_list|(
name|state
argument_list|,
name|forceNewPlan
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Bulk assign regions to<code>destination</code>.    * @param destination    * @param regions Regions to assign.    * @return true if successful    */
name|boolean
name|assign
parameter_list|(
specifier|final
name|ServerName
name|destination
parameter_list|,
specifier|final
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|long
name|startTime
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|regionCount
init|=
name|regions
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionCount
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigning "
operator|+
name|regionCount
operator|+
literal|" region(s) to "
operator|+
name|destination
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|encodedNames
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|regionCount
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
name|encodedNames
operator|.
name|add
argument_list|(
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|failedToOpenRegions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Lock
argument_list|>
name|locks
init|=
name|locker
operator|.
name|acquireLocks
argument_list|(
name|encodedNames
argument_list|)
decl_stmt|;
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|plans
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|(
name|regionCount
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RegionState
argument_list|>
name|states
init|=
operator|new
name|ArrayList
argument_list|<
name|RegionState
argument_list|>
argument_list|(
name|regionCount
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isDisabledorDisablingRegionInRIT
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|RegionState
name|state
init|=
name|forceRegionStateToOffline
argument_list|(
name|region
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|boolean
name|onDeadServer
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|regionStates
operator|.
name|wasRegionOnDeadServer
argument_list|(
name|encodedName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip assigning "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", it's host "
operator|+
name|regionStates
operator|.
name|getLastRegionServerOfRegion
argument_list|(
name|encodedName
argument_list|)
operator|+
literal|" is dead but not processed yet"
argument_list|)
expr_stmt|;
name|onDeadServer
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|RegionPlan
name|plan
init|=
operator|new
name|RegionPlan
argument_list|(
name|region
argument_list|,
name|state
operator|.
name|getServerName
argument_list|()
argument_list|,
name|destination
argument_list|)
decl_stmt|;
name|plans
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|plan
argument_list|)
expr_stmt|;
name|states
operator|.
name|add
argument_list|(
name|state
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|// Reassign if the region wasn't on a dead server
if|if
condition|(
operator|!
name|onDeadServer
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"failed to force region state to offline, "
operator|+
literal|"will reassign later: "
operator|+
name|region
argument_list|)
expr_stmt|;
name|failedToOpenRegions
operator|.
name|add
argument_list|(
name|region
argument_list|)
expr_stmt|;
comment|// assign individually later
block|}
block|}
comment|// Release the lock, this region is excluded from bulk assign because
comment|// we can't update its state, or set its znode to offline.
name|Lock
name|lock
init|=
name|locks
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|server
operator|.
name|isStopped
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Add region plans, so we can updateTimers when one region is opened so
comment|// that unnecessary timeout on RIT is reduced.
name|this
operator|.
name|addPlans
argument_list|(
name|plans
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
argument_list|>
name|regionOpenInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
argument_list|>
argument_list|(
name|states
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RegionState
name|state
range|:
name|states
control|)
block|{
name|HRegionInfo
name|region
init|=
name|state
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|PENDING_OPEN
argument_list|,
name|destination
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
init|=
name|ServerName
operator|.
name|EMPTY_SERVER_LIST
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|shouldAssignRegionsWithFavoredNodes
condition|)
block|{
name|favoredNodes
operator|=
operator|(
operator|(
name|FavoredNodeLoadBalancer
operator|)
name|this
operator|.
name|balancer
operator|)
operator|.
name|getFavoredNodes
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
name|regionOpenInfos
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
argument_list|(
name|region
argument_list|,
name|favoredNodes
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Move on to open regions.
try|try
block|{
comment|// Send OPEN RPC. If it fails on a IOE or RemoteException,
comment|// regions will be assigned individually.
name|long
name|maxWaitTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.rpc.startup.waittime"
argument_list|,
literal|60000
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|maximumAttempts
operator|&&
operator|!
name|server
operator|.
name|isStopped
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|List
argument_list|<
name|RegionOpeningState
argument_list|>
name|regionOpeningStateList
init|=
name|serverManager
operator|.
name|sendRegionOpen
argument_list|(
name|destination
argument_list|,
name|regionOpenInfos
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionOpeningStateList
operator|==
literal|null
condition|)
block|{
comment|// Failed getting RPC connection to this server
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|k
init|=
literal|0
init|,
name|n
init|=
name|regionOpeningStateList
operator|.
name|size
argument_list|()
init|;
name|k
operator|<
name|n
condition|;
name|k
operator|++
control|)
block|{
name|RegionOpeningState
name|openingState
init|=
name|regionOpeningStateList
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|openingState
operator|!=
name|RegionOpeningState
operator|.
name|OPENED
condition|)
block|{
name|HRegionInfo
name|region
init|=
name|regionOpenInfos
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getFirst
argument_list|()
decl_stmt|;
comment|// Failed opening this region, reassign it later
name|failedToOpenRegions
operator|.
name|add
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|e
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|instanceof
name|RegionServerStoppedException
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The region server was shut down, "
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// No need to retry, the region server is a goner.
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|ServerNotRunningYetException
condition|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|<
name|maxWaitTime
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server is not yet up; waiting up to "
operator|+
operator|(
name|maxWaitTime
operator|-
name|now
operator|)
operator|+
literal|"ms"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
comment|// reset the try count
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
operator|&&
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|destination
argument_list|)
condition|)
block|{
comment|// In case socket is timed out and the region server is still online,
comment|// the openRegion RPC could have been accepted by the server and
comment|// just the response didn't go through.  So we will retry to
comment|// open the region on the same server.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bulk assigner openRegion() to "
operator|+
name|destination
operator|+
literal|" has timed out, but the regions might"
operator|+
literal|" already be opened on it."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// wait and reset the re-try count, server might be just busy.
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
continue|continue;
block|}
throw|throw
name|e
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Can be a socket timeout, EOF, NoRouteToHost, etc
name|LOG
operator|.
name|info
argument_list|(
literal|"Unable to communicate with "
operator|+
name|destination
operator|+
literal|" in order to assign regions, "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
for|for
control|(
name|Lock
name|lock
range|:
name|locks
operator|.
name|values
argument_list|()
control|)
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|failedToOpenRegions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|HRegionInfo
name|region
range|:
name|failedToOpenRegions
control|)
block|{
if|if
condition|(
operator|!
name|regionStates
operator|.
name|isRegionOnline
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|invokeAssign
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bulk assigning done for "
operator|+
name|destination
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|metricsAssignmentManager
operator|.
name|updateBulkAssignTime
argument_list|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Send CLOSE RPC if the server is online, otherwise, offline the region.    *    * The RPC will be sent only to the region sever found in the region state    * if it is passed in, otherwise, to the src server specified. If region    * state is not specified, we don't update region state at all, instead    * we just send the RPC call. This is useful for some cleanup without    * messing around the region states (see handleRegion, on region opened    * on an unexpected server scenario, for an example)    */
specifier|private
name|void
name|unassign
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|RegionState
name|state
parameter_list|,
specifier|final
name|ServerName
name|dest
parameter_list|)
block|{
name|ServerName
name|server
init|=
name|state
operator|.
name|getServerName
argument_list|()
decl_stmt|;
name|long
name|maxWaitTime
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|this
operator|.
name|maximumAttempts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|this
operator|.
name|server
operator|.
name|isStopped
argument_list|()
operator|||
name|this
operator|.
name|server
operator|.
name|isAborted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server stopped/aborted; skipping unassign of "
operator|+
name|region
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|server
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Offline "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", no need to unassign since it's on a dead server: "
operator|+
name|server
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
comment|// Send CLOSE RPC
if|if
condition|(
name|serverManager
operator|.
name|sendRegionClose
argument_list|(
name|server
argument_list|,
name|region
argument_list|,
name|dest
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sent CLOSE to "
operator|+
name|server
operator|+
literal|" for region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// This never happens. Currently regionserver close always return true.
comment|// Todo; this can now happen (0.96) if there is an exception in a coprocessor
name|LOG
operator|.
name|warn
argument_list|(
literal|"Server "
operator|+
name|server
operator|+
literal|" region CLOSE RPC returned false for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|RemoteException
condition|)
block|{
name|t
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|t
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
name|boolean
name|logRetries
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|NotServingRegionException
operator|||
name|t
operator|instanceof
name|RegionServerStoppedException
operator|||
name|t
operator|instanceof
name|ServerNotRunningYetException
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Offline "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", it's not any more on "
operator|+
name|server
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|t
operator|instanceof
name|FailedServerException
operator|||
name|t
operator|instanceof
name|RegionAlreadyInTransitionException
condition|)
block|{
name|long
name|sleepTime
init|=
literal|0
decl_stmt|;
name|Configuration
name|conf
init|=
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|FailedServerException
condition|)
block|{
name|sleepTime
operator|=
literal|1
operator|+
name|conf
operator|.
name|getInt
argument_list|(
name|RpcClient
operator|.
name|FAILED_SERVER_EXPIRY_KEY
argument_list|,
name|RpcClient
operator|.
name|FAILED_SERVER_EXPIRY_DEFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|maxWaitTime
operator|<
literal|0
condition|)
block|{
name|maxWaitTime
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|+
name|conf
operator|.
name|getLong
argument_list|(
name|ALREADY_IN_TRANSITION_WAITTIME
argument_list|,
name|DEFAULT_ALREADY_IN_TRANSITION_WAITTIME
argument_list|)
expr_stmt|;
block|}
name|long
name|now
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|<
name|maxWaitTime
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Region is already in transition; "
operator|+
literal|"waiting up to "
operator|+
operator|(
name|maxWaitTime
operator|-
name|now
operator|)
operator|+
literal|"ms"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|sleepTime
operator|=
literal|100
expr_stmt|;
name|i
operator|--
expr_stmt|;
comment|// reset the try count
name|logRetries
operator|=
literal|false
expr_stmt|;
block|}
block|}
try|try
block|{
if|if
condition|(
name|sleepTime
operator|>
literal|0
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to unassign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" since interrupted"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_CLOSE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
if|if
condition|(
name|logRetries
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Server "
operator|+
name|server
operator|+
literal|" returned "
operator|+
name|t
operator|+
literal|" for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", try="
operator|+
name|i
operator|+
literal|" of "
operator|+
name|this
operator|.
name|maximumAttempts
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// Presume retry or server will expire.
block|}
block|}
block|}
comment|// Run out of attempts
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_CLOSE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set region to OFFLINE unless it is opening and forceNewPlan is false.    */
specifier|private
name|RegionState
name|forceRegionStateToOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
block|{
name|RegionState
name|state
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|region
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Assigning a region not in region states: "
operator|+
name|region
argument_list|)
expr_stmt|;
name|state
operator|=
name|regionStates
operator|.
name|createRegionState
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|forceNewPlan
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Force region state offline "
operator|+
name|state
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|state
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|OPEN
case|:
case|case
name|OPENING
case|:
case|case
name|PENDING_OPEN
case|:
case|case
name|CLOSING
case|:
case|case
name|PENDING_CLOSE
case|:
if|if
condition|(
operator|!
name|forceNewPlan
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip assigning "
operator|+
name|region
operator|+
literal|", it is already "
operator|+
name|state
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
case|case
name|FAILED_CLOSE
case|:
case|case
name|FAILED_OPEN
case|:
name|unassign
argument_list|(
name|region
argument_list|,
name|state
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|state
operator|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|isFailedClose
argument_list|()
condition|)
block|{
comment|// If we can't close the region, we can't re-assign
comment|// it so as to avoid possible double assignment/data loss.
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip assigning "
operator|+
name|region
operator|+
literal|", we couldn't close it: "
operator|+
name|state
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
case|case
name|OFFLINE
case|:
case|case
name|CLOSED
case|:
break|break;
default|default:
name|LOG
operator|.
name|error
argument_list|(
literal|"Trying to assign region "
operator|+
name|region
operator|+
literal|", which is "
operator|+
name|state
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|state
return|;
block|}
comment|/**    * Caller must hold lock on the passed<code>state</code> object.    * @param state    * @param forceNewPlan    */
specifier|private
name|void
name|assign
parameter_list|(
name|RegionState
name|state
parameter_list|,
name|boolean
name|forceNewPlan
parameter_list|)
block|{
name|long
name|startTime
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
try|try
block|{
name|Configuration
name|conf
init|=
name|server
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|RegionPlan
name|plan
init|=
literal|null
decl_stmt|;
name|long
name|maxWaitTime
init|=
operator|-
literal|1
decl_stmt|;
name|HRegionInfo
name|region
init|=
name|state
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|RegionOpeningState
name|regionOpenState
decl_stmt|;
name|Throwable
name|previousException
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|maximumAttempts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|server
operator|.
name|isStopped
argument_list|()
operator|||
name|server
operator|.
name|isAborted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip assigning "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", the server is stopped/aborted"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
block|{
comment|// Get a server for the region at first
try|try
block|{
name|plan
operator|=
name|getRegionPlan
argument_list|(
name|region
argument_list|,
name|forceNewPlan
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get region plan"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to determine a plan to assign "
operator|+
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|sleepTimeBeforeRetryingMetaAssignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|maximumAttempts
condition|)
name|i
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Got exception while waiting for hbase:meta assignment"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// In case of assignment from EnableTableHandler table state is ENABLING. Any how
comment|// EnableTableHandler will set ENABLED after assigning all the table regions. If we
comment|// try to set to ENABLED directly then client API may think table is enabled.
comment|// When we have a case such as all the regions are added directly into hbase:meta and we call
comment|// assignRegion then we need to make the table ENABLED. Hence in such case the table
comment|// will not be in ENABLING or ENABLED state.
name|TableName
name|tableName
init|=
name|region
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tableStateManager
operator|.
name|isTableState
argument_list|(
name|tableName
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|ENABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|ENABLING
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setting table "
operator|+
name|tableName
operator|+
literal|" to ENABLED state."
argument_list|)
expr_stmt|;
name|setEnabledTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigning "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Transition RegionState to PENDING_OPEN
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|PENDING_OPEN
argument_list|,
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|needNewPlan
decl_stmt|;
specifier|final
name|String
name|assignMsg
init|=
literal|"Failed assignment of "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
init|=
name|ServerName
operator|.
name|EMPTY_SERVER_LIST
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|shouldAssignRegionsWithFavoredNodes
condition|)
block|{
name|favoredNodes
operator|=
operator|(
operator|(
name|FavoredNodeLoadBalancer
operator|)
name|this
operator|.
name|balancer
operator|)
operator|.
name|getFavoredNodes
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
name|regionOpenState
operator|=
name|serverManager
operator|.
name|sendRegionOpen
argument_list|(
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|,
name|region
argument_list|,
name|favoredNodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionOpenState
operator|==
name|RegionOpeningState
operator|.
name|FAILED_OPENING
condition|)
block|{
comment|// Failed opening this region, looping again on a new server.
name|needNewPlan
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|assignMsg
operator|+
literal|", regionserver says 'FAILED_OPENING', "
operator|+
literal|" trying to assign elsewhere instead; "
operator|+
literal|"try="
operator|+
name|i
operator|+
literal|" of "
operator|+
name|this
operator|.
name|maximumAttempts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we're done
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|RemoteException
condition|)
block|{
name|t
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|t
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
name|previousException
operator|=
name|t
expr_stmt|;
comment|// Should we wait a little before retrying? If the server is starting it's yes.
comment|// If the region is already in transition, it's yes as well: we want to be sure that
comment|//  the region will get opened but we don't want a double assignment.
name|boolean
name|hold
init|=
operator|(
name|t
operator|instanceof
name|RegionAlreadyInTransitionException
operator|||
name|t
operator|instanceof
name|ServerNotRunningYetException
operator|)
decl_stmt|;
comment|// In case socket is timed out and the region server is still online,
comment|// the openRegion RPC could have been accepted by the server and
comment|// just the response didn't go through.  So we will retry to
comment|// open the region on the same server to avoid possible
comment|// double assignment.
name|boolean
name|retry
init|=
operator|!
name|hold
operator|&&
operator|(
name|t
operator|instanceof
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
operator|&&
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|hold
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|assignMsg
operator|+
literal|", waiting a little before trying on the same region server "
operator|+
literal|"try="
operator|+
name|i
operator|+
literal|" of "
operator|+
name|this
operator|.
name|maximumAttempts
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxWaitTime
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|RegionAlreadyInTransitionException
condition|)
block|{
name|maxWaitTime
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|+
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|ALREADY_IN_TRANSITION_WAITTIME
argument_list|,
name|DEFAULT_ALREADY_IN_TRANSITION_WAITTIME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxWaitTime
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|+
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.rpc.startup.waittime"
argument_list|,
literal|60000
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|needNewPlan
operator|=
literal|false
expr_stmt|;
name|long
name|now
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|<
name|maxWaitTime
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server is not yet up or region is already in transition; "
operator|+
literal|"waiting up to "
operator|+
operator|(
name|maxWaitTime
operator|-
name|now
operator|)
operator|+
literal|"ms"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
comment|// reset the try count
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|t
operator|instanceof
name|RegionAlreadyInTransitionException
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server is not up for a while; try a new one"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|needNewPlan
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to assign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" since interrupted"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|retry
condition|)
block|{
name|needNewPlan
operator|=
literal|false
expr_stmt|;
name|i
operator|--
expr_stmt|;
comment|// we want to retry as many times as needed as long as the RS is not dead.
name|LOG
operator|.
name|warn
argument_list|(
name|assignMsg
operator|+
literal|", trying to assign to the same region server due "
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|needNewPlan
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|assignMsg
operator|+
literal|", trying to assign elsewhere instead;"
operator|+
literal|" try="
operator|+
name|i
operator|+
literal|" of "
operator|+
name|this
operator|.
name|maximumAttempts
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|this
operator|.
name|maximumAttempts
condition|)
block|{
comment|// Don't reset the region state or get a new plan any more.
comment|// This is the last try.
continue|continue;
block|}
comment|// If region opened on destination of present plan, reassigning to new
comment|// RS may cause double assignments. In case of RegionAlreadyInTransitionException
comment|// reassigning to same RS.
if|if
condition|(
name|needNewPlan
condition|)
block|{
comment|// Force a new plan and reassign. Will return null if no servers.
comment|// The new plan could be the same as the existing plan since we don't
comment|// exclude the server of the original plan, which should not be
comment|// excluded since it could be the only server up now.
name|RegionPlan
name|newPlan
init|=
literal|null
decl_stmt|;
try|try
block|{
name|newPlan
operator|=
name|getRegionPlan
argument_list|(
name|region
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get region plan"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newPlan
operator|==
literal|null
condition|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to find a viable location to assign region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|plan
operator|!=
name|newPlan
operator|&&
operator|!
name|plan
operator|.
name|getDestination
argument_list|()
operator|.
name|equals
argument_list|(
name|newPlan
operator|.
name|getDestination
argument_list|()
argument_list|)
condition|)
block|{
comment|// Clean out plan we failed execute and one that doesn't look like it'll
comment|// succeed anyways; we need a new plan!
comment|// Transition back to OFFLINE
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
name|plan
operator|=
name|newPlan
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plan
operator|.
name|getDestination
argument_list|()
operator|.
name|equals
argument_list|(
name|newPlan
operator|.
name|getDestination
argument_list|()
argument_list|)
operator|&&
name|previousException
operator|instanceof
name|FailedServerException
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to re-assign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to the same failed server."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1
operator|+
name|conf
operator|.
name|getInt
argument_list|(
name|RpcClient
operator|.
name|FAILED_SERVER_EXPIRY_KEY
argument_list|,
name|RpcClient
operator|.
name|FAILED_SERVER_EXPIRY_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to assign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" since interrupted"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|// Run out of attempts
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|metricsAssignmentManager
operator|.
name|updateAssignmentTime
argument_list|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|isDisabledorDisablingRegionInRIT
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|tableStateManager
operator|.
name|isTableState
argument_list|(
name|region
operator|.
name|getTable
argument_list|()
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
operator|||
name|replicasToClose
operator|.
name|contains
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Table "
operator|+
name|region
operator|.
name|getTable
argument_list|()
operator|+
literal|" is disabled or disabling;"
operator|+
literal|" skipping assign of "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|offlineDisabledRegion
argument_list|(
name|region
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * @param region the region to assign    * @return Plan for passed<code>region</code> (If none currently, it creates one or    * if no servers to assign, it returns null).    */
specifier|private
name|RegionPlan
name|getRegionPlan
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
throws|throws
name|HBaseIOException
block|{
return|return
name|getRegionPlan
argument_list|(
name|region
argument_list|,
literal|null
argument_list|,
name|forceNewPlan
argument_list|)
return|;
block|}
comment|/**    * @param region the region to assign    * @param serverToExclude Server to exclude (we know its bad). Pass null if    * all servers are thought to be assignable.    * @param forceNewPlan If true, then if an existing plan exists, a new plan    * will be generated.    * @return Plan for passed<code>region</code> (If none currently, it creates one or    * if no servers to assign, it returns null).    */
specifier|private
name|RegionPlan
name|getRegionPlan
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|ServerName
name|serverToExclude
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
throws|throws
name|HBaseIOException
block|{
comment|// Pickup existing plan or make a new one
specifier|final
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|destServers
init|=
name|serverManager
operator|.
name|createDestinationServersList
argument_list|(
name|serverToExclude
argument_list|)
decl_stmt|;
if|if
condition|(
name|destServers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can't move "
operator|+
name|encodedName
operator|+
literal|", there is no destination server available."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|RegionPlan
name|randomPlan
init|=
literal|null
decl_stmt|;
name|boolean
name|newPlan
init|=
literal|false
decl_stmt|;
name|RegionPlan
name|existingPlan
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|existingPlan
operator|=
name|this
operator|.
name|regionPlans
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|existingPlan
operator|!=
literal|null
operator|&&
name|existingPlan
operator|.
name|getDestination
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found an existing plan for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" destination server is "
operator|+
name|existingPlan
operator|.
name|getDestination
argument_list|()
operator|+
literal|" accepted as a dest server = "
operator|+
name|destServers
operator|.
name|contains
argument_list|(
name|existingPlan
operator|.
name|getDestination
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|forceNewPlan
operator|||
name|existingPlan
operator|==
literal|null
operator|||
name|existingPlan
operator|.
name|getDestination
argument_list|()
operator|==
literal|null
operator|||
operator|!
name|destServers
operator|.
name|contains
argument_list|(
name|existingPlan
operator|.
name|getDestination
argument_list|()
argument_list|)
condition|)
block|{
name|newPlan
operator|=
literal|true
expr_stmt|;
name|randomPlan
operator|=
operator|new
name|RegionPlan
argument_list|(
name|region
argument_list|,
literal|null
argument_list|,
name|balancer
operator|.
name|randomAssignment
argument_list|(
name|region
argument_list|,
name|destServers
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|region
operator|.
name|isMetaTable
argument_list|()
operator|&&
name|shouldAssignRegionsWithFavoredNodes
condition|)
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|regions
operator|.
name|add
argument_list|(
name|region
argument_list|)
expr_stmt|;
try|try
block|{
name|processFavoredNodes
argument_list|(
name|regions
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring exception in processFavoredNodes "
operator|+
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|regionPlans
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|randomPlan
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newPlan
condition|)
block|{
if|if
condition|(
name|randomPlan
operator|.
name|getDestination
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can't find a destination for "
operator|+
name|encodedName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"No previous transition plan found (or ignoring "
operator|+
literal|"an existing plan) for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|"; generated random plan="
operator|+
name|randomPlan
operator|+
literal|"; "
operator|+
name|destServers
operator|.
name|size
argument_list|()
operator|+
literal|" (online="
operator|+
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|") available servers, forceNewPlan="
operator|+
name|forceNewPlan
argument_list|)
expr_stmt|;
return|return
name|randomPlan
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using pre-existing plan for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|"; plan="
operator|+
name|existingPlan
argument_list|)
expr_stmt|;
return|return
name|existingPlan
return|;
block|}
comment|/**    * Unassigns the specified region.    *<p>    * Updates the RegionState and sends the CLOSE RPC unless region is being    * split by regionserver; then the unassign fails (silently) because we    * presume the region being unassigned no longer exists (its been split out    * of existence). TODO: What to do if split fails and is rolled back and    * parent is revivified?    *<p>    * If a RegionPlan is already set, it will remain.    *    * @param region server to be unassigned    */
specifier|public
name|void
name|unassign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
name|unassign
argument_list|(
name|region
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Unassigns the specified region.    *<p>    * Updates the RegionState and sends the CLOSE RPC unless region is being    * split by regionserver; then the unassign fails (silently) because we    * presume the region being unassigned no longer exists (its been split out    * of existence). TODO: What to do if split fails and is rolled back and    * parent is revivified?    *<p>    * If a RegionPlan is already set, it will remain.    *    * @param region server to be unassigned    * @param dest the destination server of the region    */
specifier|public
name|void
name|unassign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|dest
parameter_list|)
block|{
comment|// TODO: Method needs refactoring.  Ugly buried returns throughout.  Beware!
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting unassign of "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" (offlining), current state: "
operator|+
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
comment|// Grab the state of this region and synchronize on it
comment|// We need a lock here as we're going to do a put later and we don't want multiple states
comment|//  creation
name|ReentrantLock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|RegionState
name|state
init|=
name|regionStates
operator|.
name|getRegionTransitionState
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|state
operator|==
literal|null
operator|||
name|state
operator|.
name|isFailedClose
argument_list|()
condition|)
block|{
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
comment|// Region is not in transition.
comment|// We can unassign it only if it's not SPLIT/MERGED.
name|state
operator|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
operator|&&
name|state
operator|.
name|isUnassignable
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to unassign "
operator|+
name|state
operator|+
literal|", ignored"
argument_list|)
expr_stmt|;
comment|// Offline region will be reassigned below
return|return;
block|}
if|if
condition|(
name|state
operator|==
literal|null
operator|||
name|state
operator|.
name|getServerName
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// We don't know where the region is, offline it.
comment|// No need to send CLOSE RPC
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempting to unassign a region not in RegionStates"
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", offlined"
argument_list|)
expr_stmt|;
name|regionOffline
argument_list|(
name|region
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|state
operator|=
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|PENDING_CLOSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|isFailedOpen
argument_list|()
condition|)
block|{
comment|// The region is not open yet
name|regionOffline
argument_list|(
name|region
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to unassign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but it is "
operator|+
literal|"already in transition ("
operator|+
name|state
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|unassign
argument_list|(
name|region
argument_list|,
name|state
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// Region is expected to be reassigned afterwards
if|if
condition|(
operator|!
name|replicasToClose
operator|.
name|contains
argument_list|(
name|region
argument_list|)
operator|&&
name|regionStates
operator|.
name|isRegionInState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|OFFLINE
argument_list|)
condition|)
block|{
name|assign
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Used by unit tests. Return the number of regions opened so far in the life    * of the master. Increases by one every time the master opens a region    * @return the counter value of the number of regions opened so far    */
specifier|public
name|int
name|getNumRegionsOpened
parameter_list|()
block|{
return|return
name|numRegionsOpened
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Waits until the specified region has completed assignment.    *<p>    * If the region is already assigned, returns immediately.  Otherwise, method    * blocks until the region is assigned.    * @param regionInfo region to wait on assignment for    * @throws InterruptedException    */
specifier|public
name|boolean
name|waitForAssignment
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|InterruptedException
block|{
while|while
condition|(
operator|!
name|regionStates
operator|.
name|isRegionOnline
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|regionStates
operator|.
name|isRegionInState
argument_list|(
name|regionInfo
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
operator|||
name|this
operator|.
name|server
operator|.
name|isStopped
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We should receive a notification, but it's
comment|//  better to have a timeout to recheck the condition here:
comment|//  it lowers the impact of a race condition if any
name|regionStates
operator|.
name|waitForUpdate
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Assigns the hbase:meta region.    *<p>    * Assumes that hbase:meta is currently closed and is not being actively served by    * any RegionServer.    */
specifier|public
name|void
name|assignMeta
parameter_list|()
throws|throws
name|KeeperException
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|,
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assigns specified regions retaining assignments, if any.    *<p>    * This is a synchronous call and will return once every region has been    * assigned.  If anything fails, an exception is thrown    * @throws InterruptedException    * @throws IOException    */
specifier|public
name|void
name|assign
parameter_list|(
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regions
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|regions
operator|==
literal|null
operator|||
name|regions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
init|=
name|serverManager
operator|.
name|createDestinationServersList
argument_list|()
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|null
operator|||
name|servers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Found no destination server to assign region(s)"
argument_list|)
throw|;
block|}
comment|// Reuse existing assignment info
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
init|=
name|balancer
operator|.
name|retainAssignment
argument_list|(
name|regions
argument_list|,
name|servers
argument_list|)
decl_stmt|;
name|assign
argument_list|(
name|regions
operator|.
name|size
argument_list|()
argument_list|,
name|servers
operator|.
name|size
argument_list|()
argument_list|,
literal|"retainAssignment=true"
argument_list|,
name|bulkPlan
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assigns specified regions round robin, if any.    *<p>    * This is a synchronous call and will return once every region has been    * assigned.  If anything fails, an exception is thrown    * @throws InterruptedException    * @throws IOException    */
specifier|public
name|void
name|assign
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|regions
operator|==
literal|null
operator|||
name|regions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
init|=
name|serverManager
operator|.
name|createDestinationServersList
argument_list|()
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|null
operator|||
name|servers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Found no destination server to assign region(s)"
argument_list|)
throw|;
block|}
comment|// Generate a round-robin bulk assignment plan
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
init|=
name|balancer
operator|.
name|roundRobinAssignment
argument_list|(
name|regions
argument_list|,
name|servers
argument_list|)
decl_stmt|;
name|processFavoredNodes
argument_list|(
name|regions
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|regions
operator|.
name|size
argument_list|()
argument_list|,
name|servers
operator|.
name|size
argument_list|()
argument_list|,
literal|"round-robin=true"
argument_list|,
name|bulkPlan
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|assign
parameter_list|(
name|int
name|regions
parameter_list|,
name|int
name|totalServers
parameter_list|,
name|String
name|message
parameter_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|int
name|servers
init|=
name|bulkPlan
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|1
operator|||
operator|(
name|regions
operator|<
name|bulkAssignThresholdRegions
operator|&&
name|servers
operator|<
name|bulkAssignThresholdServers
operator|)
condition|)
block|{
comment|// Not use bulk assignment.  This could be more efficient in small
comment|// cluster, especially mini cluster for testing, so that tests won't time out
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Not using bulk assignment since we are assigning only "
operator|+
name|regions
operator|+
literal|" region(s) to "
operator|+
name|servers
operator|+
literal|" server(s)"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|plan
range|:
name|bulkPlan
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|assign
argument_list|(
name|plan
operator|.
name|getKey
argument_list|()
argument_list|,
name|plan
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
for|for
control|(
name|HRegionInfo
name|region
range|:
name|plan
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|regionStates
operator|.
name|isRegionOnline
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|invokeAssign
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Bulk assigning "
operator|+
name|regions
operator|+
literal|" region(s) across "
operator|+
name|totalServers
operator|+
literal|" server(s), "
operator|+
name|message
argument_list|)
expr_stmt|;
comment|// Use fixed count thread pool assigning.
name|BulkAssigner
name|ba
init|=
operator|new
name|GeneralBulkAssigner
argument_list|(
name|this
operator|.
name|server
argument_list|,
name|bulkPlan
argument_list|,
name|this
argument_list|,
name|bulkAssignWaitTillAllAssigned
argument_list|)
decl_stmt|;
name|ba
operator|.
name|bulkAssign
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Bulk assigning done"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Assigns all user regions, if any exist.  Used during cluster startup.    *<p>    * This is a synchronous call and will return once every region has been    * assigned.  If anything fails, an exception is thrown and the cluster    * should be shutdown.    * @throws InterruptedException    * @throws IOException    */
specifier|private
name|void
name|assignAllUserRegions
parameter_list|(
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|allRegions
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|allRegions
operator|==
literal|null
operator|||
name|allRegions
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// Determine what type of assignment to do on startup
name|boolean
name|retainAssignment
init|=
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.startup.retainassign"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|regionsFromMetaScan
init|=
name|allRegions
operator|.
name|keySet
argument_list|()
decl_stmt|;
if|if
condition|(
name|retainAssignment
condition|)
block|{
name|assign
argument_list|(
name|allRegions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|regionsFromMetaScan
argument_list|)
decl_stmt|;
name|assign
argument_list|(
name|regions
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|regionsFromMetaScan
control|)
block|{
name|TableName
name|tableName
init|=
name|hri
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tableStateManager
operator|.
name|isTableState
argument_list|(
name|tableName
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|ENABLED
argument_list|)
condition|)
block|{
name|setEnabledTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
comment|// assign all the replicas that were not recorded in the meta
name|assign
argument_list|(
name|replicaRegionsNotRecordedInMeta
argument_list|(
name|regionsFromMetaScan
argument_list|,
operator|(
name|MasterServices
operator|)
name|server
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a list of replica regions that are:    * not recorded in meta yet. We might not have recorded the locations    * for the replicas since the replicas may not have been online yet, master restarted    * in the middle of assigning, ZK erased, etc.    * @param regionsRecordedInMeta the list of regions we know are recorded in meta    * either as a default, or, as the location of a replica    * @param master    * @return list of replica regions    * @throws IOException    */
specifier|public
specifier|static
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|replicaRegionsNotRecordedInMeta
parameter_list|(
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|regionsRecordedInMeta
parameter_list|,
name|MasterServices
name|master
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regionsNotRecordedInMeta
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|regionsRecordedInMeta
control|)
block|{
name|TableName
name|table
init|=
name|hri
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|HTableDescriptor
name|htd
init|=
name|master
operator|.
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|table
argument_list|)
decl_stmt|;
comment|// look at the HTD for the replica count. That's the source of truth
name|int
name|desiredRegionReplication
init|=
name|htd
operator|.
name|getRegionReplication
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|desiredRegionReplication
condition|;
name|i
operator|++
control|)
block|{
name|HRegionInfo
name|replica
init|=
name|RegionReplicaUtil
operator|.
name|getRegionInfoForReplica
argument_list|(
name|hri
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionsRecordedInMeta
operator|.
name|contains
argument_list|(
name|replica
argument_list|)
condition|)
continue|continue;
name|regionsNotRecordedInMeta
operator|.
name|add
argument_list|(
name|replica
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|regionsNotRecordedInMeta
return|;
block|}
comment|/**    * Rebuild the list of user regions and assignment information.    *<p>    * Returns a set of servers that are not found to be online that hosted    * some regions.    * @return set of servers not online that hosted some regions per meta    * @throws IOException    */
name|Set
argument_list|<
name|ServerName
argument_list|>
name|rebuildUserRegions
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|CoordinatedStateException
block|{
name|Set
argument_list|<
name|TableName
argument_list|>
name|disabledOrEnablingTables
init|=
name|tableStateManager
operator|.
name|getTablesInStates
argument_list|(
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|ENABLING
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|TableName
argument_list|>
name|disabledOrDisablingOrEnabling
init|=
name|tableStateManager
operator|.
name|getTablesInStates
argument_list|(
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|ENABLING
argument_list|)
decl_stmt|;
comment|// Region assignment from META
name|List
argument_list|<
name|Result
argument_list|>
name|results
init|=
name|MetaTableAccessor
operator|.
name|fullScanOfMeta
argument_list|(
name|server
operator|.
name|getShortCircuitConnection
argument_list|()
argument_list|)
decl_stmt|;
comment|// Get any new but slow to checkin region server that joined the cluster
name|Set
argument_list|<
name|ServerName
argument_list|>
name|onlineServers
init|=
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|keySet
argument_list|()
decl_stmt|;
comment|// Set of offline servers to be returned
name|Set
argument_list|<
name|ServerName
argument_list|>
name|offlineServers
init|=
operator|new
name|HashSet
argument_list|<
name|ServerName
argument_list|>
argument_list|()
decl_stmt|;
comment|// Iterate regions in META
for|for
control|(
name|Result
name|result
range|:
name|results
control|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"null result from meta - ignoring but this is strange."
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// keep a track of replicas to close. These were the replicas of the originally
comment|// unmerged regions. The master might have closed them before but it mightn't
comment|// maybe because it crashed.
name|PairOfSameType
argument_list|<
name|HRegionInfo
argument_list|>
name|p
init|=
name|MetaTableAccessor
operator|.
name|getMergeRegions
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|getFirst
argument_list|()
operator|!=
literal|null
operator|&&
name|p
operator|.
name|getSecond
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|int
name|numReplicas
init|=
operator|(
operator|(
name|MasterServices
operator|)
name|server
operator|)
operator|.
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|p
operator|.
name|getFirst
argument_list|()
operator|.
name|getTable
argument_list|()
argument_list|)
operator|.
name|getRegionReplication
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|merge
range|:
name|p
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numReplicas
condition|;
name|i
operator|++
control|)
block|{
name|replicasToClose
operator|.
name|add
argument_list|(
name|RegionReplicaUtil
operator|.
name|getRegionInfoForReplica
argument_list|(
name|merge
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|RegionLocations
name|rl
init|=
name|MetaTableAccessor
operator|.
name|getRegionLocations
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|rl
operator|==
literal|null
condition|)
continue|continue;
name|HRegionLocation
index|[]
name|locations
init|=
name|rl
operator|.
name|getRegionLocations
argument_list|()
decl_stmt|;
if|if
condition|(
name|locations
operator|==
literal|null
condition|)
continue|continue;
for|for
control|(
name|HRegionLocation
name|hrl
range|:
name|locations
control|)
block|{
name|HRegionInfo
name|regionInfo
init|=
name|hrl
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionInfo
operator|==
literal|null
condition|)
continue|continue;
name|int
name|replicaId
init|=
name|regionInfo
operator|.
name|getReplicaId
argument_list|()
decl_stmt|;
name|State
name|state
init|=
name|RegionStateStore
operator|.
name|getRegionState
argument_list|(
name|result
argument_list|,
name|replicaId
argument_list|)
decl_stmt|;
comment|// keep a track of replicas to close. These were the replicas of the split parents
comment|// from the previous life of the master. The master should have closed them before
comment|// but it couldn't maybe because it crashed
if|if
condition|(
name|replicaId
operator|==
literal|0
operator|&&
name|state
operator|.
name|equals
argument_list|(
name|State
operator|.
name|SPLIT
argument_list|)
condition|)
block|{
for|for
control|(
name|HRegionLocation
name|h
range|:
name|locations
control|)
block|{
name|replicasToClose
operator|.
name|add
argument_list|(
name|h
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|ServerName
name|lastHost
init|=
name|hrl
operator|.
name|getServerName
argument_list|()
decl_stmt|;
name|ServerName
name|regionLocation
init|=
name|RegionStateStore
operator|.
name|getRegionServer
argument_list|(
name|result
argument_list|,
name|replicaId
argument_list|)
decl_stmt|;
name|regionStates
operator|.
name|createRegionState
argument_list|(
name|regionInfo
argument_list|,
name|state
argument_list|,
name|regionLocation
argument_list|,
name|lastHost
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regionStates
operator|.
name|isRegionInState
argument_list|(
name|regionInfo
argument_list|,
name|State
operator|.
name|OPEN
argument_list|)
condition|)
block|{
comment|// Region is not open (either offline or in transition), skip
continue|continue;
block|}
name|TableName
name|tableName
init|=
name|regionInfo
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|onlineServers
operator|.
name|contains
argument_list|(
name|regionLocation
argument_list|)
condition|)
block|{
comment|// Region is located on a server that isn't online
name|offlineServers
operator|.
name|add
argument_list|(
name|regionLocation
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|disabledOrEnablingTables
operator|.
name|contains
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
comment|// Region is being served and on an active server
comment|// add only if region not in disabled or enabling table
name|regionStates
operator|.
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|regionLocation
argument_list|)
expr_stmt|;
name|balancer
operator|.
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|regionLocation
argument_list|)
expr_stmt|;
block|}
comment|// need to enable the table if not disabled or disabling or enabling
comment|// this will be used in rolling restarts
if|if
condition|(
operator|!
name|disabledOrDisablingOrEnabling
operator|.
name|contains
argument_list|(
name|tableName
argument_list|)
operator|&&
operator|!
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|tableName
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|ENABLED
argument_list|)
condition|)
block|{
name|setEnabledTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|offlineServers
return|;
block|}
comment|/**    * Recover the tables that were not fully moved to DISABLED state. These    * tables are in DISABLING state when the master restarted/switched.    *    * @throws KeeperException    * @throws TableNotFoundException    * @throws IOException    */
specifier|private
name|void
name|recoverTableInDisablingState
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|IOException
throws|,
name|CoordinatedStateException
block|{
name|Set
argument_list|<
name|TableName
argument_list|>
name|disablingTables
init|=
name|tableStateManager
operator|.
name|getTablesInStates
argument_list|(
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
decl_stmt|;
if|if
condition|(
name|disablingTables
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|TableName
name|tableName
range|:
name|disablingTables
control|)
block|{
comment|// Recover by calling DisableTableHandler
name|LOG
operator|.
name|info
argument_list|(
literal|"The table "
operator|+
name|tableName
operator|+
literal|" is in DISABLING state.  Hence recovering by moving the table"
operator|+
literal|" to DISABLED state."
argument_list|)
expr_stmt|;
operator|new
name|DisableTableHandler
argument_list|(
name|this
operator|.
name|server
argument_list|,
name|tableName
argument_list|,
name|this
argument_list|,
name|tableLockManager
argument_list|,
literal|true
argument_list|)
operator|.
name|prepare
argument_list|()
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Recover the tables that are not fully moved to ENABLED state. These tables    * are in ENABLING state when the master restarted/switched    *    * @throws KeeperException    * @throws org.apache.hadoop.hbase.TableNotFoundException    * @throws IOException    */
specifier|private
name|void
name|recoverTableInEnablingState
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|IOException
throws|,
name|CoordinatedStateException
block|{
name|Set
argument_list|<
name|TableName
argument_list|>
name|enablingTables
init|=
name|tableStateManager
operator|.
name|getTablesInStates
argument_list|(
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|ENABLING
argument_list|)
decl_stmt|;
if|if
condition|(
name|enablingTables
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|TableName
name|tableName
range|:
name|enablingTables
control|)
block|{
comment|// Recover by calling EnableTableHandler
name|LOG
operator|.
name|info
argument_list|(
literal|"The table "
operator|+
name|tableName
operator|+
literal|" is in ENABLING state.  Hence recovering by moving the table"
operator|+
literal|" to ENABLED state."
argument_list|)
expr_stmt|;
comment|// enableTable in sync way during master startup,
comment|// no need to invoke coprocessor
name|EnableTableHandler
name|eth
init|=
operator|new
name|EnableTableHandler
argument_list|(
name|this
operator|.
name|server
argument_list|,
name|tableName
argument_list|,
name|this
argument_list|,
name|tableLockManager
argument_list|,
literal|true
argument_list|)
decl_stmt|;
try|try
block|{
name|eth
operator|.
name|prepare
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TableNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Table "
operator|+
name|tableName
operator|+
literal|" not found in hbase:meta to recover."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|eth
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Processes list of regions in transition at startup    */
name|void
name|processRegionsInTransition
parameter_list|(
name|Collection
argument_list|<
name|RegionState
argument_list|>
name|regionStates
parameter_list|)
block|{
comment|// We need to send RPC call again for PENDING_OPEN/PENDING_CLOSE regions
comment|// in case the RPC call is not sent out yet before the master was shut down
comment|// since we update the state before we send the RPC call. We can't update
comment|// the state after the RPC call. Otherwise, we don't know what's happened
comment|// to the region if the master dies right after the RPC call is out.
for|for
control|(
name|RegionState
name|regionState
range|:
name|regionStates
control|)
block|{
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
comment|// SSH will handle it
block|}
name|State
name|state
init|=
name|regionState
operator|.
name|getState
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing "
operator|+
name|regionState
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|PENDING_OPEN
case|:
name|retrySendRegionOpen
argument_list|(
name|regionState
argument_list|)
expr_stmt|;
break|break;
case|case
name|PENDING_CLOSE
case|:
name|retrySendRegionClose
argument_list|(
name|regionState
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// No process for other states
block|}
block|}
block|}
comment|/**    * At master failover, for pending_open region, make sure    * sendRegionOpen RPC call is sent to the target regionserver    */
specifier|private
name|void
name|retrySendRegionOpen
parameter_list|(
specifier|final
name|RegionState
name|regionState
parameter_list|)
block|{
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|EventHandler
argument_list|(
name|server
argument_list|,
name|EventType
operator|.
name|M_MASTER_RECOVERY
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|HRegionInfo
name|hri
init|=
name|regionState
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|ServerName
name|serverName
init|=
name|regionState
operator|.
name|getServerName
argument_list|()
decl_stmt|;
name|ReentrantLock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|regionState
operator|.
name|equals
argument_list|(
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|hri
argument_list|)
argument_list|)
condition|)
block|{
return|return;
comment|// Region is not in the expected state any more
block|}
while|while
condition|(
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|serverName
argument_list|)
operator|&&
operator|!
name|server
operator|.
name|isStopped
argument_list|()
operator|&&
operator|!
name|server
operator|.
name|isAborted
argument_list|()
condition|)
block|{
try|try
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
init|=
name|ServerName
operator|.
name|EMPTY_SERVER_LIST
decl_stmt|;
if|if
condition|(
name|shouldAssignRegionsWithFavoredNodes
condition|)
block|{
name|favoredNodes
operator|=
operator|(
operator|(
name|FavoredNodeLoadBalancer
operator|)
name|balancer
operator|)
operator|.
name|getFavoredNodes
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
name|RegionOpeningState
name|regionOpenState
init|=
name|serverManager
operator|.
name|sendRegionOpen
argument_list|(
name|serverName
argument_list|,
name|hri
argument_list|,
name|favoredNodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionOpenState
operator|==
name|RegionOpeningState
operator|.
name|FAILED_OPENING
condition|)
block|{
comment|// Failed opening this region, this means the target server didn't get
comment|// the original region open RPC, so re-assign it with a new plan
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got failed_opening in retry sendRegionOpen for "
operator|+
name|regionState
operator|+
literal|", re-assign it"
argument_list|)
expr_stmt|;
name|invokeAssign
argument_list|(
name|hri
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return;
comment|// Done.
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|RemoteException
condition|)
block|{
name|t
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|t
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
comment|// In case SocketTimeoutException/FailedServerException, retry
if|if
condition|(
name|t
operator|instanceof
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
operator|||
name|t
operator|instanceof
name|FailedServerException
condition|)
block|{
name|Threads
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// For other exceptions, re-assign it
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got exception in retry sendRegionOpen for "
operator|+
name|regionState
operator|+
literal|", re-assign it"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|invokeAssign
argument_list|(
name|hri
argument_list|)
expr_stmt|;
return|return;
comment|// Done.
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * At master failover, for pending_close region, make sure    * sendRegionClose RPC call is sent to the target regionserver    */
specifier|private
name|void
name|retrySendRegionClose
parameter_list|(
specifier|final
name|RegionState
name|regionState
parameter_list|)
block|{
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|EventHandler
argument_list|(
name|server
argument_list|,
name|EventType
operator|.
name|M_MASTER_RECOVERY
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|HRegionInfo
name|hri
init|=
name|regionState
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|ServerName
name|serverName
init|=
name|regionState
operator|.
name|getServerName
argument_list|()
decl_stmt|;
name|ReentrantLock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|regionState
operator|.
name|equals
argument_list|(
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|hri
argument_list|)
argument_list|)
condition|)
block|{
return|return;
comment|// Region is not in the expected state any more
block|}
while|while
condition|(
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|serverName
argument_list|)
operator|&&
operator|!
name|server
operator|.
name|isStopped
argument_list|()
operator|&&
operator|!
name|server
operator|.
name|isAborted
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|serverManager
operator|.
name|sendRegionClose
argument_list|(
name|serverName
argument_list|,
name|hri
argument_list|,
literal|null
argument_list|)
condition|)
block|{
comment|// This means the region is still on the target server
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got false in retry sendRegionClose for "
operator|+
name|regionState
operator|+
literal|", re-close it"
argument_list|)
expr_stmt|;
name|invokeUnAssign
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
return|return;
comment|// Done.
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|RemoteException
condition|)
block|{
name|t
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|t
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
comment|// In case SocketTimeoutException/FailedServerException, retry
if|if
condition|(
name|t
operator|instanceof
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
operator|||
name|t
operator|instanceof
name|FailedServerException
condition|)
block|{
name|Threads
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|t
operator|instanceof
name|NotServingRegionException
operator|||
name|t
operator|instanceof
name|RegionAlreadyInTransitionException
operator|)
condition|)
block|{
comment|// NotServingRegionException/RegionAlreadyInTransitionException
comment|// means the target server got the original region close request.
comment|// For other exceptions, re-close it
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got exception in retry sendRegionClose for "
operator|+
name|regionState
operator|+
literal|", re-close it"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|invokeUnAssign
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
return|return;
comment|// Done.
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set Regions in transitions metrics.    * This takes an iterator on the RegionInTransition map (CLSM), and is not synchronized.    * This iterator is not fail fast, which may lead to stale read; but that's better than    * creating a copy of the map for metrics computation, as this method will be invoked    * on a frequent interval.    */
specifier|public
name|void
name|updateRegionsInTransitionMetrics
parameter_list|()
block|{
name|long
name|currentTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|totalRITs
init|=
literal|0
decl_stmt|;
name|int
name|totalRITsOverThreshold
init|=
literal|0
decl_stmt|;
name|long
name|oldestRITTime
init|=
literal|0
decl_stmt|;
name|int
name|ritThreshold
init|=
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|METRICS_RIT_STUCK_WARNING_THRESHOLD
argument_list|,
literal|60000
argument_list|)
decl_stmt|;
for|for
control|(
name|RegionState
name|state
range|:
name|regionStates
operator|.
name|getRegionsInTransition
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|totalRITs
operator|++
expr_stmt|;
name|long
name|ritTime
init|=
name|currentTime
operator|-
name|state
operator|.
name|getStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|ritTime
operator|>
name|ritThreshold
condition|)
block|{
comment|// more than the threshold
name|totalRITsOverThreshold
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|oldestRITTime
operator|<
name|ritTime
condition|)
block|{
name|oldestRITTime
operator|=
name|ritTime
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|metricsAssignmentManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|metricsAssignmentManager
operator|.
name|updateRITOldestAge
argument_list|(
name|oldestRITTime
argument_list|)
expr_stmt|;
name|this
operator|.
name|metricsAssignmentManager
operator|.
name|updateRITCount
argument_list|(
name|totalRITs
argument_list|)
expr_stmt|;
name|this
operator|.
name|metricsAssignmentManager
operator|.
name|updateRITCountOverThreshold
argument_list|(
name|totalRITsOverThreshold
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @param region Region whose plan we are to clear.    */
name|void
name|clearRegionPlan
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|this
operator|.
name|regionPlans
operator|.
name|remove
argument_list|(
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Wait on region to clear regions-in-transition.    * @param hri Region to wait on.    * @throws IOException    */
specifier|public
name|void
name|waitOnRegionToClearRegionsInTransition
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|waitOnRegionToClearRegionsInTransition
argument_list|(
name|hri
argument_list|,
operator|-
literal|1L
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait on region to clear regions-in-transition or time out    * @param hri    * @param timeOut Milliseconds to wait for current region to be out of transition state.    * @return True when a region clears regions-in-transition before timeout otherwise false    * @throws InterruptedException    */
specifier|public
name|boolean
name|waitOnRegionToClearRegionsInTransition
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
name|long
name|timeOut
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
operator|!
name|regionStates
operator|.
name|isRegionInTransition
argument_list|(
name|hri
argument_list|)
condition|)
return|return
literal|true
return|;
name|long
name|end
init|=
operator|(
name|timeOut
operator|<=
literal|0
operator|)
condition|?
name|Long
operator|.
name|MAX_VALUE
else|:
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|+
name|timeOut
decl_stmt|;
comment|// There is already a timeout monitor on regions in transition so I
comment|// should not have to have one here too?
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for "
operator|+
name|hri
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" to leave regions-in-transition, timeOut="
operator|+
name|timeOut
operator|+
literal|" ms."
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|this
operator|.
name|server
operator|.
name|isStopped
argument_list|()
operator|&&
name|regionStates
operator|.
name|isRegionInTransition
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|regionStates
operator|.
name|waitForUpdate
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|>
name|end
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Timed out on waiting for "
operator|+
name|hri
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" to be assigned."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|server
operator|.
name|isStopped
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Giving up wait on regions in transition because stoppable.isStopped is set"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
name|void
name|invokeAssign
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|invokeAssign
argument_list|(
name|regionInfo
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|void
name|invokeAssign
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|boolean
name|newPlan
parameter_list|)
block|{
name|threadPoolExecutorService
operator|.
name|submit
argument_list|(
operator|new
name|AssignCallable
argument_list|(
name|this
argument_list|,
name|regionInfo
argument_list|,
name|newPlan
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|invokeUnAssign
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|threadPoolExecutorService
operator|.
name|submit
argument_list|(
operator|new
name|UnAssignCallable
argument_list|(
name|this
argument_list|,
name|regionInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isCarryingMeta
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
return|return
name|isCarryingRegion
argument_list|(
name|serverName
argument_list|,
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
return|;
block|}
comment|/**    * Check if the shutdown server carries the specific region.    * @return whether the serverName currently hosts the region    */
specifier|private
name|boolean
name|isCarryingRegion
parameter_list|(
name|ServerName
name|serverName
parameter_list|,
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|RegionState
name|regionState
init|=
name|regionStates
operator|.
name|getRegionTransitionState
argument_list|(
name|hri
argument_list|)
decl_stmt|;
name|ServerName
name|transitionAddr
init|=
name|regionState
operator|!=
literal|null
condition|?
name|regionState
operator|.
name|getServerName
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|transitionAddr
operator|!=
literal|null
condition|)
block|{
name|boolean
name|matchTransitionAddr
init|=
name|transitionAddr
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking region="
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", transitioning on server="
operator|+
name|matchTransitionAddr
operator|+
literal|" server being checked: "
operator|+
name|serverName
operator|+
literal|", matches="
operator|+
name|matchTransitionAddr
argument_list|)
expr_stmt|;
return|return
name|matchTransitionAddr
return|;
block|}
name|ServerName
name|assignedAddr
init|=
name|regionStates
operator|.
name|getRegionServerOfRegion
argument_list|(
name|hri
argument_list|)
decl_stmt|;
name|boolean
name|matchAssignedAddr
init|=
name|serverName
operator|.
name|equals
argument_list|(
name|assignedAddr
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"based on AM, current region="
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" is on server="
operator|+
name|assignedAddr
operator|+
literal|", server being checked: "
operator|+
name|serverName
argument_list|)
expr_stmt|;
return|return
name|matchAssignedAddr
return|;
block|}
comment|/**    * Process shutdown server removing any assignments.    * @param sn Server that went down.    * @return list of regions in transition on this server    */
specifier|public
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|processServerShutdown
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
comment|// Clean out any existing assignment plans for this server
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|>
name|i
init|=
name|this
operator|.
name|regionPlans
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|e
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|ServerName
name|otherSn
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getDestination
argument_list|()
decl_stmt|;
comment|// The name will be null if the region is planned for a random assign.
if|if
condition|(
name|otherSn
operator|!=
literal|null
operator|&&
name|otherSn
operator|.
name|equals
argument_list|(
name|sn
argument_list|)
condition|)
block|{
comment|// Use iterator's remove else we'll get CME
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
name|regionStates
operator|.
name|serverOffline
argument_list|(
name|sn
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|HRegionInfo
argument_list|>
name|it
init|=
name|regions
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|HRegionInfo
name|hri
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|encodedName
init|=
name|hri
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
comment|// We need a lock on the region as we could update it
name|Lock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
try|try
block|{
name|RegionState
name|regionState
init|=
name|regionStates
operator|.
name|getRegionTransitionState
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
name|regionState
operator|.
name|getServerName
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|regionState
operator|.
name|isOnServer
argument_list|(
name|sn
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|regionState
operator|.
name|isFailedClose
argument_list|()
operator|||
name|regionState
operator|.
name|isOffline
argument_list|()
operator|||
name|regionState
operator|.
name|isPendingOpenOrOpening
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip "
operator|+
name|regionState
operator|+
literal|" since it is not opening/failed_close"
operator|+
literal|" on the dead server any more: "
operator|+
name|sn
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tableStateManager
operator|.
name|isTableState
argument_list|(
name|hri
operator|.
name|getTable
argument_list|()
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
condition|)
block|{
name|regionStates
operator|.
name|regionOffline
argument_list|(
name|hri
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// Mark the region offline and assign it again by SSH
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|hri
argument_list|,
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|regions
return|;
block|}
comment|/**    * @param plan Plan to execute.    */
specifier|public
name|void
name|balance
parameter_list|(
specifier|final
name|RegionPlan
name|plan
parameter_list|)
block|{
name|HRegionInfo
name|hri
init|=
name|plan
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|TableName
name|tableName
init|=
name|hri
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|tableStateManager
operator|.
name|isTableState
argument_list|(
name|tableName
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignored moving region of disabling/disabled table "
operator|+
name|tableName
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Move the region only if it's assigned
name|String
name|encodedName
init|=
name|hri
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|ReentrantLock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|regionStates
operator|.
name|isRegionOnline
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|RegionState
name|state
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignored moving region not assigned: "
operator|+
name|hri
operator|+
literal|", "
operator|+
operator|(
name|state
operator|==
literal|null
condition|?
literal|"not in region states"
else|:
name|state
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|this
operator|.
name|regionPlans
operator|.
name|put
argument_list|(
name|plan
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|plan
argument_list|)
expr_stmt|;
block|}
name|unassign
argument_list|(
name|hri
argument_list|,
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|stop
parameter_list|()
block|{
comment|// Shutdown the threadpool executor service
name|threadPoolExecutorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|regionStateStore
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|void
name|setEnabledTable
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|tableStateManager
operator|.
name|setTableState
argument_list|(
name|tableName
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|ENABLED
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CoordinatedStateException
name|e
parameter_list|)
block|{
comment|// here we can abort as it is the start up flow
name|String
name|errorMsg
init|=
literal|"Unable to ensure that the table "
operator|+
name|tableName
operator|+
literal|" will be"
operator|+
literal|" enabled because of a ZooKeeper issue"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
name|this
operator|.
name|server
operator|.
name|abort
argument_list|(
name|errorMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|onRegionFailedOpen
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
name|String
name|encodedName
init|=
name|hri
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|AtomicInteger
name|failedOpenCount
init|=
name|failedOpenTracker
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|failedOpenCount
operator|==
literal|null
condition|)
block|{
name|failedOpenCount
operator|=
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
comment|// No need to use putIfAbsent, or extra synchronization since
comment|// this whole handleRegion block is locked on the encoded region
comment|// name, and failedOpenTracker is updated only in this block
name|failedOpenTracker
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|failedOpenCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failedOpenCount
operator|.
name|incrementAndGet
argument_list|()
operator|>=
name|maximumAttempts
condition|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|hri
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
comment|// remove the tracking info to save memory, also reset
comment|// the count for next open initiative
name|failedOpenTracker
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Handle this the same as if it were opened and then closed.
name|RegionState
name|regionState
init|=
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|hri
argument_list|,
name|State
operator|.
name|CLOSED
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
condition|)
block|{
comment|// When there are more than one region server a new RS is selected as the
comment|// destination and the same is updated in the region plan. (HBASE-5546)
if|if
condition|(
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|hri
operator|.
name|getTable
argument_list|()
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
operator|||
name|replicasToClose
operator|.
name|contains
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|offlineDisabledRegion
argument_list|(
name|hri
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// ZK Node is in CLOSED state, assign it.
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|hri
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|CLOSED
argument_list|)
expr_stmt|;
comment|// This below has to do w/ online enable/disable of a table
name|removeClosedRegion
argument_list|(
name|hri
argument_list|)
expr_stmt|;
try|try
block|{
name|getRegionPlan
argument_list|(
name|hri
argument_list|,
name|sn
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get region plan"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|invokeAssign
argument_list|(
name|hri
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|onRegionOpen
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
specifier|final
name|ServerName
name|sn
parameter_list|,
name|long
name|openSeqNum
parameter_list|)
block|{
name|regionOnline
argument_list|(
name|hri
argument_list|,
name|sn
argument_list|,
name|openSeqNum
argument_list|)
expr_stmt|;
comment|// reset the count, if any
name|failedOpenTracker
operator|.
name|remove
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|hri
operator|.
name|getTable
argument_list|()
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
condition|)
block|{
name|invokeUnAssign
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|onRegionClosed
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
block|{
if|if
condition|(
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|hri
operator|.
name|getTable
argument_list|()
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
operator|||
name|replicasToClose
operator|.
name|contains
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|offlineDisabledRegion
argument_list|(
name|hri
argument_list|)
expr_stmt|;
return|return;
block|}
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|hri
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|CLOSED
argument_list|)
expr_stmt|;
name|sendRegionClosedNotification
argument_list|(
name|hri
argument_list|)
expr_stmt|;
comment|// This below has to do w/ online enable/disable of a table
name|removeClosedRegion
argument_list|(
name|hri
argument_list|)
expr_stmt|;
name|invokeAssign
argument_list|(
name|hri
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|onRegionSplit
parameter_list|(
name|ServerName
name|sn
parameter_list|,
name|TransitionCode
name|code
parameter_list|,
specifier|final
name|HRegionInfo
name|p
parameter_list|,
specifier|final
name|HRegionInfo
name|a
parameter_list|,
specifier|final
name|HRegionInfo
name|b
parameter_list|)
block|{
specifier|final
name|RegionState
name|rs_p
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|RegionState
name|rs_a
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|RegionState
name|rs_b
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rs_p
operator|.
name|isOpenOrSplittingOnServer
argument_list|(
name|sn
argument_list|)
operator|&&
operator|(
name|rs_a
operator|==
literal|null
operator|||
name|rs_a
operator|.
name|isOpenOrSplittingNewOnServer
argument_list|(
name|sn
argument_list|)
operator|)
operator|&&
operator|(
name|rs_b
operator|==
literal|null
operator|||
name|rs_b
operator|.
name|isOpenOrSplittingNewOnServer
argument_list|(
name|sn
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
literal|"Not in state good for split"
return|;
block|}
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|a
argument_list|,
name|State
operator|.
name|SPLITTING_NEW
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|b
argument_list|,
name|State
operator|.
name|SPLITTING_NEW
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|p
argument_list|,
name|State
operator|.
name|SPLITTING
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TransitionCode
operator|.
name|SPLIT
condition|)
block|{
if|if
condition|(
name|TEST_SKIP_SPLIT_HANDLING
condition|)
block|{
return|return
literal|"Skipping split message, TEST_SKIP_SPLIT_HANDLING is set"
return|;
block|}
name|regionOffline
argument_list|(
name|p
argument_list|,
name|State
operator|.
name|SPLIT
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|a
argument_list|,
name|sn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|b
argument_list|,
name|sn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// User could disable the table before master knows the new region.
if|if
condition|(
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|p
operator|.
name|getTable
argument_list|()
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
condition|)
block|{
name|invokeUnAssign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|invokeUnAssign
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Callable
argument_list|<
name|Object
argument_list|>
name|splitReplicasCallable
init|=
operator|new
name|Callable
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|call
parameter_list|()
block|{
name|doSplittingOfReplicas
argument_list|(
name|p
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
name|threadPoolExecutorService
operator|.
name|submit
argument_list|(
name|splitReplicasCallable
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TransitionCode
operator|.
name|SPLIT_PONR
condition|)
block|{
try|try
block|{
name|regionStates
operator|.
name|splitRegion
argument_list|(
name|p
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to record split region "
operator|+
name|p
operator|.
name|getShortNameToLog
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|"Failed to record the splitting in meta"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TransitionCode
operator|.
name|SPLIT_REVERTED
condition|)
block|{
name|regionOnline
argument_list|(
name|p
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionOffline
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|regionOffline
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|p
operator|.
name|getTable
argument_list|()
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
condition|)
block|{
name|invokeUnAssign
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|String
name|onRegionMerge
parameter_list|(
name|ServerName
name|sn
parameter_list|,
name|TransitionCode
name|code
parameter_list|,
specifier|final
name|HRegionInfo
name|p
parameter_list|,
specifier|final
name|HRegionInfo
name|a
parameter_list|,
specifier|final
name|HRegionInfo
name|b
parameter_list|)
block|{
name|RegionState
name|rs_p
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|RegionState
name|rs_a
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|RegionState
name|rs_b
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rs_a
operator|.
name|isOpenOrMergingOnServer
argument_list|(
name|sn
argument_list|)
operator|&&
name|rs_b
operator|.
name|isOpenOrMergingOnServer
argument_list|(
name|sn
argument_list|)
operator|&&
operator|(
name|rs_p
operator|==
literal|null
operator|||
name|rs_p
operator|.
name|isOpenOrMergingNewOnServer
argument_list|(
name|sn
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
literal|"Not in state good for merge"
return|;
block|}
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|a
argument_list|,
name|State
operator|.
name|MERGING
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|b
argument_list|,
name|State
operator|.
name|MERGING
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|p
argument_list|,
name|State
operator|.
name|MERGING_NEW
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|String
name|encodedName
init|=
name|p
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TransitionCode
operator|.
name|READY_TO_MERGE
condition|)
block|{
name|mergingRegions
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
operator|new
name|PairOfSameType
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TransitionCode
operator|.
name|MERGED
condition|)
block|{
name|mergingRegions
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
name|regionOffline
argument_list|(
name|a
argument_list|,
name|State
operator|.
name|MERGED
argument_list|)
expr_stmt|;
name|regionOffline
argument_list|(
name|b
argument_list|,
name|State
operator|.
name|MERGED
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|p
argument_list|,
name|sn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// User could disable the table before master knows the new region.
if|if
condition|(
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|p
operator|.
name|getTable
argument_list|()
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
condition|)
block|{
name|invokeUnAssign
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Callable
argument_list|<
name|Object
argument_list|>
name|mergeReplicasCallable
init|=
operator|new
name|Callable
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|call
parameter_list|()
block|{
name|doMergingOfReplicas
argument_list|(
name|p
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
name|threadPoolExecutorService
operator|.
name|submit
argument_list|(
name|mergeReplicasCallable
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TransitionCode
operator|.
name|MERGE_PONR
condition|)
block|{
try|try
block|{
name|regionStates
operator|.
name|mergeRegions
argument_list|(
name|p
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to record merged region "
operator|+
name|p
operator|.
name|getShortNameToLog
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|"Failed to record the merging in meta"
return|;
block|}
block|}
else|else
block|{
name|mergingRegions
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|a
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|b
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionOffline
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|p
operator|.
name|getTable
argument_list|()
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLED
argument_list|,
name|ZooKeeperProtos
operator|.
name|Table
operator|.
name|State
operator|.
name|DISABLING
argument_list|)
condition|)
block|{
name|invokeUnAssign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|invokeUnAssign
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|doMergingOfReplicas
parameter_list|(
name|HRegionInfo
name|mergedHri
parameter_list|,
specifier|final
name|HRegionInfo
name|hri_a
parameter_list|,
specifier|final
name|HRegionInfo
name|hri_b
parameter_list|)
block|{
comment|// Close replicas for the original unmerged regions. create/assign new replicas
comment|// for the merged parent.
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|unmergedRegions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|unmergedRegions
operator|.
name|add
argument_list|(
name|hri_a
argument_list|)
expr_stmt|;
name|unmergedRegions
operator|.
name|add
argument_list|(
name|hri_b
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|map
init|=
name|regionStates
operator|.
name|getRegionAssignments
argument_list|(
name|unmergedRegions
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|c
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|l
range|:
name|c
control|)
block|{
for|for
control|(
name|HRegionInfo
name|h
range|:
name|l
control|)
block|{
if|if
condition|(
operator|!
name|RegionReplicaUtil
operator|.
name|isDefaultReplica
argument_list|(
name|h
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unassigning un-merged replica "
operator|+
name|h
argument_list|)
expr_stmt|;
name|unassign
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|int
name|numReplicas
init|=
literal|1
decl_stmt|;
try|try
block|{
name|numReplicas
operator|=
operator|(
operator|(
name|MasterServices
operator|)
name|server
operator|)
operator|.
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|mergedHri
operator|.
name|getTable
argument_list|()
argument_list|)
operator|.
name|getRegionReplication
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't get the replication attribute of the table "
operator|+
name|mergedHri
operator|.
name|getTable
argument_list|()
operator|+
literal|" due to "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|". The assignment of replicas for the merged region "
operator|+
literal|"will not be done"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numReplicas
condition|;
name|i
operator|++
control|)
block|{
name|regions
operator|.
name|add
argument_list|(
name|RegionReplicaUtil
operator|.
name|getRegionInfoForReplica
argument_list|(
name|mergedHri
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|assign
argument_list|(
name|regions
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't assign all replica(s) of region "
operator|+
name|mergedHri
operator|+
literal|" because of "
operator|+
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't assign all replica(s) of region "
operator|+
name|mergedHri
operator|+
literal|" because of "
operator|+
name|ie
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|doSplittingOfReplicas
parameter_list|(
specifier|final
name|HRegionInfo
name|parentHri
parameter_list|,
specifier|final
name|HRegionInfo
name|hri_a
parameter_list|,
specifier|final
name|HRegionInfo
name|hri_b
parameter_list|)
block|{
comment|// create new regions for the replica, and assign them to match with the
comment|// current replica assignments. If replica1 of parent is assigned to RS1,
comment|// the replica1s of daughters will be on the same machine
name|int
name|numReplicas
init|=
literal|1
decl_stmt|;
try|try
block|{
name|numReplicas
operator|=
operator|(
operator|(
name|MasterServices
operator|)
name|server
operator|)
operator|.
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|parentHri
operator|.
name|getTable
argument_list|()
argument_list|)
operator|.
name|getRegionReplication
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't get the replication attribute of the table "
operator|+
name|parentHri
operator|.
name|getTable
argument_list|()
operator|+
literal|" due to "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|". The assignment of daughter replicas "
operator|+
literal|"replicas will not be done"
argument_list|)
expr_stmt|;
block|}
comment|// unassign the old replicas
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|parentRegion
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|parentRegion
operator|.
name|add
argument_list|(
name|parentHri
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|currentAssign
init|=
name|regionStates
operator|.
name|getRegionAssignments
argument_list|(
name|parentRegion
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|c
init|=
name|currentAssign
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|l
range|:
name|c
control|)
block|{
for|for
control|(
name|HRegionInfo
name|h
range|:
name|l
control|)
block|{
if|if
condition|(
operator|!
name|RegionReplicaUtil
operator|.
name|isDefaultReplica
argument_list|(
name|h
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unassigning parent's replica "
operator|+
name|h
argument_list|)
expr_stmt|;
name|unassign
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// assign daughter replicas
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numReplicas
condition|;
name|i
operator|++
control|)
block|{
name|prepareDaughterReplicaForAssignment
argument_list|(
name|hri_a
argument_list|,
name|parentHri
argument_list|,
name|i
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|prepareDaughterReplicaForAssignment
argument_list|(
name|hri_b
argument_list|,
name|parentHri
argument_list|,
name|i
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|assign
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception "
operator|+
name|e
operator|+
literal|" while trying to assign replica(s) of daughter(s)"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception "
operator|+
name|e
operator|+
literal|" while trying to assign replica(s) of daughter(s)"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|prepareDaughterReplicaForAssignment
parameter_list|(
name|HRegionInfo
name|daughterHri
parameter_list|,
name|HRegionInfo
name|parentHri
parameter_list|,
name|int
name|replicaId
parameter_list|,
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|map
parameter_list|)
block|{
name|HRegionInfo
name|parentReplica
init|=
name|RegionReplicaUtil
operator|.
name|getRegionInfoForReplica
argument_list|(
name|parentHri
argument_list|,
name|replicaId
argument_list|)
decl_stmt|;
name|HRegionInfo
name|daughterReplica
init|=
name|RegionReplicaUtil
operator|.
name|getRegionInfoForReplica
argument_list|(
name|daughterHri
argument_list|,
name|replicaId
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created replica region for daughter "
operator|+
name|daughterReplica
argument_list|)
expr_stmt|;
name|ServerName
name|sn
decl_stmt|;
if|if
condition|(
operator|(
name|sn
operator|=
name|regionStates
operator|.
name|getRegionServerOfRegion
argument_list|(
name|parentReplica
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|daughterReplica
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
init|=
name|serverManager
operator|.
name|getOnlineServersList
argument_list|()
decl_stmt|;
name|sn
operator|=
name|servers
operator|.
name|get
argument_list|(
operator|(
operator|new
name|Random
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
operator|)
operator|.
name|nextInt
argument_list|(
name|servers
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|daughterReplica
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|getReplicasToClose
parameter_list|()
block|{
return|return
name|replicasToClose
return|;
block|}
comment|/**    * A region is offline.  The new state should be the specified one,    * if not null.  If the specified state is null, the new state is Offline.    * The specified state can be Split/Merged/Offline/null only.    */
specifier|private
name|void
name|regionOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|State
name|state
parameter_list|)
block|{
name|regionStates
operator|.
name|regionOffline
argument_list|(
name|regionInfo
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|removeClosedRegion
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
comment|// remove the region plan as well just in case.
name|clearRegionPlan
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|balancer
operator|.
name|regionOffline
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
comment|// Tell our listeners that a region was closed
name|sendRegionClosedNotification
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
comment|// also note that all the replicas of the primary should be closed
if|if
condition|(
name|state
operator|!=
literal|null
operator|&&
name|state
operator|.
name|equals
argument_list|(
name|State
operator|.
name|SPLIT
argument_list|)
condition|)
block|{
name|Collection
argument_list|<
name|HRegionInfo
argument_list|>
name|c
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|c
operator|.
name|add
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|map
init|=
name|regionStates
operator|.
name|getRegionAssignments
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|allReplicas
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|list
range|:
name|allReplicas
control|)
block|{
name|replicasToClose
operator|.
name|addAll
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|!=
literal|null
operator|&&
name|state
operator|.
name|equals
argument_list|(
name|State
operator|.
name|MERGED
argument_list|)
condition|)
block|{
name|Collection
argument_list|<
name|HRegionInfo
argument_list|>
name|c
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|c
operator|.
name|add
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|map
init|=
name|regionStates
operator|.
name|getRegionAssignments
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|allReplicas
init|=
name|map
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|list
range|:
name|allReplicas
control|)
block|{
name|replicasToClose
operator|.
name|addAll
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|sendRegionOpenedNotification
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|AssignmentListener
name|listener
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|listener
operator|.
name|regionOpened
argument_list|(
name|regionInfo
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|sendRegionClosedNotification
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|AssignmentListener
name|listener
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|listener
operator|.
name|regionClosed
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Try to update some region states. If the state machine prevents    * such update, an error message is returned to explain the reason.    *    * It's expected that in each transition there should have just one    * region for opening/closing, 3 regions for splitting/merging.    * These regions should be on the server that requested the change.    *    * Region state machine. Only these transitions    * are expected to be triggered by a region server.    *    * On the state transition:    *  (1) Open/Close should be initiated by master    *      (a) Master sets the region to pending_open/pending_close    *        in memory and hbase:meta after sending the request    *        to the region server    *      (b) Region server reports back to the master    *        after open/close is done (either success/failure)    *      (c) If region server has problem to report the status    *        to master, it must be because the master is down or some    *        temporary network issue. Otherwise, the region server should    *        abort since it must be a bug. If the master is not accessible,    *        the region server should keep trying until the server is    *        stopped or till the status is reported to the (new) master    *      (d) If region server dies in the middle of opening/closing    *        a region, SSH picks it up and finishes it    *      (e) If master dies in the middle, the new master recovers    *        the state during initialization from hbase:meta. Region server    *        can report any transition that has not been reported to    *        the previous active master yet    *  (2) Split/merge is initiated by region servers    *      (a) To split a region, a region server sends a request    *        to master to try to set a region to splitting, together with    *        two daughters (to be created) to splitting new. If approved    *        by the master, the splitting can then move ahead    *      (b) To merge two regions, a region server sends a request to    *        master to try to set the new merged region (to be created) to    *        merging_new, together with two regions (to be merged) to merging.    *        If it is ok with the master, the merge can then move ahead    *      (c) Once the splitting/merging is done, the region server    *        reports the status back to the master either success/failure.    *      (d) Other scenarios should be handled similarly as for    *        region open/close    */
specifier|protected
name|String
name|onRegionTransition
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|RegionStateTransition
name|transition
parameter_list|)
block|{
name|TransitionCode
name|code
init|=
name|transition
operator|.
name|getTransitionCode
argument_list|()
decl_stmt|;
name|HRegionInfo
name|hri
init|=
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|RegionState
name|current
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|hri
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got transition "
operator|+
name|code
operator|+
literal|" for "
operator|+
operator|(
name|current
operator|!=
literal|null
condition|?
name|current
operator|.
name|toString
argument_list|()
else|:
name|hri
operator|.
name|getShortNameToLog
argument_list|()
operator|)
operator|+
literal|" from "
operator|+
name|serverName
argument_list|)
expr_stmt|;
block|}
name|String
name|errorMsg
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|OPENED
case|:
if|if
condition|(
name|current
operator|!=
literal|null
operator|&&
name|current
operator|.
name|isOpened
argument_list|()
operator|&&
name|current
operator|.
name|isOnServer
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Region "
operator|+
name|hri
operator|.
name|getShortNameToLog
argument_list|()
operator|+
literal|" is already "
operator|+
name|current
operator|.
name|getState
argument_list|()
operator|+
literal|" on "
operator|+
name|serverName
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|FAILED_OPEN
case|:
if|if
condition|(
name|current
operator|==
literal|null
operator|||
operator|!
name|current
operator|.
name|isPendingOpenOrOpeningOnServer
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|errorMsg
operator|=
name|hri
operator|.
name|getShortNameToLog
argument_list|()
operator|+
literal|" is not pending open on "
operator|+
name|serverName
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TransitionCode
operator|.
name|FAILED_OPEN
condition|)
block|{
name|onRegionFailedOpen
argument_list|(
name|hri
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|openSeqNum
init|=
name|HConstants
operator|.
name|NO_SEQNUM
decl_stmt|;
if|if
condition|(
name|transition
operator|.
name|hasOpenSeqNum
argument_list|()
condition|)
block|{
name|openSeqNum
operator|=
name|transition
operator|.
name|getOpenSeqNum
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|openSeqNum
operator|<
literal|0
condition|)
block|{
name|errorMsg
operator|=
literal|"Newly opened region has invalid open seq num "
operator|+
name|openSeqNum
expr_stmt|;
block|}
else|else
block|{
name|onRegionOpen
argument_list|(
name|hri
argument_list|,
name|serverName
argument_list|,
name|openSeqNum
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CLOSED
case|:
if|if
condition|(
name|current
operator|==
literal|null
operator|||
operator|!
name|current
operator|.
name|isPendingCloseOrClosingOnServer
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|errorMsg
operator|=
name|hri
operator|.
name|getShortNameToLog
argument_list|()
operator|+
literal|" is not pending close on "
operator|+
name|serverName
expr_stmt|;
block|}
else|else
block|{
name|onRegionClosed
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|READY_TO_SPLIT
case|:
case|case
name|SPLIT_PONR
case|:
case|case
name|SPLIT
case|:
case|case
name|SPLIT_REVERTED
case|:
name|errorMsg
operator|=
name|onRegionSplit
argument_list|(
name|serverName
argument_list|,
name|code
argument_list|,
name|hri
argument_list|,
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|READY_TO_MERGE
case|:
case|case
name|MERGE_PONR
case|:
case|case
name|MERGED
case|:
case|case
name|MERGE_REVERTED
case|:
name|errorMsg
operator|=
name|onRegionMerge
argument_list|(
name|serverName
argument_list|,
name|code
argument_list|,
name|hri
argument_list|,
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|HRegionInfo
operator|.
name|convert
argument_list|(
name|transition
operator|.
name|getRegionInfo
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errorMsg
operator|=
literal|"Unexpected transition code "
operator|+
name|code
expr_stmt|;
block|}
if|if
condition|(
name|errorMsg
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to transition region from "
operator|+
name|current
operator|+
literal|" to "
operator|+
name|code
operator|+
literal|" by "
operator|+
name|serverName
operator|+
literal|": "
operator|+
name|errorMsg
argument_list|)
expr_stmt|;
block|}
return|return
name|errorMsg
return|;
block|}
comment|/**    * @return Instance of load balancer    */
specifier|public
name|LoadBalancer
name|getBalancer
parameter_list|()
block|{
return|return
name|this
operator|.
name|balancer
return|;
block|}
specifier|public
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|getSnapShotOfAssignment
parameter_list|(
name|Collection
argument_list|<
name|HRegionInfo
argument_list|>
name|infos
parameter_list|)
block|{
return|return
name|getRegionStates
argument_list|()
operator|.
name|getRegionAssignments
argument_list|(
name|infos
argument_list|)
return|;
block|}
block|}
end_class

end_unit

