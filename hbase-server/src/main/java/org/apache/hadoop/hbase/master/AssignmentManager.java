begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Chore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionTransition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Stoppable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|CatalogTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|EventHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|EventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcClient
operator|.
name|FailedServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcClient
operator|.
name|FailedServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|ServerNotRunningYetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|FavoredNodeAssignmentHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|FavoredNodeLoadBalancer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|ClosedRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|DisableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|EnableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|OpenedRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionAlreadyInTransitionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionMergeTransaction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionOpeningState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionServerStoppedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|SplitTransaction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|KeyLocker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|PairOfSameType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MetaRegionTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKAssign
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|NoNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|NodeExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedHashMultimap
import|;
end_import

begin_comment
comment|/**  * Manages and performs region assignment.  *<p>  * Monitors ZooKeeper for events related to regions in transition.  *<p>  * Handles existing regions in transition during master failover.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|AssignmentManager
extends|extends
name|ZooKeeperListener
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AssignmentManager
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|ServerName
name|HBCK_CODE_SERVERNAME
init|=
name|ServerName
operator|.
name|valueOf
argument_list|(
name|HConstants
operator|.
name|HBCK_CODE_NAME
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1L
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASSIGNMENT_TIMEOUT
init|=
literal|"hbase.master.assignment.timeoutmonitor.timeout"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_ASSIGNMENT_TIMEOUT_DEFAULT
init|=
literal|600000
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ASSIGNMENT_TIMEOUT_MANAGEMENT
init|=
literal|"hbase.assignment.timeout.management"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_ASSIGNMENT_TIMEOUT_MANAGEMENT
init|=
literal|false
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ALREADY_IN_TRANSITION_WAITTIME
init|=
literal|"hbase.assignment.already.intransition.waittime"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_ALREADY_IN_TRANSITION_WAITTIME
init|=
literal|60000
decl_stmt|;
comment|// 1 minute
specifier|protected
specifier|final
name|Server
name|server
decl_stmt|;
specifier|private
name|ServerManager
name|serverManager
decl_stmt|;
specifier|private
name|boolean
name|shouldAssignRegionsWithFavoredNodes
decl_stmt|;
specifier|private
name|CatalogTracker
name|catalogTracker
decl_stmt|;
specifier|protected
specifier|final
name|TimeoutMonitor
name|timeoutMonitor
decl_stmt|;
specifier|private
specifier|final
name|TimerUpdater
name|timerUpdater
decl_stmt|;
specifier|private
name|LoadBalancer
name|balancer
decl_stmt|;
specifier|private
specifier|final
name|MetricsAssignmentManager
name|metricsAssignmentManager
decl_stmt|;
specifier|private
specifier|final
name|TableLockManager
name|tableLockManager
decl_stmt|;
specifier|private
name|AtomicInteger
name|numRegionsOpened
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
specifier|private
name|KeyLocker
argument_list|<
name|String
argument_list|>
name|locker
init|=
operator|new
name|KeyLocker
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Map of regions to reopen after the schema of a table is changed. Key -    * encoded region name, value - HRegionInfo    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HRegionInfo
argument_list|>
name|regionsToReopen
decl_stmt|;
comment|/*    * Maximum times we recurse an assignment/unassignment.    * See below in {@link #assign()} and {@link #unassign()}.    */
specifier|private
specifier|final
name|int
name|maximumAttempts
decl_stmt|;
comment|/**    * Map of two merging regions from the region to be created.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|PairOfSameType
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|mergingRegions
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|PairOfSameType
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * The sleep time for which the assignment will wait before retrying in case of hbase:meta assignment    * failure due to lack of availability of region plan    */
specifier|private
specifier|final
name|long
name|sleepTimeBeforeRetryingMetaAssignment
decl_stmt|;
comment|/** Plans for region movement. Key is the encoded version of a region name*/
comment|// TODO: When do plans get cleaned out?  Ever? In server open and in server
comment|// shutdown processing -- St.Ack
comment|// All access to this Map must be synchronized.
specifier|final
name|NavigableMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|regionPlans
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ZKTable
name|zkTable
decl_stmt|;
comment|/**    * Contains the server which need to update timer, these servers will be    * handled by {@link TimerUpdater}    */
specifier|private
specifier|final
name|ConcurrentSkipListSet
argument_list|<
name|ServerName
argument_list|>
name|serversInUpdatingTimer
decl_stmt|;
specifier|private
specifier|final
name|ExecutorService
name|executorService
decl_stmt|;
comment|// For unit tests, keep track of calls to ClosedRegionHandler
specifier|private
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|AtomicBoolean
argument_list|>
name|closedRegionHandlerCalled
init|=
literal|null
decl_stmt|;
comment|// For unit tests, keep track of calls to OpenedRegionHandler
specifier|private
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|AtomicBoolean
argument_list|>
name|openedRegionHandlerCalled
init|=
literal|null
decl_stmt|;
comment|//Thread pool executor service for timeout monitor
specifier|private
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
name|threadPoolExecutorService
decl_stmt|;
comment|// A bunch of ZK events workers. Each is a single thread executor service
specifier|private
specifier|final
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
name|zkEventWorkers
decl_stmt|;
specifier|private
name|List
argument_list|<
name|EventType
argument_list|>
name|ignoreStatesRSOffline
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|EventType
operator|.
name|RS_ZK_REGION_FAILED_OPEN
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_CLOSED
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|RegionStates
name|regionStates
decl_stmt|;
comment|// The threshold to use bulk assigning. Using bulk assignment
comment|// only if assigning at least this many regions to at least this
comment|// many servers. If assigning fewer regions to fewer servers,
comment|// bulk assigning may be not as efficient.
specifier|private
specifier|final
name|int
name|bulkAssignThresholdRegions
decl_stmt|;
specifier|private
specifier|final
name|int
name|bulkAssignThresholdServers
decl_stmt|;
comment|// Should bulk assignment wait till all regions are assigned,
comment|// or it is timed out?  This is useful to measure bulk assignment
comment|// performance, but not needed in most use cases.
specifier|private
specifier|final
name|boolean
name|bulkAssignWaitTillAllAssigned
decl_stmt|;
comment|/**    * Indicator that AssignmentManager has recovered the region states so    * that ServerShutdownHandler can be fully enabled and re-assign regions    * of dead servers. So that when re-assignment happens, AssignmentManager    * has proper region states.    *    * Protected to ease testing.    */
specifier|protected
specifier|final
name|AtomicBoolean
name|failoverCleanupDone
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/** Is the TimeOutManagement activated **/
specifier|private
specifier|final
name|boolean
name|tomActivated
decl_stmt|;
comment|/**    * A map to track the count a region fails to open in a row.    * So that we don't try to open a region forever if the failure is    * unrecoverable.  We don't put this information in region states    * because we don't expect this to happen frequently; we don't    * want to copy this information over during each state transition either.    */
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|failedOpenTracker
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * For testing only!  Set to true to skip handling of split.    */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"MS_SHOULD_BE_FINAL"
argument_list|)
specifier|public
specifier|static
name|boolean
name|TEST_SKIP_SPLIT_HANDLING
init|=
literal|false
decl_stmt|;
comment|/**    * Constructs a new assignment manager.    *    * @param server    * @param serverManager    * @param catalogTracker    * @param service    * @throws KeeperException    * @throws IOException    */
specifier|public
name|AssignmentManager
parameter_list|(
name|Server
name|server
parameter_list|,
name|ServerManager
name|serverManager
parameter_list|,
name|CatalogTracker
name|catalogTracker
parameter_list|,
specifier|final
name|LoadBalancer
name|balancer
parameter_list|,
specifier|final
name|ExecutorService
name|service
parameter_list|,
name|MetricsMaster
name|metricsMaster
parameter_list|,
specifier|final
name|TableLockManager
name|tableLockManager
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
name|super
argument_list|(
name|server
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
name|serverManager
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|=
name|catalogTracker
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|regionsToReopen
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HRegionInfo
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|server
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
comment|// Only read favored nodes if using the favored nodes load balancer.
name|this
operator|.
name|shouldAssignRegionsWithFavoredNodes
operator|=
name|conf
operator|.
name|getClass
argument_list|(
name|HConstants
operator|.
name|HBASE_MASTER_LOADBALANCER_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
operator|.
name|equals
argument_list|(
name|FavoredNodeLoadBalancer
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|tomActivated
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|ASSIGNMENT_TIMEOUT_MANAGEMENT
argument_list|,
name|DEFAULT_ASSIGNMENT_TIMEOUT_MANAGEMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tomActivated
condition|)
block|{
name|this
operator|.
name|serversInUpdatingTimer
operator|=
operator|new
name|ConcurrentSkipListSet
argument_list|<
name|ServerName
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|timeoutMonitor
operator|=
operator|new
name|TimeoutMonitor
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.assignment.timeoutmonitor.period"
argument_list|,
literal|30000
argument_list|)
argument_list|,
name|server
argument_list|,
name|serverManager
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|ASSIGNMENT_TIMEOUT
argument_list|,
name|DEFAULT_ASSIGNMENT_TIMEOUT_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|timerUpdater
operator|=
operator|new
name|TimerUpdater
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.assignment.timerupdater.period"
argument_list|,
literal|10000
argument_list|)
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|timerUpdater
operator|.
name|getThread
argument_list|()
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|".timerUpdater"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|serversInUpdatingTimer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|timeoutMonitor
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|timerUpdater
operator|=
literal|null
expr_stmt|;
block|}
try|try
block|{
name|this
operator|.
name|zkTable
operator|=
operator|new
name|ZKTable
argument_list|(
name|this
operator|.
name|watcher
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
block|}
comment|// This is the max attempts, not retries, so it should be at least 1.
name|this
operator|.
name|maximumAttempts
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.assignment.maximum.attempts"
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|sleepTimeBeforeRetryingMetaAssignment
operator|=
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"hbase.meta.assignment.retry.sleeptime"
argument_list|,
literal|1000l
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|=
name|balancer
expr_stmt|;
name|int
name|maxThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.assignment.threads.max"
argument_list|,
literal|30
argument_list|)
decl_stmt|;
name|this
operator|.
name|threadPoolExecutorService
operator|=
name|Threads
operator|.
name|getBoundedCachedThreadPool
argument_list|(
name|maxThreads
argument_list|,
literal|60L
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|Threads
operator|.
name|newDaemonThreadFactory
argument_list|(
literal|"AM."
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionStates
operator|=
operator|new
name|RegionStates
argument_list|(
name|server
argument_list|,
name|serverManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|bulkAssignWaitTillAllAssigned
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.bulk.assignment.waittillallassigned"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|bulkAssignThresholdRegions
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.bulk.assignment.threshold.regions"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|this
operator|.
name|bulkAssignThresholdServers
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.bulk.assignment.threshold.servers"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|int
name|workers
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.assignment.zkevent.workers"
argument_list|,
literal|20
argument_list|)
decl_stmt|;
name|ThreadFactory
name|threadFactory
init|=
name|Threads
operator|.
name|newDaemonThreadFactory
argument_list|(
literal|"AM.ZK.Worker"
argument_list|)
decl_stmt|;
name|zkEventWorkers
operator|=
name|Threads
operator|.
name|getBoundedCachedThreadPool
argument_list|(
name|workers
argument_list|,
literal|60L
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|threadFactory
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableLockManager
operator|=
name|tableLockManager
expr_stmt|;
name|this
operator|.
name|metricsAssignmentManager
operator|=
operator|new
name|MetricsAssignmentManager
argument_list|()
expr_stmt|;
block|}
name|void
name|startTimeOutMonitor
parameter_list|()
block|{
if|if
condition|(
name|tomActivated
condition|)
block|{
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|timeoutMonitor
operator|.
name|getThread
argument_list|()
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|".timeoutMonitor"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return Instance of ZKTable.    */
specifier|public
name|ZKTable
name|getZKTable
parameter_list|()
block|{
comment|// These are 'expensive' to make involving trip to zk ensemble so allow
comment|// sharing.
return|return
name|this
operator|.
name|zkTable
return|;
block|}
comment|/**    * This SHOULD not be public. It is public now    * because of some unit tests.    *    * TODO: make it package private and keep RegionStates in the master package    */
specifier|public
name|RegionStates
name|getRegionStates
parameter_list|()
block|{
return|return
name|regionStates
return|;
block|}
specifier|public
name|RegionPlan
name|getRegionReopenPlan
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
return|return
operator|new
name|RegionPlan
argument_list|(
name|hri
argument_list|,
literal|null
argument_list|,
name|regionStates
operator|.
name|getRegionServerOfRegion
argument_list|(
name|hri
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Add a regionPlan for the specified region.    * @param encodedName    * @param plan    */
specifier|public
name|void
name|addPlan
parameter_list|(
name|String
name|encodedName
parameter_list|,
name|RegionPlan
name|plan
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regionPlans
init|)
block|{
name|regionPlans
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|plan
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add a map of region plans.    */
specifier|public
name|void
name|addPlans
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|plans
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regionPlans
init|)
block|{
name|regionPlans
operator|.
name|putAll
argument_list|(
name|plans
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the list of regions that will be reopened    * because of an update in table schema    *    * @param regions    *          list of regions that should be tracked for reopen    */
specifier|public
name|void
name|setRegionsToReopen
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|regions
control|)
block|{
name|regionsToReopen
operator|.
name|put
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Used by the client to identify if all regions have the schema updates    *    * @param tableName    * @return Pair indicating the status of the alter command    * @throws IOException    */
specifier|public
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|getReopenStatus
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|hris
init|=
name|MetaReader
operator|.
name|getTableRegions
argument_list|(
name|this
operator|.
name|server
operator|.
name|getCatalogTracker
argument_list|()
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Integer
name|pending
init|=
literal|0
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|hris
control|)
block|{
name|String
name|name
init|=
name|hri
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
comment|// no lock concurrent access ok: sequential consistency respected.
if|if
condition|(
name|regionsToReopen
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
operator|||
name|regionStates
operator|.
name|isRegionInTransition
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|pending
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|pending
argument_list|,
name|hris
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Used by ServerShutdownHandler to make sure AssignmentManager has completed    * the failover cleanup before re-assigning regions of dead servers. So that    * when re-assignment happens, AssignmentManager has proper region states.    */
specifier|public
name|boolean
name|isFailoverCleanupDone
parameter_list|()
block|{
return|return
name|failoverCleanupDone
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * To avoid racing with AM, external entities may need to lock a region,    * for example, when SSH checks what regions to skip re-assigning.    */
specifier|public
name|Lock
name|acquireRegionLock
parameter_list|(
specifier|final
name|String
name|encodedName
parameter_list|)
block|{
return|return
name|locker
operator|.
name|acquireLock
argument_list|(
name|encodedName
argument_list|)
return|;
block|}
comment|/**    * Now, failover cleanup is completed. Notify server manager to    * process queued up dead servers processing, if any.    */
name|void
name|failoverCleanupDone
parameter_list|()
block|{
name|failoverCleanupDone
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|serverManager
operator|.
name|processQueuedDeadServers
argument_list|()
expr_stmt|;
block|}
comment|/**    * Called on startup.    * Figures whether a fresh cluster start of we are joining extant running cluster.    * @throws IOException    * @throws KeeperException    * @throws InterruptedException    */
name|void
name|joinCluster
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
comment|// Concurrency note: In the below the accesses on regionsInTransition are
comment|// outside of a synchronization block where usually all accesses to RIT are
comment|// synchronized.  The presumption is that in this case it is safe since this
comment|// method is being played by a single thread on startup.
comment|// TODO: Regions that have a null location and are not in regionsInTransitions
comment|// need to be handled.
comment|// Scan hbase:meta to build list of existing regions, servers, and assignment
comment|// Returns servers who have not checked in (assumed dead) and their regions
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|deadServers
init|=
name|rebuildUserRegions
argument_list|()
decl_stmt|;
comment|// This method will assign all user regions if a clean server startup or
comment|// it will reconstruct master state and cleanup any leftovers from
comment|// previous master process.
name|processDeadServersAndRegionsInTransition
argument_list|(
name|deadServers
argument_list|)
expr_stmt|;
name|recoverTableInDisablingState
argument_list|()
expr_stmt|;
name|recoverTableInEnablingState
argument_list|()
expr_stmt|;
block|}
comment|/**    * Process all regions that are in transition in zookeeper and also    * processes the list of dead servers by scanning the META.    * Used by master joining an cluster.  If we figure this is a clean cluster    * startup, will assign all user regions.    * @param deadServers    *          Map of dead servers and their regions. Can be null.    * @throws KeeperException    * @throws IOException    * @throws InterruptedException    */
name|void
name|processDeadServersAndRegionsInTransition
parameter_list|(
specifier|final
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|deadServers
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
throws|,
name|InterruptedException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|nodes
init|=
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|assignmentZNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|==
literal|null
condition|)
block|{
name|String
name|errorMessage
init|=
literal|"Failed to get the children from ZK"
decl_stmt|;
name|server
operator|.
name|abort
argument_list|(
name|errorMessage
argument_list|,
operator|new
name|IOException
argument_list|(
name|errorMessage
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|boolean
name|failover
init|=
operator|(
operator|!
name|serverManager
operator|.
name|getDeadServers
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|serverManager
operator|.
name|getRequeuedDeadServers
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|failover
condition|)
block|{
comment|// If any one region except meta is assigned, it's a failover.
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regions
init|=
name|regionStates
operator|.
name|getRegionAssignments
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|regions
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|hri
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|hri
operator|+
literal|" out on cluster"
argument_list|)
expr_stmt|;
name|failover
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|failover
condition|)
block|{
comment|// If any one region except meta is in transition, it's a failover.
for|for
control|(
name|String
name|encodedName
range|:
name|nodes
control|)
block|{
name|RegionState
name|state
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
operator|&&
operator|!
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" in RITs"
argument_list|)
expr_stmt|;
name|failover
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|// If we found user regions out on cluster, its a failover.
if|if
condition|(
name|failover
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found regions out on cluster or in RIT; presuming failover"
argument_list|)
expr_stmt|;
comment|// Process list of dead servers and regions in RIT.
comment|// See HBASE-4580 for more information.
name|processDeadServersAndRecoverLostRegions
argument_list|(
name|deadServers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Fresh cluster startup.
name|LOG
operator|.
name|info
argument_list|(
literal|"Clean cluster startup. Assigning userregions"
argument_list|)
expr_stmt|;
name|assignAllUserRegions
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * If region is up in zk in transition, then do fixup and block and wait until    * the region is assigned and out of transition.  Used on startup for    * catalog regions.    * @param hri Region to look for.    * @return True if we processed a region in transition else false if region    * was not up in zk in transition.    * @throws InterruptedException    * @throws KeeperException    * @throws IOException    */
name|boolean
name|processRegionInTransitionAndBlockUntilAssigned
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|KeeperException
throws|,
name|IOException
block|{
name|String
name|encodedRegionName
init|=
name|hri
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|processRegionInTransition
argument_list|(
name|encodedRegionName
argument_list|,
name|hri
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
comment|// The region is not in transition
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting on "
operator|+
name|HRegionInfo
operator|.
name|prettyPrint
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|this
operator|.
name|server
operator|.
name|isStopped
argument_list|()
operator|&&
name|this
operator|.
name|regionStates
operator|.
name|isRegionInTransition
argument_list|(
name|encodedRegionName
argument_list|)
condition|)
block|{
name|RegionState
name|state
init|=
name|this
operator|.
name|regionStates
operator|.
name|getRegionTransitionState
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
operator|||
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|state
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
comment|// The region is not in transition, or not in transition on an online
comment|// server. Doesn't help to block here any more. Caller need to
comment|// verify the region is actually assigned.
break|break;
block|}
name|this
operator|.
name|regionStates
operator|.
name|waitForUpdate
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Process failover of new master for region<code>encodedRegionName</code>    * up in zookeeper.    * @param encodedRegionName Region to process failover for.    * @param regionInfo If null we'll go get it from meta table.    * @return True if we processed<code>regionInfo</code> as a RIT.    * @throws KeeperException    * @throws IOException    */
name|boolean
name|processRegionInTransition
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
comment|// We need a lock here to ensure that we will not put the same region twice
comment|// It has no reason to be a lock shared with the other operations.
comment|// We can do the lock on the region only, instead of a global lock: what we want to ensure
comment|// is that we don't have two threads working on the same region.
name|Lock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
try|try
block|{
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getDataAndWatch
argument_list|(
name|watcher
argument_list|,
name|encodedRegionName
argument_list|,
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|RegionTransition
name|rt
decl_stmt|;
try|try
block|{
name|rt
operator|=
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed parse znode data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|HRegionInfo
name|hri
init|=
name|regionInfo
decl_stmt|;
if|if
condition|(
name|hri
operator|==
literal|null
condition|)
block|{
comment|// The region info is not passed in. We will try to find the region
comment|// from region states map/meta based on the encoded region name. But we
comment|// may not be able to find it. This is valid for online merge that
comment|// the region may have not been created if the merge is not completed.
comment|// Therefore, it is not in meta at master recovery time.
name|hri
operator|=
name|regionStates
operator|.
name|getRegionInfo
argument_list|(
name|rt
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
name|EventType
name|et
init|=
name|rt
operator|.
name|getEventType
argument_list|()
decl_stmt|;
if|if
condition|(
name|hri
operator|==
literal|null
operator|&&
name|et
operator|!=
name|EventType
operator|.
name|RS_ZK_REGION_MERGING
operator|&&
name|et
operator|!=
name|EventType
operator|.
name|RS_ZK_REQUEST_REGION_MERGE
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't find the region in recovering "
operator|+
name|rt
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
name|processRegionsInTransition
argument_list|(
name|rt
argument_list|,
name|hri
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This call is invoked only (1) master assign meta;    * (2) during failover mode startup, zk assignment node processing.    * The locker is set in the caller. It returns true if the region    * is in transition for sure, false otherwise.    *    * It should be private but it is used by some test too.    */
name|boolean
name|processRegionsInTransition
parameter_list|(
specifier|final
name|RegionTransition
name|rt
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|int
name|expectedVersion
parameter_list|)
throws|throws
name|KeeperException
block|{
name|EventType
name|et
init|=
name|rt
operator|.
name|getEventType
argument_list|()
decl_stmt|;
comment|// Get ServerName.  Could not be null.
specifier|final
name|ServerName
name|sn
init|=
name|rt
operator|.
name|getServerName
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|regionName
init|=
name|rt
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|encodedName
init|=
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
specifier|final
name|String
name|prettyPrintedRegionName
init|=
name|HRegionInfo
operator|.
name|prettyPrint
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" in state: "
operator|+
name|et
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionStates
operator|.
name|isRegionInTransition
argument_list|(
name|encodedName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processed region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" in state: "
operator|+
name|et
operator|+
literal|", does nothing since the region is already in transition "
operator|+
name|regionStates
operator|.
name|getRegionTransitionState
argument_list|(
name|encodedName
argument_list|)
argument_list|)
expr_stmt|;
comment|// Just return
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
condition|)
block|{
comment|// It was transitioning on a dead server, so it's closed now.
comment|// Force to OFFLINE and put it in transition, but not assign it
comment|// since log splitting for the dead server is not done yet.
name|LOG
operator|.
name|debug
argument_list|(
literal|"RIT "
operator|+
name|encodedName
operator|+
literal|" in state="
operator|+
name|rt
operator|.
name|getEventType
argument_list|()
operator|+
literal|" was on deadserver; forcing offline"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionStates
operator|.
name|isRegionOnline
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
comment|// Meta could still show the region is assigned to the previous
comment|// server. If that server is online, when we reload the meta, the
comment|// region is put back to online, we need to offline it.
name|regionStates
operator|.
name|regionOffline
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|// Put it back in transition so that SSH can re-assign it
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|regionInfo
argument_list|,
name|State
operator|.
name|OFFLINE
argument_list|,
name|sn
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionInfo
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
comment|// If it's meta region, reset the meta location.
comment|// So that master knows the right meta region server.
name|MetaRegionTracker
operator|.
name|setMetaLocation
argument_list|(
name|watcher
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No matter the previous server is online or offline,
comment|// we need to reset the last region server of the region.
name|regionStates
operator|.
name|setLastRegionServerOfRegion
argument_list|(
name|sn
argument_list|,
name|encodedName
argument_list|)
expr_stmt|;
comment|// Make sure we know the server is dead.
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerDead
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|serverManager
operator|.
name|expireServer
argument_list|(
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|et
condition|)
block|{
case|case
name|M_ZK_REGION_CLOSING
case|:
comment|// Insert into RIT& resend the query to the region server: may be the previous master
comment|// died before sending the query the first time.
specifier|final
name|RegionState
name|rsClosing
init|=
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|rt
argument_list|,
name|State
operator|.
name|CLOSING
argument_list|)
decl_stmt|;
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|EventHandler
argument_list|(
name|server
argument_list|,
name|EventType
operator|.
name|M_MASTER_RECOVERY
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|ReentrantLock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|unassign
argument_list|(
name|regionInfo
argument_list|,
name|rsClosing
argument_list|,
name|expectedVersion
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionStates
operator|.
name|isRegionOffline
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
name|assign
argument_list|(
name|regionInfo
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_CLOSED
case|:
case|case
name|RS_ZK_REGION_FAILED_OPEN
case|:
comment|// Region is closed, insert into RIT and handle it
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|regionInfo
argument_list|,
name|State
operator|.
name|CLOSED
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|invokeAssign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ZK_REGION_OFFLINE
case|:
comment|// Insert in RIT and resend to the regionserver
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|rt
argument_list|,
name|State
operator|.
name|PENDING_OPEN
argument_list|)
expr_stmt|;
specifier|final
name|RegionState
name|rsOffline
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|EventHandler
argument_list|(
name|server
argument_list|,
name|EventType
operator|.
name|M_MASTER_RECOVERY
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|IOException
block|{
name|ReentrantLock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|RegionPlan
name|plan
init|=
operator|new
name|RegionPlan
argument_list|(
name|regionInfo
argument_list|,
literal|null
argument_list|,
name|sn
argument_list|)
decl_stmt|;
name|addPlan
argument_list|(
name|encodedName
argument_list|,
name|plan
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|rsOffline
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENING
case|:
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|rt
argument_list|,
name|State
operator|.
name|OPENING
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENED
case|:
comment|// Region is opened, insert into RIT and handle it
comment|// This could be done asynchronously, we would need then to acquire the lock in the
comment|//  handler.
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|rt
argument_list|,
name|State
operator|.
name|OPEN
argument_list|)
expr_stmt|;
operator|new
name|OpenedRegionHandler
argument_list|(
name|server
argument_list|,
name|this
argument_list|,
name|regionInfo
argument_list|,
name|sn
argument_list|,
name|expectedVersion
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
break|break;
case|case
name|RS_ZK_REQUEST_REGION_SPLIT
case|:
case|case
name|RS_ZK_REGION_SPLITTING
case|:
case|case
name|RS_ZK_REGION_SPLIT
case|:
comment|// Splitting region should be online. We could have skipped it during
comment|// user region rebuilding since we may consider the split is completed.
comment|// Put it in SPLITTING state to avoid complications.
name|regionStates
operator|.
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|rt
argument_list|,
name|State
operator|.
name|SPLITTING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handleRegionSplitting
argument_list|(
name|rt
argument_list|,
name|encodedName
argument_list|,
name|prettyPrintedRegionName
argument_list|,
name|sn
argument_list|)
condition|)
block|{
name|deleteSplittingNode
argument_list|(
name|encodedName
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RS_ZK_REQUEST_REGION_MERGE
case|:
case|case
name|RS_ZK_REGION_MERGING
case|:
case|case
name|RS_ZK_REGION_MERGED
case|:
if|if
condition|(
operator|!
name|handleRegionMerging
argument_list|(
name|rt
argument_list|,
name|encodedName
argument_list|,
name|prettyPrintedRegionName
argument_list|,
name|sn
argument_list|)
condition|)
block|{
name|deleteMergingNode
argument_list|(
name|encodedName
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Received region in state:"
operator|+
name|et
operator|+
literal|" is not valid."
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Processed region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" in state "
operator|+
name|et
operator|+
literal|", on "
operator|+
operator|(
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
condition|?
literal|""
else|:
literal|"dead "
operator|)
operator|+
literal|"server: "
operator|+
name|sn
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * When a region is closed, it should be removed from the regionsToReopen    * @param hri HRegionInfo of the region which was closed    */
specifier|public
name|void
name|removeClosedRegion
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
if|if
condition|(
name|regionsToReopen
operator|.
name|remove
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed region from reopening regions because it was closed"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Handles various states an unassigned node can be in.    *<p>    * Method is called when a state change is suspected for an unassigned node.    *<p>    * This deals with skipped transitions (we got a CLOSED but didn't see CLOSING    * yet).    * @param rt    * @param expectedVersion    */
name|void
name|handleRegion
parameter_list|(
specifier|final
name|RegionTransition
name|rt
parameter_list|,
name|int
name|expectedVersion
parameter_list|)
block|{
if|if
condition|(
name|rt
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected NULL input for RegionTransition rt"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|ServerName
name|sn
init|=
name|rt
operator|.
name|getServerName
argument_list|()
decl_stmt|;
comment|// Check if this is a special HBCK transition
if|if
condition|(
name|sn
operator|.
name|equals
argument_list|(
name|HBCK_CODE_SERVERNAME
argument_list|)
condition|)
block|{
name|handleHBCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|long
name|createTime
init|=
name|rt
operator|.
name|getCreateTime
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|regionName
init|=
name|rt
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|String
name|encodedName
init|=
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|String
name|prettyPrintedRegionName
init|=
name|HRegionInfo
operator|.
name|prettyPrint
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
comment|// Verify this is a known server
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
operator|&&
operator|!
name|ignoreStatesRSOffline
operator|.
name|contains
argument_list|(
name|rt
operator|.
name|getEventType
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempted to handle region transition for server but "
operator|+
literal|"it is not online: "
operator|+
name|prettyPrintedRegionName
operator|+
literal|", "
operator|+
name|rt
argument_list|)
expr_stmt|;
return|return;
block|}
name|RegionState
name|regionState
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|boolean
name|lateEvent
init|=
name|createTime
operator|<
operator|(
name|startTime
operator|-
literal|15000
operator|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling "
operator|+
name|rt
operator|.
name|getEventType
argument_list|()
operator|+
literal|", server="
operator|+
name|sn
operator|+
literal|", region="
operator|+
operator|(
name|prettyPrintedRegionName
operator|==
literal|null
condition|?
literal|"null"
else|:
name|prettyPrintedRegionName
operator|)
operator|+
operator|(
name|lateEvent
condition|?
literal|", which is more than 15 seconds late"
else|:
literal|""
operator|)
operator|+
literal|", current_state="
operator|+
name|regionState
argument_list|)
expr_stmt|;
block|}
comment|// We don't do anything for this event,
comment|// so separate it out, no need to lock/unlock anything
if|if
condition|(
name|rt
operator|.
name|getEventType
argument_list|()
operator|==
name|EventType
operator|.
name|M_ZK_REGION_OFFLINE
condition|)
block|{
return|return;
block|}
comment|// We need a lock on the region as we could update it
name|Lock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
try|try
block|{
name|RegionState
name|latestState
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|regionState
operator|==
literal|null
operator|&&
name|latestState
operator|!=
literal|null
operator|)
operator|||
operator|(
name|regionState
operator|!=
literal|null
operator|&&
name|latestState
operator|==
literal|null
operator|)
operator|||
operator|(
name|regionState
operator|!=
literal|null
operator|&&
name|latestState
operator|!=
literal|null
operator|&&
name|latestState
operator|.
name|getState
argument_list|()
operator|!=
name|regionState
operator|.
name|getState
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region state changed from "
operator|+
name|regionState
operator|+
literal|" to "
operator|+
name|latestState
operator|+
literal|", while acquiring lock"
argument_list|)
expr_stmt|;
block|}
name|long
name|waitedTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
decl_stmt|;
if|if
condition|(
name|waitedTime
operator|>
literal|5000
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Took "
operator|+
name|waitedTime
operator|+
literal|"ms to acquire the lock"
argument_list|)
expr_stmt|;
block|}
name|regionState
operator|=
name|latestState
expr_stmt|;
switch|switch
condition|(
name|rt
operator|.
name|getEventType
argument_list|()
condition|)
block|{
case|case
name|RS_ZK_REQUEST_REGION_SPLIT
case|:
case|case
name|RS_ZK_REGION_SPLITTING
case|:
case|case
name|RS_ZK_REGION_SPLIT
case|:
if|if
condition|(
operator|!
name|handleRegionSplitting
argument_list|(
name|rt
argument_list|,
name|encodedName
argument_list|,
name|prettyPrintedRegionName
argument_list|,
name|sn
argument_list|)
condition|)
block|{
name|deleteSplittingNode
argument_list|(
name|encodedName
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RS_ZK_REQUEST_REGION_MERGE
case|:
case|case
name|RS_ZK_REGION_MERGING
case|:
case|case
name|RS_ZK_REGION_MERGED
case|:
comment|// Merged region is a new region, we can't find it in the region states now.
comment|// However, the two merging regions are not new. They should be in state for merging.
if|if
condition|(
operator|!
name|handleRegionMerging
argument_list|(
name|rt
argument_list|,
name|encodedName
argument_list|,
name|prettyPrintedRegionName
argument_list|,
name|sn
argument_list|)
condition|)
block|{
name|deleteMergingNode
argument_list|(
name|encodedName
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_ZK_REGION_CLOSING
case|:
comment|// Should see CLOSING after we have asked it to CLOSE or additional
comment|// times after already being in state of CLOSING
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|!
name|regionState
operator|.
name|isPendingCloseOrClosingOnServer
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received CLOSING for "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from "
operator|+
name|sn
operator|+
literal|" but the region isn't PENDING_CLOSE/CLOSING here: "
operator|+
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Transition to CLOSING (or update stamp if already CLOSING)
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|rt
argument_list|,
name|State
operator|.
name|CLOSING
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_CLOSED
case|:
comment|// Should see CLOSED after CLOSING but possible after PENDING_CLOSE
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|!
name|regionState
operator|.
name|isPendingCloseOrClosingOnServer
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received CLOSED for "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from "
operator|+
name|sn
operator|+
literal|" but the region isn't PENDING_CLOSE/CLOSING here: "
operator|+
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Handle CLOSED by assigning elsewhere or stopping if a disable
comment|// If we got here all is good.  Need to update RegionState -- else
comment|// what follows will fail because not in expected state.
operator|new
name|ClosedRegionHandler
argument_list|(
name|server
argument_list|,
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
name|updateClosedRegionHandlerTracker
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_FAILED_OPEN
case|:
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|!
name|regionState
operator|.
name|isPendingOpenOrOpeningOnServer
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received FAILED_OPEN for "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from "
operator|+
name|sn
operator|+
literal|" but the region isn't PENDING_OPEN/OPENING here: "
operator|+
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|AtomicInteger
name|failedOpenCount
init|=
name|failedOpenTracker
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|failedOpenCount
operator|==
literal|null
condition|)
block|{
name|failedOpenCount
operator|=
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
comment|// No need to use putIfAbsent, or extra synchronization since
comment|// this whole handleRegion block is locked on the encoded region
comment|// name, and failedOpenTracker is updated only in this block
name|failedOpenTracker
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|failedOpenCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failedOpenCount
operator|.
name|incrementAndGet
argument_list|()
operator|>=
name|maximumAttempts
condition|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|rt
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
comment|// remove the tracking info to save memory, also reset
comment|// the count for next open initiative
name|failedOpenTracker
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Handle this the same as if it were opened and then closed.
name|regionState
operator|=
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|rt
argument_list|,
name|State
operator|.
name|CLOSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
condition|)
block|{
comment|// When there are more than one region server a new RS is selected as the
comment|// destination and the same is updated in the regionplan. (HBASE-5546)
try|try
block|{
name|getRegionPlan
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|,
name|sn
argument_list|,
literal|true
argument_list|)
expr_stmt|;
operator|new
name|ClosedRegionHandler
argument_list|(
name|server
argument_list|,
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get region plan"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|RS_ZK_REGION_OPENING
case|:
comment|// Should see OPENING after we have asked it to OPEN or additional
comment|// times after already being in state of OPENING
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|!
name|regionState
operator|.
name|isPendingOpenOrOpeningOnServer
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received OPENING for "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from "
operator|+
name|sn
operator|+
literal|" but the region isn't PENDING_OPEN/OPENING here: "
operator|+
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Transition to OPENING (or update stamp if already OPENING)
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|rt
argument_list|,
name|State
operator|.
name|OPENING
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENED
case|:
comment|// Should see OPENED after OPENING but possible after PENDING_OPEN.
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|!
name|regionState
operator|.
name|isPendingOpenOrOpeningOnServer
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received OPENED for "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from "
operator|+
name|sn
operator|+
literal|" but the region isn't PENDING_OPEN/OPENING here: "
operator|+
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
condition|)
block|{
comment|// Close it without updating the internal region states,
comment|// so as not to create double assignments in unlucky scenarios
comment|// mentioned in OpenRegionHandler#process
name|unassign
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Handle OPENED by removing from transition and deleted zk node
name|regionState
operator|=
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|rt
argument_list|,
name|State
operator|.
name|OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
condition|)
block|{
name|failedOpenTracker
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
comment|// reset the count, if any
operator|new
name|OpenedRegionHandler
argument_list|(
name|server
argument_list|,
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|,
name|sn
argument_list|,
name|expectedVersion
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
name|updateOpenedRegionHandlerTracker
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Received event is not valid."
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|//For unit tests only
name|boolean
name|wasClosedHandlerCalled
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|AtomicBoolean
name|b
init|=
name|closedRegionHandlerCalled
operator|.
name|get
argument_list|(
name|hri
argument_list|)
decl_stmt|;
comment|//compareAndSet to be sure that unit tests don't see stale values. Means,
comment|//we will return true exactly once unless the handler code resets to true
comment|//this value.
return|return
name|b
operator|==
literal|null
condition|?
literal|false
else|:
name|b
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|//For unit tests only
name|boolean
name|wasOpenedHandlerCalled
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|AtomicBoolean
name|b
init|=
name|openedRegionHandlerCalled
operator|.
name|get
argument_list|(
name|hri
argument_list|)
decl_stmt|;
comment|//compareAndSet to be sure that unit tests don't see stale values. Means,
comment|//we will return true exactly once unless the handler code resets to true
comment|//this value.
return|return
name|b
operator|==
literal|null
condition|?
literal|false
else|:
name|b
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|//For unit tests only
name|void
name|initializeHandlerTrackers
parameter_list|()
block|{
name|closedRegionHandlerCalled
operator|=
operator|new
name|HashMap
argument_list|<
name|HRegionInfo
argument_list|,
name|AtomicBoolean
argument_list|>
argument_list|()
expr_stmt|;
name|openedRegionHandlerCalled
operator|=
operator|new
name|HashMap
argument_list|<
name|HRegionInfo
argument_list|,
name|AtomicBoolean
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|void
name|updateClosedRegionHandlerTracker
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
if|if
condition|(
name|closedRegionHandlerCalled
operator|!=
literal|null
condition|)
block|{
comment|//only for unit tests this is true
name|closedRegionHandlerCalled
operator|.
name|put
argument_list|(
name|hri
argument_list|,
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|updateOpenedRegionHandlerTracker
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
if|if
condition|(
name|openedRegionHandlerCalled
operator|!=
literal|null
condition|)
block|{
comment|//only for unit tests this is true
name|openedRegionHandlerCalled
operator|.
name|put
argument_list|(
name|hri
argument_list|,
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: processFavoredNodes might throw an exception, for e.g., if the
comment|// meta could not be contacted/updated. We need to see how seriously to treat
comment|// this problem as. Should we fail the current assignment. We should be able
comment|// to recover from this problem eventually (if the meta couldn't be updated
comment|// things should work normally and eventually get fixed up).
name|void
name|processFavoredNodes
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|shouldAssignRegionsWithFavoredNodes
condition|)
return|return;
comment|// The AM gets the favored nodes info for each region and updates the meta
comment|// table with that info
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
name|regionToFavoredNodes
init|=
operator|new
name|HashMap
argument_list|<
name|HRegionInfo
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
name|regionToFavoredNodes
operator|.
name|put
argument_list|(
name|region
argument_list|,
operator|(
operator|(
name|FavoredNodeLoadBalancer
operator|)
name|this
operator|.
name|balancer
operator|)
operator|.
name|getFavoredNodes
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FavoredNodeAssignmentHelper
operator|.
name|updateMetaWithFavoredNodesInfo
argument_list|(
name|regionToFavoredNodes
argument_list|,
name|catalogTracker
argument_list|)
expr_stmt|;
block|}
comment|/**    * Handle a ZK unassigned node transition triggered by HBCK repair tool.    *<p>    * This is handled in a separate code path because it breaks the normal rules.    * @param rt    */
specifier|private
name|void
name|handleHBCK
parameter_list|(
name|RegionTransition
name|rt
parameter_list|)
block|{
name|String
name|encodedName
init|=
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|rt
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Handling HBCK triggered transition="
operator|+
name|rt
operator|.
name|getEventType
argument_list|()
operator|+
literal|", server="
operator|+
name|rt
operator|.
name|getServerName
argument_list|()
operator|+
literal|", region="
operator|+
name|HRegionInfo
operator|.
name|prettyPrint
argument_list|(
name|encodedName
argument_list|)
argument_list|)
expr_stmt|;
name|RegionState
name|regionState
init|=
name|regionStates
operator|.
name|getRegionTransitionState
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rt
operator|.
name|getEventType
argument_list|()
condition|)
block|{
case|case
name|M_ZK_REGION_OFFLINE
case|:
name|HRegionInfo
name|regionInfo
decl_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
condition|)
block|{
name|regionInfo
operator|=
name|regionState
operator|.
name|getRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|byte
index|[]
name|name
init|=
name|rt
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|p
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|catalogTracker
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|regionInfo
operator|=
name|p
operator|.
name|getFirst
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Exception reading hbase:meta doing HBCK repair operation"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"HBCK repair is triggering assignment of region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// trigger assign, node is already in OFFLINE so don't need to update ZK
name|assign
argument_list|(
name|regionInfo
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received unexpected region state from HBCK: "
operator|+
name|rt
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// ZooKeeper events
comment|/**    * New unassigned node has been created.    *    *<p>This happens when an RS begins the OPENING or CLOSING of a region by    * creating an unassigned node.    *    *<p>When this happens we must:    *<ol>    *<li>Watch the node for further events</li>    *<li>Read and handle the state in the node</li>    *</ol>    */
annotation|@
name|Override
specifier|public
name|void
name|nodeCreated
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|handleAssignmentEvent
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/**    * Existing unassigned node has had data changed.    *    *<p>This happens when an RS transitions from OFFLINE to OPENING, or between    * OPENING/OPENED and CLOSING/CLOSED.    *    *<p>When this happens we must:    *<ol>    *<li>Watch the node for further events</li>    *<li>Read and handle the state in the node</li>    *</ol>    */
annotation|@
name|Override
specifier|public
name|void
name|nodeDataChanged
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|handleAssignmentEvent
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|// We  don't want to have two events on the same region managed simultaneously.
comment|// For this reason, we need to wait if an event on the same region is currently in progress.
comment|// So we track the region names of the events in progress, and we keep a waiting list.
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|regionsInProgress
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// In a LinkedHashMultimap, the put order is kept when we retrieve the collection back. We need
comment|//  this as we want the events to be managed in the same order as we received them.
specifier|private
specifier|final
name|LinkedHashMultimap
argument_list|<
name|String
argument_list|,
name|RegionRunnable
argument_list|>
name|zkEventWorkerWaitingList
init|=
name|LinkedHashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
comment|/**    * A specific runnable that works only on a region.    */
specifier|private
interface|interface
name|RegionRunnable
extends|extends
name|Runnable
block|{
comment|/**      * @return - the name of the region it works on.      */
name|String
name|getRegionName
parameter_list|()
function_decl|;
block|}
comment|/**    * Submit a task, ensuring that there is only one task at a time that working on a given region.    * Order is respected.    */
specifier|protected
name|void
name|zkEventWorkersSubmit
parameter_list|(
specifier|final
name|RegionRunnable
name|regRunnable
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regionsInProgress
init|)
block|{
comment|// If we're there is already a task with this region, we add it to the
comment|//  waiting list and return.
if|if
condition|(
name|regionsInProgress
operator|.
name|contains
argument_list|(
name|regRunnable
operator|.
name|getRegionName
argument_list|()
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|zkEventWorkerWaitingList
init|)
block|{
name|zkEventWorkerWaitingList
operator|.
name|put
argument_list|(
name|regRunnable
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|regRunnable
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// No event in progress on this region => we can submit a new task immediately.
name|regionsInProgress
operator|.
name|add
argument_list|(
name|regRunnable
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
name|zkEventWorkers
operator|.
name|submit
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|regRunnable
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
comment|// now that we have finished, let's see if there is an event for the same region in the
comment|//  waiting list. If it's the case, we can now submit it to the pool.
synchronized|synchronized
init|(
name|regionsInProgress
init|)
block|{
name|regionsInProgress
operator|.
name|remove
argument_list|(
name|regRunnable
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|zkEventWorkerWaitingList
init|)
block|{
name|java
operator|.
name|util
operator|.
name|Set
argument_list|<
name|RegionRunnable
argument_list|>
name|waiting
init|=
name|zkEventWorkerWaitingList
operator|.
name|get
argument_list|(
name|regRunnable
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|waiting
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// We want the first object only. The only way to get it is through an iterator.
name|RegionRunnable
name|toSubmit
init|=
name|waiting
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|zkEventWorkerWaitingList
operator|.
name|remove
argument_list|(
name|toSubmit
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|toSubmit
argument_list|)
expr_stmt|;
name|zkEventWorkersSubmit
argument_list|(
name|toSubmit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|nodeDeleted
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|watcher
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
specifier|final
name|String
name|regionName
init|=
name|ZKAssign
operator|.
name|getRegionName
argument_list|(
name|watcher
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|zkEventWorkersSubmit
argument_list|(
operator|new
name|RegionRunnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|getRegionName
parameter_list|()
block|{
return|return
name|regionName
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Lock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
try|try
block|{
name|RegionState
name|rs
init|=
name|regionStates
operator|.
name|getRegionTransitionState
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|==
literal|null
condition|)
block|{
name|rs
operator|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
literal|null
operator|||
operator|!
name|rs
operator|.
name|isMergingNew
argument_list|()
condition|)
block|{
comment|// MergingNew is an offline state
return|return;
block|}
block|}
name|HRegionInfo
name|regionInfo
init|=
name|rs
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|String
name|regionNameStr
init|=
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Znode "
operator|+
name|regionNameStr
operator|+
literal|" deleted, state: "
operator|+
name|rs
argument_list|)
expr_stmt|;
name|boolean
name|disabled
init|=
name|getZKTable
argument_list|()
operator|.
name|isDisablingOrDisabledTable
argument_list|(
name|regionInfo
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
name|ServerName
name|serverName
init|=
name|rs
operator|.
name|getServerName
argument_list|()
decl_stmt|;
if|if
condition|(
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
if|if
condition|(
name|rs
operator|.
name|isOnServer
argument_list|(
name|serverName
argument_list|)
operator|&&
operator|(
name|rs
operator|.
name|isOpened
argument_list|()
operator|||
name|rs
operator|.
name|isSplitting
argument_list|()
operator|)
condition|)
block|{
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
name|disabled
condition|)
block|{
comment|// if server is offline, no hurt to unassign again
name|LOG
operator|.
name|info
argument_list|(
literal|"Opened "
operator|+
name|regionNameStr
operator|+
literal|"but this table is disabled, triggering close of region"
argument_list|)
expr_stmt|;
name|unassign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rs
operator|.
name|isMergingNew
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|regionStates
init|)
block|{
name|String
name|p
init|=
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|PairOfSameType
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
name|mergingRegions
operator|.
name|get
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|regions
operator|!=
literal|null
condition|)
block|{
name|onlineMergingRegion
argument_list|(
name|disabled
argument_list|,
name|regions
operator|.
name|getFirst
argument_list|()
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
name|onlineMergingRegion
argument_list|(
name|disabled
argument_list|,
name|regions
operator|.
name|getSecond
argument_list|()
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|onlineMergingRegion
parameter_list|(
name|boolean
name|disabled
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
name|RegionState
name|regionState
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|hri
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
operator|&&
name|regionState
operator|.
name|isMerging
argument_list|()
operator|&&
name|regionState
operator|.
name|isOnServer
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|regionOnline
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
name|disabled
condition|)
block|{
name|unassign
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * New unassigned node has been created.    *    *<p>This happens when an RS begins the OPENING, SPLITTING or CLOSING of a    * region by creating a znode.    *    *<p>When this happens we must:    *<ol>    *<li>Watch the node for further children changed events</li>    *<li>Watch all new children for changed events</li>    *</ol>    */
annotation|@
name|Override
specifier|public
name|void
name|nodeChildrenChanged
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
name|watcher
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
name|zkEventWorkers
operator|.
name|submit
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// Just make sure we see the changes for the new znodes
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|assignmentZNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|children
operator|!=
literal|null
condition|)
block|{
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|child
range|:
name|children
control|)
block|{
comment|// if region is in transition, we already have a watch
comment|// on it, so no need to watch it again. So, as I know for now,
comment|// this is needed to watch splitting nodes only.
if|if
condition|(
operator|!
name|regionStates
operator|.
name|isRegionInTransition
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|ZKAssign
operator|.
name|getDataAndWatch
argument_list|(
name|watcher
argument_list|,
name|child
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception reading unassigned children"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Marks the region as online.  Removes it from regions in transition and    * updates the in-memory assignment information.    *<p>    * Used when a region has been successfully opened on a region server.    * @param regionInfo    * @param sn    */
name|void
name|regionOnline
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|ServerName
name|sn
parameter_list|)
block|{
name|numRegionsOpened
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|regionStates
operator|.
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|sn
argument_list|)
expr_stmt|;
comment|// Remove plan if one.
name|clearRegionPlan
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
comment|// Add the server to serversInUpdatingTimer
name|addToServersInUpdatingTimer
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|balancer
operator|.
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
comment|/**    * Pass the assignment event to a worker for processing.    * Each worker is a single thread executor service.  The reason    * for just one thread is to make sure all events for a given    * region are processed in order.    *    * @param path    */
specifier|private
name|void
name|handleAssignmentEvent
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|watcher
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
specifier|final
name|String
name|regionName
init|=
name|ZKAssign
operator|.
name|getRegionName
argument_list|(
name|watcher
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|zkEventWorkersSubmit
argument_list|(
operator|new
name|RegionRunnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|getRegionName
parameter_list|()
block|{
return|return
name|regionName
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getDataAndWatch
argument_list|(
name|watcher
argument_list|,
name|path
argument_list|,
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
return|return;
name|RegionTransition
name|rt
init|=
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|handleRegion
argument_list|(
name|rt
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception reading unassigned node data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Unexpected exception deserializing node data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add the server to the set serversInUpdatingTimer, then {@link TimerUpdater}    * will update timers for this server in background    * @param sn    */
specifier|private
name|void
name|addToServersInUpdatingTimer
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
if|if
condition|(
name|tomActivated
condition|)
block|{
name|this
operator|.
name|serversInUpdatingTimer
operator|.
name|add
argument_list|(
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Touch timers for all regions in transition that have the passed    *<code>sn</code> in common.    * Call this method whenever a server checks in.  Doing so helps the case where    * a new regionserver has joined the cluster and its been given 1k regions to    * open.  If this method is tickled every time the region reports in a    * successful open then the 1k-th region won't be timed out just because its    * sitting behind the open of 999 other regions.  This method is NOT used    * as part of bulk assign -- there we have a different mechanism for extending    * the regions in transition timer (we turn it off temporarily -- because    * there is no regionplan involved when bulk assigning.    * @param sn    */
specifier|private
name|void
name|updateTimers
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|tomActivated
argument_list|)
expr_stmt|;
if|if
condition|(
name|sn
operator|==
literal|null
condition|)
return|return;
comment|// This loop could be expensive.
comment|// First make a copy of current regionPlan rather than hold sync while
comment|// looping because holding sync can cause deadlock.  Its ok in this loop
comment|// if the Map we're going against is a little stale
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|>
name|rps
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|rps
operator|=
operator|new
name|ArrayList
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|>
argument_list|(
name|regionPlans
operator|.
name|entrySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|e
range|:
name|rps
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getKey
argument_list|()
operator|!=
literal|null
operator|&&
name|sn
operator|.
name|equals
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getDestination
argument_list|()
argument_list|)
condition|)
block|{
name|RegionState
name|regionState
init|=
name|regionStates
operator|.
name|getRegionTransitionState
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
condition|)
block|{
name|regionState
operator|.
name|updateTimestampToNow
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Marks the region as offline.  Removes it from regions in transition and    * removes in-memory assignment information.    *<p>    * Used when a region has been closed and should remain closed.    * @param regionInfo    */
specifier|public
name|void
name|regionOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|regionOffline
argument_list|(
name|regionInfo
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|offlineDisabledRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
comment|// Disabling so should not be reassigned, just delete the CLOSED node
name|LOG
operator|.
name|debug
argument_list|(
literal|"Table being disabled so deleting ZK node and removing from "
operator|+
literal|"regions in transition, skipping assignment of region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|encodedName
init|=
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|deleteNodeInStates
argument_list|(
name|encodedName
argument_list|,
literal|"closed"
argument_list|,
literal|null
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_CLOSED
argument_list|,
name|EventType
operator|.
name|M_ZK_REGION_OFFLINE
argument_list|)
expr_stmt|;
name|regionOffline
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|// Assignment methods
comment|/**    * Assigns the specified region.    *<p>    * If a RegionPlan is available with a valid destination then it will be used    * to determine what server region is assigned to.  If no RegionPlan is    * available, region will be assigned to a random available server.    *<p>    * Updates the RegionState and sends the OPEN RPC.    *<p>    * This will only succeed if the region is in transition and in a CLOSED or    * OFFLINE state or not in transition (in-memory not zk), and of course, the    * chosen server is up and running (It may have just crashed!).  If the    * in-memory checks pass, the zk node is forced to OFFLINE before assigning.    *    * @param region server to be assigned    * @param setOfflineInZK whether ZK node should be created/transitioned to an    *                       OFFLINE state before assigning the region    */
specifier|public
name|void
name|assign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|setOfflineInZK
parameter_list|)
block|{
name|assign
argument_list|(
name|region
argument_list|,
name|setOfflineInZK
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Use care with forceNewPlan. It could cause double assignment.    */
specifier|public
name|void
name|assign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|setOfflineInZK
parameter_list|,
name|boolean
name|forceNewPlan
parameter_list|)
block|{
if|if
condition|(
name|isDisabledorDisablingRegionInRIT
argument_list|(
name|region
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|.
name|isClusterShutdown
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cluster shutdown is set; skipping assign of "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|Lock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
try|try
block|{
name|RegionState
name|state
init|=
name|forceRegionStateToOffline
argument_list|(
name|region
argument_list|,
name|forceNewPlan
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|regionStates
operator|.
name|wasRegionOnDeadServer
argument_list|(
name|encodedName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip assigning "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", it's host "
operator|+
name|regionStates
operator|.
name|getLastRegionServerOfRegion
argument_list|(
name|encodedName
argument_list|)
operator|+
literal|" is dead but not processed yet"
argument_list|)
expr_stmt|;
return|return;
block|}
name|assign
argument_list|(
name|state
argument_list|,
name|setOfflineInZK
argument_list|,
name|forceNewPlan
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Bulk assign regions to<code>destination</code>.    * @param destination    * @param regions Regions to assign.    * @return true if successful    */
name|boolean
name|assign
parameter_list|(
specifier|final
name|ServerName
name|destination
parameter_list|,
specifier|final
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|long
name|startTime
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|regionCount
init|=
name|regions
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionCount
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Assigning "
operator|+
name|regionCount
operator|+
literal|" region(s) to "
operator|+
name|destination
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|encodedNames
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|regionCount
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
name|encodedNames
operator|.
name|add
argument_list|(
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|failedToOpenRegions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Lock
argument_list|>
name|locks
init|=
name|locker
operator|.
name|acquireLocks
argument_list|(
name|encodedNames
argument_list|)
decl_stmt|;
try|try
block|{
name|AtomicInteger
name|counter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|offlineNodesVersions
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|OfflineCallback
name|cb
init|=
operator|new
name|OfflineCallback
argument_list|(
name|watcher
argument_list|,
name|destination
argument_list|,
name|counter
argument_list|,
name|offlineNodesVersions
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|plans
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|(
name|regions
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RegionState
argument_list|>
name|states
init|=
operator|new
name|ArrayList
argument_list|<
name|RegionState
argument_list|>
argument_list|(
name|regions
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isDisabledorDisablingRegionInRIT
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|RegionState
name|state
init|=
name|forceRegionStateToOffline
argument_list|(
name|region
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|boolean
name|onDeadServer
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|regionStates
operator|.
name|wasRegionOnDeadServer
argument_list|(
name|encodedName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip assigning "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", it's host "
operator|+
name|regionStates
operator|.
name|getLastRegionServerOfRegion
argument_list|(
name|encodedName
argument_list|)
operator|+
literal|" is dead but not processed yet"
argument_list|)
expr_stmt|;
name|onDeadServer
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asyncSetOfflineInZooKeeper
argument_list|(
name|state
argument_list|,
name|cb
argument_list|,
name|destination
argument_list|)
condition|)
block|{
name|RegionPlan
name|plan
init|=
operator|new
name|RegionPlan
argument_list|(
name|region
argument_list|,
name|state
operator|.
name|getServerName
argument_list|()
argument_list|,
name|destination
argument_list|)
decl_stmt|;
name|plans
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|plan
argument_list|)
expr_stmt|;
name|states
operator|.
name|add
argument_list|(
name|state
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|// Reassign if the region wasn't on a dead server
if|if
condition|(
operator|!
name|onDeadServer
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"failed to force region state to offline or "
operator|+
literal|"failed to set it offline in ZK, will reassign later: "
operator|+
name|region
argument_list|)
expr_stmt|;
name|failedToOpenRegions
operator|.
name|add
argument_list|(
name|region
argument_list|)
expr_stmt|;
comment|// assign individually later
block|}
block|}
comment|// Release the lock, this region is excluded from bulk assign because
comment|// we can't update its state, or set its znode to offline.
name|Lock
name|lock
init|=
name|locks
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Wait until all unassigned nodes have been put up and watchers set.
name|int
name|total
init|=
name|states
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|oldCounter
init|=
literal|0
init|;
operator|!
name|server
operator|.
name|isStopped
argument_list|()
condition|;
control|)
block|{
name|int
name|count
init|=
name|counter
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldCounter
operator|!=
name|count
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|destination
operator|.
name|toString
argument_list|()
operator|+
literal|" unassigned znodes="
operator|+
name|count
operator|+
literal|" of total="
operator|+
name|total
argument_list|)
expr_stmt|;
name|oldCounter
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>=
name|total
condition|)
break|break;
name|Thread
operator|.
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|server
operator|.
name|isStopped
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Add region plans, so we can updateTimers when one region is opened so
comment|// that unnecessary timeout on RIT is reduced.
name|this
operator|.
name|addPlans
argument_list|(
name|plans
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Triple
argument_list|<
name|HRegionInfo
argument_list|,
name|Integer
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
argument_list|>
name|regionOpenInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|Triple
argument_list|<
name|HRegionInfo
argument_list|,
name|Integer
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
argument_list|>
argument_list|(
name|states
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RegionState
name|state
range|:
name|states
control|)
block|{
name|HRegionInfo
name|region
init|=
name|state
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|String
name|encodedRegionName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|Integer
name|nodeVersion
init|=
name|offlineNodesVersions
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeVersion
operator|==
literal|null
operator|||
name|nodeVersion
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to offline in zookeeper: "
operator|+
name|region
argument_list|)
expr_stmt|;
name|failedToOpenRegions
operator|.
name|add
argument_list|(
name|region
argument_list|)
expr_stmt|;
comment|// assign individually later
name|Lock
name|lock
init|=
name|locks
operator|.
name|remove
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|PENDING_OPEN
argument_list|,
name|destination
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
init|=
name|ServerName
operator|.
name|EMPTY_SERVER_LIST
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|shouldAssignRegionsWithFavoredNodes
condition|)
block|{
name|favoredNodes
operator|=
operator|(
operator|(
name|FavoredNodeLoadBalancer
operator|)
name|this
operator|.
name|balancer
operator|)
operator|.
name|getFavoredNodes
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
name|regionOpenInfos
operator|.
name|add
argument_list|(
operator|new
name|Triple
argument_list|<
name|HRegionInfo
argument_list|,
name|Integer
argument_list|,
name|List
argument_list|<
name|ServerName
argument_list|>
argument_list|>
argument_list|(
name|region
argument_list|,
name|nodeVersion
argument_list|,
name|favoredNodes
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Move on to open regions.
try|try
block|{
comment|// Send OPEN RPC. If it fails on a IOE or RemoteException,
comment|// regions will be assigned individually.
name|long
name|maxWaitTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.rpc.startup.waittime"
argument_list|,
literal|60000
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|maximumAttempts
operator|&&
operator|!
name|server
operator|.
name|isStopped
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|List
argument_list|<
name|RegionOpeningState
argument_list|>
name|regionOpeningStateList
init|=
name|serverManager
operator|.
name|sendRegionOpen
argument_list|(
name|destination
argument_list|,
name|regionOpenInfos
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionOpeningStateList
operator|==
literal|null
condition|)
block|{
comment|// Failed getting RPC connection to this server
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|k
init|=
literal|0
init|,
name|n
init|=
name|regionOpeningStateList
operator|.
name|size
argument_list|()
init|;
name|k
operator|<
name|n
condition|;
name|k
operator|++
control|)
block|{
name|RegionOpeningState
name|openingState
init|=
name|regionOpeningStateList
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|openingState
operator|!=
name|RegionOpeningState
operator|.
name|OPENED
condition|)
block|{
name|HRegionInfo
name|region
init|=
name|regionOpenInfos
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|openingState
operator|==
name|RegionOpeningState
operator|.
name|ALREADY_OPENED
condition|)
block|{
name|processAlreadyOpenedRegion
argument_list|(
name|region
argument_list|,
name|destination
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|openingState
operator|==
name|RegionOpeningState
operator|.
name|FAILED_OPENING
condition|)
block|{
comment|// Failed opening this region, reassign it later
name|failedToOpenRegions
operator|.
name|add
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"THIS SHOULD NOT HAPPEN: unknown opening state "
operator|+
name|openingState
operator|+
literal|" in assigning region "
operator|+
name|region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|e
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|instanceof
name|RegionServerStoppedException
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The region server was shut down, "
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// No need to retry, the region server is a goner.
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|ServerNotRunningYetException
condition|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|<
name|maxWaitTime
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server is not yet up; waiting up to "
operator|+
operator|(
name|maxWaitTime
operator|-
name|now
operator|)
operator|+
literal|"ms"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
comment|// reset the try count
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
operator|&&
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|destination
argument_list|)
condition|)
block|{
comment|// In case socket is timed out and the region server is still online,
comment|// the openRegion RPC could have been accepted by the server and
comment|// just the response didn't go through.  So we will retry to
comment|// open the region on the same server.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bulk assigner openRegion() to "
operator|+
name|destination
operator|+
literal|" has timed out, but the regions might"
operator|+
literal|" already be opened on it."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
throw|throw
name|e
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Can be a socket timeout, EOF, NoRouteToHost, etc
name|LOG
operator|.
name|info
argument_list|(
literal|"Unable to communicate with "
operator|+
name|destination
operator|+
literal|" in order to assign regions, "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
for|for
control|(
name|Lock
name|lock
range|:
name|locks
operator|.
name|values
argument_list|()
control|)
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|failedToOpenRegions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|HRegionInfo
name|region
range|:
name|failedToOpenRegions
control|)
block|{
if|if
condition|(
operator|!
name|regionStates
operator|.
name|isRegionOnline
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|invokeAssign
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bulk assigning done for "
operator|+
name|destination
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|metricsAssignmentManager
operator|.
name|updateBulkAssignTime
argument_list|(
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Send CLOSE RPC if the server is online, otherwise, offline the region.    *    * The RPC will be sent only to the region sever found in the region state    * if it is passed in, otherwise, to the src server specified. If region    * state is not specified, we don't update region state at all, instead    * we just send the RPC call. This is useful for some cleanup without    * messing around the region states (see handleRegion, on region opened    * on an unexpected server scenario, for an example)    */
specifier|private
name|void
name|unassign
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|RegionState
name|state
parameter_list|,
specifier|final
name|int
name|versionOfClosingNode
parameter_list|,
specifier|final
name|ServerName
name|dest
parameter_list|,
specifier|final
name|boolean
name|transitionInZK
parameter_list|,
specifier|final
name|ServerName
name|src
parameter_list|)
block|{
name|ServerName
name|server
init|=
name|src
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|server
operator|=
name|state
operator|.
name|getServerName
argument_list|()
expr_stmt|;
block|}
name|long
name|maxWaitTime
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|this
operator|.
name|maximumAttempts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|this
operator|.
name|server
operator|.
name|isStopped
argument_list|()
operator|||
name|this
operator|.
name|server
operator|.
name|isAborted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server stopped/aborted; skipping unassign of "
operator|+
name|region
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// ClosedRegionhandler can remove the server from this.regions
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|server
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Offline "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", no need to unassign since it's on a dead server: "
operator|+
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|transitionInZK
condition|)
block|{
comment|// delete the node. if no node exists need not bother.
name|deleteClosingOrClosedNode
argument_list|(
name|region
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|regionOffline
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
try|try
block|{
comment|// Send CLOSE RPC
if|if
condition|(
name|serverManager
operator|.
name|sendRegionClose
argument_list|(
name|server
argument_list|,
name|region
argument_list|,
name|versionOfClosingNode
argument_list|,
name|dest
argument_list|,
name|transitionInZK
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sent CLOSE to "
operator|+
name|server
operator|+
literal|" for region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|transitionInZK
operator|&&
name|state
operator|!=
literal|null
condition|)
block|{
comment|// Retry to make sure the region is
comment|// closed so as to avoid double assignment.
name|unassign
argument_list|(
name|region
argument_list|,
name|state
argument_list|,
name|versionOfClosingNode
argument_list|,
name|dest
argument_list|,
name|transitionInZK
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// This never happens. Currently regionserver close always return true.
comment|// Todo; this can now happen (0.96) if there is an exception in a coprocessor
name|LOG
operator|.
name|warn
argument_list|(
literal|"Server "
operator|+
name|server
operator|+
literal|" region CLOSE RPC returned false for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|RemoteException
condition|)
block|{
name|t
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|t
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|NotServingRegionException
operator|||
name|t
operator|instanceof
name|RegionServerStoppedException
operator|||
name|t
operator|instanceof
name|ServerNotRunningYetException
operator|||
name|t
operator|instanceof
name|FailedServerException
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Offline "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", it's not any more on "
operator|+
name|server
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|transitionInZK
condition|)
block|{
name|deleteClosingOrClosedNode
argument_list|(
name|region
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|regionOffline
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|state
operator|!=
literal|null
operator|&&
name|t
operator|instanceof
name|RegionAlreadyInTransitionException
condition|)
block|{
comment|// RS is already processing this region, only need to update the timestamp
name|LOG
operator|.
name|debug
argument_list|(
literal|"update "
operator|+
name|state
operator|+
literal|" the timestamp."
argument_list|)
expr_stmt|;
name|state
operator|.
name|updateTimestampToNow
argument_list|()
expr_stmt|;
if|if
condition|(
name|maxWaitTime
operator|<
literal|0
condition|)
block|{
name|maxWaitTime
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|ALREADY_IN_TRANSITION_WAITTIME
argument_list|,
name|DEFAULT_ALREADY_IN_TRANSITION_WAITTIME
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|long
name|now
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|<
name|maxWaitTime
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Region is already in transition; "
operator|+
literal|"waiting up to "
operator|+
operator|(
name|maxWaitTime
operator|-
name|now
operator|)
operator|+
literal|"ms"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
comment|// reset the try count
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to unassign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" since interrupted"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|tomActivated
condition|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_CLOSE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Server "
operator|+
name|server
operator|+
literal|" returned "
operator|+
name|t
operator|+
literal|" for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", try="
operator|+
name|i
operator|+
literal|" of "
operator|+
name|this
operator|.
name|maximumAttempts
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// Presume retry or server will expire.
block|}
block|}
block|}
comment|// Run out of attempts
if|if
condition|(
operator|!
name|tomActivated
operator|&&
name|state
operator|!=
literal|null
condition|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_CLOSE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set region to OFFLINE unless it is opening and forceNewPlan is false.    */
specifier|private
name|RegionState
name|forceRegionStateToOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
block|{
name|RegionState
name|state
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|region
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Assigning a region not in region states: "
operator|+
name|region
argument_list|)
expr_stmt|;
name|state
operator|=
name|regionStates
operator|.
name|createRegionState
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
name|ServerName
name|sn
init|=
name|state
operator|.
name|getServerName
argument_list|()
decl_stmt|;
if|if
condition|(
name|forceNewPlan
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Force region state offline "
operator|+
name|state
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|state
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|OPEN
case|:
case|case
name|OPENING
case|:
case|case
name|PENDING_OPEN
case|:
case|case
name|CLOSING
case|:
case|case
name|PENDING_CLOSE
case|:
if|if
condition|(
operator|!
name|forceNewPlan
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip assigning "
operator|+
name|region
operator|+
literal|", it is already "
operator|+
name|state
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
case|case
name|FAILED_CLOSE
case|:
case|case
name|FAILED_OPEN
case|:
name|unassign
argument_list|(
name|region
argument_list|,
name|state
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|state
operator|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|isFailedClose
argument_list|()
condition|)
block|{
comment|// If we can't close the region, we can't re-assign
comment|// it so as to avoid possible double assignment/data loss.
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip assigning "
operator|+
name|region
operator|+
literal|", we couldn't close it: "
operator|+
name|state
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
case|case
name|OFFLINE
case|:
comment|// This region could have been open on this server
comment|// for a while. If the server is dead and not processed
comment|// yet, we can move on only if the meta shows the
comment|// region is not on this server actually, or on a server
comment|// not dead, or dead and processed already.
if|if
condition|(
name|regionStates
operator|.
name|isServerDeadAndNotProcessed
argument_list|(
name|sn
argument_list|)
operator|&&
name|wasRegionOnDeadServerByMeta
argument_list|(
name|region
argument_list|,
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip assigning "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", it is on a dead but not processed yet server"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
case|case
name|CLOSED
case|:
break|break;
default|default:
name|LOG
operator|.
name|error
argument_list|(
literal|"Trying to assign region "
operator|+
name|region
operator|+
literal|", which is "
operator|+
name|state
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|state
return|;
block|}
specifier|private
name|boolean
name|wasRegionOnDeadServerByMeta
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|region
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|ServerName
name|server
init|=
name|catalogTracker
operator|.
name|getMetaLocation
argument_list|()
decl_stmt|;
return|return
name|regionStates
operator|.
name|isServerDeadAndNotProcessed
argument_list|(
name|server
argument_list|)
return|;
block|}
while|while
condition|(
operator|!
name|server
operator|.
name|isStopped
argument_list|()
condition|)
block|{
try|try
block|{
name|catalogTracker
operator|.
name|waitForMeta
argument_list|()
expr_stmt|;
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|r
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|catalogTracker
argument_list|,
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|ServerName
name|server
init|=
name|r
operator|==
literal|null
condition|?
literal|null
else|:
name|r
operator|.
name|getSecond
argument_list|()
decl_stmt|;
return|return
name|regionStates
operator|.
name|isServerDeadAndNotProcessed
argument_list|(
name|server
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Received exception accessing hbase:meta during force assign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", retrying"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Interrupted accessing hbase:meta"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Call is interrupted or server is stopped.
return|return
name|regionStates
operator|.
name|isServerDeadAndNotProcessed
argument_list|(
name|sn
argument_list|)
return|;
block|}
comment|/**    * Caller must hold lock on the passed<code>state</code> object.    * @param state    * @param setOfflineInZK    * @param forceNewPlan    */
specifier|private
name|void
name|assign
parameter_list|(
name|RegionState
name|state
parameter_list|,
specifier|final
name|boolean
name|setOfflineInZK
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
block|{
name|long
name|startTime
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|Configuration
name|conf
init|=
name|server
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|RegionState
name|currentState
init|=
name|state
decl_stmt|;
name|int
name|versionOfOfflineNode
init|=
operator|-
literal|1
decl_stmt|;
name|RegionPlan
name|plan
init|=
literal|null
decl_stmt|;
name|long
name|maxWaitTime
init|=
operator|-
literal|1
decl_stmt|;
name|HRegionInfo
name|region
init|=
name|state
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|RegionOpeningState
name|regionOpenState
decl_stmt|;
name|Throwable
name|previousException
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|maximumAttempts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|server
operator|.
name|isStopped
argument_list|()
operator|||
name|server
operator|.
name|isAborted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip assigning "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", the server is stopped/aborted"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
block|{
comment|// Get a server for the region at first
try|try
block|{
name|plan
operator|=
name|getRegionPlan
argument_list|(
name|region
argument_list|,
name|forceNewPlan
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get region plan"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to determine a plan to assign "
operator|+
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|tomActivated
condition|)
block|{
name|this
operator|.
name|timeoutMonitor
operator|.
name|setAllRegionServersOffline
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|region
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|sleepTimeBeforeRetryingMetaAssignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|maximumAttempts
condition|)
name|i
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Got exception while waiting for hbase:meta assignment"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|setOfflineInZK
operator|&&
name|versionOfOfflineNode
operator|==
operator|-
literal|1
condition|)
block|{
comment|// get the version of the znode after setting it to OFFLINE.
comment|// versionOfOfflineNode will be -1 if the znode was not set to OFFLINE
name|versionOfOfflineNode
operator|=
name|setOfflineInZooKeeper
argument_list|(
name|currentState
argument_list|,
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|versionOfOfflineNode
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|isDisabledorDisablingRegionInRIT
argument_list|(
name|region
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// In case of assignment from EnableTableHandler table state is ENABLING. Any how
comment|// EnableTableHandler will set ENABLED after assigning all the table regions. If we
comment|// try to set to ENABLED directly then client API may think table is enabled.
comment|// When we have a case such as all the regions are added directly into hbase:meta and we call
comment|// assignRegion then we need to make the table ENABLED. Hence in such case the table
comment|// will not be in ENABLING or ENABLED state.
name|TableName
name|tableName
init|=
name|region
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|zkTable
operator|.
name|isEnablingTable
argument_list|(
name|tableName
argument_list|)
operator|&&
operator|!
name|zkTable
operator|.
name|isEnabledTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setting table "
operator|+
name|tableName
operator|+
literal|" to ENABLED state."
argument_list|)
expr_stmt|;
name|setEnabledTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|setOfflineInZK
operator|&&
name|versionOfOfflineNode
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unable to set offline in ZooKeeper to assign "
operator|+
name|region
argument_list|)
expr_stmt|;
comment|// Setting offline in ZK must have been failed due to ZK racing or some
comment|// exception which may make the server to abort. If it is ZK racing,
comment|// we should retry since we already reset the region state,
comment|// existing (re)assignment will fail anyway.
if|if
condition|(
operator|!
name|server
operator|.
name|isAborted
argument_list|()
condition|)
block|{
continue|continue;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigning "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Transition RegionState to PENDING_OPEN
name|currentState
operator|=
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|PENDING_OPEN
argument_list|,
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|needNewPlan
decl_stmt|;
specifier|final
name|String
name|assignMsg
init|=
literal|"Failed assignment of "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|favoredNodes
init|=
name|ServerName
operator|.
name|EMPTY_SERVER_LIST
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|shouldAssignRegionsWithFavoredNodes
condition|)
block|{
name|favoredNodes
operator|=
operator|(
operator|(
name|FavoredNodeLoadBalancer
operator|)
name|this
operator|.
name|balancer
operator|)
operator|.
name|getFavoredNodes
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
name|regionOpenState
operator|=
name|serverManager
operator|.
name|sendRegionOpen
argument_list|(
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|,
name|region
argument_list|,
name|versionOfOfflineNode
argument_list|,
name|favoredNodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionOpenState
operator|==
name|RegionOpeningState
operator|.
name|FAILED_OPENING
condition|)
block|{
comment|// Failed opening this region, looping again on a new server.
name|needNewPlan
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|assignMsg
operator|+
literal|", regionserver says 'FAILED_OPENING', "
operator|+
literal|" trying to assign elsewhere instead; "
operator|+
literal|"try="
operator|+
name|i
operator|+
literal|" of "
operator|+
name|this
operator|.
name|maximumAttempts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we're done
if|if
condition|(
name|regionOpenState
operator|==
name|RegionOpeningState
operator|.
name|ALREADY_OPENED
condition|)
block|{
name|processAlreadyOpenedRegion
argument_list|(
name|region
argument_list|,
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|RemoteException
condition|)
block|{
name|t
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|t
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
name|previousException
operator|=
name|t
expr_stmt|;
comment|// Should we wait a little before retrying? If the server is starting it's yes.
comment|// If the region is already in transition, it's yes as well: we want to be sure that
comment|//  the region will get opened but we don't want a double assignment.
name|boolean
name|hold
init|=
operator|(
name|t
operator|instanceof
name|RegionAlreadyInTransitionException
operator|||
name|t
operator|instanceof
name|ServerNotRunningYetException
operator|)
decl_stmt|;
comment|// In case socket is timed out and the region server is still online,
comment|// the openRegion RPC could have been accepted by the server and
comment|// just the response didn't go through.  So we will retry to
comment|// open the region on the same server to avoid possible
comment|// double assignment.
name|boolean
name|retry
init|=
operator|!
name|hold
operator|&&
operator|(
name|t
operator|instanceof
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
operator|&&
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|hold
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|assignMsg
operator|+
literal|", waiting a little before trying on the same region server "
operator|+
literal|"try="
operator|+
name|i
operator|+
literal|" of "
operator|+
name|this
operator|.
name|maximumAttempts
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxWaitTime
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|RegionAlreadyInTransitionException
condition|)
block|{
name|maxWaitTime
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|ALREADY_IN_TRANSITION_WAITTIME
argument_list|,
name|DEFAULT_ALREADY_IN_TRANSITION_WAITTIME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxWaitTime
operator|=
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.rpc.startup.waittime"
argument_list|,
literal|60000
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|needNewPlan
operator|=
literal|false
expr_stmt|;
name|long
name|now
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|<
name|maxWaitTime
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server is not yet up or region is already in transition; "
operator|+
literal|"waiting up to "
operator|+
operator|(
name|maxWaitTime
operator|-
name|now
operator|)
operator|+
literal|"ms"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
comment|// reset the try count
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|t
operator|instanceof
name|RegionAlreadyInTransitionException
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server is not up for a while; try a new one"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|needNewPlan
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to assign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" since interrupted"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|tomActivated
condition|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|retry
condition|)
block|{
name|needNewPlan
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|assignMsg
operator|+
literal|", trying to assign to the same region server "
operator|+
literal|"try="
operator|+
name|i
operator|+
literal|" of "
operator|+
name|this
operator|.
name|maximumAttempts
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|needNewPlan
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|assignMsg
operator|+
literal|", trying to assign elsewhere instead;"
operator|+
literal|" try="
operator|+
name|i
operator|+
literal|" of "
operator|+
name|this
operator|.
name|maximumAttempts
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|this
operator|.
name|maximumAttempts
condition|)
block|{
comment|// Don't reset the region state or get a new plan any more.
comment|// This is the last try.
continue|continue;
block|}
comment|// If region opened on destination of present plan, reassigning to new
comment|// RS may cause double assignments. In case of RegionAlreadyInTransitionException
comment|// reassigning to same RS.
if|if
condition|(
name|needNewPlan
condition|)
block|{
comment|// Force a new plan and reassign. Will return null if no servers.
comment|// The new plan could be the same as the existing plan since we don't
comment|// exclude the server of the original plan, which should not be
comment|// excluded since it could be the only server up now.
name|RegionPlan
name|newPlan
init|=
literal|null
decl_stmt|;
try|try
block|{
name|newPlan
operator|=
name|getRegionPlan
argument_list|(
name|region
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HBaseIOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get region plan"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newPlan
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|tomActivated
condition|)
block|{
name|this
operator|.
name|timeoutMonitor
operator|.
name|setAllRegionServersOffline
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to find a viable location to assign region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|plan
operator|!=
name|newPlan
operator|&&
operator|!
name|plan
operator|.
name|getDestination
argument_list|()
operator|.
name|equals
argument_list|(
name|newPlan
operator|.
name|getDestination
argument_list|()
argument_list|)
condition|)
block|{
comment|// Clean out plan we failed execute and one that doesn't look like it'll
comment|// succeed anyways; we need a new plan!
comment|// Transition back to OFFLINE
name|currentState
operator|=
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
name|versionOfOfflineNode
operator|=
operator|-
literal|1
expr_stmt|;
name|plan
operator|=
name|newPlan
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plan
operator|.
name|getDestination
argument_list|()
operator|.
name|equals
argument_list|(
name|newPlan
operator|.
name|getDestination
argument_list|()
argument_list|)
operator|&&
name|previousException
operator|instanceof
name|FailedServerException
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to re-assign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to the same failed server."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1
operator|+
name|conf
operator|.
name|getInt
argument_list|(
name|RpcClient
operator|.
name|FAILED_SERVER_EXPIRY_KEY
argument_list|,
name|RpcClient
operator|.
name|FAILED_SERVER_EXPIRY_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to assign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" since interrupted"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|tomActivated
condition|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
block|}
comment|// Run out of attempts
if|if
condition|(
operator|!
name|tomActivated
condition|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|metricsAssignmentManager
operator|.
name|updateAssignmentTime
argument_list|(
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|processAlreadyOpenedRegion
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|sn
parameter_list|)
block|{
comment|// Remove region from in-memory transition and unassigned node from ZK
comment|// While trying to enable the table the regions of the table were
comment|// already enabled.
name|LOG
operator|.
name|debug
argument_list|(
literal|"ALREADY_OPENED "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|sn
argument_list|)
expr_stmt|;
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|deleteNodeInStates
argument_list|(
name|encodedName
argument_list|,
literal|"offline"
argument_list|,
name|sn
argument_list|,
name|EventType
operator|.
name|M_ZK_REGION_OFFLINE
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|regionOnline
argument_list|(
name|region
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|isDisabledorDisablingRegionInRIT
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|)
block|{
name|TableName
name|tableName
init|=
name|region
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|boolean
name|disabled
init|=
name|this
operator|.
name|zkTable
operator|.
name|isDisabledTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|disabled
operator|||
name|this
operator|.
name|zkTable
operator|.
name|isDisablingTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Table "
operator|+
name|tableName
operator|+
operator|(
name|disabled
condition|?
literal|" disabled;"
else|:
literal|" disabling;"
operator|)
operator|+
literal|" skipping assign of "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|offlineDisabledRegion
argument_list|(
name|region
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Set region as OFFLINED up in zookeeper    *    * @param state    * @return the version of the offline node if setting of the OFFLINE node was    *         successful, -1 otherwise.    */
specifier|private
name|int
name|setOfflineInZooKeeper
parameter_list|(
specifier|final
name|RegionState
name|state
parameter_list|,
specifier|final
name|ServerName
name|destination
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
operator|.
name|isClosed
argument_list|()
operator|&&
operator|!
name|state
operator|.
name|isOffline
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"Unexpected state : "
operator|+
name|state
operator|+
literal|" .. Cannot transit it to OFFLINE."
decl_stmt|;
name|this
operator|.
name|server
operator|.
name|abort
argument_list|(
name|msg
argument_list|,
operator|new
name|IllegalStateException
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
name|int
name|versionOfOfflineNode
decl_stmt|;
try|try
block|{
comment|// get the version after setting the znode to OFFLINE
name|versionOfOfflineNode
operator|=
name|ZKAssign
operator|.
name|createOrForceNodeOffline
argument_list|(
name|watcher
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
name|destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|versionOfOfflineNode
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempted to create/force node into OFFLINE state before "
operator|+
literal|"completing assignment but failed to do so for "
operator|+
name|state
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception creating/setting node OFFLINE"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|versionOfOfflineNode
return|;
block|}
comment|/**    * @param region the region to assign    * @return Plan for passed<code>region</code> (If none currently, it creates one or    * if no servers to assign, it returns null).    */
specifier|private
name|RegionPlan
name|getRegionPlan
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
throws|throws
name|HBaseIOException
block|{
return|return
name|getRegionPlan
argument_list|(
name|region
argument_list|,
literal|null
argument_list|,
name|forceNewPlan
argument_list|)
return|;
block|}
comment|/**    * @param region the region to assign    * @param serverToExclude Server to exclude (we know its bad). Pass null if    * all servers are thought to be assignable.    * @param forceNewPlan If true, then if an existing plan exists, a new plan    * will be generated.    * @return Plan for passed<code>region</code> (If none currently, it creates one or    * if no servers to assign, it returns null).    */
specifier|private
name|RegionPlan
name|getRegionPlan
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|ServerName
name|serverToExclude
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
throws|throws
name|HBaseIOException
block|{
comment|// Pickup existing plan or make a new one
specifier|final
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|destServers
init|=
name|serverManager
operator|.
name|createDestinationServersList
argument_list|(
name|serverToExclude
argument_list|)
decl_stmt|;
if|if
condition|(
name|destServers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can't move "
operator|+
name|encodedName
operator|+
literal|", there is no destination server available."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|RegionPlan
name|randomPlan
init|=
literal|null
decl_stmt|;
name|boolean
name|newPlan
init|=
literal|false
decl_stmt|;
name|RegionPlan
name|existingPlan
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|existingPlan
operator|=
name|this
operator|.
name|regionPlans
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|existingPlan
operator|!=
literal|null
operator|&&
name|existingPlan
operator|.
name|getDestination
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found an existing plan for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" destination server is "
operator|+
name|existingPlan
operator|.
name|getDestination
argument_list|()
operator|+
literal|" accepted as a dest server = "
operator|+
name|destServers
operator|.
name|contains
argument_list|(
name|existingPlan
operator|.
name|getDestination
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|forceNewPlan
operator|||
name|existingPlan
operator|==
literal|null
operator|||
name|existingPlan
operator|.
name|getDestination
argument_list|()
operator|==
literal|null
operator|||
operator|!
name|destServers
operator|.
name|contains
argument_list|(
name|existingPlan
operator|.
name|getDestination
argument_list|()
argument_list|)
condition|)
block|{
name|newPlan
operator|=
literal|true
expr_stmt|;
name|randomPlan
operator|=
operator|new
name|RegionPlan
argument_list|(
name|region
argument_list|,
literal|null
argument_list|,
name|balancer
operator|.
name|randomAssignment
argument_list|(
name|region
argument_list|,
name|destServers
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|region
operator|.
name|isMetaTable
argument_list|()
operator|&&
name|shouldAssignRegionsWithFavoredNodes
condition|)
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|regions
operator|.
name|add
argument_list|(
name|region
argument_list|)
expr_stmt|;
try|try
block|{
name|processFavoredNodes
argument_list|(
name|regions
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring exception in processFavoredNodes "
operator|+
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|regionPlans
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|randomPlan
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newPlan
condition|)
block|{
if|if
condition|(
name|randomPlan
operator|.
name|getDestination
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can't find a destination for "
operator|+
name|encodedName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"No previous transition plan found (or ignoring "
operator|+
literal|"an existing plan) for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|"; generated random plan="
operator|+
name|randomPlan
operator|+
literal|"; "
operator|+
name|serverManager
operator|.
name|countOfRegionServers
argument_list|()
operator|+
literal|" (online="
operator|+
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|", available="
operator|+
name|destServers
operator|.
name|size
argument_list|()
operator|+
literal|") available servers"
operator|+
literal|", forceNewPlan="
operator|+
name|forceNewPlan
argument_list|)
expr_stmt|;
return|return
name|randomPlan
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using pre-existing plan for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|"; plan="
operator|+
name|existingPlan
argument_list|)
expr_stmt|;
return|return
name|existingPlan
return|;
block|}
comment|/**    * Unassigns the specified region.    *<p>    * Updates the RegionState and sends the CLOSE RPC unless region is being    * split by regionserver; then the unassign fails (silently) because we    * presume the region being unassigned no longer exists (its been split out    * of existence). TODO: What to do if split fails and is rolled back and    * parent is revivified?    *<p>    * If a RegionPlan is already set, it will remain.    *    * @param region server to be unassigned    */
specifier|public
name|void
name|unassign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
name|unassign
argument_list|(
name|region
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Unassigns the specified region.    *<p>    * Updates the RegionState and sends the CLOSE RPC unless region is being    * split by regionserver; then the unassign fails (silently) because we    * presume the region being unassigned no longer exists (its been split out    * of existence). TODO: What to do if split fails and is rolled back and    * parent is revivified?    *<p>    * If a RegionPlan is already set, it will remain.    *    * @param region server to be unassigned    * @param force if region should be closed even if already closing    */
specifier|public
name|void
name|unassign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|force
parameter_list|,
name|ServerName
name|dest
parameter_list|)
block|{
comment|// TODO: Method needs refactoring.  Ugly buried returns throughout.  Beware!
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting unassign of "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" (offlining), current state: "
operator|+
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
comment|// Grab the state of this region and synchronize on it
name|int
name|versionOfClosingNode
init|=
operator|-
literal|1
decl_stmt|;
comment|// We need a lock here as we're going to do a put later and we don't want multiple states
comment|//  creation
name|ReentrantLock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|RegionState
name|state
init|=
name|regionStates
operator|.
name|getRegionTransitionState
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|boolean
name|reassign
init|=
literal|true
decl_stmt|;
try|try
block|{
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
comment|// Region is not in transition.
comment|// We can unassign it only if it's not SPLIT/MERGED.
name|state
operator|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
operator|&&
name|state
operator|.
name|isUnassignable
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to unassign "
operator|+
name|state
operator|+
literal|", ignored"
argument_list|)
expr_stmt|;
comment|// Offline region will be reassigned below
return|return;
block|}
comment|// Create the znode in CLOSING state
try|try
block|{
if|if
condition|(
name|state
operator|==
literal|null
operator|||
name|state
operator|.
name|getServerName
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// We don't know where the region is, offline it.
comment|// No need to send CLOSE RPC
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempting to unassign a region not in RegionStates"
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", offlined"
argument_list|)
expr_stmt|;
name|regionOffline
argument_list|(
name|region
argument_list|)
expr_stmt|;
return|return;
block|}
name|versionOfClosingNode
operator|=
name|ZKAssign
operator|.
name|createNodeClosing
argument_list|(
name|watcher
argument_list|,
name|region
argument_list|,
name|state
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|versionOfClosingNode
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to unassign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but ZK closing node "
operator|+
literal|"can't be created."
argument_list|)
expr_stmt|;
name|reassign
operator|=
literal|false
expr_stmt|;
comment|// not unassigned at all
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|NodeExistsException
condition|)
block|{
comment|// Handle race between master initiated close and regionserver
comment|// orchestrated splitting. See if existing node is in a
comment|// SPLITTING or SPLIT state.  If so, the regionserver started
comment|// an op on node before we could get our CLOSING in.  Deal.
name|NodeExistsException
name|nee
init|=
operator|(
name|NodeExistsException
operator|)
name|e
decl_stmt|;
name|String
name|path
init|=
name|nee
operator|.
name|getPath
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isSplitOrSplittingOrMergedOrMerging
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|path
operator|+
literal|" is SPLIT or SPLITTING or MERGED or MERGING; "
operator|+
literal|"skipping unassign because region no longer exists -- its split or merge"
argument_list|)
expr_stmt|;
name|reassign
operator|=
literal|false
expr_stmt|;
comment|// no need to reassign for split/merged region
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|ke
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed getData on SPLITTING/SPLIT at "
operator|+
name|path
operator|+
literal|"; presuming split and that the region to unassign, "
operator|+
name|encodedName
operator|+
literal|", no longer exists -- confirm"
argument_list|,
name|ke
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected zk state"
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|de
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed parse"
argument_list|,
name|de
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If we get here, don't understand whats going on -- abort.
name|server
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception creating node CLOSING"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|reassign
operator|=
literal|false
expr_stmt|;
comment|// heading out already
return|return;
block|}
name|state
operator|=
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|PENDING_CLOSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|isFailedOpen
argument_list|()
condition|)
block|{
comment|// The region is not open yet
name|regionOffline
argument_list|(
name|region
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|force
operator|&&
name|state
operator|.
name|isPendingCloseOrClosing
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to unassign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" which is already "
operator|+
name|state
operator|.
name|getState
argument_list|()
operator|+
literal|" but forcing to send a CLOSE RPC again "
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|isFailedClose
argument_list|()
condition|)
block|{
name|state
operator|=
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|region
argument_list|,
name|State
operator|.
name|PENDING_CLOSE
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|updateTimestampToNow
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to unassign "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but it is "
operator|+
literal|"already in transition ("
operator|+
name|state
operator|.
name|getState
argument_list|()
operator|+
literal|", force="
operator|+
name|force
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return;
block|}
name|unassign
argument_list|(
name|region
argument_list|,
name|state
argument_list|,
name|versionOfClosingNode
argument_list|,
name|dest
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// Region is expected to be reassigned afterwards
if|if
condition|(
name|reassign
operator|&&
name|regionStates
operator|.
name|isRegionOffline
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|assign
argument_list|(
name|region
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|unassign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
name|unassign
argument_list|(
name|region
argument_list|,
name|force
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param region regioninfo of znode to be deleted.    */
specifier|public
name|void
name|deleteClosingOrClosedNode
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|sn
parameter_list|)
block|{
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|deleteNodeInStates
argument_list|(
name|encodedName
argument_list|,
literal|"closing"
argument_list|,
name|sn
argument_list|,
name|EventType
operator|.
name|M_ZK_REGION_CLOSING
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_CLOSED
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param path    * @return True if znode is in SPLIT or SPLITTING or MERGED or MERGING state.    * @throws KeeperException Can happen if the znode went away in meantime.    * @throws DeserializationException    */
specifier|private
name|boolean
name|isSplitOrSplittingOrMergedOrMerging
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|DeserializationException
block|{
name|boolean
name|result
init|=
literal|false
decl_stmt|;
comment|// This may fail if the SPLIT or SPLITTING or MERGED or MERGING znode gets
comment|// cleaned up before we can get data from it.
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|watcher
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Node "
operator|+
name|path
operator|+
literal|" is gone"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|RegionTransition
name|rt
init|=
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rt
operator|.
name|getEventType
argument_list|()
condition|)
block|{
case|case
name|RS_ZK_REQUEST_REGION_SPLIT
case|:
case|case
name|RS_ZK_REGION_SPLIT
case|:
case|case
name|RS_ZK_REGION_SPLITTING
case|:
case|case
name|RS_ZK_REQUEST_REGION_MERGE
case|:
case|case
name|RS_ZK_REGION_MERGED
case|:
case|case
name|RS_ZK_REGION_MERGING
case|:
name|result
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|info
argument_list|(
literal|"Node "
operator|+
name|path
operator|+
literal|" is in "
operator|+
name|rt
operator|.
name|getEventType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Used by unit tests. Return the number of regions opened so far in the life    * of the master. Increases by one every time the master opens a region    * @return the counter value of the number of regions opened so far    */
specifier|public
name|int
name|getNumRegionsOpened
parameter_list|()
block|{
return|return
name|numRegionsOpened
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Waits until the specified region has completed assignment.    *<p>    * If the region is already assigned, returns immediately.  Otherwise, method    * blocks until the region is assigned.    * @param regionInfo region to wait on assignment for    * @throws InterruptedException    */
specifier|public
name|boolean
name|waitForAssignment
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|InterruptedException
block|{
while|while
condition|(
operator|!
name|regionStates
operator|.
name|isRegionOnline
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|regionStates
operator|.
name|isRegionInState
argument_list|(
name|regionInfo
argument_list|,
name|State
operator|.
name|FAILED_OPEN
argument_list|)
operator|||
name|this
operator|.
name|server
operator|.
name|isStopped
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We should receive a notification, but it's
comment|//  better to have a timeout to recheck the condition here:
comment|//  it lowers the impact of a race condition if any
name|regionStates
operator|.
name|waitForUpdate
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Assigns the hbase:meta region.    *<p>    * Assumes that hbase:meta is currently closed and is not being actively served by    * any RegionServer.    *<p>    * Forcibly unsets the current meta region location in ZooKeeper and assigns    * hbase:meta to a random RegionServer.    * @throws KeeperException    */
specifier|public
name|void
name|assignMeta
parameter_list|()
throws|throws
name|KeeperException
block|{
name|MetaRegionTracker
operator|.
name|deleteMetaLocation
argument_list|(
name|this
operator|.
name|watcher
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assigns specified regions retaining assignments, if any.    *<p>    * This is a synchronous call and will return once every region has been    * assigned.  If anything fails, an exception is thrown    * @throws InterruptedException    * @throws IOException    */
specifier|public
name|void
name|assign
parameter_list|(
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regions
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|regions
operator|==
literal|null
operator|||
name|regions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
init|=
name|serverManager
operator|.
name|createDestinationServersList
argument_list|()
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|null
operator|||
name|servers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Found no destination server to assign region(s)"
argument_list|)
throw|;
block|}
comment|// Reuse existing assignment info
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
init|=
name|balancer
operator|.
name|retainAssignment
argument_list|(
name|regions
argument_list|,
name|servers
argument_list|)
decl_stmt|;
name|assign
argument_list|(
name|regions
operator|.
name|size
argument_list|()
argument_list|,
name|servers
operator|.
name|size
argument_list|()
argument_list|,
literal|"retainAssignment=true"
argument_list|,
name|bulkPlan
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assigns specified regions round robin, if any.    *<p>    * This is a synchronous call and will return once every region has been    * assigned.  If anything fails, an exception is thrown    * @throws InterruptedException    * @throws IOException    */
specifier|public
name|void
name|assign
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|regions
operator|==
literal|null
operator|||
name|regions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
init|=
name|serverManager
operator|.
name|createDestinationServersList
argument_list|()
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|null
operator|||
name|servers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Found no destination server to assign region(s)"
argument_list|)
throw|;
block|}
comment|// Generate a round-robin bulk assignment plan
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
init|=
name|balancer
operator|.
name|roundRobinAssignment
argument_list|(
name|regions
argument_list|,
name|servers
argument_list|)
decl_stmt|;
name|processFavoredNodes
argument_list|(
name|regions
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|regions
operator|.
name|size
argument_list|()
argument_list|,
name|servers
operator|.
name|size
argument_list|()
argument_list|,
literal|"round-robin=true"
argument_list|,
name|bulkPlan
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|assign
parameter_list|(
name|int
name|regions
parameter_list|,
name|int
name|totalServers
parameter_list|,
name|String
name|message
parameter_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|int
name|servers
init|=
name|bulkPlan
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|1
operator|||
operator|(
name|regions
operator|<
name|bulkAssignThresholdRegions
operator|&&
name|servers
operator|<
name|bulkAssignThresholdServers
operator|)
condition|)
block|{
comment|// Not use bulk assignment.  This could be more efficient in small
comment|// cluster, especially mini cluster for testing, so that tests won't time out
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Not using bulk assignment since we are assigning only "
operator|+
name|regions
operator|+
literal|" region(s) to "
operator|+
name|servers
operator|+
literal|" server(s)"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|plan
range|:
name|bulkPlan
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|assign
argument_list|(
name|plan
operator|.
name|getKey
argument_list|()
argument_list|,
name|plan
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
for|for
control|(
name|HRegionInfo
name|region
range|:
name|plan
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|regionStates
operator|.
name|isRegionOnline
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|invokeAssign
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Bulk assigning "
operator|+
name|regions
operator|+
literal|" region(s) across "
operator|+
name|totalServers
operator|+
literal|" server(s), "
operator|+
name|message
argument_list|)
expr_stmt|;
comment|// Use fixed count thread pool assigning.
name|BulkAssigner
name|ba
init|=
operator|new
name|GeneralBulkAssigner
argument_list|(
name|this
operator|.
name|server
argument_list|,
name|bulkPlan
argument_list|,
name|this
argument_list|,
name|bulkAssignWaitTillAllAssigned
argument_list|)
decl_stmt|;
name|ba
operator|.
name|bulkAssign
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Bulk assigning done"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Assigns all user regions, if any exist.  Used during cluster startup.    *<p>    * This is a synchronous call and will return once every region has been    * assigned.  If anything fails, an exception is thrown and the cluster    * should be shutdown.    * @throws InterruptedException    * @throws IOException    * @throws KeeperException    */
specifier|private
name|void
name|assignAllUserRegions
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
block|{
comment|// Cleanup any existing ZK nodes and start watching
name|ZKAssign
operator|.
name|deleteAllNodes
argument_list|(
name|watcher
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|this
operator|.
name|watcher
argument_list|,
name|this
operator|.
name|watcher
operator|.
name|assignmentZNode
argument_list|)
expr_stmt|;
name|failoverCleanupDone
argument_list|()
expr_stmt|;
comment|// Skip assignment for regions of tables in DISABLING state because during clean cluster startup
comment|// no RS is alive and regions map also doesn't have any information about the regions.
comment|// See HBASE-6281.
name|Set
argument_list|<
name|TableName
argument_list|>
name|disabledOrDisablingOrEnabling
init|=
name|ZKTable
operator|.
name|getDisabledOrDisablingTables
argument_list|(
name|watcher
argument_list|)
decl_stmt|;
name|disabledOrDisablingOrEnabling
operator|.
name|addAll
argument_list|(
name|ZKTable
operator|.
name|getEnablingTables
argument_list|(
name|watcher
argument_list|)
argument_list|)
expr_stmt|;
comment|// Scan hbase:meta for all user regions, skipping any disabled tables
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|allRegions
decl_stmt|;
name|SnapshotOfRegionAssignmentFromMeta
name|snapshotOfRegionAssignment
init|=
operator|new
name|SnapshotOfRegionAssignmentFromMeta
argument_list|(
name|catalogTracker
argument_list|,
name|disabledOrDisablingOrEnabling
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|snapshotOfRegionAssignment
operator|.
name|initialize
argument_list|()
expr_stmt|;
name|allRegions
operator|=
name|snapshotOfRegionAssignment
operator|.
name|getRegionToRegionServerMap
argument_list|()
expr_stmt|;
if|if
condition|(
name|allRegions
operator|==
literal|null
operator|||
name|allRegions
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// Determine what type of assignment to do on startup
name|boolean
name|retainAssignment
init|=
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.startup.retainassign"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|retainAssignment
condition|)
block|{
name|assign
argument_list|(
name|allRegions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|allRegions
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|assign
argument_list|(
name|regions
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|allRegions
operator|.
name|keySet
argument_list|()
control|)
block|{
name|TableName
name|tableName
init|=
name|hri
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|zkTable
operator|.
name|isEnabledTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|setEnabledTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Wait until no regions in transition.    * @param timeout How long to wait.    * @return True if nothing in regions in transition.    * @throws InterruptedException    */
name|boolean
name|waitUntilNoRegionsInTransition
parameter_list|(
specifier|final
name|long
name|timeout
parameter_list|)
throws|throws
name|InterruptedException
block|{
comment|// Blocks until there are no regions in transition. It is possible that
comment|// there
comment|// are regions in transition immediately after this returns but guarantees
comment|// that if it returns without an exception that there was a period of time
comment|// with no regions in transition from the point-of-view of the in-memory
comment|// state of the Master.
specifier|final
name|long
name|endTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|timeout
decl_stmt|;
while|while
condition|(
operator|!
name|this
operator|.
name|server
operator|.
name|isStopped
argument_list|()
operator|&&
name|regionStates
operator|.
name|isRegionsInTransition
argument_list|()
operator|&&
name|endTime
operator|>
name|System
operator|.
name|currentTimeMillis
argument_list|()
condition|)
block|{
name|regionStates
operator|.
name|waitForUpdate
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|regionStates
operator|.
name|isRegionsInTransition
argument_list|()
return|;
block|}
comment|/**    * Rebuild the list of user regions and assignment information.    *<p>    * Returns a map of servers that are not found to be online and the regions    * they were hosting.    * @return map of servers not online to their assigned regions, as stored    *         in META    * @throws IOException    */
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|rebuildUserRegions
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
name|Set
argument_list|<
name|TableName
argument_list|>
name|enablingTables
init|=
name|ZKTable
operator|.
name|getEnablingTables
argument_list|(
name|watcher
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|TableName
argument_list|>
name|disabledOrEnablingTables
init|=
name|ZKTable
operator|.
name|getDisabledTables
argument_list|(
name|watcher
argument_list|)
decl_stmt|;
name|disabledOrEnablingTables
operator|.
name|addAll
argument_list|(
name|enablingTables
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|TableName
argument_list|>
name|disabledOrDisablingOrEnabling
init|=
name|ZKTable
operator|.
name|getDisablingTables
argument_list|(
name|watcher
argument_list|)
decl_stmt|;
name|disabledOrDisablingOrEnabling
operator|.
name|addAll
argument_list|(
name|disabledOrEnablingTables
argument_list|)
expr_stmt|;
comment|// Region assignment from META
name|List
argument_list|<
name|Result
argument_list|>
name|results
init|=
name|MetaReader
operator|.
name|fullScan
argument_list|(
name|this
operator|.
name|catalogTracker
argument_list|)
decl_stmt|;
comment|// Get any new but slow to checkin region server that joined the cluster
name|Set
argument_list|<
name|ServerName
argument_list|>
name|onlineServers
init|=
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|keySet
argument_list|()
decl_stmt|;
comment|// Map of offline servers and their regions to be returned
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|offlineServers
init|=
operator|new
name|TreeMap
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// Iterate regions in META
for|for
control|(
name|Result
name|result
range|:
name|results
control|)
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|region
init|=
name|HRegionInfo
operator|.
name|getHRegionInfoAndServerName
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
continue|continue;
name|HRegionInfo
name|regionInfo
init|=
name|region
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|ServerName
name|regionLocation
init|=
name|region
operator|.
name|getSecond
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionInfo
operator|==
literal|null
condition|)
continue|continue;
name|regionStates
operator|.
name|createRegionState
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionStates
operator|.
name|isRegionInState
argument_list|(
name|regionInfo
argument_list|,
name|State
operator|.
name|SPLIT
argument_list|)
condition|)
block|{
comment|// Split is considered to be completed. If the split znode still
comment|// exists, the region will be put back to SPLITTING state later
name|LOG
operator|.
name|debug
argument_list|(
literal|"Region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" split is completed. Hence need not add to regions list"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|TableName
name|tableName
init|=
name|regionInfo
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionLocation
operator|==
literal|null
condition|)
block|{
comment|// regionLocation could be null if createTable didn't finish properly.
comment|// When createTable is in progress, HMaster restarts.
comment|// Some regions have been added to hbase:meta, but have not been assigned.
comment|// When this happens, the region's table must be in ENABLING state.
comment|// It can't be in ENABLED state as that is set when all regions are
comment|// assigned.
comment|// It can't be in DISABLING state, because DISABLING state transitions
comment|// from ENABLED state when application calls disableTable.
comment|// It can't be in DISABLED state, because DISABLED states transitions
comment|// from DISABLING state.
if|if
condition|(
operator|!
name|enablingTables
operator|.
name|contains
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" has null regionLocation."
operator|+
literal|" But its table "
operator|+
name|tableName
operator|+
literal|" isn't in ENABLING state."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|onlineServers
operator|.
name|contains
argument_list|(
name|regionLocation
argument_list|)
condition|)
block|{
comment|// Region is located on a server that isn't online
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|offlineRegions
init|=
name|offlineServers
operator|.
name|get
argument_list|(
name|regionLocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|offlineRegions
operator|==
literal|null
condition|)
block|{
name|offlineRegions
operator|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|offlineServers
operator|.
name|put
argument_list|(
name|regionLocation
argument_list|,
name|offlineRegions
argument_list|)
expr_stmt|;
block|}
name|offlineRegions
operator|.
name|add
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
comment|// need to enable the table if not disabled or disabling or enabling
comment|// this will be used in rolling restarts
if|if
condition|(
operator|!
name|disabledOrDisablingOrEnabling
operator|.
name|contains
argument_list|(
name|tableName
argument_list|)
operator|&&
operator|!
name|getZKTable
argument_list|()
operator|.
name|isEnabledTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|setEnabledTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Region is being served and on an active server
comment|// add only if region not in disabled or enabling table
if|if
condition|(
operator|!
name|disabledOrEnablingTables
operator|.
name|contains
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|regionInfo
argument_list|,
name|State
operator|.
name|OPEN
argument_list|,
name|regionLocation
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|regionLocation
argument_list|)
expr_stmt|;
name|balancer
operator|.
name|regionOnline
argument_list|(
name|regionInfo
argument_list|,
name|regionLocation
argument_list|)
expr_stmt|;
block|}
comment|// need to enable the table if not disabled or disabling or enabling
comment|// this will be used in rolling restarts
if|if
condition|(
operator|!
name|disabledOrDisablingOrEnabling
operator|.
name|contains
argument_list|(
name|tableName
argument_list|)
operator|&&
operator|!
name|getZKTable
argument_list|()
operator|.
name|isEnabledTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|setEnabledTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|offlineServers
return|;
block|}
comment|/**    * Recover the tables that were not fully moved to DISABLED state. These    * tables are in DISABLING state when the master restarted/switched.    *    * @throws KeeperException    * @throws TableNotFoundException    * @throws IOException    */
specifier|private
name|void
name|recoverTableInDisablingState
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|TableNotFoundException
throws|,
name|IOException
block|{
name|Set
argument_list|<
name|TableName
argument_list|>
name|disablingTables
init|=
name|ZKTable
operator|.
name|getDisablingTables
argument_list|(
name|watcher
argument_list|)
decl_stmt|;
if|if
condition|(
name|disablingTables
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|TableName
name|tableName
range|:
name|disablingTables
control|)
block|{
comment|// Recover by calling DisableTableHandler
name|LOG
operator|.
name|info
argument_list|(
literal|"The table "
operator|+
name|tableName
operator|+
literal|" is in DISABLING state.  Hence recovering by moving the table"
operator|+
literal|" to DISABLED state."
argument_list|)
expr_stmt|;
operator|new
name|DisableTableHandler
argument_list|(
name|this
operator|.
name|server
argument_list|,
name|tableName
argument_list|,
name|catalogTracker
argument_list|,
name|this
argument_list|,
name|tableLockManager
argument_list|,
literal|true
argument_list|)
operator|.
name|prepare
argument_list|()
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Recover the tables that are not fully moved to ENABLED state. These tables    * are in ENABLING state when the master restarted/switched    *    * @throws KeeperException    * @throws org.apache.hadoop.hbase.TableNotFoundException    * @throws IOException    */
specifier|private
name|void
name|recoverTableInEnablingState
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|TableNotFoundException
throws|,
name|IOException
block|{
name|Set
argument_list|<
name|TableName
argument_list|>
name|enablingTables
init|=
name|ZKTable
operator|.
name|getEnablingTables
argument_list|(
name|watcher
argument_list|)
decl_stmt|;
if|if
condition|(
name|enablingTables
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|TableName
name|tableName
range|:
name|enablingTables
control|)
block|{
comment|// Recover by calling EnableTableHandler
name|LOG
operator|.
name|info
argument_list|(
literal|"The table "
operator|+
name|tableName
operator|+
literal|" is in ENABLING state.  Hence recovering by moving the table"
operator|+
literal|" to ENABLED state."
argument_list|)
expr_stmt|;
comment|// enableTable in sync way during master startup,
comment|// no need to invoke coprocessor
name|EnableTableHandler
name|eth
init|=
operator|new
name|EnableTableHandler
argument_list|(
name|this
operator|.
name|server
argument_list|,
name|tableName
argument_list|,
name|catalogTracker
argument_list|,
name|this
argument_list|,
name|tableLockManager
argument_list|,
literal|true
argument_list|)
decl_stmt|;
try|try
block|{
name|eth
operator|.
name|prepare
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TableNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Table "
operator|+
name|tableName
operator|+
literal|" not found in hbase:meta to recover."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|eth
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Processes list of dead servers from result of hbase:meta scan and regions in RIT    *<p>    * This is used for failover to recover the lost regions that belonged to    * RegionServers which failed while there was no active master or regions    * that were in RIT.    *<p>    *    *    * @param deadServers    *          The list of dead servers which failed while there was no active    *          master. Can be null.    * @throws IOException    * @throws KeeperException    */
specifier|private
name|void
name|processDeadServersAndRecoverLostRegions
parameter_list|(
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|deadServers
parameter_list|)
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
if|if
condition|(
name|deadServers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|server
range|:
name|deadServers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ServerName
name|serverName
init|=
name|server
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// We need to keep such info even if the server is known dead
name|regionStates
operator|.
name|setLastRegionServerOfRegions
argument_list|(
name|serverName
argument_list|,
name|server
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerDead
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|serverManager
operator|.
name|expireServer
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
comment|// Let SSH do region re-assign
block|}
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|nodes
init|=
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|this
operator|.
name|watcher
argument_list|,
name|this
operator|.
name|watcher
operator|.
name|assignmentZNode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|encodedRegionName
range|:
name|nodes
control|)
block|{
name|processRegionInTransition
argument_list|(
name|encodedRegionName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Now we can safely claim failover cleanup completed and enable
comment|// ServerShutdownHandler for further processing. The nodes (below)
comment|// in transition, if any, are for regions not related to those
comment|// dead servers at all, and can be done in parallel to SSH.
name|failoverCleanupDone
argument_list|()
expr_stmt|;
block|}
comment|/**    * Set Regions in transitions metrics.    * This takes an iterator on the RegionInTransition map (CLSM), and is not synchronized.    * This iterator is not fail fast, which may lead to stale read; but that's better than    * creating a copy of the map for metrics computation, as this method will be invoked    * on a frequent interval.    */
specifier|public
name|void
name|updateRegionsInTransitionMetrics
parameter_list|()
block|{
name|long
name|currentTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|totalRITs
init|=
literal|0
decl_stmt|;
name|int
name|totalRITsOverThreshold
init|=
literal|0
decl_stmt|;
name|long
name|oldestRITTime
init|=
literal|0
decl_stmt|;
name|int
name|ritThreshold
init|=
name|this
operator|.
name|server
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|METRICS_RIT_STUCK_WARNING_THRESHOLD
argument_list|,
literal|60000
argument_list|)
decl_stmt|;
for|for
control|(
name|RegionState
name|state
range|:
name|regionStates
operator|.
name|getRegionsInTransition
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|totalRITs
operator|++
expr_stmt|;
name|long
name|ritTime
init|=
name|currentTime
operator|-
name|state
operator|.
name|getStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|ritTime
operator|>
name|ritThreshold
condition|)
block|{
comment|// more than the threshold
name|totalRITsOverThreshold
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|oldestRITTime
operator|<
name|ritTime
condition|)
block|{
name|oldestRITTime
operator|=
name|ritTime
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|metricsAssignmentManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|metricsAssignmentManager
operator|.
name|updateRITOldestAge
argument_list|(
name|oldestRITTime
argument_list|)
expr_stmt|;
name|this
operator|.
name|metricsAssignmentManager
operator|.
name|updateRITCount
argument_list|(
name|totalRITs
argument_list|)
expr_stmt|;
name|this
operator|.
name|metricsAssignmentManager
operator|.
name|updateRITCountOverThreshold
argument_list|(
name|totalRITsOverThreshold
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @param region Region whose plan we are to clear.    */
name|void
name|clearRegionPlan
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|this
operator|.
name|regionPlans
operator|.
name|remove
argument_list|(
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Wait on region to clear regions-in-transition.    * @param hri Region to wait on.    * @throws IOException    */
specifier|public
name|void
name|waitOnRegionToClearRegionsInTransition
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|waitOnRegionToClearRegionsInTransition
argument_list|(
name|hri
argument_list|,
operator|-
literal|1L
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait on region to clear regions-in-transition or time out    * @param hri    * @param timeOut Milliseconds to wait for current region to be out of transition state.    * @return True when a region clears regions-in-transition before timeout otherwise false    * @throws InterruptedException    */
specifier|public
name|boolean
name|waitOnRegionToClearRegionsInTransition
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
name|long
name|timeOut
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
operator|!
name|regionStates
operator|.
name|isRegionInTransition
argument_list|(
name|hri
argument_list|)
condition|)
return|return
literal|true
return|;
name|long
name|end
init|=
operator|(
name|timeOut
operator|<=
literal|0
operator|)
condition|?
name|Long
operator|.
name|MAX_VALUE
else|:
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|timeOut
decl_stmt|;
comment|// There is already a timeout monitor on regions in transition so I
comment|// should not have to have one here too?
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for "
operator|+
name|hri
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" to leave regions-in-transition, timeOut="
operator|+
name|timeOut
operator|+
literal|" ms."
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|this
operator|.
name|server
operator|.
name|isStopped
argument_list|()
operator|&&
name|regionStates
operator|.
name|isRegionInTransition
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|regionStates
operator|.
name|waitForUpdate
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|>
name|end
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Timed out on waiting for "
operator|+
name|hri
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" to be assigned."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|server
operator|.
name|isStopped
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Giving up wait on regions in transition because stoppable.isStopped is set"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Update timers for all regions in transition going against the server in the    * serversInUpdatingTimer.    */
specifier|public
class|class
name|TimerUpdater
extends|extends
name|Chore
block|{
specifier|public
name|TimerUpdater
parameter_list|(
specifier|final
name|int
name|period
parameter_list|,
specifier|final
name|Stoppable
name|stopper
parameter_list|)
block|{
name|super
argument_list|(
literal|"AssignmentTimerUpdater"
argument_list|,
name|period
argument_list|,
name|stopper
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|tomActivated
argument_list|)
expr_stmt|;
name|ServerName
name|serverToUpdateTimer
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|!
name|serversInUpdatingTimer
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|stopper
operator|.
name|isStopped
argument_list|()
condition|)
block|{
if|if
condition|(
name|serverToUpdateTimer
operator|==
literal|null
condition|)
block|{
name|serverToUpdateTimer
operator|=
name|serversInUpdatingTimer
operator|.
name|first
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|serverToUpdateTimer
operator|=
name|serversInUpdatingTimer
operator|.
name|higher
argument_list|(
name|serverToUpdateTimer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serverToUpdateTimer
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|updateTimers
argument_list|(
name|serverToUpdateTimer
argument_list|)
expr_stmt|;
name|serversInUpdatingTimer
operator|.
name|remove
argument_list|(
name|serverToUpdateTimer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Monitor to check for time outs on region transition operations    */
specifier|public
class|class
name|TimeoutMonitor
extends|extends
name|Chore
block|{
specifier|private
name|boolean
name|allRegionServersOffline
init|=
literal|false
decl_stmt|;
specifier|private
name|ServerManager
name|serverManager
decl_stmt|;
specifier|private
specifier|final
name|int
name|timeout
decl_stmt|;
comment|/**      * Creates a periodic monitor to check for time outs on region transition      * operations.  This will deal with retries if for some reason something      * doesn't happen within the specified timeout.      * @param period    * @param stopper When {@link Stoppable#isStopped()} is true, this thread will    * cleanup and exit cleanly.      * @param timeout      */
specifier|public
name|TimeoutMonitor
parameter_list|(
specifier|final
name|int
name|period
parameter_list|,
specifier|final
name|Stoppable
name|stopper
parameter_list|,
name|ServerManager
name|serverManager
parameter_list|,
specifier|final
name|int
name|timeout
parameter_list|)
block|{
name|super
argument_list|(
literal|"AssignmentTimeoutMonitor"
argument_list|,
name|period
argument_list|,
name|stopper
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
name|serverManager
expr_stmt|;
block|}
specifier|private
specifier|synchronized
name|void
name|setAllRegionServersOffline
parameter_list|(
name|boolean
name|allRegionServersOffline
parameter_list|)
block|{
name|this
operator|.
name|allRegionServersOffline
operator|=
name|allRegionServersOffline
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|tomActivated
argument_list|)
expr_stmt|;
name|boolean
name|noRSAvailable
init|=
name|this
operator|.
name|serverManager
operator|.
name|createDestinationServersList
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
comment|// Iterate all regions in transition checking for time outs
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// no lock concurrent access ok: we will be working on a copy, and it's java-valid to do
comment|//  a copy while another thread is adding/removing items
for|for
control|(
name|String
name|regionName
range|:
name|regionStates
operator|.
name|getRegionsInTransition
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
name|RegionState
name|regionState
init|=
name|regionStates
operator|.
name|getRegionTransitionState
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionState
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|regionState
operator|.
name|getStamp
argument_list|()
operator|+
name|timeout
operator|<=
name|now
condition|)
block|{
comment|// decide on action upon timeout
name|actOnTimeOut
argument_list|(
name|regionState
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|allRegionServersOffline
operator|&&
operator|!
name|noRSAvailable
condition|)
block|{
name|RegionPlan
name|existingPlan
init|=
name|regionPlans
operator|.
name|get
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingPlan
operator|==
literal|null
operator|||
operator|!
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|existingPlan
operator|.
name|getDestination
argument_list|()
argument_list|)
condition|)
block|{
comment|// if some RSs just came back online, we can start the assignment
comment|// right away
name|actOnTimeOut
argument_list|(
name|regionState
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|setAllRegionServersOffline
argument_list|(
name|noRSAvailable
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|actOnTimeOut
parameter_list|(
name|RegionState
name|regionState
parameter_list|)
block|{
name|HRegionInfo
name|regionInfo
init|=
name|regionState
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Regions in transition timed out:  "
operator|+
name|regionState
argument_list|)
expr_stmt|;
comment|// Expired! Do a retry.
switch|switch
condition|(
name|regionState
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|CLOSED
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" has been CLOSED for too long, waiting on queued "
operator|+
literal|"ClosedRegionHandler to run or server shutdown"
argument_list|)
expr_stmt|;
comment|// Update our timestamp.
name|regionState
operator|.
name|updateTimestampToNow
argument_list|()
expr_stmt|;
break|break;
case|case
name|OFFLINE
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been OFFLINE for too long, "
operator|+
literal|"reassigning "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to a random server"
argument_list|)
expr_stmt|;
name|invokeAssign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|PENDING_OPEN
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been PENDING_OPEN for too "
operator|+
literal|"long, reassigning region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|invokeAssign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPENING
case|:
name|processOpeningState
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPEN
case|:
name|LOG
operator|.
name|error
argument_list|(
literal|"Region has been OPEN for too long, "
operator|+
literal|"we don't know where region was opened so can't do anything"
argument_list|)
expr_stmt|;
name|regionState
operator|.
name|updateTimestampToNow
argument_list|()
expr_stmt|;
break|break;
case|case
name|PENDING_CLOSE
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been PENDING_CLOSE for too "
operator|+
literal|"long, running forced unassign again on region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|invokeUnassign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOSING
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been CLOSING for too "
operator|+
literal|"long, this should eventually complete or the server will "
operator|+
literal|"expire, send RPC again"
argument_list|)
expr_stmt|;
name|invokeUnassign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPLIT
case|:
case|case
name|SPLITTING
case|:
case|case
name|FAILED_OPEN
case|:
case|case
name|FAILED_CLOSE
case|:
case|case
name|MERGING
case|:
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Received event is not valid."
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|processOpeningState
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been OPENING for too long, reassigning region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Should have a ZK node in OPENING state
try|try
block|{
name|String
name|node
init|=
name|ZKAssign
operator|.
name|getNodeName
argument_list|(
name|watcher
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getDataNoWatch
argument_list|(
name|watcher
argument_list|,
name|node
argument_list|,
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Data is null, node "
operator|+
name|node
operator|+
literal|" no longer exists"
argument_list|)
expr_stmt|;
return|return;
block|}
name|RegionTransition
name|rt
init|=
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|EventType
name|et
init|=
name|rt
operator|.
name|getEventType
argument_list|()
decl_stmt|;
if|if
condition|(
name|et
operator|==
name|EventType
operator|.
name|RS_ZK_REGION_OPENED
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Region has transitioned to OPENED, allowing "
operator|+
literal|"watched event handlers to process"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|et
operator|!=
name|EventType
operator|.
name|RS_ZK_REGION_OPENING
operator|&&
name|et
operator|!=
name|EventType
operator|.
name|RS_ZK_REGION_FAILED_OPEN
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"While timing out a region, found ZK node in unexpected state: "
operator|+
name|et
argument_list|)
expr_stmt|;
return|return;
block|}
name|invokeAssign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected ZK exception timing out CLOSING region"
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected exception parsing CLOSING region"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|invokeAssign
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|threadPoolExecutorService
operator|.
name|submit
argument_list|(
operator|new
name|AssignCallable
argument_list|(
name|this
argument_list|,
name|regionInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|invokeUnassign
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|threadPoolExecutorService
operator|.
name|submit
argument_list|(
operator|new
name|UnAssignCallable
argument_list|(
name|this
argument_list|,
name|regionInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isCarryingMeta
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
return|return
name|isCarryingRegion
argument_list|(
name|serverName
argument_list|,
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
return|;
block|}
comment|/**    * Check if the shutdown server carries the specific region.    * We have a bunch of places that store region location    * Those values aren't consistent. There is a delay of notification.    * The location from zookeeper unassigned node has the most recent data;    * but the node could be deleted after the region is opened by AM.    * The AM's info could be old when OpenedRegionHandler    * processing hasn't finished yet when server shutdown occurs.    * @return whether the serverName currently hosts the region    */
specifier|private
name|boolean
name|isCarryingRegion
parameter_list|(
name|ServerName
name|serverName
parameter_list|,
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|RegionTransition
name|rt
init|=
literal|null
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|watcher
argument_list|,
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
comment|// This call can legitimately come by null
name|rt
operator|=
name|data
operator|==
literal|null
condition|?
literal|null
else|:
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Exception reading unassigned node for region="
operator|+
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Exception parsing unassigned node for region="
operator|+
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|ServerName
name|addressFromZK
init|=
name|rt
operator|!=
literal|null
condition|?
name|rt
operator|.
name|getServerName
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|addressFromZK
operator|!=
literal|null
condition|)
block|{
comment|// if we get something from ZK, we will use the data
name|boolean
name|matchZK
init|=
name|addressFromZK
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking region="
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", zk server="
operator|+
name|addressFromZK
operator|+
literal|" current="
operator|+
name|serverName
operator|+
literal|", matches="
operator|+
name|matchZK
argument_list|)
expr_stmt|;
return|return
name|matchZK
return|;
block|}
name|ServerName
name|addressFromAM
init|=
name|regionStates
operator|.
name|getRegionServerOfRegion
argument_list|(
name|hri
argument_list|)
decl_stmt|;
name|boolean
name|matchAM
init|=
operator|(
name|addressFromAM
operator|!=
literal|null
operator|&&
name|addressFromAM
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
operator|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"based on AM, current region="
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" is on server="
operator|+
operator|(
name|addressFromAM
operator|!=
literal|null
condition|?
name|addressFromAM
else|:
literal|"null"
operator|)
operator|+
literal|" server being checked: "
operator|+
name|serverName
argument_list|)
expr_stmt|;
return|return
name|matchAM
return|;
block|}
comment|/**    * Process shutdown server removing any assignments.    * @param sn Server that went down.    * @return list of regions in transition on this server    */
specifier|public
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|processServerShutdown
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
comment|// Clean out any existing assignment plans for this server
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|>
name|i
init|=
name|this
operator|.
name|regionPlans
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|e
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|ServerName
name|otherSn
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getDestination
argument_list|()
decl_stmt|;
comment|// The name will be null if the region is planned for a random assign.
if|if
condition|(
name|otherSn
operator|!=
literal|null
operator|&&
name|otherSn
operator|.
name|equals
argument_list|(
name|sn
argument_list|)
condition|)
block|{
comment|// Use iterator's remove else we'll get CME
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
name|regionStates
operator|.
name|serverOffline
argument_list|(
name|watcher
argument_list|,
name|sn
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|HRegionInfo
argument_list|>
name|it
init|=
name|regions
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|HRegionInfo
name|hri
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|encodedName
init|=
name|hri
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
comment|// We need a lock on the region as we could update it
name|Lock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
try|try
block|{
name|RegionState
name|regionState
init|=
name|regionStates
operator|.
name|getRegionTransitionState
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
name|regionState
operator|.
name|getServerName
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|regionState
operator|.
name|isOnServer
argument_list|(
name|sn
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|regionState
operator|.
name|isFailedClose
argument_list|()
operator|||
name|regionState
operator|.
name|isOffline
argument_list|()
operator|||
name|regionState
operator|.
name|isPendingOpenOrOpening
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip "
operator|+
name|regionState
operator|+
literal|" since it is not opening/failed_close"
operator|+
literal|" on the dead server any more: "
operator|+
name|sn
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
comment|// Delete the ZNode if exists
name|ZKAssign
operator|.
name|deleteNodeFailSilent
argument_list|(
name|watcher
argument_list|,
name|hri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception deleting node "
operator|+
name|hri
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zkTable
operator|.
name|isDisablingOrDisabledTable
argument_list|(
name|hri
operator|.
name|getTable
argument_list|()
argument_list|)
condition|)
block|{
name|regionStates
operator|.
name|regionOffline
argument_list|(
name|hri
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// Mark the region offline and assign it again by SSH
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|hri
argument_list|,
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|regions
return|;
block|}
comment|/**    * @param plan Plan to execute.    */
specifier|public
name|void
name|balance
parameter_list|(
specifier|final
name|RegionPlan
name|plan
parameter_list|)
block|{
name|HRegionInfo
name|hri
init|=
name|plan
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|TableName
name|tableName
init|=
name|hri
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|zkTable
operator|.
name|isDisablingOrDisabledTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignored moving region of disabling/disabled table "
operator|+
name|tableName
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Move the region only if it's assigned
name|String
name|encodedName
init|=
name|hri
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|ReentrantLock
name|lock
init|=
name|locker
operator|.
name|acquireLock
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|regionStates
operator|.
name|isRegionOnline
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|RegionState
name|state
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignored moving region not assigned: "
operator|+
name|hri
operator|+
literal|", "
operator|+
operator|(
name|state
operator|==
literal|null
condition|?
literal|"not in region states"
else|:
name|state
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|this
operator|.
name|regionPlans
operator|.
name|put
argument_list|(
name|plan
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|plan
argument_list|)
expr_stmt|;
block|}
name|unassign
argument_list|(
name|hri
argument_list|,
literal|false
argument_list|,
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|shutdown
argument_list|()
expr_stmt|;
comment|// Stop executor service, etc
if|if
condition|(
name|tomActivated
condition|)
block|{
name|this
operator|.
name|timeoutMonitor
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|this
operator|.
name|timerUpdater
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Shutdown the threadpool executor service    */
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
comment|// It's an immediate shutdown, so we're clearing the remaining tasks.
synchronized|synchronized
init|(
name|zkEventWorkerWaitingList
init|)
block|{
name|zkEventWorkerWaitingList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|threadPoolExecutorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|zkEventWorkers
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|void
name|setEnabledTable
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|zkTable
operator|.
name|setEnabledTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
comment|// here we can abort as it is the start up flow
name|String
name|errorMsg
init|=
literal|"Unable to ensure that the table "
operator|+
name|tableName
operator|+
literal|" will be"
operator|+
literal|" enabled because of a ZooKeeper issue"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
name|this
operator|.
name|server
operator|.
name|abort
argument_list|(
name|errorMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set region as OFFLINED up in zookeeper asynchronously.    * @param state    * @return True if we succeeded, false otherwise (State was incorrect or failed    * updating zk).    */
specifier|private
name|boolean
name|asyncSetOfflineInZooKeeper
parameter_list|(
specifier|final
name|RegionState
name|state
parameter_list|,
specifier|final
name|AsyncCallback
operator|.
name|StringCallback
name|cb
parameter_list|,
specifier|final
name|ServerName
name|destination
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
operator|.
name|isClosed
argument_list|()
operator|&&
operator|!
name|state
operator|.
name|isOffline
argument_list|()
condition|)
block|{
name|this
operator|.
name|server
operator|.
name|abort
argument_list|(
literal|"Unexpected state trying to OFFLINE; "
operator|+
name|state
argument_list|,
operator|new
name|IllegalStateException
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
try|try
block|{
name|ZKAssign
operator|.
name|asyncCreateNodeOffline
argument_list|(
name|watcher
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
name|destination
argument_list|,
name|cb
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|NodeExistsException
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Node for "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|+
literal|" already exists"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception creating/setting node OFFLINE"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|deleteNodeInStates
parameter_list|(
name|String
name|encodedName
parameter_list|,
name|String
name|desc
parameter_list|,
name|ServerName
name|sn
parameter_list|,
name|EventType
modifier|...
name|types
parameter_list|)
block|{
try|try
block|{
for|for
control|(
name|EventType
name|et
range|:
name|types
control|)
block|{
if|if
condition|(
name|ZKAssign
operator|.
name|deleteNode
argument_list|(
name|watcher
argument_list|,
name|encodedName
argument_list|,
name|et
argument_list|,
name|sn
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to delete the "
operator|+
name|desc
operator|+
literal|" node for "
operator|+
name|encodedName
operator|+
literal|". The node type may not match"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoNodeException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The "
operator|+
name|desc
operator|+
literal|" node for "
operator|+
name|encodedName
operator|+
literal|" already deleted"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception deleting "
operator|+
name|desc
operator|+
literal|" node for the region "
operator|+
name|encodedName
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|deleteMergingNode
parameter_list|(
name|String
name|encodedName
parameter_list|,
name|ServerName
name|sn
parameter_list|)
block|{
name|deleteNodeInStates
argument_list|(
name|encodedName
argument_list|,
literal|"merging"
argument_list|,
name|sn
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_MERGING
argument_list|,
name|EventType
operator|.
name|RS_ZK_REQUEST_REGION_MERGE
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_MERGED
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|deleteSplittingNode
parameter_list|(
name|String
name|encodedName
parameter_list|,
name|ServerName
name|sn
parameter_list|)
block|{
name|deleteNodeInStates
argument_list|(
name|encodedName
argument_list|,
literal|"splitting"
argument_list|,
name|sn
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_SPLITTING
argument_list|,
name|EventType
operator|.
name|RS_ZK_REQUEST_REGION_SPLIT
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_SPLIT
argument_list|)
expr_stmt|;
block|}
comment|/**    * A helper to handle region merging transition event.    * It transitions merging regions to MERGING state.    */
specifier|private
name|boolean
name|handleRegionMerging
parameter_list|(
specifier|final
name|RegionTransition
name|rt
parameter_list|,
specifier|final
name|String
name|encodedName
parameter_list|,
specifier|final
name|String
name|prettyPrintedRegionName
parameter_list|,
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Dropped merging! ServerName="
operator|+
name|sn
operator|+
literal|" unknown."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|byte
index|[]
name|payloadOfMerging
init|=
name|rt
operator|.
name|getPayload
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|mergingRegions
decl_stmt|;
try|try
block|{
name|mergingRegions
operator|=
name|HRegionInfo
operator|.
name|parseDelimitedFrom
argument_list|(
name|payloadOfMerging
argument_list|,
literal|0
argument_list|,
name|payloadOfMerging
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Dropped merging! Failed reading "
operator|+
name|rt
operator|.
name|getEventType
argument_list|()
operator|+
literal|" payload for "
operator|+
name|prettyPrintedRegionName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
assert|assert
name|mergingRegions
operator|.
name|size
argument_list|()
operator|==
literal|3
assert|;
name|HRegionInfo
name|p
init|=
name|mergingRegions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|HRegionInfo
name|hri_a
init|=
name|mergingRegions
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|HRegionInfo
name|hri_b
init|=
name|mergingRegions
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|RegionState
name|rs_p
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|RegionState
name|rs_a
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|hri_a
argument_list|)
decl_stmt|;
name|RegionState
name|rs_b
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|hri_b
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|rs_a
operator|==
literal|null
operator|||
name|rs_a
operator|.
name|isOpenOrMergingOnServer
argument_list|(
name|sn
argument_list|)
operator|)
operator|&&
operator|(
name|rs_b
operator|==
literal|null
operator|||
name|rs_b
operator|.
name|isOpenOrMergingOnServer
argument_list|(
name|sn
argument_list|)
operator|)
operator|&&
operator|(
name|rs_p
operator|==
literal|null
operator|||
name|rs_p
operator|.
name|isOpenOrMergingNewOnServer
argument_list|(
name|sn
argument_list|)
operator|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Dropped merging! Not in state good for MERGING; rs_p="
operator|+
name|rs_p
operator|+
literal|", rs_a="
operator|+
name|rs_a
operator|+
literal|", rs_b="
operator|+
name|rs_b
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|EventType
name|et
init|=
name|rt
operator|.
name|getEventType
argument_list|()
decl_stmt|;
if|if
condition|(
name|et
operator|==
name|EventType
operator|.
name|RS_ZK_REQUEST_REGION_MERGE
condition|)
block|{
try|try
block|{
if|if
condition|(
name|RegionMergeTransaction
operator|.
name|transitionMergingNode
argument_list|(
name|watcher
argument_list|,
name|p
argument_list|,
name|hri_a
argument_list|,
name|hri_b
argument_list|,
name|sn
argument_list|,
operator|-
literal|1
argument_list|,
name|EventType
operator|.
name|RS_ZK_REQUEST_REGION_MERGE
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_MERGING
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|watcher
argument_list|,
name|encodedName
argument_list|)
decl_stmt|;
name|EventType
name|currentType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|RegionTransition
name|newRt
init|=
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|currentType
operator|=
name|newRt
operator|.
name|getEventType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|currentType
operator|==
literal|null
operator|||
operator|(
name|currentType
operator|!=
name|EventType
operator|.
name|RS_ZK_REGION_MERGED
operator|&&
name|currentType
operator|!=
name|EventType
operator|.
name|RS_ZK_REGION_MERGING
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to transition pending_merge node "
operator|+
name|encodedName
operator|+
literal|" to merging, it's now "
operator|+
name|currentType
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to transition pending_merge node "
operator|+
name|encodedName
operator|+
literal|" to merging"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
synchronized|synchronized
init|(
name|regionStates
init|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|hri_a
argument_list|,
name|State
operator|.
name|MERGING
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|hri_b
argument_list|,
name|State
operator|.
name|MERGING
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|p
argument_list|,
name|State
operator|.
name|MERGING_NEW
argument_list|,
name|sn
argument_list|)
expr_stmt|;
if|if
condition|(
name|et
operator|!=
name|EventType
operator|.
name|RS_ZK_REGION_MERGED
condition|)
block|{
name|regionStates
operator|.
name|regionOffline
argument_list|(
name|p
argument_list|,
name|State
operator|.
name|MERGING_NEW
argument_list|)
expr_stmt|;
name|this
operator|.
name|mergingRegions
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
operator|new
name|PairOfSameType
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|hri_a
argument_list|,
name|hri_b
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|mergingRegions
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
name|regionOffline
argument_list|(
name|hri_a
argument_list|,
name|State
operator|.
name|MERGED
argument_list|)
expr_stmt|;
name|regionOffline
argument_list|(
name|hri_b
argument_list|,
name|State
operator|.
name|MERGED
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|p
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|et
operator|==
name|EventType
operator|.
name|RS_ZK_REGION_MERGED
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling MERGED event for "
operator|+
name|encodedName
operator|+
literal|"; deleting node"
argument_list|)
expr_stmt|;
comment|// Remove region from ZK
try|try
block|{
name|boolean
name|successful
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|successful
condition|)
block|{
comment|// It's possible that the RS tickles in between the reading of the
comment|// znode and the deleting, so it's safe to retry.
name|successful
operator|=
name|ZKAssign
operator|.
name|deleteNode
argument_list|(
name|watcher
argument_list|,
name|encodedName
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_MERGED
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|NoNodeException
condition|)
block|{
name|String
name|znodePath
init|=
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|watcher
operator|.
name|splitLogZNode
argument_list|,
name|encodedName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"The znode "
operator|+
name|znodePath
operator|+
literal|" does not exist.  May be deleted already."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Error deleting MERGED node "
operator|+
name|encodedName
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Handled MERGED event; merged="
operator|+
name|p
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", region_a="
operator|+
name|hri_a
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", region_b="
operator|+
name|hri_b
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", on "
operator|+
name|sn
argument_list|)
expr_stmt|;
comment|// User could disable the table before master knows the new region.
if|if
condition|(
name|zkTable
operator|.
name|isDisablingOrDisabledTable
argument_list|(
name|p
operator|.
name|getTable
argument_list|()
argument_list|)
condition|)
block|{
name|unassign
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * A helper to handle region splitting transition event.    */
specifier|private
name|boolean
name|handleRegionSplitting
parameter_list|(
specifier|final
name|RegionTransition
name|rt
parameter_list|,
specifier|final
name|String
name|encodedName
parameter_list|,
specifier|final
name|String
name|prettyPrintedRegionName
parameter_list|,
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Dropped splitting! ServerName="
operator|+
name|sn
operator|+
literal|" unknown."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|byte
index|[]
name|payloadOfSplitting
init|=
name|rt
operator|.
name|getPayload
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|splittingRegions
decl_stmt|;
try|try
block|{
name|splittingRegions
operator|=
name|HRegionInfo
operator|.
name|parseDelimitedFrom
argument_list|(
name|payloadOfSplitting
argument_list|,
literal|0
argument_list|,
name|payloadOfSplitting
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Dropped splitting! Failed reading "
operator|+
name|rt
operator|.
name|getEventType
argument_list|()
operator|+
literal|" payload for "
operator|+
name|prettyPrintedRegionName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
assert|assert
name|splittingRegions
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
name|HRegionInfo
name|hri_a
init|=
name|splittingRegions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|HRegionInfo
name|hri_b
init|=
name|splittingRegions
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|RegionState
name|rs_p
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|RegionState
name|rs_a
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|hri_a
argument_list|)
decl_stmt|;
name|RegionState
name|rs_b
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|hri_b
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|rs_p
operator|==
literal|null
operator|||
name|rs_p
operator|.
name|isOpenOrSplittingOnServer
argument_list|(
name|sn
argument_list|)
operator|)
operator|&&
operator|(
name|rs_a
operator|==
literal|null
operator|||
name|rs_a
operator|.
name|isOpenOrSplittingNewOnServer
argument_list|(
name|sn
argument_list|)
operator|)
operator|&&
operator|(
name|rs_b
operator|==
literal|null
operator|||
name|rs_b
operator|.
name|isOpenOrSplittingNewOnServer
argument_list|(
name|sn
argument_list|)
operator|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Dropped splitting! Not in state good for SPLITTING; rs_p="
operator|+
name|rs_p
operator|+
literal|", rs_a="
operator|+
name|rs_a
operator|+
literal|", rs_b="
operator|+
name|rs_b
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|rs_p
operator|==
literal|null
condition|)
block|{
comment|// Splitting region should be online
name|rs_p
operator|=
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|rt
argument_list|,
name|State
operator|.
name|OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_p
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received splitting for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|sn
operator|+
literal|" but it doesn't exist anymore,"
operator|+
literal|" probably already processed its split"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|regionStates
operator|.
name|regionOnline
argument_list|(
name|rs_p
operator|.
name|getRegion
argument_list|()
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
name|HRegionInfo
name|p
init|=
name|rs_p
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|EventType
name|et
init|=
name|rt
operator|.
name|getEventType
argument_list|()
decl_stmt|;
if|if
condition|(
name|et
operator|==
name|EventType
operator|.
name|RS_ZK_REQUEST_REGION_SPLIT
condition|)
block|{
try|try
block|{
if|if
condition|(
name|SplitTransaction
operator|.
name|transitionSplittingNode
argument_list|(
name|watcher
argument_list|,
name|p
argument_list|,
name|hri_a
argument_list|,
name|hri_b
argument_list|,
name|sn
argument_list|,
operator|-
literal|1
argument_list|,
name|EventType
operator|.
name|RS_ZK_REQUEST_REGION_SPLIT
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_SPLITTING
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|watcher
argument_list|,
name|encodedName
argument_list|)
decl_stmt|;
name|EventType
name|currentType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|RegionTransition
name|newRt
init|=
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|currentType
operator|=
name|newRt
operator|.
name|getEventType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|currentType
operator|==
literal|null
operator|||
operator|(
name|currentType
operator|!=
name|EventType
operator|.
name|RS_ZK_REGION_SPLIT
operator|&&
name|currentType
operator|!=
name|EventType
operator|.
name|RS_ZK_REGION_SPLITTING
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to transition pending_split node "
operator|+
name|encodedName
operator|+
literal|" to splitting, it's now "
operator|+
name|currentType
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to transition pending_split node "
operator|+
name|encodedName
operator|+
literal|" to splitting"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
synchronized|synchronized
init|(
name|regionStates
init|)
block|{
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|hri_a
argument_list|,
name|State
operator|.
name|SPLITTING_NEW
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|hri_b
argument_list|,
name|State
operator|.
name|SPLITTING_NEW
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|regionOffline
argument_list|(
name|hri_a
argument_list|,
name|State
operator|.
name|SPLITTING_NEW
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|regionOffline
argument_list|(
name|hri_b
argument_list|,
name|State
operator|.
name|SPLITTING_NEW
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|updateRegionState
argument_list|(
name|rt
argument_list|,
name|State
operator|.
name|SPLITTING
argument_list|)
expr_stmt|;
comment|// The below is for testing ONLY!  We can't do fault injection easily, so
comment|// resort to this kinda uglyness -- St.Ack 02/25/2011.
if|if
condition|(
name|TEST_SKIP_SPLIT_HANDLING
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Skipping split message, TEST_SKIP_SPLIT_HANDLING is set"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// return true so that the splitting node stays
block|}
if|if
condition|(
name|et
operator|==
name|EventType
operator|.
name|RS_ZK_REGION_SPLIT
condition|)
block|{
name|regionOffline
argument_list|(
name|p
argument_list|,
name|State
operator|.
name|SPLIT
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|hri_a
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|hri_b
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|et
operator|==
name|EventType
operator|.
name|RS_ZK_REGION_SPLIT
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling SPLIT event for "
operator|+
name|encodedName
operator|+
literal|"; deleting node"
argument_list|)
expr_stmt|;
comment|// Remove region from ZK
try|try
block|{
name|boolean
name|successful
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|successful
condition|)
block|{
comment|// It's possible that the RS tickles in between the reading of the
comment|// znode and the deleting, so it's safe to retry.
name|successful
operator|=
name|ZKAssign
operator|.
name|deleteNode
argument_list|(
name|watcher
argument_list|,
name|encodedName
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_SPLIT
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|NoNodeException
condition|)
block|{
name|String
name|znodePath
init|=
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|watcher
operator|.
name|splitLogZNode
argument_list|,
name|encodedName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"The znode "
operator|+
name|znodePath
operator|+
literal|" does not exist.  May be deleted already."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|server
operator|.
name|abort
argument_list|(
literal|"Error deleting SPLIT node "
operator|+
name|encodedName
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Handled SPLIT event; parent="
operator|+
name|p
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", daughter a="
operator|+
name|hri_a
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", daughter b="
operator|+
name|hri_b
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", on "
operator|+
name|sn
argument_list|)
expr_stmt|;
comment|// User could disable the table before master knows the new region.
if|if
condition|(
name|zkTable
operator|.
name|isDisablingOrDisabledTable
argument_list|(
name|p
operator|.
name|getTable
argument_list|()
argument_list|)
condition|)
block|{
name|unassign
argument_list|(
name|hri_a
argument_list|)
expr_stmt|;
name|unassign
argument_list|(
name|hri_b
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * A region is offline.  The new state should be the specified one,    * if not null.  If the specified state is null, the new state is Offline.    * The specified state can be Split/Merged/Offline/null only.    */
specifier|private
name|void
name|regionOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|State
name|state
parameter_list|)
block|{
name|regionStates
operator|.
name|regionOffline
argument_list|(
name|regionInfo
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|removeClosedRegion
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
comment|// remove the region plan as well just in case.
name|clearRegionPlan
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
name|balancer
operator|.
name|regionOffline
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return Instance of load balancer    */
specifier|public
name|LoadBalancer
name|getBalancer
parameter_list|()
block|{
return|return
name|this
operator|.
name|balancer
return|;
block|}
block|}
end_class

end_unit

