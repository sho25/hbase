begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|compactions
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterators
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|PeekingIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseInterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreConfigInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_comment
comment|/**  * HBASE-15181 This is a simple implementation of date-based tiered compaction similar to  * Cassandra's for the following benefits:  * 1. Improve date-range-based scan by structuring store files in date-based tiered layout.  * 2. Reduce compaction overhead.  * 3. Improve TTL efficiency.  * Perfect fit for the use cases that:  * 1. has mostly date-based data write and scan and a focus on the most recent data.  * 2. never or rarely deletes data. Out-of-order writes are handled gracefully. Time range  * overlapping among store files is tolerated and the performance impact is minimized. Configuration  * can be set at hbase-site or overriden at per-table or per-column-famly level by hbase shell.  * Design spec is at  * https://docs.google.com/document/d/1_AmlNb2N8Us1xICsTeGDLKIqL6T-oHoRLZ323MG_uy8/  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|CONFIG
argument_list|)
specifier|public
class|class
name|DateTieredCompactionPolicy
extends|extends
name|RatioBasedCompactionPolicy
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DateTieredCompactionPolicy
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|RatioBasedCompactionPolicy
name|compactionPolicyPerWindow
decl_stmt|;
specifier|public
name|DateTieredCompactionPolicy
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|StoreConfigInformation
name|storeConfigInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|storeConfigInfo
argument_list|)
expr_stmt|;
try|try
block|{
name|compactionPolicyPerWindow
operator|=
name|ReflectionUtils
operator|.
name|instantiateWithCustomCtor
argument_list|(
name|comConf
operator|.
name|getCompactionPolicyForTieredWindow
argument_list|()
argument_list|,
operator|new
name|Class
index|[]
block|{
name|Configuration
operator|.
name|class
block|,
name|StoreConfigInformation
operator|.
name|class
block|}
argument_list|,
operator|new
name|Object
index|[]
block|{
name|conf
block|,
name|storeConfigInfo
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to load configured compaction policy '"
operator|+
name|comConf
operator|.
name|getCompactionPolicyForTieredWindow
argument_list|()
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isMajorCompaction
parameter_list|(
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|filesToCompact
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Never do major compaction unless forced
return|return
literal|false
return|;
block|}
annotation|@
name|Override
comment|/**    * Heuristics for guessing whether we need compaction.    */
specifier|public
name|boolean
name|needsCompaction
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|storeFiles
parameter_list|,
specifier|final
name|List
argument_list|<
name|StoreFile
argument_list|>
name|filesCompacting
parameter_list|)
block|{
return|return
name|needsCompaction
argument_list|(
name|storeFiles
argument_list|,
name|filesCompacting
argument_list|,
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|boolean
name|needsCompaction
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|storeFiles
parameter_list|,
specifier|final
name|List
argument_list|<
name|StoreFile
argument_list|>
name|filesCompacting
parameter_list|,
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
operator|!
name|super
operator|.
name|needsCompaction
argument_list|(
name|storeFiles
argument_list|,
name|filesCompacting
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|candidates
init|=
operator|new
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
argument_list|(
name|storeFiles
argument_list|)
decl_stmt|;
name|candidates
operator|=
name|filterBulk
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|skipLargeFiles
argument_list|(
name|candidates
argument_list|,
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|candidates
operator|=
name|applyCompactionPolicy
argument_list|(
name|candidates
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Can not check for compaction: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|candidates
operator|!=
literal|null
operator|&&
name|candidates
operator|.
name|size
argument_list|()
operator|>=
name|comConf
operator|.
name|getMinFilesToCompact
argument_list|()
return|;
block|}
comment|/**    * Could return null if no candidates are found    */
annotation|@
name|Override
specifier|public
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|applyCompactionPolicy
parameter_list|(
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|candidates
parameter_list|,
name|boolean
name|mayUseOffPeak
parameter_list|,
name|boolean
name|mayBeStuck
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|applyCompactionPolicy
argument_list|(
name|candidates
argument_list|,
name|mayUseOffPeak
argument_list|,
name|mayBeStuck
argument_list|,
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Input candidates are sorted from oldest to newest by seqId. Could return null if no candidates    * are found.    */
annotation|@
name|VisibleForTesting
specifier|public
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|applyCompactionPolicy
parameter_list|(
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|candidates
parameter_list|,
name|boolean
name|mayUseOffPeak
parameter_list|,
name|boolean
name|mayBeStuck
parameter_list|,
name|long
name|now
parameter_list|)
throws|throws
name|IOException
block|{
name|Iterable
argument_list|<
name|StoreFile
argument_list|>
name|candidatesInWindow
init|=
name|filterOldStoreFiles
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|candidates
argument_list|)
argument_list|,
name|comConf
operator|.
name|getMaxStoreFileAgeMillis
argument_list|()
argument_list|,
name|now
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
argument_list|>
name|buckets
init|=
name|partitionFilesToBuckets
argument_list|(
name|candidatesInWindow
argument_list|,
name|comConf
operator|.
name|getBaseWindowMillis
argument_list|()
argument_list|,
name|comConf
operator|.
name|getWindowsPerTier
argument_list|()
argument_list|,
name|now
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Compaction buckets are: "
operator|+
name|buckets
argument_list|)
expr_stmt|;
return|return
name|newestBucket
argument_list|(
name|buckets
argument_list|,
name|comConf
operator|.
name|getIncomingWindowMin
argument_list|()
argument_list|,
name|now
argument_list|,
name|comConf
operator|.
name|getBaseWindowMillis
argument_list|()
argument_list|,
name|mayUseOffPeak
argument_list|)
return|;
block|}
comment|/**    * @param buckets the list of buckets, sorted from newest to oldest, from which to return the    *          newest bucket within thresholds.    * @param incomingWindowThreshold minimum number of storeFiles in a bucket to qualify.    * @param maxThreshold maximum number of storeFiles to compact at once (the returned bucket will    *          be trimmed down to this).    * @return a bucket (a list of store files within a window to be compacted).    * @throws IOException error    */
specifier|private
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|newestBucket
parameter_list|(
name|List
argument_list|<
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
argument_list|>
name|buckets
parameter_list|,
name|int
name|incomingWindowThreshold
parameter_list|,
name|long
name|now
parameter_list|,
name|long
name|baseWindowMillis
parameter_list|,
name|boolean
name|mayUseOffPeak
parameter_list|)
throws|throws
name|IOException
block|{
name|Window
name|incomingWindow
init|=
name|getInitialWindow
argument_list|(
name|now
argument_list|,
name|baseWindowMillis
argument_list|)
decl_stmt|;
for|for
control|(
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|bucket
range|:
name|buckets
control|)
block|{
name|int
name|minThreshold
init|=
name|incomingWindow
operator|.
name|compareToTimestamp
argument_list|(
name|bucket
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getMaximumTimestamp
argument_list|()
argument_list|)
operator|<=
literal|0
condition|?
name|comConf
operator|.
name|getIncomingWindowMin
argument_list|()
else|:
name|comConf
operator|.
name|getMinFilesToCompact
argument_list|()
decl_stmt|;
name|compactionPolicyPerWindow
operator|.
name|setMinThreshold
argument_list|(
name|minThreshold
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|candidates
init|=
name|compactionPolicyPerWindow
operator|.
name|applyCompactionPolicy
argument_list|(
name|bucket
argument_list|,
name|mayUseOffPeak
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|candidates
operator|!=
literal|null
operator|&&
operator|!
name|candidates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|candidates
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * We receive store files sorted in ascending order by seqId then scan the list of files. If the    * current file has a maxTimestamp older than last known maximum, treat this file as it carries    * the last known maximum. This way both seqId and timestamp are in the same order. If files carry    * the same maxTimestamps, they are ordered by seqId. We then reverse the list so they are ordered    * by seqId and maxTimestamp in decending order and build the time windows. All the out-of-order    * data into the same compaction windows, guaranteeing contiguous compaction based on sequence id.    */
specifier|private
specifier|static
name|List
argument_list|<
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
argument_list|>
name|partitionFilesToBuckets
parameter_list|(
name|Iterable
argument_list|<
name|StoreFile
argument_list|>
name|storeFiles
parameter_list|,
name|long
name|baseWindowSizeMillis
parameter_list|,
name|int
name|windowsPerTier
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|List
argument_list|<
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
argument_list|>
name|buckets
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|Window
name|window
init|=
name|getInitialWindow
argument_list|(
name|now
argument_list|,
name|baseWindowSizeMillis
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|StoreFile
argument_list|,
name|Long
argument_list|>
argument_list|>
name|storefileMaxTimestampPairs
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|Iterables
operator|.
name|size
argument_list|(
name|storeFiles
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|maxTimestampSeen
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
for|for
control|(
name|StoreFile
name|storeFile
range|:
name|storeFiles
control|)
block|{
comment|// if there is out-of-order data,
comment|// we put them in the same window as the last file in increasing order
name|maxTimestampSeen
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxTimestampSeen
argument_list|,
name|storeFile
operator|.
name|getMaximumTimestamp
argument_list|()
argument_list|)
expr_stmt|;
name|storefileMaxTimestampPairs
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<
name|StoreFile
argument_list|,
name|Long
argument_list|>
argument_list|(
name|storeFile
argument_list|,
name|maxTimestampSeen
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|reverse
argument_list|(
name|storefileMaxTimestampPairs
argument_list|)
expr_stmt|;
name|PeekingIterator
argument_list|<
name|Pair
argument_list|<
name|StoreFile
argument_list|,
name|Long
argument_list|>
argument_list|>
name|it
init|=
name|Iterators
operator|.
name|peekingIterator
argument_list|(
name|storefileMaxTimestampPairs
operator|.
name|iterator
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|compResult
init|=
name|window
operator|.
name|compareToTimestamp
argument_list|(
name|it
operator|.
name|peek
argument_list|()
operator|.
name|getSecond
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|compResult
operator|>
literal|0
condition|)
block|{
comment|// If the file is too old for the window, switch to the next window
name|window
operator|=
name|window
operator|.
name|nextWindow
argument_list|(
name|windowsPerTier
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The file is within the target window
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|bucket
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// Add all files in the same window to current bucket. For incoming window
comment|// we tolerate files with future data although it is sub-optimal
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
operator|&&
name|window
operator|.
name|compareToTimestamp
argument_list|(
name|it
operator|.
name|peek
argument_list|()
operator|.
name|getSecond
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|bucket
operator|.
name|add
argument_list|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bucket
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|buckets
operator|.
name|add
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|buckets
return|;
block|}
comment|/**    * Removes all store files with max timestamp older than (current - maxAge).    * @param storeFiles all store files to consider    * @param maxAge the age in milliseconds when a store file stops participating in compaction.    * @param now current time. store files with max timestamp less than (now - maxAge) are filtered.    * @return a list of storeFiles with the store file older than maxAge excluded    */
specifier|private
specifier|static
name|Iterable
argument_list|<
name|StoreFile
argument_list|>
name|filterOldStoreFiles
parameter_list|(
name|List
argument_list|<
name|StoreFile
argument_list|>
name|storeFiles
parameter_list|,
name|long
name|maxAge
parameter_list|,
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|maxAge
operator|==
literal|0
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
specifier|final
name|long
name|cutoff
init|=
name|now
operator|-
name|maxAge
decl_stmt|;
return|return
name|Iterables
operator|.
name|filter
argument_list|(
name|storeFiles
argument_list|,
operator|new
name|Predicate
argument_list|<
name|StoreFile
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|StoreFile
name|storeFile
parameter_list|)
block|{
comment|// Known findbugs issue to guava. SuppressWarning or Nonnull annotation don't work.
if|if
condition|(
name|storeFile
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
return|return
name|storeFile
operator|.
name|getMaximumTimestamp
argument_list|()
operator|>=
name|cutoff
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Window
name|getInitialWindow
parameter_list|(
name|long
name|now
parameter_list|,
name|long
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|Window
argument_list|(
name|timeUnit
argument_list|,
name|now
operator|/
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    * This is the class we use to partition from epoch time to now into tiers of exponential sizes of    * windows.    */
specifier|private
specifier|static
specifier|final
class|class
name|Window
block|{
comment|/**      * How big a range of timestamps fit inside the window in milliseconds.      */
specifier|private
specifier|final
name|long
name|windowMillis
decl_stmt|;
comment|/**      * A timestamp t is within the window iff t / size == divPosition.      */
specifier|private
specifier|final
name|long
name|divPosition
decl_stmt|;
specifier|private
name|Window
parameter_list|(
name|long
name|baseWindowMillis
parameter_list|,
name|long
name|divPosition
parameter_list|)
block|{
name|this
operator|.
name|windowMillis
operator|=
name|baseWindowMillis
expr_stmt|;
name|this
operator|.
name|divPosition
operator|=
name|divPosition
expr_stmt|;
block|}
comment|/**      * Compares the window to a timestamp.      * @param timestamp the timestamp to compare.      * @return a negative integer, zero, or a positive integer as the window lies before, covering,      *         or after than the timestamp.      */
specifier|public
name|int
name|compareToTimestamp
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
name|long
name|pos
init|=
name|timestamp
operator|/
name|windowMillis
decl_stmt|;
return|return
name|divPosition
operator|==
name|pos
condition|?
literal|0
else|:
name|divPosition
operator|<
name|pos
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|/**      * Move to the new window of the same tier or of the next tier, which represents an earlier time      * span.      * @param windowsPerTier The number of contiguous windows that will have the same size. Windows      *          following those will be<code>tierBase</code> times as big.      * @return The next window      */
specifier|public
name|Window
name|nextWindow
parameter_list|(
name|int
name|windowsPerTier
parameter_list|)
block|{
if|if
condition|(
name|divPosition
operator|%
name|windowsPerTier
operator|>
literal|0
condition|)
block|{
return|return
operator|new
name|Window
argument_list|(
name|windowMillis
argument_list|,
name|divPosition
operator|-
literal|1
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|Window
argument_list|(
name|windowMillis
operator|*
name|windowsPerTier
argument_list|,
name|divPosition
operator|/
name|windowsPerTier
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
block|}
block|}
end_class

end_unit

