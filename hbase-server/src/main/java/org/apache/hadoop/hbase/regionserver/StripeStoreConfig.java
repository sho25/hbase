begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|compactions
operator|.
name|CompactionConfiguration
import|;
end_import

begin_comment
comment|/**  * Configuration class for stripe store and compactions.  * See {@link StripeStoreFileManager} for general documentation.  * See getters for the description of each setting.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|StripeStoreConfig
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|StripeStoreConfig
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** The maximum number of files to compact within a stripe; same as for regular compaction. */
specifier|public
specifier|static
specifier|final
name|String
name|MAX_FILES_KEY
init|=
literal|"hbase.store.stripe.compaction.maxFiles"
decl_stmt|;
comment|/** The minimum number of files to compact within a stripe; same as for regular compaction. */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_FILES_KEY
init|=
literal|"hbase.store.stripe.compaction.minFiles"
decl_stmt|;
comment|/**  The minimum number of files to compact when compacting L0; same as minFiles for regular    * compaction. Given that L0 causes unnecessary overwriting of the data, should be higher than    * regular minFiles. */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_FILES_L0_KEY
init|=
literal|"hbase.store.stripe.compaction.minFilesL0"
decl_stmt|;
comment|/** The size the stripe should achieve to be considered for splitting into multiple stripes.    Stripe will be split when it can be fully compacted, and it is above this size. */
specifier|public
specifier|static
specifier|final
name|String
name|SIZE_TO_SPLIT_KEY
init|=
literal|"hbase.store.stripe.sizeToSplit"
decl_stmt|;
comment|/** The target count of new stripes to produce when splitting a stripe. A floating point    number, default is 2. Values less than 1 will be converted to 1/x. Non-whole numbers will    produce unbalanced splits, which may be good for some cases. In this case the "smaller" of    the new stripes will always be the rightmost one. If the stripe is bigger than sizeToSplit    when splitting, this will be adjusted by a whole increment. */
specifier|public
specifier|static
specifier|final
name|String
name|SPLIT_PARTS_KEY
init|=
literal|"hbase.store.stripe.splitPartCount"
decl_stmt|;
comment|/** The initial stripe count to create. If the row distribution is roughly the same over time,    it's good to set this to a count of stripes that is expected to be achieved in most regions,    to get this count from the outset and prevent unnecessary splitting. */
specifier|public
specifier|static
specifier|final
name|String
name|INITIAL_STRIPE_COUNT_KEY
init|=
literal|"hbase.store.stripe.initialStripeCount"
decl_stmt|;
comment|/** Whether to flush memstore to L0 files, or directly to stripes. */
specifier|public
specifier|static
specifier|final
name|String
name|FLUSH_TO_L0_KEY
init|=
literal|"hbase.store.stripe.compaction.flushToL0"
decl_stmt|;
comment|/** When splitting region, the maximum size imbalance to allow in an attempt to split at a    stripe boundary, so that no files go to both regions. Most users won't need to change that. */
specifier|public
specifier|static
specifier|final
name|String
name|MAX_REGION_SPLIT_IMBALANCE_KEY
init|=
literal|"hbase.store.stripe.region.split.max.imbalance"
decl_stmt|;
specifier|private
specifier|final
name|float
name|maxRegionSplitImbalance
decl_stmt|;
specifier|private
specifier|final
name|int
name|level0CompactMinFiles
decl_stmt|;
specifier|private
specifier|final
name|int
name|stripeCompactMinFiles
decl_stmt|;
specifier|private
specifier|final
name|int
name|stripeCompactMaxFiles
decl_stmt|;
specifier|private
specifier|final
name|int
name|initialCount
decl_stmt|;
specifier|private
specifier|final
name|long
name|sizeToSplitAt
decl_stmt|;
specifier|private
specifier|final
name|float
name|splitPartCount
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|flushIntoL0
decl_stmt|;
specifier|private
specifier|final
name|long
name|splitPartSize
decl_stmt|;
comment|// derived from sizeToSplitAt and splitPartCount
specifier|private
specifier|static
specifier|final
name|double
name|EPSILON
init|=
literal|0.001
decl_stmt|;
comment|// good enough for this, not a real epsilon.
specifier|public
name|StripeStoreConfig
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|StoreConfigInformation
name|sci
parameter_list|)
block|{
name|this
operator|.
name|level0CompactMinFiles
operator|=
name|config
operator|.
name|getInt
argument_list|(
name|MIN_FILES_L0_KEY
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|this
operator|.
name|flushIntoL0
operator|=
name|config
operator|.
name|getBoolean
argument_list|(
name|FLUSH_TO_L0_KEY
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|minMinFiles
init|=
name|flushIntoL0
condition|?
literal|3
else|:
literal|4
decl_stmt|;
comment|// make sure not to compact tiny files too often.
name|int
name|minFiles
init|=
name|config
operator|.
name|getInt
argument_list|(
name|CompactionConfiguration
operator|.
name|HBASE_HSTORE_COMPACTION_MIN_KEY
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|this
operator|.
name|stripeCompactMinFiles
operator|=
name|config
operator|.
name|getInt
argument_list|(
name|MIN_FILES_KEY
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|minMinFiles
argument_list|,
name|minFiles
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|stripeCompactMaxFiles
operator|=
name|config
operator|.
name|getInt
argument_list|(
name|MAX_FILES_KEY
argument_list|,
name|config
operator|.
name|getInt
argument_list|(
name|CompactionConfiguration
operator|.
name|HBASE_HSTORE_COMPACTION_MAX_KEY
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxRegionSplitImbalance
operator|=
name|getFloat
argument_list|(
name|config
argument_list|,
name|MAX_REGION_SPLIT_IMBALANCE_KEY
argument_list|,
literal|1.5f
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|float
name|splitPartCount
init|=
name|getFloat
argument_list|(
name|config
argument_list|,
name|SPLIT_PARTS_KEY
argument_list|,
literal|2f
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|splitPartCount
operator|-
literal|1.0
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Split part count cannot be 1 ("
operator|+
name|splitPartCount
operator|+
literal|"), using the default"
argument_list|)
expr_stmt|;
name|splitPartCount
operator|=
literal|2f
expr_stmt|;
block|}
name|this
operator|.
name|splitPartCount
operator|=
name|splitPartCount
expr_stmt|;
comment|// Arbitrary default split size - 4 times the size of one L0 compaction.
comment|// If we flush into L0 there's no split compaction, but for default value it is ok.
name|double
name|flushSize
init|=
name|sci
operator|.
name|getMemstoreFlushSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|flushSize
operator|==
literal|0
condition|)
block|{
name|flushSize
operator|=
literal|128
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
block|}
name|long
name|defaultSplitSize
init|=
call|(
name|long
call|)
argument_list|(
name|flushSize
operator|*
name|getLevel0MinFiles
argument_list|()
operator|*
literal|4
operator|*
name|splitPartCount
argument_list|)
decl_stmt|;
name|this
operator|.
name|sizeToSplitAt
operator|=
name|config
operator|.
name|getLong
argument_list|(
name|SIZE_TO_SPLIT_KEY
argument_list|,
name|defaultSplitSize
argument_list|)
expr_stmt|;
name|int
name|initialCount
init|=
name|config
operator|.
name|getInt
argument_list|(
name|INITIAL_STRIPE_COUNT_KEY
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|initialCount
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Initial stripe count is 0, using the default"
argument_list|)
expr_stmt|;
name|initialCount
operator|=
literal|1
expr_stmt|;
block|}
name|this
operator|.
name|initialCount
operator|=
name|initialCount
expr_stmt|;
name|this
operator|.
name|splitPartSize
operator|=
call|(
name|long
call|)
argument_list|(
name|this
operator|.
name|sizeToSplitAt
operator|/
name|this
operator|.
name|splitPartCount
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|float
name|getFloat
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|String
name|key
parameter_list|,
name|float
name|defaultValue
parameter_list|,
name|boolean
name|moreThanOne
parameter_list|)
block|{
name|float
name|value
init|=
name|config
operator|.
name|getFloat
argument_list|(
name|key
argument_list|,
name|defaultValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
name|EPSILON
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s is set to 0 or negative; using default value of %f"
argument_list|,
name|key
argument_list|,
name|defaultValue
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|defaultValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|value
operator|>
literal|1f
operator|)
operator|!=
name|moreThanOne
condition|)
block|{
name|value
operator|=
literal|1f
operator|/
name|value
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
specifier|public
name|float
name|getMaxSplitImbalance
parameter_list|()
block|{
return|return
name|this
operator|.
name|maxRegionSplitImbalance
return|;
block|}
specifier|public
name|int
name|getLevel0MinFiles
parameter_list|()
block|{
return|return
name|level0CompactMinFiles
return|;
block|}
specifier|public
name|int
name|getStripeCompactMinFiles
parameter_list|()
block|{
return|return
name|stripeCompactMinFiles
return|;
block|}
specifier|public
name|int
name|getStripeCompactMaxFiles
parameter_list|()
block|{
return|return
name|stripeCompactMaxFiles
return|;
block|}
specifier|public
name|boolean
name|isUsingL0Flush
parameter_list|()
block|{
return|return
name|flushIntoL0
return|;
block|}
specifier|public
name|long
name|getSplitSize
parameter_list|()
block|{
return|return
name|sizeToSplitAt
return|;
block|}
specifier|public
name|int
name|getInitialCount
parameter_list|()
block|{
return|return
name|initialCount
return|;
block|}
specifier|public
name|float
name|getSplitCount
parameter_list|()
block|{
return|return
name|splitPartCount
return|;
block|}
comment|/**    * @return the desired size of the target stripe when splitting, in bytes.    *         Derived from {@link #getSplitSize()} and {@link #getSplitCount()}.    */
specifier|public
name|long
name|getSplitPartSize
parameter_list|()
block|{
return|return
name|splitPartSize
return|;
block|}
block|}
end_class

end_unit

