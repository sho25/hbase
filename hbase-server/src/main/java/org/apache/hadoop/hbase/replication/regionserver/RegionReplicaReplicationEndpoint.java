begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableDescriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ClusterConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionAdminServiceCallable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionReplicaUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RetryingCallable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RpcRetryingCallerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRpcController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcControllerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ReplicationProtbufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|HBaseReplicationEndpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|WALEntryFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WAL
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALSplitter
operator|.
name|EntryBuffers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALSplitter
operator|.
name|OutputSink
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALSplitter
operator|.
name|PipelineController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALSplitter
operator|.
name|RegionEntryBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALSplitter
operator|.
name|SinkWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|Cache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|ReplicateWALEntryResponse
import|;
end_import

begin_comment
comment|/**  * A {@link org.apache.hadoop.hbase.replication.ReplicationEndpoint} endpoint  * which receives the WAL edits from the WAL, and sends the edits to replicas  * of regions.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|RegionReplicaReplicationEndpoint
extends|extends
name|HBaseReplicationEndpoint
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RegionReplicaReplicationEndpoint
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Can be configured differently than hbase.client.retries.number
specifier|private
specifier|static
name|String
name|CLIENT_RETRIES_NUMBER
init|=
literal|"hbase.region.replica.replication.client.retries.number"
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|ClusterConnection
name|connection
decl_stmt|;
specifier|private
name|TableDescriptors
name|tableDescriptors
decl_stmt|;
comment|// Reuse WALSplitter constructs as a WAL pipe
specifier|private
name|PipelineController
name|controller
decl_stmt|;
specifier|private
name|RegionReplicaOutputSink
name|outputSink
decl_stmt|;
specifier|private
name|EntryBuffers
name|entryBuffers
decl_stmt|;
comment|// Number of writer threads
specifier|private
name|int
name|numWriterThreads
decl_stmt|;
specifier|private
name|int
name|operationTimeout
decl_stmt|;
specifier|private
name|ExecutorService
name|pool
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|(
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|init
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|HBaseConfiguration
operator|.
name|create
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableDescriptors
operator|=
name|context
operator|.
name|getTableDescriptors
argument_list|()
expr_stmt|;
comment|// HRS multiplies client retries by 10 globally for meta operations, but we do not want this.
comment|// We are resetting it here because we want default number of retries (35) rather than 10 times
comment|// that which makes very long retries for disabled tables etc.
name|int
name|defaultNumRetries
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_RETRIES_NUMBER
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultNumRetries
operator|>
literal|10
condition|)
block|{
name|int
name|mult
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_SERVERSIDE_RETRIES_MULTIPLIER
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_SERVERSIDE_RETRIES_MULTIPLIER
argument_list|)
decl_stmt|;
name|defaultNumRetries
operator|=
name|defaultNumRetries
operator|/
name|mult
expr_stmt|;
comment|// reset if HRS has multiplied this already
block|}
name|conf
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_SERVERSIDE_RETRIES_MULTIPLIER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|int
name|numRetries
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|CLIENT_RETRIES_NUMBER
argument_list|,
name|defaultNumRetries
argument_list|)
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|numRetries
argument_list|)
expr_stmt|;
name|this
operator|.
name|numWriterThreads
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.region.replica.replication.writer.threads"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|controller
operator|=
operator|new
name|PipelineController
argument_list|()
expr_stmt|;
name|entryBuffers
operator|=
operator|new
name|EntryBuffers
argument_list|(
name|controller
argument_list|,
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.region.replica.replication.buffersize"
argument_list|,
literal|128
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
comment|// use the regular RPC timeout for replica replication RPC's
name|this
operator|.
name|operationTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_OPERATION_TIMEOUT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_OPERATION_TIMEOUT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
try|try
block|{
name|connection
operator|=
operator|(
name|ClusterConnection
operator|)
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|pool
operator|=
name|getDefaultThreadPool
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|outputSink
operator|=
operator|new
name|RegionReplicaOutputSink
argument_list|(
name|controller
argument_list|,
name|tableDescriptors
argument_list|,
name|entryBuffers
argument_list|,
name|connection
argument_list|,
name|pool
argument_list|,
name|numWriterThreads
argument_list|,
name|operationTimeout
argument_list|)
expr_stmt|;
name|outputSink
operator|.
name|startWriterThreads
argument_list|()
expr_stmt|;
name|super
operator|.
name|doStart
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received exception while creating connection :"
operator|+
name|ex
argument_list|)
expr_stmt|;
name|notifyFailed
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
if|if
condition|(
name|outputSink
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|outputSink
operator|.
name|finishWritingAndClose
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Got exception while trying to close OutputSink"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|pool
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|pool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
try|try
block|{
comment|// wait for 10 sec
name|boolean
name|shutdown
init|=
name|this
operator|.
name|pool
operator|.
name|awaitTermination
argument_list|(
literal|10000
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shutdown
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to shutdown the thread pool after 10 seconds"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Got interrupted while waiting for the thread pool to shut down"
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Got exception closing connection :"
operator|+
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
name|super
operator|.
name|doStop
argument_list|()
expr_stmt|;
block|}
comment|/**    * Returns a Thread pool for the RPC's to region replicas. Similar to    * Connection's thread pool.    */
specifier|private
name|ExecutorService
name|getDefaultThreadPool
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|maxThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.region.replica.replication.threads.max"
argument_list|,
literal|256
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxThreads
operator|==
literal|0
condition|)
block|{
name|maxThreads
operator|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
operator|*
literal|8
expr_stmt|;
block|}
name|long
name|keepAliveTime
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.region.replica.replication.threads.keepalivetime"
argument_list|,
literal|60
argument_list|)
decl_stmt|;
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
name|workQueue
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<>
argument_list|(
name|maxThreads
operator|*
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_MAX_TOTAL_TASKS
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_MAX_TOTAL_TASKS
argument_list|)
argument_list|)
decl_stmt|;
name|ThreadPoolExecutor
name|tpe
init|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|maxThreads
argument_list|,
name|maxThreads
argument_list|,
name|keepAliveTime
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|workQueue
argument_list|,
name|Threads
operator|.
name|newDaemonThreadFactory
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"-rpc-shared-"
argument_list|)
argument_list|)
decl_stmt|;
name|tpe
operator|.
name|allowCoreThreadTimeOut
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|tpe
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|replicate
parameter_list|(
name|ReplicateContext
name|replicateContext
parameter_list|)
block|{
comment|/* A note on batching in RegionReplicaReplicationEndpoint (RRRE):      *      * RRRE relies on batching from two different mechanisms. The first is the batching from      * ReplicationSource since RRRE is a ReplicationEndpoint driven by RS. RS reads from a single      * WAL file filling up a buffer of heap size "replication.source.size.capacity"(64MB) or at most      * "replication.source.nb.capacity" entries or until it sees the end of file (in live tailing).      * Then RS passes all the buffered edits in this replicate() call context. RRRE puts the edits      * to the WALSplitter.EntryBuffers which is a blocking buffer space of up to      * "hbase.region.replica.replication.buffersize" (128MB) in size. This buffer splits the edits      * based on regions.      *      * There are "hbase.region.replica.replication.writer.threads"(default 3) writer threads which      * pick largest per-region buffer and send it to the SinkWriter (see RegionReplicaOutputSink).      * The SinkWriter in this case will send the wal edits to all secondary region replicas in      * parallel via a retrying rpc call. EntryBuffers guarantees that while a buffer is      * being written to the sink, another buffer for the same region will not be made available to      * writers ensuring regions edits are not replayed out of order.      *      * The replicate() call won't return until all the buffers are sent and ack'd by the sinks so      * that the replication can assume all edits are persisted. We may be able to do a better      * pipelining between the replication thread and output sinks later if it becomes a bottleneck.      */
while|while
condition|(
name|this
operator|.
name|isRunning
argument_list|()
condition|)
block|{
try|try
block|{
for|for
control|(
name|Entry
name|entry
range|:
name|replicateContext
operator|.
name|getEntries
argument_list|()
control|)
block|{
name|entryBuffers
operator|.
name|appendEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|outputSink
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// make sure everything is flushed
name|ctx
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrLogEditsFiltered
argument_list|(
name|outputSink
operator|.
name|getSkippedEditsCounter
argument_list|()
operator|.
name|getAndSet
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received IOException while trying to replicate"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|canReplicateToSameCluster
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|WALEntryFilter
name|getScopeWALEntryFilter
parameter_list|()
block|{
comment|// we do not care about scope. We replicate everything.
return|return
literal|null
return|;
block|}
specifier|static
class|class
name|RegionReplicaOutputSink
extends|extends
name|OutputSink
block|{
specifier|private
specifier|final
name|RegionReplicaSinkWriter
name|sinkWriter
decl_stmt|;
specifier|private
specifier|final
name|TableDescriptors
name|tableDescriptors
decl_stmt|;
specifier|private
specifier|final
name|Cache
argument_list|<
name|TableName
argument_list|,
name|Boolean
argument_list|>
name|memstoreReplicationEnabled
decl_stmt|;
specifier|public
name|RegionReplicaOutputSink
parameter_list|(
name|PipelineController
name|controller
parameter_list|,
name|TableDescriptors
name|tableDescriptors
parameter_list|,
name|EntryBuffers
name|entryBuffers
parameter_list|,
name|ClusterConnection
name|connection
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|int
name|numWriters
parameter_list|,
name|int
name|operationTimeout
parameter_list|)
block|{
name|super
argument_list|(
name|controller
argument_list|,
name|entryBuffers
argument_list|,
name|numWriters
argument_list|)
expr_stmt|;
name|this
operator|.
name|sinkWriter
operator|=
operator|new
name|RegionReplicaSinkWriter
argument_list|(
name|this
argument_list|,
name|connection
argument_list|,
name|pool
argument_list|,
name|operationTimeout
argument_list|,
name|tableDescriptors
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableDescriptors
operator|=
name|tableDescriptors
expr_stmt|;
comment|// A cache for the table "memstore replication enabled" flag.
comment|// It has a default expiry of 5 sec. This means that if the table is altered
comment|// with a different flag value, we might miss to replicate for that amount of
comment|// time. But this cache avoid the slow lookup and parsing of the TableDescriptor.
name|int
name|memstoreReplicationEnabledCacheExpiryMs
init|=
name|connection
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.region.replica.replication.cache.memstoreReplicationEnabled.expiryMs"
argument_list|,
literal|5000
argument_list|)
decl_stmt|;
name|this
operator|.
name|memstoreReplicationEnabled
operator|=
name|CacheBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|expireAfterWrite
argument_list|(
name|memstoreReplicationEnabledCacheExpiryMs
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
operator|.
name|initialCapacity
argument_list|(
literal|10
argument_list|)
operator|.
name|maximumSize
argument_list|(
literal|1000
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|append
parameter_list|(
name|RegionEntryBuffer
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Entry
argument_list|>
name|entries
init|=
name|buffer
operator|.
name|getEntryBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|entries
operator|.
name|isEmpty
argument_list|()
operator|||
name|entries
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// meta edits (e.g. flush) are always replicated.
comment|// data edits (e.g. put) are replicated if the table requires them.
if|if
condition|(
operator|!
name|requiresReplication
argument_list|(
name|buffer
operator|.
name|getTableName
argument_list|()
argument_list|,
name|entries
argument_list|)
condition|)
block|{
return|return;
block|}
name|sinkWriter
operator|.
name|append
argument_list|(
name|buffer
operator|.
name|getTableName
argument_list|()
argument_list|,
name|buffer
operator|.
name|getEncodedRegionName
argument_list|()
argument_list|,
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|entries
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
comment|// nothing much to do for now. Wait for the Writer threads to finish up
comment|// append()'ing the data.
name|entryBuffers
operator|.
name|waitUntilDrained
argument_list|()
expr_stmt|;
return|return
name|super
operator|.
name|flush
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|keepRegionEvent
parameter_list|(
name|Entry
name|entry
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Path
argument_list|>
name|finishWritingAndClose
parameter_list|()
throws|throws
name|IOException
block|{
name|finishWriting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|getOutputCounts
parameter_list|()
block|{
return|return
literal|null
return|;
comment|// only used in tests
block|}
annotation|@
name|Override
specifier|public
name|int
name|getNumberOfRecoveredRegions
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|AtomicLong
name|getSkippedEditsCounter
parameter_list|()
block|{
return|return
name|skippedEdits
return|;
block|}
comment|/**      * returns true if the specified entry must be replicated.      * We should always replicate meta operations (e.g. flush)      * and use the user HTD flag to decide whether or not replicate the memstore.      */
specifier|private
name|boolean
name|requiresReplication
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|List
argument_list|<
name|Entry
argument_list|>
name|entries
parameter_list|)
throws|throws
name|IOException
block|{
comment|// unit-tests may not the TableDescriptors, bypass the check and always replicate
if|if
condition|(
name|tableDescriptors
operator|==
literal|null
condition|)
return|return
literal|true
return|;
name|Boolean
name|requiresReplication
init|=
name|memstoreReplicationEnabled
operator|.
name|getIfPresent
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|requiresReplication
operator|==
literal|null
condition|)
block|{
comment|// check if the table requires memstore replication
comment|// some unit-test drop the table, so we should do a bypass check and always replicate.
name|TableDescriptor
name|htd
init|=
name|tableDescriptors
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|requiresReplication
operator|=
name|htd
operator|==
literal|null
operator|||
name|htd
operator|.
name|hasRegionMemStoreReplication
argument_list|()
expr_stmt|;
name|memstoreReplicationEnabled
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|requiresReplication
argument_list|)
expr_stmt|;
block|}
comment|// if memstore replication is not required, check the entries.
comment|// meta edits (e.g. flush) must be always replicated.
if|if
condition|(
operator|!
name|requiresReplication
condition|)
block|{
name|int
name|skipEdits
init|=
literal|0
decl_stmt|;
name|java
operator|.
name|util
operator|.
name|Iterator
argument_list|<
name|Entry
argument_list|>
name|it
init|=
name|entries
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
name|entry
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|isMetaEdit
argument_list|()
condition|)
block|{
name|requiresReplication
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|skipEdits
operator|++
expr_stmt|;
block|}
block|}
name|skippedEdits
operator|.
name|addAndGet
argument_list|(
name|skipEdits
argument_list|)
expr_stmt|;
block|}
return|return
name|requiresReplication
return|;
block|}
block|}
specifier|static
class|class
name|RegionReplicaSinkWriter
extends|extends
name|SinkWriter
block|{
name|RegionReplicaOutputSink
name|sink
decl_stmt|;
name|ClusterConnection
name|connection
decl_stmt|;
name|RpcControllerFactory
name|rpcControllerFactory
decl_stmt|;
name|RpcRetryingCallerFactory
name|rpcRetryingCallerFactory
decl_stmt|;
name|int
name|operationTimeout
decl_stmt|;
name|ExecutorService
name|pool
decl_stmt|;
name|Cache
argument_list|<
name|TableName
argument_list|,
name|Boolean
argument_list|>
name|disabledAndDroppedTables
decl_stmt|;
name|TableDescriptors
name|tableDescriptors
decl_stmt|;
specifier|public
name|RegionReplicaSinkWriter
parameter_list|(
name|RegionReplicaOutputSink
name|sink
parameter_list|,
name|ClusterConnection
name|connection
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|int
name|operationTimeout
parameter_list|,
name|TableDescriptors
name|tableDescriptors
parameter_list|)
block|{
name|this
operator|.
name|sink
operator|=
name|sink
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|operationTimeout
operator|=
name|operationTimeout
expr_stmt|;
name|this
operator|.
name|rpcRetryingCallerFactory
operator|=
name|RpcRetryingCallerFactory
operator|.
name|instantiate
argument_list|(
name|connection
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcControllerFactory
operator|=
name|RpcControllerFactory
operator|.
name|instantiate
argument_list|(
name|connection
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|tableDescriptors
operator|=
name|tableDescriptors
expr_stmt|;
name|int
name|nonExistentTableCacheExpiryMs
init|=
name|connection
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.region.replica.replication.cache.disabledAndDroppedTables.expiryMs"
argument_list|,
literal|5000
argument_list|)
decl_stmt|;
comment|// A cache for non existing tables that have a default expiry of 5 sec. This means that if the
comment|// table is created again with the same name, we might miss to replicate for that amount of
comment|// time. But this cache prevents overloading meta requests for every edit from a deleted file.
name|disabledAndDroppedTables
operator|=
name|CacheBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|expireAfterWrite
argument_list|(
name|nonExistentTableCacheExpiryMs
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
operator|.
name|initialCapacity
argument_list|(
literal|10
argument_list|)
operator|.
name|maximumSize
argument_list|(
literal|1000
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|append
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|byte
index|[]
name|encodedRegionName
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|List
argument_list|<
name|Entry
argument_list|>
name|entries
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|disabledAndDroppedTables
operator|.
name|getIfPresent
argument_list|(
name|tableName
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping "
operator|+
name|entries
operator|.
name|size
argument_list|()
operator|+
literal|" entries because table "
operator|+
name|tableName
operator|+
literal|" is cached as a disabled or dropped table"
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
name|entry
range|:
name|entries
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping : "
operator|+
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|sink
operator|.
name|getSkippedEditsCounter
argument_list|()
operator|.
name|addAndGet
argument_list|(
name|entries
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If the table is disabled or dropped, we should not replay the entries, and we can skip
comment|// replaying them. However, we might not know whether the table is disabled until we
comment|// invalidate the cache and check from meta
name|RegionLocations
name|locations
init|=
literal|null
decl_stmt|;
name|boolean
name|useCache
init|=
literal|true
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// get the replicas of the primary region
try|try
block|{
name|locations
operator|=
name|RegionReplicaReplayCallable
operator|.
name|getRegionLocations
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|row
argument_list|,
name|useCache
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|locations
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HBaseIOException
argument_list|(
literal|"Cannot locate locations for "
operator|+
name|tableName
operator|+
literal|", row:"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|row
argument_list|)
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|TableNotFoundException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping "
operator|+
name|entries
operator|.
name|size
argument_list|()
operator|+
literal|" entries because table "
operator|+
name|tableName
operator|+
literal|" is dropped. Adding table to cache."
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
name|entry
range|:
name|entries
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping : "
operator|+
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|disabledAndDroppedTables
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
comment|// put to cache. Value ignored
comment|// skip this entry
name|sink
operator|.
name|getSkippedEditsCounter
argument_list|()
operator|.
name|addAndGet
argument_list|(
name|entries
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// check whether we should still replay this entry. If the regions are changed, or the
comment|// entry is not coming from the primary region, filter it out.
name|HRegionLocation
name|primaryLocation
init|=
name|locations
operator|.
name|getDefaultRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|primaryLocation
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|,
name|encodedRegionName
argument_list|)
condition|)
block|{
if|if
condition|(
name|useCache
condition|)
block|{
name|useCache
operator|=
literal|false
expr_stmt|;
continue|continue;
comment|// this will retry location lookup
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping "
operator|+
name|entries
operator|.
name|size
argument_list|()
operator|+
literal|" entries in table "
operator|+
name|tableName
operator|+
literal|" because located region "
operator|+
name|primaryLocation
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" is different than the original region "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|encodedRegionName
argument_list|)
operator|+
literal|" from WALEdit"
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
name|entry
range|:
name|entries
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping : "
operator|+
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|sink
operator|.
name|getSkippedEditsCounter
argument_list|()
operator|.
name|addAndGet
argument_list|(
name|entries
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
if|if
condition|(
name|locations
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return;
block|}
name|ArrayList
argument_list|<
name|Future
argument_list|<
name|ReplicateWALEntryResponse
argument_list|>
argument_list|>
name|tasks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|locations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// All passed entries should belong to one region because it is coming from the EntryBuffers
comment|// split per region. But the regions might split and merge (unlike log recovery case).
for|for
control|(
name|int
name|replicaId
init|=
literal|0
init|;
name|replicaId
operator|<
name|locations
operator|.
name|size
argument_list|()
condition|;
name|replicaId
operator|++
control|)
block|{
name|HRegionLocation
name|location
init|=
name|locations
operator|.
name|getRegionLocation
argument_list|(
name|replicaId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|RegionReplicaUtil
operator|.
name|isDefaultReplica
argument_list|(
name|replicaId
argument_list|)
condition|)
block|{
name|RegionInfo
name|regionInfo
init|=
name|location
operator|==
literal|null
condition|?
name|RegionReplicaUtil
operator|.
name|getRegionInfoForReplica
argument_list|(
name|locations
operator|.
name|getDefaultRegionLocation
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|replicaId
argument_list|)
else|:
name|location
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|RegionReplicaReplayCallable
name|callable
init|=
operator|new
name|RegionReplicaReplayCallable
argument_list|(
name|connection
argument_list|,
name|rpcControllerFactory
argument_list|,
name|tableName
argument_list|,
name|location
argument_list|,
name|regionInfo
argument_list|,
name|row
argument_list|,
name|entries
argument_list|,
name|sink
operator|.
name|getSkippedEditsCounter
argument_list|()
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|ReplicateWALEntryResponse
argument_list|>
name|task
init|=
name|pool
operator|.
name|submit
argument_list|(
operator|new
name|RetryingRpcCallable
argument_list|<>
argument_list|(
name|rpcRetryingCallerFactory
argument_list|,
name|callable
argument_list|,
name|operationTimeout
argument_list|)
argument_list|)
decl_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|tasksCancelled
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|replicaId
init|=
literal|0
init|;
name|replicaId
operator|<
name|tasks
operator|.
name|size
argument_list|()
condition|;
name|replicaId
operator|++
control|)
block|{
try|try
block|{
name|tasks
operator|.
name|get
argument_list|(
name|replicaId
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|e
operator|.
name|getCause
argument_list|()
decl_stmt|;
name|boolean
name|canBeSkipped
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|cause
operator|instanceof
name|IOException
condition|)
block|{
comment|// The table can be disabled or dropped at this time. For disabled tables, we have no
comment|// cheap mechanism to detect this case because meta does not contain this information.
comment|// ClusterConnection.isTableDisabled() is a zk call which we cannot do for every replay
comment|// RPC. So instead we start the replay RPC with retries and check whether the table is
comment|// dropped or disabled which might cause SocketTimeoutException, or
comment|// RetriesExhaustedException or similar if we get IOE.
if|if
condition|(
name|cause
operator|instanceof
name|TableNotFoundException
operator|||
name|connection
operator|.
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|disabledAndDroppedTables
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
comment|// put to cache for later.
name|canBeSkipped
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tableDescriptors
operator|!=
literal|null
condition|)
block|{
name|TableDescriptor
name|tableDescriptor
init|=
name|tableDescriptors
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableDescriptor
operator|!=
literal|null
comment|//(replicaId + 1) as no task is added for primary replica for replication
operator|&&
name|tableDescriptor
operator|.
name|getRegionReplication
argument_list|()
operator|<=
operator|(
name|replicaId
operator|+
literal|1
operator|)
condition|)
block|{
name|canBeSkipped
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|canBeSkipped
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping "
operator|+
name|entries
operator|.
name|size
argument_list|()
operator|+
literal|" entries in table "
operator|+
name|tableName
operator|+
literal|" because received exception for dropped or disabled table"
argument_list|,
name|cause
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
name|entry
range|:
name|entries
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping : "
operator|+
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|tasksCancelled
condition|)
block|{
name|sink
operator|.
name|getSkippedEditsCounter
argument_list|()
operator|.
name|addAndGet
argument_list|(
name|entries
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|tasksCancelled
operator|=
literal|true
expr_stmt|;
comment|// so that we do not add to skipped counter again
block|}
continue|continue;
block|}
comment|// otherwise rethrow
throw|throw
operator|(
name|IOException
operator|)
name|cause
throw|;
block|}
comment|// unexpected exception
throw|throw
operator|new
name|IOException
argument_list|(
name|cause
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|static
class|class
name|RetryingRpcCallable
parameter_list|<
name|V
parameter_list|>
implements|implements
name|Callable
argument_list|<
name|V
argument_list|>
block|{
name|RpcRetryingCallerFactory
name|factory
decl_stmt|;
name|RetryingCallable
argument_list|<
name|V
argument_list|>
name|callable
decl_stmt|;
name|int
name|timeout
decl_stmt|;
specifier|public
name|RetryingRpcCallable
parameter_list|(
name|RpcRetryingCallerFactory
name|factory
parameter_list|,
name|RetryingCallable
argument_list|<
name|V
argument_list|>
name|callable
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|this
operator|.
name|factory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|callable
operator|=
name|callable
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|factory
operator|.
expr|<
name|V
operator|>
name|newCaller
argument_list|()
operator|.
name|callWithRetries
argument_list|(
name|callable
argument_list|,
name|timeout
argument_list|)
return|;
block|}
block|}
comment|/**    * Calls replay on the passed edits for the given set of entries belonging to the region. It skips    * the entry if the region boundaries have changed or the region is gone.    */
specifier|static
class|class
name|RegionReplicaReplayCallable
extends|extends
name|RegionAdminServiceCallable
argument_list|<
name|ReplicateWALEntryResponse
argument_list|>
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|Entry
argument_list|>
name|entries
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|initialEncodedRegionName
decl_stmt|;
specifier|private
specifier|final
name|AtomicLong
name|skippedEntries
decl_stmt|;
specifier|public
name|RegionReplicaReplayCallable
parameter_list|(
name|ClusterConnection
name|connection
parameter_list|,
name|RpcControllerFactory
name|rpcControllerFactory
parameter_list|,
name|TableName
name|tableName
parameter_list|,
name|HRegionLocation
name|location
parameter_list|,
name|RegionInfo
name|regionInfo
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|List
argument_list|<
name|Entry
argument_list|>
name|entries
parameter_list|,
name|AtomicLong
name|skippedEntries
parameter_list|)
block|{
name|super
argument_list|(
name|connection
argument_list|,
name|rpcControllerFactory
argument_list|,
name|location
argument_list|,
name|tableName
argument_list|,
name|row
argument_list|,
name|regionInfo
operator|.
name|getReplicaId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
name|this
operator|.
name|skippedEntries
operator|=
name|skippedEntries
expr_stmt|;
name|this
operator|.
name|initialEncodedRegionName
operator|=
name|regionInfo
operator|.
name|getEncodedNameAsBytes
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|ReplicateWALEntryResponse
name|call
parameter_list|(
name|HBaseRpcController
name|controller
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Check whether we should still replay this entry. If the regions are changed, or the
comment|// entry is not coming form the primary region, filter it out because we do not need it.
comment|// Regions can change because of (1) region split (2) region merge (3) table recreated
name|boolean
name|skip
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|,
name|initialEncodedRegionName
argument_list|)
condition|)
block|{
name|skip
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|entries
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|skip
condition|)
block|{
name|Entry
index|[]
name|entriesArray
init|=
operator|new
name|Entry
index|[
name|this
operator|.
name|entries
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|entriesArray
operator|=
name|this
operator|.
name|entries
operator|.
name|toArray
argument_list|(
name|entriesArray
argument_list|)
expr_stmt|;
comment|// set the region name for the target region replica
name|Pair
argument_list|<
name|AdminProtos
operator|.
name|ReplicateWALEntryRequest
argument_list|,
name|CellScanner
argument_list|>
name|p
init|=
name|ReplicationProtbufUtil
operator|.
name|buildReplicateWALEntryRequest
argument_list|(
name|entriesArray
argument_list|,
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|controller
operator|.
name|setCellScanner
argument_list|(
name|p
operator|.
name|getSecond
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|stub
operator|.
name|replay
argument_list|(
name|controller
argument_list|,
name|p
operator|.
name|getFirst
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|skip
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping "
operator|+
name|entries
operator|.
name|size
argument_list|()
operator|+
literal|" entries in table "
operator|+
name|tableName
operator|+
literal|" because located region "
operator|+
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" is different than the original region "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|initialEncodedRegionName
argument_list|)
operator|+
literal|" from WALEdit"
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
name|entry
range|:
name|entries
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Skipping : "
operator|+
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|skippedEntries
operator|.
name|addAndGet
argument_list|(
name|entries
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ReplicateWALEntryResponse
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

