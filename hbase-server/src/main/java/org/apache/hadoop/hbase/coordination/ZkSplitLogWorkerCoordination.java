begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coordination
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
operator|.
name|DEFAULT_HBASE_SPLIT_WAL_MAX_SPLITTER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
operator|.
name|HBASE_SPLIT_WAL_MAX_SPLITTER
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|LongAdder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|RandomUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|mutable
operator|.
name|MutableInt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|SplitLogCounters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|SplitLogTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|log
operator|.
name|HBaseMarkers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionServerServices
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|SplitLogWorker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|SplitLogWorker
operator|.
name|TaskExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|WALSplitterHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CancelableProgressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|AbstractFSWALProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKSplitLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZNodePaths
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * ZooKeeper based implementation of {@link SplitLogWorkerCoordination}  * It listen for changes in ZooKeeper and  *  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|ZkSplitLogWorkerCoordination
extends|extends
name|ZKListener
implements|implements
name|SplitLogWorkerCoordination
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ZkSplitLogWorkerCoordination
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|checkInterval
init|=
literal|5000
decl_stmt|;
comment|// 5 seconds
specifier|private
specifier|static
specifier|final
name|int
name|FAILED_TO_OWN_TASK
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|SplitLogWorker
name|worker
decl_stmt|;
specifier|private
name|TaskExecutor
name|splitTaskExecutor
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|taskReadySeq
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|String
name|currentTask
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|currentVersion
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|shouldStop
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|Object
name|grabTaskLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|workerInGrabTask
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|reportPeriod
decl_stmt|;
specifier|private
name|RegionServerServices
name|server
init|=
literal|null
decl_stmt|;
specifier|protected
specifier|final
name|AtomicInteger
name|tasksInProgress
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
name|int
name|maxConcurrentTasks
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|ServerName
name|serverName
decl_stmt|;
specifier|public
name|ZkSplitLogWorkerCoordination
parameter_list|(
name|ServerName
name|serverName
parameter_list|,
name|ZKWatcher
name|watcher
parameter_list|)
block|{
name|super
argument_list|(
name|watcher
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
block|}
comment|/**    * Override handler from {@link ZKListener}    */
annotation|@
name|Override
specifier|public
name|void
name|nodeChildrenChanged
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
name|watcher
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|splitLogZNode
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"tasks arrived or departed on "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|taskReadySeq
init|)
block|{
name|this
operator|.
name|taskReadySeq
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|taskReadySeq
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Override handler from {@link ZKListener}    */
annotation|@
name|Override
specifier|public
name|void
name|nodeDataChanged
parameter_list|(
name|String
name|path
parameter_list|)
block|{
comment|// there will be a self generated dataChanged event every time attemptToOwnTask()
comment|// heartbeats the task znode by upping its version
synchronized|synchronized
init|(
name|grabTaskLock
init|)
block|{
if|if
condition|(
name|workerInGrabTask
condition|)
block|{
comment|// currentTask can change
name|String
name|taskpath
init|=
name|currentTask
decl_stmt|;
if|if
condition|(
name|taskpath
operator|!=
literal|null
operator|&&
name|taskpath
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|getDataSetWatchAsync
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Override setter from {@link SplitLogWorkerCoordination}    */
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|(
name|RegionServerServices
name|server
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|TaskExecutor
name|splitExecutor
parameter_list|,
name|SplitLogWorker
name|worker
parameter_list|)
block|{
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
name|this
operator|.
name|worker
operator|=
name|worker
expr_stmt|;
name|this
operator|.
name|splitTaskExecutor
operator|=
name|splitExecutor
expr_stmt|;
name|maxConcurrentTasks
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HBASE_SPLIT_WAL_MAX_SPLITTER
argument_list|,
name|DEFAULT_HBASE_SPLIT_WAL_MAX_SPLITTER
argument_list|)
expr_stmt|;
name|reportPeriod
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.splitlog.report.period"
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_SPLITLOG_MANAGER_TIMEOUT
argument_list|,
name|ZKSplitLogManagerCoordination
operator|.
name|DEFAULT_TIMEOUT
argument_list|)
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* Support functions for ZooKeeper async callback */
name|void
name|getDataSetWatchFailure
parameter_list|(
name|String
name|path
parameter_list|)
block|{
synchronized|synchronized
init|(
name|grabTaskLock
init|)
block|{
if|if
condition|(
name|workerInGrabTask
condition|)
block|{
comment|// currentTask can change but that's ok
name|String
name|taskpath
init|=
name|currentTask
decl_stmt|;
if|if
condition|(
name|taskpath
operator|!=
literal|null
operator|&&
name|taskpath
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"retrying data watch on "
operator|+
name|path
argument_list|)
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_get_data_retry
operator|.
name|increment
argument_list|()
expr_stmt|;
name|getDataSetWatchAsync
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// no point setting a watch on the task which this worker is not
comment|// working upon anymore
block|}
block|}
block|}
block|}
specifier|public
name|void
name|getDataSetWatchAsync
parameter_list|()
block|{
name|watcher
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getZooKeeper
argument_list|()
operator|.
name|getData
argument_list|(
name|currentTask
argument_list|,
name|watcher
argument_list|,
operator|new
name|GetDataAsyncCallback
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_get_data_queued
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
name|void
name|getDataSetWatchSuccess
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
name|SplitLogTask
name|slt
decl_stmt|;
try|try
block|{
name|slt
operator|=
name|SplitLogTask
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed parse"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
synchronized|synchronized
init|(
name|grabTaskLock
init|)
block|{
if|if
condition|(
name|workerInGrabTask
condition|)
block|{
comment|// currentTask can change but that's ok
name|String
name|taskpath
init|=
name|currentTask
decl_stmt|;
if|if
condition|(
name|taskpath
operator|!=
literal|null
operator|&&
name|taskpath
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|// have to compare data. cannot compare version because then there
comment|// will be race with attemptToOwnTask()
comment|// cannot just check whether the node has been transitioned to
comment|// UNASSIGNED because by the time this worker sets the data watch
comment|// the node might have made two transitions - from owned by this
comment|// worker to unassigned to owned by another worker
if|if
condition|(
operator|!
name|slt
operator|.
name|isOwned
argument_list|(
name|serverName
argument_list|)
operator|&&
operator|!
name|slt
operator|.
name|isDone
argument_list|(
name|serverName
argument_list|)
operator|&&
operator|!
name|slt
operator|.
name|isErr
argument_list|(
name|serverName
argument_list|)
operator|&&
operator|!
name|slt
operator|.
name|isResigned
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"task "
operator|+
name|taskpath
operator|+
literal|" preempted from "
operator|+
name|serverName
operator|+
literal|", current task state and owner="
operator|+
name|slt
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|worker
operator|.
name|stopTask
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * try to grab a 'lock' on the task zk node to own and execute the task.    *<p>    * @param path zk node for the task    * @return boolean value when grab a task success return true otherwise false    */
specifier|private
name|boolean
name|grabTask
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
synchronized|synchronized
init|(
name|grabTaskLock
init|)
block|{
name|currentTask
operator|=
name|path
expr_stmt|;
name|workerInGrabTask
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
try|try
block|{
try|try
block|{
if|if
condition|(
operator|(
name|data
operator|=
name|ZKUtil
operator|.
name|getDataNoWatch
argument_list|(
name|watcher
argument_list|,
name|path
argument_list|,
name|stat
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|SplitLogCounters
operator|.
name|tot_wkr_failed_to_grab_task_no_data
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get data for znode "
operator|+
name|path
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_failed_to_grab_task_exception
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|SplitLogTask
name|slt
decl_stmt|;
try|try
block|{
name|slt
operator|=
name|SplitLogTask
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed parse data for znode "
operator|+
name|path
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_failed_to_grab_task_exception
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|slt
operator|.
name|isUnassigned
argument_list|()
condition|)
block|{
name|SplitLogCounters
operator|.
name|tot_wkr_failed_to_grab_task_owned
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|currentVersion
operator|=
name|attemptToOwnTask
argument_list|(
literal|true
argument_list|,
name|watcher
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|path
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentVersion
operator|<
literal|0
condition|)
block|{
name|SplitLogCounters
operator|.
name|tot_wkr_failed_to_grab_task_lost_race
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|ZKSplitLog
operator|.
name|isRescanNode
argument_list|(
name|watcher
argument_list|,
name|currentTask
argument_list|)
condition|)
block|{
name|ZkSplitLogWorkerCoordination
operator|.
name|ZkSplitTaskDetails
name|splitTaskDetails
init|=
operator|new
name|ZkSplitLogWorkerCoordination
operator|.
name|ZkSplitTaskDetails
argument_list|()
decl_stmt|;
name|splitTaskDetails
operator|.
name|setTaskNode
argument_list|(
name|currentTask
argument_list|)
expr_stmt|;
name|splitTaskDetails
operator|.
name|setCurTaskZKVersion
argument_list|(
operator|new
name|MutableInt
argument_list|(
name|currentVersion
argument_list|)
argument_list|)
expr_stmt|;
name|endTask
argument_list|(
operator|new
name|SplitLogTask
operator|.
name|Done
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
argument_list|)
argument_list|,
name|SplitLogCounters
operator|.
name|tot_wkr_task_acquired_rescan
argument_list|,
name|splitTaskDetails
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"worker "
operator|+
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|" acquired task "
operator|+
name|path
argument_list|)
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_task_acquired
operator|.
name|increment
argument_list|()
expr_stmt|;
name|getDataSetWatchAsync
argument_list|()
expr_stmt|;
name|submitTask
argument_list|(
name|path
argument_list|,
name|currentVersion
argument_list|,
name|reportPeriod
argument_list|)
expr_stmt|;
comment|// after a successful submit, sleep a little bit to allow other RSs to grab the rest tasks
try|try
block|{
name|int
name|sleepTime
init|=
name|RandomUtils
operator|.
name|nextInt
argument_list|(
literal|0
argument_list|,
literal|500
argument_list|)
operator|+
literal|500
decl_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while yielding for other region servers"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|grabTaskLock
init|)
block|{
name|workerInGrabTask
operator|=
literal|false
expr_stmt|;
comment|// clear the interrupt from stopTask() otherwise the next task will
comment|// suffer
name|Thread
operator|.
name|interrupted
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Submit a log split task to executor service    * @param curTask task to submit    * @param curTaskZKVersion current version of task    */
name|void
name|submitTask
parameter_list|(
specifier|final
name|String
name|curTask
parameter_list|,
specifier|final
name|int
name|curTaskZKVersion
parameter_list|,
specifier|final
name|int
name|reportPeriod
parameter_list|)
block|{
specifier|final
name|MutableInt
name|zkVersion
init|=
operator|new
name|MutableInt
argument_list|(
name|curTaskZKVersion
argument_list|)
decl_stmt|;
name|CancelableProgressable
name|reporter
init|=
operator|new
name|CancelableProgressable
argument_list|()
block|{
specifier|private
name|long
name|last_report_at
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|progress
parameter_list|()
block|{
name|long
name|t
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|-
name|last_report_at
operator|)
operator|>
name|reportPeriod
condition|)
block|{
name|last_report_at
operator|=
name|t
expr_stmt|;
name|int
name|latestZKVersion
init|=
name|attemptToOwnTask
argument_list|(
literal|false
argument_list|,
name|watcher
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|curTask
argument_list|,
name|zkVersion
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|latestZKVersion
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to heartbeat the task"
operator|+
name|curTask
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|zkVersion
operator|.
name|setValue
argument_list|(
name|latestZKVersion
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|ZkSplitLogWorkerCoordination
operator|.
name|ZkSplitTaskDetails
name|splitTaskDetails
init|=
operator|new
name|ZkSplitLogWorkerCoordination
operator|.
name|ZkSplitTaskDetails
argument_list|()
decl_stmt|;
name|splitTaskDetails
operator|.
name|setTaskNode
argument_list|(
name|curTask
argument_list|)
expr_stmt|;
name|splitTaskDetails
operator|.
name|setCurTaskZKVersion
argument_list|(
name|zkVersion
argument_list|)
expr_stmt|;
name|WALSplitterHandler
name|hsh
init|=
operator|new
name|WALSplitterHandler
argument_list|(
name|server
argument_list|,
name|this
argument_list|,
name|splitTaskDetails
argument_list|,
name|reporter
argument_list|,
name|this
operator|.
name|tasksInProgress
argument_list|,
name|splitTaskExecutor
argument_list|)
decl_stmt|;
name|server
operator|.
name|getExecutorService
argument_list|()
operator|.
name|submit
argument_list|(
name|hsh
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return true if more splitters are available, otherwise false.    */
specifier|private
name|boolean
name|areSplittersAvailable
parameter_list|()
block|{
return|return
name|maxConcurrentTasks
operator|-
name|tasksInProgress
operator|.
name|get
argument_list|()
operator|>
literal|0
return|;
block|}
comment|/**    * Try to own the task by transitioning the zk node data from UNASSIGNED to OWNED.    *<p>    * This method is also used to periodically heartbeat the task progress by transitioning the node    * from OWNED to OWNED.    *<p>    * @param isFirstTime shows whther it's the first attempt.    * @param zkw zk wathcer    * @param server name    * @param task to own    * @param taskZKVersion version of the task in zk    * @return non-negative integer value when task can be owned by current region server otherwise -1    */
specifier|protected
specifier|static
name|int
name|attemptToOwnTask
parameter_list|(
name|boolean
name|isFirstTime
parameter_list|,
name|ZKWatcher
name|zkw
parameter_list|,
name|ServerName
name|server
parameter_list|,
name|String
name|task
parameter_list|,
name|int
name|taskZKVersion
parameter_list|)
block|{
name|int
name|latestZKVersion
init|=
name|FAILED_TO_OWN_TASK
decl_stmt|;
try|try
block|{
name|SplitLogTask
name|slt
init|=
operator|new
name|SplitLogTask
operator|.
name|Owned
argument_list|(
name|server
argument_list|)
decl_stmt|;
name|Stat
name|stat
init|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|setData
argument_list|(
name|task
argument_list|,
name|slt
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|taskZKVersion
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"zk.setData() returned null for path "
operator|+
name|task
argument_list|)
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_task_heartbeat_failed
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return
name|FAILED_TO_OWN_TASK
return|;
block|}
name|latestZKVersion
operator|=
name|stat
operator|.
name|getVersion
argument_list|()
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_task_heartbeat
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return
name|latestZKVersion
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isFirstTime
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|.
name|equals
argument_list|(
name|KeeperException
operator|.
name|Code
operator|.
name|NONODE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"NONODE failed to assert ownership for "
operator|+
name|task
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|.
name|equals
argument_list|(
name|KeeperException
operator|.
name|Code
operator|.
name|BADVERSION
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"BADVERSION failed to assert ownership for "
operator|+
name|task
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to assert ownership for "
operator|+
name|task
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while trying to assert ownership of "
operator|+
name|task
operator|+
literal|" "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e1
argument_list|)
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|SplitLogCounters
operator|.
name|tot_wkr_task_heartbeat_failed
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return
name|FAILED_TO_OWN_TASK
return|;
block|}
comment|/**    * Wait for tasks to become available at /hbase/splitlog zknode. Grab a task one at a time. This    * policy puts an upper-limit on the number of simultaneous log splitting that could be happening    * in a cluster.    *<p>    * Synchronization using<code>taskReadySeq</code> ensures that it will try to grab every task    * that has been put up    * @throws InterruptedException    */
annotation|@
name|Override
specifier|public
name|void
name|taskLoop
parameter_list|()
throws|throws
name|InterruptedException
block|{
while|while
condition|(
operator|!
name|shouldStop
condition|)
block|{
name|int
name|seq_start
init|=
name|taskReadySeq
operator|.
name|get
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|paths
decl_stmt|;
name|paths
operator|=
name|getTaskList
argument_list|()
expr_stmt|;
if|if
condition|(
name|paths
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not get tasks, did someone remove "
operator|+
name|watcher
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|splitLogZNode
operator|+
literal|" ... worker thread exiting."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// shuffle the paths to prevent different split log worker start from the same log file after
comment|// meta log (if any)
name|Collections
operator|.
name|shuffle
argument_list|(
name|paths
argument_list|)
expr_stmt|;
comment|// pick meta wal firstly
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|AbstractFSWALProvider
operator|.
name|isMetaFile
argument_list|(
name|paths
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|int
name|numTasks
init|=
name|paths
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|taskGrabbed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTasks
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|!
name|shouldStop
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|areSplittersAvailable
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Current region server "
operator|+
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|" is ready to take more tasks, will get task list and try grab tasks again."
argument_list|)
expr_stmt|;
block|}
name|int
name|idx
init|=
operator|(
name|i
operator|+
name|offset
operator|)
operator|%
name|paths
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// don't call ZKSplitLog.getNodeName() because that will lead to
comment|// double encoding of the path name
name|taskGrabbed
operator||=
name|grabTask
argument_list|(
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|watcher
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|splitLogZNode
argument_list|,
name|paths
operator|.
name|get
argument_list|(
name|idx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Current region server "
operator|+
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|" has "
operator|+
name|this
operator|.
name|tasksInProgress
operator|.
name|get
argument_list|()
operator|+
literal|" tasks in progress and can't take more."
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shouldStop
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|taskGrabbed
operator|&&
operator|!
name|shouldStop
condition|)
block|{
comment|// do not grab any tasks, sleep a little bit to reduce zk request.
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|SplitLogCounters
operator|.
name|tot_wkr_task_grabing
operator|.
name|increment
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|taskReadySeq
init|)
block|{
while|while
condition|(
name|seq_start
operator|==
name|taskReadySeq
operator|.
name|get
argument_list|()
condition|)
block|{
name|taskReadySeq
operator|.
name|wait
argument_list|(
name|checkInterval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getTaskList
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|childrenPaths
init|=
literal|null
decl_stmt|;
name|long
name|sleepTime
init|=
literal|1000
decl_stmt|;
comment|// It will be in loop till it gets the list of children or
comment|// it will come out if worker thread exited.
while|while
condition|(
operator|!
name|shouldStop
condition|)
block|{
try|try
block|{
name|childrenPaths
operator|=
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|splitLogZNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|childrenPaths
operator|!=
literal|null
condition|)
block|{
return|return
name|childrenPaths
return|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not get children of znode "
operator|+
name|watcher
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|splitLogZNode
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Retry listChildren of znode "
operator|+
name|watcher
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|splitLogZNode
operator|+
literal|" after sleep for "
operator|+
name|sleepTime
operator|+
literal|"ms!"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
return|return
name|childrenPaths
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|markCorrupted
parameter_list|(
name|Path
name|rootDir
parameter_list|,
name|String
name|name
parameter_list|,
name|FileSystem
name|fs
parameter_list|)
block|{
name|ZKSplitLog
operator|.
name|markCorrupted
argument_list|(
name|rootDir
argument_list|,
name|name
argument_list|,
name|fs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isReady
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
name|result
operator|=
name|ZKUtil
operator|.
name|checkExists
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|splitLogZNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
comment|// ignore
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception when checking for "
operator|+
name|watcher
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|splitLogZNode
operator|+
literal|" ... retrying"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|watcher
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|splitLogZNode
operator|+
literal|" znode does not exist, waiting for master to create"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|!=
operator|-
literal|1
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getTaskReadySeq
parameter_list|()
block|{
return|return
name|taskReadySeq
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|registerListener
parameter_list|()
block|{
name|watcher
operator|.
name|registerListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeListener
parameter_list|()
block|{
name|watcher
operator|.
name|unregisterListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stopProcessingTasks
parameter_list|()
block|{
name|this
operator|.
name|shouldStop
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStop
parameter_list|()
block|{
return|return
name|shouldStop
return|;
block|}
comment|/**    * Asynchronous handler for zk get-data-set-watch on node results.    */
class|class
name|GetDataAsyncCallback
implements|implements
name|AsyncCallback
operator|.
name|DataCallback
block|{
specifier|private
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|GetDataAsyncCallback
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|processResult
parameter_list|(
name|int
name|rc
parameter_list|,
name|String
name|path
parameter_list|,
name|Object
name|ctx
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|Stat
name|stat
parameter_list|)
block|{
name|SplitLogCounters
operator|.
name|tot_wkr_get_data_result
operator|.
name|increment
argument_list|()
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"getdata rc = "
operator|+
name|KeeperException
operator|.
name|Code
operator|.
name|get
argument_list|(
name|rc
argument_list|)
operator|+
literal|" "
operator|+
name|path
argument_list|)
expr_stmt|;
name|getDataSetWatchFailure
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|data
operator|=
name|ZKMetadata
operator|.
name|removeMetaData
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|getDataSetWatchSuccess
argument_list|(
name|path
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Next part is related to WALSplitterHandler    */
comment|/**    * endTask() can fail and the only way to recover out of it is for the    * {@link org.apache.hadoop.hbase.master.SplitLogManager} to timeout the task node.    * @param slt    * @param ctr    */
annotation|@
name|Override
specifier|public
name|void
name|endTask
parameter_list|(
name|SplitLogTask
name|slt
parameter_list|,
name|LongAdder
name|ctr
parameter_list|,
name|SplitTaskDetails
name|details
parameter_list|)
block|{
name|ZkSplitTaskDetails
name|zkDetails
init|=
operator|(
name|ZkSplitTaskDetails
operator|)
name|details
decl_stmt|;
name|String
name|task
init|=
name|zkDetails
operator|.
name|getTaskNode
argument_list|()
decl_stmt|;
name|int
name|taskZKVersion
init|=
name|zkDetails
operator|.
name|getCurTaskZKVersion
argument_list|()
operator|.
name|intValue
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|ZKUtil
operator|.
name|setData
argument_list|(
name|watcher
argument_list|,
name|task
argument_list|,
name|slt
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|taskZKVersion
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"successfully transitioned task "
operator|+
name|task
operator|+
literal|" to final state "
operator|+
name|slt
argument_list|)
expr_stmt|;
name|ctr
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to transistion task "
operator|+
name|task
operator|+
literal|" to end state "
operator|+
name|slt
operator|+
literal|" because of version mismatch "
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|BadVersionException
name|bve
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"transisition task "
operator|+
name|task
operator|+
literal|" to "
operator|+
name|slt
operator|+
literal|" failed because of version mismatch"
argument_list|,
name|bve
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|HBaseMarkers
operator|.
name|FATAL
argument_list|,
literal|"logic error - end task "
operator|+
name|task
operator|+
literal|" "
operator|+
name|slt
operator|+
literal|" failed because task doesn't exist"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to end task, "
operator|+
name|task
operator|+
literal|" "
operator|+
name|slt
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|SplitLogCounters
operator|.
name|tot_wkr_final_transition_failed
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
comment|/**    * When ZK-based implementation wants to complete the task, it needs to know task znode and    * current znode cversion (needed for subsequent update operation).    */
specifier|public
specifier|static
class|class
name|ZkSplitTaskDetails
implements|implements
name|SplitTaskDetails
block|{
specifier|private
name|String
name|taskNode
decl_stmt|;
specifier|private
name|MutableInt
name|curTaskZKVersion
decl_stmt|;
specifier|public
name|ZkSplitTaskDetails
parameter_list|()
block|{     }
specifier|public
name|ZkSplitTaskDetails
parameter_list|(
name|String
name|taskNode
parameter_list|,
name|MutableInt
name|curTaskZKVersion
parameter_list|)
block|{
name|this
operator|.
name|taskNode
operator|=
name|taskNode
expr_stmt|;
name|this
operator|.
name|curTaskZKVersion
operator|=
name|curTaskZKVersion
expr_stmt|;
block|}
specifier|public
name|String
name|getTaskNode
parameter_list|()
block|{
return|return
name|taskNode
return|;
block|}
specifier|public
name|void
name|setTaskNode
parameter_list|(
name|String
name|taskNode
parameter_list|)
block|{
name|this
operator|.
name|taskNode
operator|=
name|taskNode
expr_stmt|;
block|}
specifier|public
name|MutableInt
name|getCurTaskZKVersion
parameter_list|()
block|{
return|return
name|curTaskZKVersion
return|;
block|}
specifier|public
name|void
name|setCurTaskZKVersion
parameter_list|(
name|MutableInt
name|curTaskZKVersion
parameter_list|)
block|{
name|this
operator|.
name|curTaskZKVersion
operator|=
name|curTaskZKVersion
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getWALFile
parameter_list|()
block|{
return|return
name|ZKSplitLog
operator|.
name|getFileName
argument_list|(
name|taskNode
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

