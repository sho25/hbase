begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coordination
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|LongAdder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|RandomUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|mutable
operator|.
name|MutableInt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|SplitLogCounters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|SplitLogTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClusterStatusProtos
operator|.
name|RegionStoreSequenceIds
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ZooKeeperProtos
operator|.
name|SplitLogTask
operator|.
name|RecoveryMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionServerServices
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|SplitLogWorker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|SplitLogWorker
operator|.
name|TaskExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|FinishRegionRecoveringHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|WALSplitterHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CancelableProgressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|AbstractFSWALProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RecoverableZooKeeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKSplitLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_comment
comment|/**  * ZooKeeper based implementation of {@link SplitLogWorkerCoordination}  * It listen for changes in ZooKeeper and  *  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|ZkSplitLogWorkerCoordination
extends|extends
name|ZooKeeperListener
implements|implements
name|SplitLogWorkerCoordination
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ZkSplitLogWorkerCoordination
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|checkInterval
init|=
literal|5000
decl_stmt|;
comment|// 5 seconds
specifier|private
specifier|static
specifier|final
name|int
name|FAILED_TO_OWN_TASK
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|SplitLogWorker
name|worker
decl_stmt|;
specifier|private
name|TaskExecutor
name|splitTaskExecutor
decl_stmt|;
specifier|private
specifier|final
name|Object
name|taskReadyLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|AtomicInteger
name|taskReadySeq
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|String
name|currentTask
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|currentVersion
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|shouldStop
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|Object
name|grabTaskLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|workerInGrabTask
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|reportPeriod
decl_stmt|;
specifier|private
name|RegionServerServices
name|server
init|=
literal|null
decl_stmt|;
specifier|protected
specifier|final
name|AtomicInteger
name|tasksInProgress
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
name|int
name|maxConcurrentTasks
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|ServerName
name|serverName
decl_stmt|;
specifier|public
name|ZkSplitLogWorkerCoordination
parameter_list|(
name|ServerName
name|serverName
parameter_list|,
name|ZooKeeperWatcher
name|watcher
parameter_list|)
block|{
name|super
argument_list|(
name|watcher
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
block|}
comment|/**    * Override handler from {@link ZooKeeperListener}    */
annotation|@
name|Override
specifier|public
name|void
name|nodeChildrenChanged
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
name|watcher
operator|.
name|znodePaths
operator|.
name|splitLogZNode
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"tasks arrived or departed on "
operator|+
name|path
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|taskReadyLock
init|)
block|{
name|this
operator|.
name|taskReadySeq
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|taskReadyLock
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Override handler from {@link ZooKeeperListener}    */
annotation|@
name|Override
specifier|public
name|void
name|nodeDataChanged
parameter_list|(
name|String
name|path
parameter_list|)
block|{
comment|// there will be a self generated dataChanged event every time attemptToOwnTask()
comment|// heartbeats the task znode by upping its version
synchronized|synchronized
init|(
name|grabTaskLock
init|)
block|{
if|if
condition|(
name|workerInGrabTask
condition|)
block|{
comment|// currentTask can change
name|String
name|taskpath
init|=
name|currentTask
decl_stmt|;
if|if
condition|(
name|taskpath
operator|!=
literal|null
operator|&&
name|taskpath
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|getDataSetWatchAsync
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Override setter from {@link SplitLogWorkerCoordination}    */
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|(
name|RegionServerServices
name|server
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|TaskExecutor
name|splitExecutor
parameter_list|,
name|SplitLogWorker
name|worker
parameter_list|)
block|{
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
name|this
operator|.
name|worker
operator|=
name|worker
expr_stmt|;
name|this
operator|.
name|splitTaskExecutor
operator|=
name|splitExecutor
expr_stmt|;
name|maxConcurrentTasks
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.wal.max.splitters"
argument_list|,
name|DEFAULT_MAX_SPLITTERS
argument_list|)
expr_stmt|;
name|reportPeriod
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.splitlog.report.period"
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_SPLITLOG_MANAGER_TIMEOUT
argument_list|,
name|ZKSplitLogManagerCoordination
operator|.
name|DEFAULT_TIMEOUT
argument_list|)
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* Support functions for ZooKeeper async callback */
name|void
name|getDataSetWatchFailure
parameter_list|(
name|String
name|path
parameter_list|)
block|{
synchronized|synchronized
init|(
name|grabTaskLock
init|)
block|{
if|if
condition|(
name|workerInGrabTask
condition|)
block|{
comment|// currentTask can change but that's ok
name|String
name|taskpath
init|=
name|currentTask
decl_stmt|;
if|if
condition|(
name|taskpath
operator|!=
literal|null
operator|&&
name|taskpath
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"retrying data watch on "
operator|+
name|path
argument_list|)
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_get_data_retry
operator|.
name|increment
argument_list|()
expr_stmt|;
name|getDataSetWatchAsync
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// no point setting a watch on the task which this worker is not
comment|// working upon anymore
block|}
block|}
block|}
block|}
specifier|public
name|void
name|getDataSetWatchAsync
parameter_list|()
block|{
name|watcher
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getZooKeeper
argument_list|()
operator|.
name|getData
argument_list|(
name|currentTask
argument_list|,
name|watcher
argument_list|,
operator|new
name|GetDataAsyncCallback
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_get_data_queued
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
name|void
name|getDataSetWatchSuccess
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
name|SplitLogTask
name|slt
decl_stmt|;
try|try
block|{
name|slt
operator|=
name|SplitLogTask
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed parse"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
synchronized|synchronized
init|(
name|grabTaskLock
init|)
block|{
if|if
condition|(
name|workerInGrabTask
condition|)
block|{
comment|// currentTask can change but that's ok
name|String
name|taskpath
init|=
name|currentTask
decl_stmt|;
if|if
condition|(
name|taskpath
operator|!=
literal|null
operator|&&
name|taskpath
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|// have to compare data. cannot compare version because then there
comment|// will be race with attemptToOwnTask()
comment|// cannot just check whether the node has been transitioned to
comment|// UNASSIGNED because by the time this worker sets the data watch
comment|// the node might have made two transitions - from owned by this
comment|// worker to unassigned to owned by another worker
if|if
condition|(
operator|!
name|slt
operator|.
name|isOwned
argument_list|(
name|serverName
argument_list|)
operator|&&
operator|!
name|slt
operator|.
name|isDone
argument_list|(
name|serverName
argument_list|)
operator|&&
operator|!
name|slt
operator|.
name|isErr
argument_list|(
name|serverName
argument_list|)
operator|&&
operator|!
name|slt
operator|.
name|isResigned
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"task "
operator|+
name|taskpath
operator|+
literal|" preempted from "
operator|+
name|serverName
operator|+
literal|", current task state and owner="
operator|+
name|slt
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|worker
operator|.
name|stopTask
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * try to grab a 'lock' on the task zk node to own and execute the task.    *<p>    * @param path zk node for the task    */
specifier|private
name|void
name|grabTask
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
synchronized|synchronized
init|(
name|grabTaskLock
init|)
block|{
name|currentTask
operator|=
name|path
expr_stmt|;
name|workerInGrabTask
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
try|try
block|{
try|try
block|{
if|if
condition|(
operator|(
name|data
operator|=
name|ZKUtil
operator|.
name|getDataNoWatch
argument_list|(
name|watcher
argument_list|,
name|path
argument_list|,
name|stat
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|SplitLogCounters
operator|.
name|tot_wkr_failed_to_grab_task_no_data
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get data for znode "
operator|+
name|path
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_failed_to_grab_task_exception
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return;
block|}
name|SplitLogTask
name|slt
decl_stmt|;
try|try
block|{
name|slt
operator|=
name|SplitLogTask
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed parse data for znode "
operator|+
name|path
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_failed_to_grab_task_exception
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|slt
operator|.
name|isUnassigned
argument_list|()
condition|)
block|{
name|SplitLogCounters
operator|.
name|tot_wkr_failed_to_grab_task_owned
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return;
block|}
name|currentVersion
operator|=
name|attemptToOwnTask
argument_list|(
literal|true
argument_list|,
name|watcher
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|path
argument_list|,
name|slt
operator|.
name|getMode
argument_list|()
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentVersion
operator|<
literal|0
condition|)
block|{
name|SplitLogCounters
operator|.
name|tot_wkr_failed_to_grab_task_lost_race
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ZKSplitLog
operator|.
name|isRescanNode
argument_list|(
name|watcher
argument_list|,
name|currentTask
argument_list|)
condition|)
block|{
name|ZkSplitLogWorkerCoordination
operator|.
name|ZkSplitTaskDetails
name|splitTaskDetails
init|=
operator|new
name|ZkSplitLogWorkerCoordination
operator|.
name|ZkSplitTaskDetails
argument_list|()
decl_stmt|;
name|splitTaskDetails
operator|.
name|setTaskNode
argument_list|(
name|currentTask
argument_list|)
expr_stmt|;
name|splitTaskDetails
operator|.
name|setCurTaskZKVersion
argument_list|(
operator|new
name|MutableInt
argument_list|(
name|currentVersion
argument_list|)
argument_list|)
expr_stmt|;
name|endTask
argument_list|(
operator|new
name|SplitLogTask
operator|.
name|Done
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|slt
operator|.
name|getMode
argument_list|()
argument_list|)
argument_list|,
name|SplitLogCounters
operator|.
name|tot_wkr_task_acquired_rescan
argument_list|,
name|splitTaskDetails
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"worker "
operator|+
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|" acquired task "
operator|+
name|path
argument_list|)
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_task_acquired
operator|.
name|increment
argument_list|()
expr_stmt|;
name|getDataSetWatchAsync
argument_list|()
expr_stmt|;
name|submitTask
argument_list|(
name|path
argument_list|,
name|slt
operator|.
name|getMode
argument_list|()
argument_list|,
name|currentVersion
argument_list|,
name|reportPeriod
argument_list|)
expr_stmt|;
comment|// after a successful submit, sleep a little bit to allow other RSs to grab the rest tasks
try|try
block|{
name|int
name|sleepTime
init|=
name|RandomUtils
operator|.
name|nextInt
argument_list|(
literal|0
argument_list|,
literal|500
argument_list|)
operator|+
literal|500
decl_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while yielding for other region servers"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|grabTaskLock
init|)
block|{
name|workerInGrabTask
operator|=
literal|false
expr_stmt|;
comment|// clear the interrupt from stopTask() otherwise the next task will
comment|// suffer
name|Thread
operator|.
name|interrupted
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Submit a log split task to executor service    * @param curTask task to submit    * @param curTaskZKVersion current version of task    */
name|void
name|submitTask
parameter_list|(
specifier|final
name|String
name|curTask
parameter_list|,
specifier|final
name|RecoveryMode
name|mode
parameter_list|,
specifier|final
name|int
name|curTaskZKVersion
parameter_list|,
specifier|final
name|int
name|reportPeriod
parameter_list|)
block|{
specifier|final
name|MutableInt
name|zkVersion
init|=
operator|new
name|MutableInt
argument_list|(
name|curTaskZKVersion
argument_list|)
decl_stmt|;
name|CancelableProgressable
name|reporter
init|=
operator|new
name|CancelableProgressable
argument_list|()
block|{
specifier|private
name|long
name|last_report_at
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|progress
parameter_list|()
block|{
name|long
name|t
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|-
name|last_report_at
operator|)
operator|>
name|reportPeriod
condition|)
block|{
name|last_report_at
operator|=
name|t
expr_stmt|;
name|int
name|latestZKVersion
init|=
name|attemptToOwnTask
argument_list|(
literal|false
argument_list|,
name|watcher
argument_list|,
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|curTask
argument_list|,
name|mode
argument_list|,
name|zkVersion
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|latestZKVersion
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to heartbeat the task"
operator|+
name|curTask
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|zkVersion
operator|.
name|setValue
argument_list|(
name|latestZKVersion
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|ZkSplitLogWorkerCoordination
operator|.
name|ZkSplitTaskDetails
name|splitTaskDetails
init|=
operator|new
name|ZkSplitLogWorkerCoordination
operator|.
name|ZkSplitTaskDetails
argument_list|()
decl_stmt|;
name|splitTaskDetails
operator|.
name|setTaskNode
argument_list|(
name|curTask
argument_list|)
expr_stmt|;
name|splitTaskDetails
operator|.
name|setCurTaskZKVersion
argument_list|(
name|zkVersion
argument_list|)
expr_stmt|;
name|WALSplitterHandler
name|hsh
init|=
operator|new
name|WALSplitterHandler
argument_list|(
name|server
argument_list|,
name|this
argument_list|,
name|splitTaskDetails
argument_list|,
name|reporter
argument_list|,
name|this
operator|.
name|tasksInProgress
argument_list|,
name|splitTaskExecutor
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|server
operator|.
name|getExecutorService
argument_list|()
operator|.
name|submit
argument_list|(
name|hsh
argument_list|)
expr_stmt|;
block|}
comment|/**    * This function calculates how many splitters it could create based on expected average tasks per    * RS and the hard limit upper bound(maxConcurrentTasks) set by configuration.<br>    * At any given time, a RS allows spawn MIN(Expected Tasks/RS, Hard Upper Bound)    * @param numTasks current total number of available tasks    */
specifier|private
name|int
name|calculateAvailableSplitters
parameter_list|(
name|int
name|numTasks
parameter_list|)
block|{
comment|// at lease one RS(itself) available
name|int
name|availableRSs
init|=
literal|1
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|regionServers
init|=
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|znodePaths
operator|.
name|rsZNode
argument_list|)
decl_stmt|;
name|availableRSs
operator|=
name|Math
operator|.
name|max
argument_list|(
name|availableRSs
argument_list|,
operator|(
name|regionServers
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|regionServers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
comment|// do nothing
name|LOG
operator|.
name|debug
argument_list|(
literal|"getAvailableRegionServers got ZooKeeper exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|int
name|expectedTasksPerRS
init|=
operator|(
name|numTasks
operator|/
name|availableRSs
operator|)
operator|+
operator|(
operator|(
name|numTasks
operator|%
name|availableRSs
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|expectedTasksPerRS
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|expectedTasksPerRS
argument_list|)
expr_stmt|;
comment|// at least be one
comment|// calculate how many more splitters we could spawn
return|return
name|Math
operator|.
name|min
argument_list|(
name|expectedTasksPerRS
argument_list|,
name|maxConcurrentTasks
argument_list|)
operator|-
name|this
operator|.
name|tasksInProgress
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Try to own the task by transitioning the zk node data from UNASSIGNED to OWNED.    *<p>    * This method is also used to periodically heartbeat the task progress by transitioning the node    * from OWNED to OWNED.    *<p>    * @param isFirstTime shows whther it's the first attempt.    * @param zkw zk wathcer    * @param server name    * @param task to own    * @param taskZKVersion version of the task in zk    * @return non-negative integer value when task can be owned by current region server otherwise -1    */
specifier|protected
specifier|static
name|int
name|attemptToOwnTask
parameter_list|(
name|boolean
name|isFirstTime
parameter_list|,
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|ServerName
name|server
parameter_list|,
name|String
name|task
parameter_list|,
name|RecoveryMode
name|mode
parameter_list|,
name|int
name|taskZKVersion
parameter_list|)
block|{
name|int
name|latestZKVersion
init|=
name|FAILED_TO_OWN_TASK
decl_stmt|;
try|try
block|{
name|SplitLogTask
name|slt
init|=
operator|new
name|SplitLogTask
operator|.
name|Owned
argument_list|(
name|server
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|Stat
name|stat
init|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|setData
argument_list|(
name|task
argument_list|,
name|slt
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|taskZKVersion
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"zk.setData() returned null for path "
operator|+
name|task
argument_list|)
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_task_heartbeat_failed
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return
name|FAILED_TO_OWN_TASK
return|;
block|}
name|latestZKVersion
operator|=
name|stat
operator|.
name|getVersion
argument_list|()
expr_stmt|;
name|SplitLogCounters
operator|.
name|tot_wkr_task_heartbeat
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return
name|latestZKVersion
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isFirstTime
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|.
name|equals
argument_list|(
name|KeeperException
operator|.
name|Code
operator|.
name|NONODE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"NONODE failed to assert ownership for "
operator|+
name|task
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|code
argument_list|()
operator|.
name|equals
argument_list|(
name|KeeperException
operator|.
name|Code
operator|.
name|BADVERSION
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"BADVERSION failed to assert ownership for "
operator|+
name|task
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to assert ownership for "
operator|+
name|task
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while trying to assert ownership of "
operator|+
name|task
operator|+
literal|" "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e1
argument_list|)
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|SplitLogCounters
operator|.
name|tot_wkr_task_heartbeat_failed
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return
name|FAILED_TO_OWN_TASK
return|;
block|}
comment|/**    * Wait for tasks to become available at /hbase/splitlog zknode. Grab a task one at a time. This    * policy puts an upper-limit on the number of simultaneous log splitting that could be happening    * in a cluster.    *<p>    * Synchronization using<code>taskReadyLock</code> ensures that it will try to grab every task    * that has been put up    * @throws InterruptedException    */
annotation|@
name|Override
specifier|public
name|void
name|taskLoop
parameter_list|()
throws|throws
name|InterruptedException
block|{
while|while
condition|(
operator|!
name|shouldStop
condition|)
block|{
name|int
name|seq_start
init|=
name|taskReadySeq
operator|.
name|get
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
literal|null
decl_stmt|;
name|paths
operator|=
name|getTaskList
argument_list|()
expr_stmt|;
if|if
condition|(
name|paths
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not get tasks, did someone remove "
operator|+
name|watcher
operator|.
name|znodePaths
operator|.
name|splitLogZNode
operator|+
literal|" ... worker thread exiting."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// pick meta wal firstly
name|int
name|offset
init|=
call|(
name|int
call|)
argument_list|(
name|Math
operator|.
name|random
argument_list|()
operator|*
name|paths
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|AbstractFSWALProvider
operator|.
name|isMetaFile
argument_list|(
name|paths
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|int
name|numTasks
init|=
name|paths
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTasks
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
operator|(
name|i
operator|+
name|offset
operator|)
operator|%
name|paths
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// don't call ZKSplitLog.getNodeName() because that will lead to
comment|// double encoding of the path name
if|if
condition|(
name|this
operator|.
name|calculateAvailableSplitters
argument_list|(
name|numTasks
argument_list|)
operator|>
literal|0
condition|)
block|{
name|grabTask
argument_list|(
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|watcher
operator|.
name|znodePaths
operator|.
name|splitLogZNode
argument_list|,
name|paths
operator|.
name|get
argument_list|(
name|idx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Current region server "
operator|+
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|" has "
operator|+
name|this
operator|.
name|tasksInProgress
operator|.
name|get
argument_list|()
operator|+
literal|" tasks in progress and can't take more."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|shouldStop
condition|)
block|{
return|return;
block|}
block|}
name|SplitLogCounters
operator|.
name|tot_wkr_task_grabing
operator|.
name|increment
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|taskReadyLock
init|)
block|{
while|while
condition|(
name|seq_start
operator|==
name|taskReadySeq
operator|.
name|get
argument_list|()
condition|)
block|{
name|taskReadyLock
operator|.
name|wait
argument_list|(
name|checkInterval
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|!=
literal|null
condition|)
block|{
comment|// check to see if we have stale recovering regions in our internal memory state
name|Map
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
name|recoveringRegions
init|=
name|server
operator|.
name|getRecoveringRegions
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|recoveringRegions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Make a local copy to prevent ConcurrentModificationException when other threads
comment|// modify recoveringRegions
name|List
argument_list|<
name|String
argument_list|>
name|tmpCopy
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|recoveringRegions
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|listSize
init|=
name|tmpCopy
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|listSize
condition|;
name|i
operator|++
control|)
block|{
name|String
name|region
init|=
name|tmpCopy
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|nodePath
init|=
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|watcher
operator|.
name|znodePaths
operator|.
name|recoveringRegionsZNode
argument_list|,
name|region
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|ZKUtil
operator|.
name|checkExists
argument_list|(
name|watcher
argument_list|,
name|nodePath
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|server
operator|.
name|getExecutorService
argument_list|()
operator|.
name|submit
argument_list|(
operator|new
name|FinishRegionRecoveringHandler
argument_list|(
name|server
argument_list|,
name|region
argument_list|,
name|nodePath
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// current check is a defensive(or redundant) mechanism to prevent us from
comment|// having stale recovering regions in our internal RS memory state while
comment|// zookeeper(source of truth) says differently. We stop at the first good one
comment|// because we should not have a single instance such as this in normal case so
comment|// check the first one is good enough.
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
comment|// ignore zookeeper error
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got a zookeeper when trying to open a recovering region"
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getTaskList
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|childrenPaths
init|=
literal|null
decl_stmt|;
name|long
name|sleepTime
init|=
literal|1000
decl_stmt|;
comment|// It will be in loop till it gets the list of children or
comment|// it will come out if worker thread exited.
while|while
condition|(
operator|!
name|shouldStop
condition|)
block|{
try|try
block|{
name|childrenPaths
operator|=
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|znodePaths
operator|.
name|splitLogZNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|childrenPaths
operator|!=
literal|null
condition|)
block|{
return|return
name|childrenPaths
return|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not get children of znode "
operator|+
name|watcher
operator|.
name|znodePaths
operator|.
name|splitLogZNode
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Retry listChildren of znode "
operator|+
name|watcher
operator|.
name|znodePaths
operator|.
name|splitLogZNode
operator|+
literal|" after sleep for "
operator|+
name|sleepTime
operator|+
literal|"ms!"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
return|return
name|childrenPaths
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|markCorrupted
parameter_list|(
name|Path
name|rootDir
parameter_list|,
name|String
name|name
parameter_list|,
name|FileSystem
name|fs
parameter_list|)
block|{
name|ZKSplitLog
operator|.
name|markCorrupted
argument_list|(
name|rootDir
argument_list|,
name|name
argument_list|,
name|fs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isReady
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
name|result
operator|=
name|ZKUtil
operator|.
name|checkExists
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|znodePaths
operator|.
name|splitLogZNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
comment|// ignore
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception when checking for "
operator|+
name|watcher
operator|.
name|znodePaths
operator|.
name|splitLogZNode
operator|+
literal|" ... retrying"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|watcher
operator|.
name|znodePaths
operator|.
name|splitLogZNode
operator|+
literal|" znode does not exist, waiting for master to create"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|!=
operator|-
literal|1
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getTaskReadySeq
parameter_list|()
block|{
return|return
name|taskReadySeq
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|registerListener
parameter_list|()
block|{
name|watcher
operator|.
name|registerListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeListener
parameter_list|()
block|{
name|watcher
operator|.
name|unregisterListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stopProcessingTasks
parameter_list|()
block|{
name|this
operator|.
name|shouldStop
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStop
parameter_list|()
block|{
return|return
name|shouldStop
return|;
block|}
annotation|@
name|Override
specifier|public
name|RegionStoreSequenceIds
name|getRegionFlushedSequenceId
parameter_list|(
name|String
name|failedServerName
parameter_list|,
name|String
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ZKSplitLog
operator|.
name|getRegionFlushedSequenceId
argument_list|(
name|watcher
argument_list|,
name|failedServerName
argument_list|,
name|key
argument_list|)
return|;
block|}
comment|/**    * Asynchronous handler for zk get-data-set-watch on node results.    */
class|class
name|GetDataAsyncCallback
implements|implements
name|AsyncCallback
operator|.
name|DataCallback
block|{
specifier|private
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|GetDataAsyncCallback
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|processResult
parameter_list|(
name|int
name|rc
parameter_list|,
name|String
name|path
parameter_list|,
name|Object
name|ctx
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|Stat
name|stat
parameter_list|)
block|{
name|SplitLogCounters
operator|.
name|tot_wkr_get_data_result
operator|.
name|increment
argument_list|()
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"getdata rc = "
operator|+
name|KeeperException
operator|.
name|Code
operator|.
name|get
argument_list|(
name|rc
argument_list|)
operator|+
literal|" "
operator|+
name|path
argument_list|)
expr_stmt|;
name|getDataSetWatchFailure
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|data
operator|=
name|RecoverableZooKeeper
operator|.
name|removeMetaData
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|getDataSetWatchSuccess
argument_list|(
name|path
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Next part is related to WALSplitterHandler    */
comment|/**    * endTask() can fail and the only way to recover out of it is for the    * {@link org.apache.hadoop.hbase.master.SplitLogManager} to timeout the task node.    * @param slt    * @param ctr    */
annotation|@
name|Override
specifier|public
name|void
name|endTask
parameter_list|(
name|SplitLogTask
name|slt
parameter_list|,
name|LongAdder
name|ctr
parameter_list|,
name|SplitTaskDetails
name|details
parameter_list|)
block|{
name|ZkSplitTaskDetails
name|zkDetails
init|=
operator|(
name|ZkSplitTaskDetails
operator|)
name|details
decl_stmt|;
name|String
name|task
init|=
name|zkDetails
operator|.
name|getTaskNode
argument_list|()
decl_stmt|;
name|int
name|taskZKVersion
init|=
name|zkDetails
operator|.
name|getCurTaskZKVersion
argument_list|()
operator|.
name|intValue
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|ZKUtil
operator|.
name|setData
argument_list|(
name|watcher
argument_list|,
name|task
argument_list|,
name|slt
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|taskZKVersion
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"successfully transitioned task "
operator|+
name|task
operator|+
literal|" to final state "
operator|+
name|slt
argument_list|)
expr_stmt|;
name|ctr
operator|.
name|increment
argument_list|()
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to transistion task "
operator|+
name|task
operator|+
literal|" to end state "
operator|+
name|slt
operator|+
literal|" because of version mismatch "
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|BadVersionException
name|bve
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"transisition task "
operator|+
name|task
operator|+
literal|" to "
operator|+
name|slt
operator|+
literal|" failed because of version mismatch"
argument_list|,
name|bve
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"logic error - end task "
operator|+
name|task
operator|+
literal|" "
operator|+
name|slt
operator|+
literal|" failed because task doesn't exist"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to end task, "
operator|+
name|task
operator|+
literal|" "
operator|+
name|slt
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|SplitLogCounters
operator|.
name|tot_wkr_final_transition_failed
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
comment|/**    * When ZK-based implementation wants to complete the task, it needs to know task znode and    * current znode cversion (needed for subsequent update operation).    */
specifier|public
specifier|static
class|class
name|ZkSplitTaskDetails
implements|implements
name|SplitTaskDetails
block|{
specifier|private
name|String
name|taskNode
decl_stmt|;
specifier|private
name|MutableInt
name|curTaskZKVersion
decl_stmt|;
specifier|public
name|ZkSplitTaskDetails
parameter_list|()
block|{     }
specifier|public
name|ZkSplitTaskDetails
parameter_list|(
name|String
name|taskNode
parameter_list|,
name|MutableInt
name|curTaskZKVersion
parameter_list|)
block|{
name|this
operator|.
name|taskNode
operator|=
name|taskNode
expr_stmt|;
name|this
operator|.
name|curTaskZKVersion
operator|=
name|curTaskZKVersion
expr_stmt|;
block|}
specifier|public
name|String
name|getTaskNode
parameter_list|()
block|{
return|return
name|taskNode
return|;
block|}
specifier|public
name|void
name|setTaskNode
parameter_list|(
name|String
name|taskNode
parameter_list|)
block|{
name|this
operator|.
name|taskNode
operator|=
name|taskNode
expr_stmt|;
block|}
specifier|public
name|MutableInt
name|getCurTaskZKVersion
parameter_list|()
block|{
return|return
name|curTaskZKVersion
return|;
block|}
specifier|public
name|void
name|setCurTaskZKVersion
parameter_list|(
name|MutableInt
name|curTaskZKVersion
parameter_list|)
block|{
name|this
operator|.
name|curTaskZKVersion
operator|=
name|curTaskZKVersion
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getWALFile
parameter_list|()
block|{
return|return
name|ZKSplitLog
operator|.
name|getFileName
argument_list|(
name|taskNode
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

