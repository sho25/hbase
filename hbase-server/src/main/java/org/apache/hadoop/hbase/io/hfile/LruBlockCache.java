begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|LongAdder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HeapSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HasThread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|MoreObjects
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|annotation
operator|.
name|JsonIgnore
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|annotation
operator|.
name|JsonIgnoreProperties
import|;
end_import

begin_comment
comment|/**  * A block cache implementation that is memory-aware using {@link HeapSize},  * memory-bound using an LRU eviction algorithm, and concurrent: backed by a  * {@link ConcurrentHashMap} and with a non-blocking eviction thread giving  * constant-time {@link #cacheBlock} and {@link #getBlock} operations.<p>  *  * Contains three levels of block priority to allow for scan-resistance and in-memory families  * {@link org.apache.hadoop.hbase.HColumnDescriptor#setInMemory(boolean)} (An in-memory column  * family is a column family that should be served from memory if possible):  * single-access, multiple-accesses, and in-memory priority.  * A block is added with an in-memory priority flag if  * {@link org.apache.hadoop.hbase.HColumnDescriptor#isInMemory()}, otherwise a block becomes a  * single access priority the first time it is read into this block cache.  If a block is  * accessed again while in cache, it is marked as a multiple access priority block.  This  * delineation of blocks is used to prevent scans from thrashing the cache adding a  * least-frequently-used element to the eviction algorithm.<p>  *  * Each priority is given its own chunk of the total cache to ensure  * fairness during eviction.  Each priority will retain close to its maximum  * size, however, if any priority is not using its entire chunk the others  * are able to grow beyond their chunk size.<p>  *  * Instantiated at a minimum with the total size and average block size.  * All sizes are in bytes.  The block size is not especially important as this  * cache is fully dynamic in its sizing of blocks.  It is only used for  * pre-allocating data structures and in initial heap estimation of the map.<p>  *  * The detailed constructor defines the sizes for the three priorities (they  * should total to the<code>maximum size</code> defined).  It also sets the levels that  * trigger and control the eviction thread.<p>  *  * The<code>acceptable size</code> is the cache size level which triggers the eviction  * process to start.  It evicts enough blocks to get the size below the  * minimum size specified.<p>  *  * Eviction happens in a separate thread and involves a single full-scan  * of the map.  It determines how many bytes must be freed to reach the minimum  * size, and then while scanning determines the fewest least-recently-used  * blocks necessary from each of the three priorities (would be 3 times bytes  * to free).  It then uses the priority chunk sizes to evict fairly according  * to the relative sizes and usage.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|JsonIgnoreProperties
argument_list|(
block|{
literal|"encodingCountsForTest"
block|}
argument_list|)
specifier|public
class|class
name|LruBlockCache
implements|implements
name|ResizableBlockCache
implements|,
name|HeapSize
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LruBlockCache
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Percentage of total size that eviction will evict until; e.g. if set to .8, then we will keep    * evicting during an eviction run till the cache size is down to 80% of the total.    */
specifier|private
specifier|static
specifier|final
name|String
name|LRU_MIN_FACTOR_CONFIG_NAME
init|=
literal|"hbase.lru.blockcache.min.factor"
decl_stmt|;
comment|/**    * Acceptable size of cache (no evictions if size< acceptable)    */
specifier|private
specifier|static
specifier|final
name|String
name|LRU_ACCEPTABLE_FACTOR_CONFIG_NAME
init|=
literal|"hbase.lru.blockcache.acceptable.factor"
decl_stmt|;
comment|/**    * Hard capacity limit of cache, will reject any put if size> this * acceptable    */
specifier|static
specifier|final
name|String
name|LRU_HARD_CAPACITY_LIMIT_FACTOR_CONFIG_NAME
init|=
literal|"hbase.lru.blockcache.hard.capacity.limit.factor"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|LRU_SINGLE_PERCENTAGE_CONFIG_NAME
init|=
literal|"hbase.lru.blockcache.single.percentage"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|LRU_MULTI_PERCENTAGE_CONFIG_NAME
init|=
literal|"hbase.lru.blockcache.multi.percentage"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|LRU_MEMORY_PERCENTAGE_CONFIG_NAME
init|=
literal|"hbase.lru.blockcache.memory.percentage"
decl_stmt|;
comment|/**    * Configuration key to force data-block always (except in-memory are too much)    * cached in memory for in-memory hfile, unlike inMemory, which is a column-family    * configuration, inMemoryForceMode is a cluster-wide configuration    */
specifier|private
specifier|static
specifier|final
name|String
name|LRU_IN_MEMORY_FORCE_MODE_CONFIG_NAME
init|=
literal|"hbase.lru.rs.inmemoryforcemode"
decl_stmt|;
comment|/* Default Configuration Parameters*/
comment|/* Backing Concurrent Map Configuration */
specifier|static
specifier|final
name|float
name|DEFAULT_LOAD_FACTOR
init|=
literal|0.75f
decl_stmt|;
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|16
decl_stmt|;
comment|/* Eviction thresholds */
specifier|private
specifier|static
specifier|final
name|float
name|DEFAULT_MIN_FACTOR
init|=
literal|0.95f
decl_stmt|;
specifier|static
specifier|final
name|float
name|DEFAULT_ACCEPTABLE_FACTOR
init|=
literal|0.99f
decl_stmt|;
comment|/* Priority buckets */
specifier|private
specifier|static
specifier|final
name|float
name|DEFAULT_SINGLE_FACTOR
init|=
literal|0.25f
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|DEFAULT_MULTI_FACTOR
init|=
literal|0.50f
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|DEFAULT_MEMORY_FACTOR
init|=
literal|0.25f
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|DEFAULT_HARD_CAPACITY_LIMIT_FACTOR
init|=
literal|1.2f
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|DEFAULT_IN_MEMORY_FORCE_MODE
init|=
literal|false
decl_stmt|;
comment|/* Statistics thread */
specifier|private
specifier|static
specifier|final
name|int
name|STAT_THREAD_PERIOD
init|=
literal|60
operator|*
literal|5
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|LRU_MAX_BLOCK_SIZE
init|=
literal|"hbase.lru.max.block.size"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|DEFAULT_MAX_BLOCK_SIZE
init|=
literal|16L
operator|*
literal|1024L
operator|*
literal|1024L
decl_stmt|;
comment|/** Concurrent map (the cache) */
specifier|private
specifier|final
name|Map
argument_list|<
name|BlockCacheKey
argument_list|,
name|LruCachedBlock
argument_list|>
name|map
decl_stmt|;
comment|/** Eviction lock (locked when eviction in process) */
specifier|private
specifier|final
name|ReentrantLock
name|evictionLock
init|=
operator|new
name|ReentrantLock
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|long
name|maxBlockSize
decl_stmt|;
comment|/** Volatile boolean to track if we are in an eviction process or not */
specifier|private
specifier|volatile
name|boolean
name|evictionInProgress
init|=
literal|false
decl_stmt|;
comment|/** Eviction thread */
specifier|private
specifier|final
name|EvictionThread
name|evictionThread
decl_stmt|;
comment|/** Statistics thread schedule pool (for heavy debugging, could remove) */
specifier|private
specifier|final
name|ScheduledExecutorService
name|scheduleThreadPool
init|=
name|Executors
operator|.
name|newScheduledThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"LruBlockCacheStatsExecutor"
argument_list|)
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Current size of cache */
specifier|private
specifier|final
name|AtomicLong
name|size
decl_stmt|;
comment|/** Current size of data blocks */
specifier|private
specifier|final
name|LongAdder
name|dataBlockSize
decl_stmt|;
comment|/** Current number of cached elements */
specifier|private
specifier|final
name|AtomicLong
name|elements
decl_stmt|;
comment|/** Current number of cached data block elements */
specifier|private
specifier|final
name|LongAdder
name|dataBlockElements
decl_stmt|;
comment|/** Cache access count (sequential ID) */
specifier|private
specifier|final
name|AtomicLong
name|count
decl_stmt|;
comment|/** hard capacity limit */
specifier|private
name|float
name|hardCapacityLimitFactor
decl_stmt|;
comment|/** Cache statistics */
specifier|private
specifier|final
name|CacheStats
name|stats
decl_stmt|;
comment|/** Maximum allowable size of cache (block put if size> max, evict) */
specifier|private
name|long
name|maxSize
decl_stmt|;
comment|/** Approximate block size */
specifier|private
name|long
name|blockSize
decl_stmt|;
comment|/** Acceptable size of cache (no evictions if size< acceptable) */
specifier|private
name|float
name|acceptableFactor
decl_stmt|;
comment|/** Minimum threshold of cache (when evicting, evict until size< min) */
specifier|private
name|float
name|minFactor
decl_stmt|;
comment|/** Single access bucket size */
specifier|private
name|float
name|singleFactor
decl_stmt|;
comment|/** Multiple access bucket size */
specifier|private
name|float
name|multiFactor
decl_stmt|;
comment|/** In-memory bucket size */
specifier|private
name|float
name|memoryFactor
decl_stmt|;
comment|/** Overhead of the structure itself */
specifier|private
name|long
name|overhead
decl_stmt|;
comment|/** Whether in-memory hfile's data block has higher priority when evicting */
specifier|private
name|boolean
name|forceInMemory
decl_stmt|;
comment|/**    * Where to send victims (blocks evicted/missing from the cache). This is used only when we use an    * external cache as L2.    * Note: See org.apache.hadoop.hbase.io.hfile.MemcachedBlockCache    */
specifier|private
name|BlockCache
name|victimHandler
init|=
literal|null
decl_stmt|;
comment|/**    * Default constructor.  Specify maximum size and expected average block    * size (approximation is fine).    *    *<p>All other factors will be calculated based on defaults specified in    * this class.    *    * @param maxSize   maximum size of cache, in bytes    * @param blockSize approximate size of each block, in bytes    */
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|)
block|{
name|this
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor used for testing.  Allows disabling of the eviction thread.    */
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|boolean
name|evictionThread
parameter_list|)
block|{
name|this
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
name|evictionThread
argument_list|,
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
literal|1.2
operator|*
name|maxSize
operator|/
name|blockSize
argument_list|)
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|,
name|DEFAULT_CONCURRENCY_LEVEL
argument_list|,
name|DEFAULT_MIN_FACTOR
argument_list|,
name|DEFAULT_ACCEPTABLE_FACTOR
argument_list|,
name|DEFAULT_SINGLE_FACTOR
argument_list|,
name|DEFAULT_MULTI_FACTOR
argument_list|,
name|DEFAULT_MEMORY_FACTOR
argument_list|,
name|DEFAULT_HARD_CAPACITY_LIMIT_FACTOR
argument_list|,
literal|false
argument_list|,
name|DEFAULT_MAX_BLOCK_SIZE
argument_list|)
expr_stmt|;
block|}
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|boolean
name|evictionThread
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
name|evictionThread
argument_list|,
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
literal|1.2
operator|*
name|maxSize
operator|/
name|blockSize
argument_list|)
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|,
name|DEFAULT_CONCURRENCY_LEVEL
argument_list|,
name|conf
operator|.
name|getFloat
argument_list|(
name|LRU_MIN_FACTOR_CONFIG_NAME
argument_list|,
name|DEFAULT_MIN_FACTOR
argument_list|)
argument_list|,
name|conf
operator|.
name|getFloat
argument_list|(
name|LRU_ACCEPTABLE_FACTOR_CONFIG_NAME
argument_list|,
name|DEFAULT_ACCEPTABLE_FACTOR
argument_list|)
argument_list|,
name|conf
operator|.
name|getFloat
argument_list|(
name|LRU_SINGLE_PERCENTAGE_CONFIG_NAME
argument_list|,
name|DEFAULT_SINGLE_FACTOR
argument_list|)
argument_list|,
name|conf
operator|.
name|getFloat
argument_list|(
name|LRU_MULTI_PERCENTAGE_CONFIG_NAME
argument_list|,
name|DEFAULT_MULTI_FACTOR
argument_list|)
argument_list|,
name|conf
operator|.
name|getFloat
argument_list|(
name|LRU_MEMORY_PERCENTAGE_CONFIG_NAME
argument_list|,
name|DEFAULT_MEMORY_FACTOR
argument_list|)
argument_list|,
name|conf
operator|.
name|getFloat
argument_list|(
name|LRU_HARD_CAPACITY_LIMIT_FACTOR_CONFIG_NAME
argument_list|,
name|DEFAULT_HARD_CAPACITY_LIMIT_FACTOR
argument_list|)
argument_list|,
name|conf
operator|.
name|getBoolean
argument_list|(
name|LRU_IN_MEMORY_FORCE_MODE_CONFIG_NAME
argument_list|,
name|DEFAULT_IN_MEMORY_FORCE_MODE
argument_list|)
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|LRU_MAX_BLOCK_SIZE
argument_list|,
name|DEFAULT_MAX_BLOCK_SIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
literal|true
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Configurable constructor.  Use this constructor if not using defaults.    *    * @param maxSize             maximum size of this cache, in bytes    * @param blockSize           expected average size of blocks, in bytes    * @param evictionThread      whether to run evictions in a bg thread or not    * @param mapInitialSize      initial size of backing ConcurrentHashMap    * @param mapLoadFactor       initial load factor of backing ConcurrentHashMap    * @param mapConcurrencyLevel initial concurrency factor for backing CHM    * @param minFactor           percentage of total size that eviction will evict until    * @param acceptableFactor    percentage of total size that triggers eviction    * @param singleFactor        percentage of total size for single-access blocks    * @param multiFactor         percentage of total size for multiple-access blocks    * @param memoryFactor        percentage of total size for in-memory blocks    */
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|boolean
name|evictionThread
parameter_list|,
name|int
name|mapInitialSize
parameter_list|,
name|float
name|mapLoadFactor
parameter_list|,
name|int
name|mapConcurrencyLevel
parameter_list|,
name|float
name|minFactor
parameter_list|,
name|float
name|acceptableFactor
parameter_list|,
name|float
name|singleFactor
parameter_list|,
name|float
name|multiFactor
parameter_list|,
name|float
name|memoryFactor
parameter_list|,
name|float
name|hardLimitFactor
parameter_list|,
name|boolean
name|forceInMemory
parameter_list|,
name|long
name|maxBlockSize
parameter_list|)
block|{
name|this
operator|.
name|maxBlockSize
operator|=
name|maxBlockSize
expr_stmt|;
if|if
condition|(
name|singleFactor
operator|+
name|multiFactor
operator|+
name|memoryFactor
operator|!=
literal|1
operator|||
name|singleFactor
operator|<
literal|0
operator|||
name|multiFactor
operator|<
literal|0
operator|||
name|memoryFactor
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Single, multi, and memory factors "
operator|+
literal|" should be non-negative and total 1.0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|minFactor
operator|>=
name|acceptableFactor
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"minFactor must be smaller than acceptableFactor"
argument_list|)
throw|;
block|}
if|if
condition|(
name|minFactor
operator|>=
literal|1.0f
operator|||
name|acceptableFactor
operator|>=
literal|1.0f
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"all factors must be< 1"
argument_list|)
throw|;
block|}
name|this
operator|.
name|maxSize
operator|=
name|maxSize
expr_stmt|;
name|this
operator|.
name|blockSize
operator|=
name|blockSize
expr_stmt|;
name|this
operator|.
name|forceInMemory
operator|=
name|forceInMemory
expr_stmt|;
name|map
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|(
name|mapInitialSize
argument_list|,
name|mapLoadFactor
argument_list|,
name|mapConcurrencyLevel
argument_list|)
expr_stmt|;
name|this
operator|.
name|minFactor
operator|=
name|minFactor
expr_stmt|;
name|this
operator|.
name|acceptableFactor
operator|=
name|acceptableFactor
expr_stmt|;
name|this
operator|.
name|singleFactor
operator|=
name|singleFactor
expr_stmt|;
name|this
operator|.
name|multiFactor
operator|=
name|multiFactor
expr_stmt|;
name|this
operator|.
name|memoryFactor
operator|=
name|memoryFactor
expr_stmt|;
name|this
operator|.
name|stats
operator|=
operator|new
name|CacheStats
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|elements
operator|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|dataBlockElements
operator|=
operator|new
name|LongAdder
argument_list|()
expr_stmt|;
name|this
operator|.
name|dataBlockSize
operator|=
operator|new
name|LongAdder
argument_list|()
expr_stmt|;
name|this
operator|.
name|overhead
operator|=
name|calculateOverhead
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
name|mapConcurrencyLevel
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|=
operator|new
name|AtomicLong
argument_list|(
name|this
operator|.
name|overhead
argument_list|)
expr_stmt|;
name|this
operator|.
name|hardCapacityLimitFactor
operator|=
name|hardLimitFactor
expr_stmt|;
if|if
condition|(
name|evictionThread
condition|)
block|{
name|this
operator|.
name|evictionThread
operator|=
operator|new
name|EvictionThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|evictionThread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// FindBugs SC_START_IN_CTOR
block|}
else|else
block|{
name|this
operator|.
name|evictionThread
operator|=
literal|null
expr_stmt|;
block|}
comment|// TODO: Add means of turning this off.  Bit obnoxious running thread just to make a log
comment|// every five minutes.
name|this
operator|.
name|scheduleThreadPool
operator|.
name|scheduleAtFixedRate
argument_list|(
operator|new
name|StatisticsThread
argument_list|(
name|this
argument_list|)
argument_list|,
name|STAT_THREAD_PERIOD
argument_list|,
name|STAT_THREAD_PERIOD
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setMaxSize
parameter_list|(
name|long
name|maxSize
parameter_list|)
block|{
name|this
operator|.
name|maxSize
operator|=
name|maxSize
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|size
operator|.
name|get
argument_list|()
operator|>
name|acceptableSize
argument_list|()
operator|&&
operator|!
name|evictionInProgress
condition|)
block|{
name|runEviction
argument_list|()
expr_stmt|;
block|}
block|}
comment|// BlockCache implementation
comment|/**    * Cache the block with the specified name and buffer.    *<p>    * It is assumed this will NOT be called on an already cached block. In rare cases (HBASE-8547)    * this can happen, for which we compare the buffer contents.    *    * @param cacheKey block's cache key    * @param buf      block buffer    * @param inMemory if block is in-memory    */
annotation|@
name|Override
specifier|public
name|void
name|cacheBlock
parameter_list|(
name|BlockCacheKey
name|cacheKey
parameter_list|,
name|Cacheable
name|buf
parameter_list|,
name|boolean
name|inMemory
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|.
name|heapSize
argument_list|()
operator|>
name|maxBlockSize
condition|)
block|{
comment|// If there are a lot of blocks that are too
comment|// big this can make the logs way too noisy.
comment|// So we log 2%
if|if
condition|(
name|stats
operator|.
name|failInsert
argument_list|()
operator|%
literal|50
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Trying to cache too large a block "
operator|+
name|cacheKey
operator|.
name|getHfileName
argument_list|()
operator|+
literal|" @ "
operator|+
name|cacheKey
operator|.
name|getOffset
argument_list|()
operator|+
literal|" is "
operator|+
name|buf
operator|.
name|heapSize
argument_list|()
operator|+
literal|" which is larger than "
operator|+
name|maxBlockSize
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|LruCachedBlock
name|cb
init|=
name|map
operator|.
name|get
argument_list|(
name|cacheKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
operator|!=
literal|null
condition|)
block|{
name|int
name|comparison
init|=
name|BlockCacheUtil
operator|.
name|validateBlockAddition
argument_list|(
name|cb
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|buf
argument_list|,
name|cacheKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|comparison
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|comparison
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cached block contents differ by nextBlockOnDiskSize. Keeping cached block."
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cached block contents differ by nextBlockOnDiskSize. Caching new block."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"Cached an already cached block: "
operator|+
name|cacheKey
operator|+
literal|" cb:"
operator|+
name|cb
operator|.
name|getCacheKey
argument_list|()
decl_stmt|;
name|msg
operator|+=
literal|". This is harmless and can happen in rare cases (see HBASE-8547)"
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|long
name|currentSize
init|=
name|size
operator|.
name|get
argument_list|()
decl_stmt|;
name|long
name|currentAcceptableSize
init|=
name|acceptableSize
argument_list|()
decl_stmt|;
name|long
name|hardLimitSize
init|=
call|(
name|long
call|)
argument_list|(
name|hardCapacityLimitFactor
operator|*
name|currentAcceptableSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentSize
operator|>=
name|hardLimitSize
condition|)
block|{
name|stats
operator|.
name|failInsert
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"LruBlockCache current size "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|currentSize
argument_list|)
operator|+
literal|" has exceeded acceptable size "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|currentAcceptableSize
argument_list|)
operator|+
literal|"."
operator|+
literal|" The hard limit size is "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|hardLimitSize
argument_list|)
operator|+
literal|", failed to put cacheKey:"
operator|+
name|cacheKey
operator|+
literal|" into LruBlockCache."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|evictionInProgress
condition|)
block|{
name|runEviction
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|cb
operator|=
operator|new
name|LruCachedBlock
argument_list|(
name|cacheKey
argument_list|,
name|buf
argument_list|,
name|count
operator|.
name|incrementAndGet
argument_list|()
argument_list|,
name|inMemory
argument_list|)
expr_stmt|;
name|long
name|newSize
init|=
name|updateSizeMetrics
argument_list|(
name|cb
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|cacheKey
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|long
name|val
init|=
name|elements
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|buf
operator|.
name|getBlockType
argument_list|()
operator|.
name|isData
argument_list|()
condition|)
block|{
name|dataBlockElements
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|long
name|size
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|assertCounterSanity
argument_list|(
name|size
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newSize
operator|>
name|currentAcceptableSize
operator|&&
operator|!
name|evictionInProgress
condition|)
block|{
name|runEviction
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Sanity-checking for parity between actual block cache content and metrics.    * Intended only for use with TRACE level logging and -ea JVM.    */
specifier|private
specifier|static
name|void
name|assertCounterSanity
parameter_list|(
name|long
name|mapSize
parameter_list|,
name|long
name|counterVal
parameter_list|)
block|{
if|if
condition|(
name|counterVal
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"counterVal overflow. Assertions unreliable. counterVal="
operator|+
name|counterVal
operator|+
literal|", mapSize="
operator|+
name|mapSize
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mapSize
operator|<
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|double
name|pct_diff
init|=
name|Math
operator|.
name|abs
argument_list|(
operator|(
operator|(
operator|(
name|double
operator|)
name|counterVal
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|mapSize
operator|)
operator|)
operator|-
literal|1.
argument_list|)
decl_stmt|;
if|if
condition|(
name|pct_diff
operator|>
literal|0.05
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"delta between reported and actual size> 5%. counterVal="
operator|+
name|counterVal
operator|+
literal|", mapSize="
operator|+
name|mapSize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Cache the block with the specified name and buffer.    *<p>    *    * @param cacheKey block's cache key    * @param buf      block buffer    */
annotation|@
name|Override
specifier|public
name|void
name|cacheBlock
parameter_list|(
name|BlockCacheKey
name|cacheKey
parameter_list|,
name|Cacheable
name|buf
parameter_list|)
block|{
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|buf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Helper function that updates the local size counter and also updates any    * per-cf or per-blocktype metrics it can discern from given    * {@link LruCachedBlock}    */
specifier|private
name|long
name|updateSizeMetrics
parameter_list|(
name|LruCachedBlock
name|cb
parameter_list|,
name|boolean
name|evict
parameter_list|)
block|{
name|long
name|heapsize
init|=
name|cb
operator|.
name|heapSize
argument_list|()
decl_stmt|;
name|BlockType
name|bt
init|=
name|cb
operator|.
name|getBuffer
argument_list|()
operator|.
name|getBlockType
argument_list|()
decl_stmt|;
if|if
condition|(
name|evict
condition|)
block|{
name|heapsize
operator|*=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bt
operator|!=
literal|null
operator|&&
name|bt
operator|.
name|isData
argument_list|()
condition|)
block|{
name|dataBlockSize
operator|.
name|add
argument_list|(
name|heapsize
argument_list|)
expr_stmt|;
block|}
return|return
name|size
operator|.
name|addAndGet
argument_list|(
name|heapsize
argument_list|)
return|;
block|}
comment|/**    * Get the buffer of the block with the specified name.    *    * @param cacheKey           block's cache key    * @param caching            true if the caller caches blocks on cache misses    * @param repeat             Whether this is a repeat lookup for the same block    *                           (used to avoid double counting cache misses when doing double-check    *                           locking)    * @param updateCacheMetrics Whether to update cache metrics or not    *    * @return buffer of specified cache key, or null if not in cache    */
annotation|@
name|Override
specifier|public
name|Cacheable
name|getBlock
parameter_list|(
name|BlockCacheKey
name|cacheKey
parameter_list|,
name|boolean
name|caching
parameter_list|,
name|boolean
name|repeat
parameter_list|,
name|boolean
name|updateCacheMetrics
parameter_list|)
block|{
name|LruCachedBlock
name|cb
init|=
name|map
operator|.
name|get
argument_list|(
name|cacheKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|repeat
operator|&&
name|updateCacheMetrics
condition|)
block|{
name|stats
operator|.
name|miss
argument_list|(
name|caching
argument_list|,
name|cacheKey
operator|.
name|isPrimary
argument_list|()
argument_list|,
name|cacheKey
operator|.
name|getBlockType
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// If there is another block cache then try and read there.
comment|// However if this is a retry ( second time in double checked locking )
comment|// And it's already a miss then the l2 will also be a miss.
if|if
condition|(
name|victimHandler
operator|!=
literal|null
operator|&&
operator|!
name|repeat
condition|)
block|{
name|Cacheable
name|result
init|=
name|victimHandler
operator|.
name|getBlock
argument_list|(
name|cacheKey
argument_list|,
name|caching
argument_list|,
name|repeat
argument_list|,
name|updateCacheMetrics
argument_list|)
decl_stmt|;
comment|// Promote this to L1.
if|if
condition|(
name|result
operator|!=
literal|null
operator|&&
name|caching
condition|)
block|{
if|if
condition|(
name|result
operator|instanceof
name|HFileBlock
operator|&&
operator|(
operator|(
name|HFileBlock
operator|)
name|result
operator|)
operator|.
name|usesSharedMemory
argument_list|()
condition|)
block|{
name|result
operator|=
operator|(
operator|(
name|HFileBlock
operator|)
name|result
operator|)
operator|.
name|deepClone
argument_list|()
expr_stmt|;
block|}
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|result
argument_list|,
comment|/* inMemory = */
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
return|return
literal|null
return|;
block|}
if|if
condition|(
name|updateCacheMetrics
condition|)
name|stats
operator|.
name|hit
argument_list|(
name|caching
argument_list|,
name|cacheKey
operator|.
name|isPrimary
argument_list|()
argument_list|,
name|cacheKey
operator|.
name|getBlockType
argument_list|()
argument_list|)
expr_stmt|;
name|cb
operator|.
name|access
argument_list|(
name|count
operator|.
name|incrementAndGet
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|cb
operator|.
name|getBuffer
argument_list|()
return|;
block|}
comment|/**    * Whether the cache contains block with specified cacheKey    *    * @return true if contains the block    */
specifier|public
name|boolean
name|containsBlock
parameter_list|(
name|BlockCacheKey
name|cacheKey
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|cacheKey
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|evictBlock
parameter_list|(
name|BlockCacheKey
name|cacheKey
parameter_list|)
block|{
name|LruCachedBlock
name|cb
init|=
name|map
operator|.
name|get
argument_list|(
name|cacheKey
argument_list|)
decl_stmt|;
return|return
name|cb
operator|!=
literal|null
operator|&&
name|evictBlock
argument_list|(
name|cb
argument_list|,
literal|false
argument_list|)
operator|>
literal|0
return|;
block|}
comment|/**    * Evicts all blocks for a specific HFile. This is an    * expensive operation implemented as a linear-time search through all blocks    * in the cache. Ideally this should be a search in a log-access-time map.    *    *<p>    * This is used for evict-on-close to remove all blocks of a specific HFile.    *    * @return the number of blocks evicted    */
annotation|@
name|Override
specifier|public
name|int
name|evictBlocksByHfileName
parameter_list|(
name|String
name|hfileName
parameter_list|)
block|{
name|int
name|numEvicted
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockCacheKey
name|key
range|:
name|map
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|key
operator|.
name|getHfileName
argument_list|()
operator|.
name|equals
argument_list|(
name|hfileName
argument_list|)
condition|)
block|{
if|if
condition|(
name|evictBlock
argument_list|(
name|key
argument_list|)
condition|)
operator|++
name|numEvicted
expr_stmt|;
block|}
block|}
if|if
condition|(
name|victimHandler
operator|!=
literal|null
condition|)
block|{
name|numEvicted
operator|+=
name|victimHandler
operator|.
name|evictBlocksByHfileName
argument_list|(
name|hfileName
argument_list|)
expr_stmt|;
block|}
return|return
name|numEvicted
return|;
block|}
comment|/**    * Evict the block, and it will be cached by the victim handler if exists&amp;&amp;    * block may be read again later    *    * @param evictedByEvictionProcess true if the given block is evicted by    *          EvictionThread    * @return the heap size of evicted block    */
specifier|protected
name|long
name|evictBlock
parameter_list|(
name|LruCachedBlock
name|block
parameter_list|,
name|boolean
name|evictedByEvictionProcess
parameter_list|)
block|{
name|boolean
name|found
init|=
name|map
operator|.
name|remove
argument_list|(
name|block
operator|.
name|getCacheKey
argument_list|()
argument_list|)
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
return|return
literal|0
return|;
block|}
name|updateSizeMetrics
argument_list|(
name|block
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|long
name|val
init|=
name|elements
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|long
name|size
init|=
name|map
operator|.
name|size
argument_list|()
decl_stmt|;
name|assertCounterSanity
argument_list|(
name|size
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|block
operator|.
name|getBuffer
argument_list|()
operator|.
name|getBlockType
argument_list|()
operator|.
name|isData
argument_list|()
condition|)
block|{
name|dataBlockElements
operator|.
name|decrement
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|evictedByEvictionProcess
condition|)
block|{
comment|// When the eviction of the block happened because of invalidation of HFiles, no need to
comment|// update the stats counter.
name|stats
operator|.
name|evicted
argument_list|(
name|block
operator|.
name|getCachedTime
argument_list|()
argument_list|,
name|block
operator|.
name|getCacheKey
argument_list|()
operator|.
name|isPrimary
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|victimHandler
operator|!=
literal|null
condition|)
block|{
name|victimHandler
operator|.
name|cacheBlock
argument_list|(
name|block
operator|.
name|getCacheKey
argument_list|()
argument_list|,
name|block
operator|.
name|getBuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|block
operator|.
name|heapSize
argument_list|()
return|;
block|}
comment|/**    * Multi-threaded call to run the eviction process.    */
specifier|private
name|void
name|runEviction
parameter_list|()
block|{
if|if
condition|(
name|evictionThread
operator|==
literal|null
condition|)
block|{
name|evict
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|evictionThread
operator|.
name|evict
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
name|boolean
name|isEvictionInProgress
parameter_list|()
block|{
return|return
name|evictionInProgress
return|;
block|}
annotation|@
name|VisibleForTesting
name|long
name|getOverhead
parameter_list|()
block|{
return|return
name|overhead
return|;
block|}
comment|/**    * Eviction method.    */
name|void
name|evict
parameter_list|()
block|{
comment|// Ensure only one eviction at a time
if|if
condition|(
operator|!
name|evictionLock
operator|.
name|tryLock
argument_list|()
condition|)
return|return;
try|try
block|{
name|evictionInProgress
operator|=
literal|true
expr_stmt|;
name|long
name|currentSize
init|=
name|this
operator|.
name|size
operator|.
name|get
argument_list|()
decl_stmt|;
name|long
name|bytesToFree
init|=
name|currentSize
operator|-
name|minSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Block cache LRU eviction started; Attempting to free "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesToFree
argument_list|)
operator|+
literal|" of total="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|currentSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytesToFree
operator|<=
literal|0
condition|)
return|return;
comment|// Instantiate priority buckets
name|BlockBucket
name|bucketSingle
init|=
operator|new
name|BlockBucket
argument_list|(
literal|"single"
argument_list|,
name|bytesToFree
argument_list|,
name|blockSize
argument_list|,
name|singleSize
argument_list|()
argument_list|)
decl_stmt|;
name|BlockBucket
name|bucketMulti
init|=
operator|new
name|BlockBucket
argument_list|(
literal|"multi"
argument_list|,
name|bytesToFree
argument_list|,
name|blockSize
argument_list|,
name|multiSize
argument_list|()
argument_list|)
decl_stmt|;
name|BlockBucket
name|bucketMemory
init|=
operator|new
name|BlockBucket
argument_list|(
literal|"memory"
argument_list|,
name|bytesToFree
argument_list|,
name|blockSize
argument_list|,
name|memorySize
argument_list|()
argument_list|)
decl_stmt|;
comment|// Scan entire map putting into appropriate buckets
for|for
control|(
name|LruCachedBlock
name|cachedBlock
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
switch|switch
condition|(
name|cachedBlock
operator|.
name|getPriority
argument_list|()
condition|)
block|{
case|case
name|SINGLE
case|:
block|{
name|bucketSingle
operator|.
name|add
argument_list|(
name|cachedBlock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MULTI
case|:
block|{
name|bucketMulti
operator|.
name|add
argument_list|(
name|cachedBlock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MEMORY
case|:
block|{
name|bucketMemory
operator|.
name|add
argument_list|(
name|cachedBlock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|long
name|bytesFreed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|forceInMemory
operator|||
name|memoryFactor
operator|>
literal|0.999f
condition|)
block|{
name|long
name|s
init|=
name|bucketSingle
operator|.
name|totalSize
argument_list|()
decl_stmt|;
name|long
name|m
init|=
name|bucketMulti
operator|.
name|totalSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesToFree
operator|>
operator|(
name|s
operator|+
name|m
operator|)
condition|)
block|{
comment|// this means we need to evict blocks in memory bucket to make room,
comment|// so the single and multi buckets will be emptied
name|bytesFreed
operator|=
name|bucketSingle
operator|.
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bytesFreed
operator|+=
name|bucketMulti
operator|.
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"freed "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesFreed
argument_list|)
operator|+
literal|" from single and multi buckets"
argument_list|)
expr_stmt|;
block|}
name|bytesFreed
operator|+=
name|bucketMemory
operator|.
name|free
argument_list|(
name|bytesToFree
operator|-
name|bytesFreed
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"freed "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesFreed
argument_list|)
operator|+
literal|" total from all three buckets "
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// this means no need to evict block in memory bucket,
comment|// and we try best to make the ratio between single-bucket and
comment|// multi-bucket is 1:2
name|long
name|bytesRemain
init|=
name|s
operator|+
name|m
operator|-
name|bytesToFree
decl_stmt|;
if|if
condition|(
literal|3
operator|*
name|s
operator|<=
name|bytesRemain
condition|)
block|{
comment|// single-bucket is small enough that no eviction happens for it
comment|// hence all eviction goes from multi-bucket
name|bytesFreed
operator|=
name|bucketMulti
operator|.
name|free
argument_list|(
name|bytesToFree
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|3
operator|*
name|m
operator|<=
literal|2
operator|*
name|bytesRemain
condition|)
block|{
comment|// multi-bucket is small enough that no eviction happens for it
comment|// hence all eviction goes from single-bucket
name|bytesFreed
operator|=
name|bucketSingle
operator|.
name|free
argument_list|(
name|bytesToFree
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// both buckets need to evict some blocks
name|bytesFreed
operator|=
name|bucketSingle
operator|.
name|free
argument_list|(
name|s
operator|-
name|bytesRemain
operator|/
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytesFreed
operator|<
name|bytesToFree
condition|)
block|{
name|bytesFreed
operator|+=
name|bucketMulti
operator|.
name|free
argument_list|(
name|bytesToFree
operator|-
name|bytesFreed
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|PriorityQueue
argument_list|<
name|BlockBucket
argument_list|>
name|bucketQueue
init|=
operator|new
name|PriorityQueue
argument_list|<>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|bucketQueue
operator|.
name|add
argument_list|(
name|bucketSingle
argument_list|)
expr_stmt|;
name|bucketQueue
operator|.
name|add
argument_list|(
name|bucketMulti
argument_list|)
expr_stmt|;
name|bucketQueue
operator|.
name|add
argument_list|(
name|bucketMemory
argument_list|)
expr_stmt|;
name|int
name|remainingBuckets
init|=
literal|3
decl_stmt|;
name|BlockBucket
name|bucket
decl_stmt|;
while|while
condition|(
operator|(
name|bucket
operator|=
name|bucketQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|overflow
init|=
name|bucket
operator|.
name|overflow
argument_list|()
decl_stmt|;
if|if
condition|(
name|overflow
operator|>
literal|0
condition|)
block|{
name|long
name|bucketBytesToFree
init|=
name|Math
operator|.
name|min
argument_list|(
name|overflow
argument_list|,
operator|(
name|bytesToFree
operator|-
name|bytesFreed
operator|)
operator|/
name|remainingBuckets
argument_list|)
decl_stmt|;
name|bytesFreed
operator|+=
name|bucket
operator|.
name|free
argument_list|(
name|bucketBytesToFree
argument_list|)
expr_stmt|;
block|}
name|remainingBuckets
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|long
name|single
init|=
name|bucketSingle
operator|.
name|totalSize
argument_list|()
decl_stmt|;
name|long
name|multi
init|=
name|bucketMulti
operator|.
name|totalSize
argument_list|()
decl_stmt|;
name|long
name|memory
init|=
name|bucketMemory
operator|.
name|totalSize
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Block cache LRU eviction completed; "
operator|+
literal|"freed="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesFreed
argument_list|)
operator|+
literal|", "
operator|+
literal|"total="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|this
operator|.
name|size
operator|.
name|get
argument_list|()
argument_list|)
operator|+
literal|", "
operator|+
literal|"single="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|single
argument_list|)
operator|+
literal|", "
operator|+
literal|"multi="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|multi
argument_list|)
operator|+
literal|", "
operator|+
literal|"memory="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|memory
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|stats
operator|.
name|evict
argument_list|()
expr_stmt|;
name|evictionInProgress
operator|=
literal|false
expr_stmt|;
name|evictionLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|MoreObjects
operator|.
name|toStringHelper
argument_list|(
name|this
argument_list|)
operator|.
name|add
argument_list|(
literal|"blockCount"
argument_list|,
name|getBlockCount
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"currentSize"
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|getCurrentSize
argument_list|()
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"freeSize"
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|getFreeSize
argument_list|()
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"maxSize"
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|getMaxSize
argument_list|()
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"heapSize"
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|heapSize
argument_list|()
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"minSize"
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|minSize
argument_list|()
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"minFactor"
argument_list|,
name|minFactor
argument_list|)
operator|.
name|add
argument_list|(
literal|"multiSize"
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|multiSize
argument_list|()
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"multiFactor"
argument_list|,
name|multiFactor
argument_list|)
operator|.
name|add
argument_list|(
literal|"singleSize"
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|singleSize
argument_list|()
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"singleFactor"
argument_list|,
name|singleFactor
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Used to group blocks into priority buckets.  There will be a BlockBucket    * for each priority (single, multi, memory).  Once bucketed, the eviction    * algorithm takes the appropriate number of elements out of each according    * to configuration parameters and their relatives sizes.    */
specifier|private
class|class
name|BlockBucket
implements|implements
name|Comparable
argument_list|<
name|BlockBucket
argument_list|>
block|{
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
name|LruCachedBlockQueue
name|queue
decl_stmt|;
specifier|private
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|bucketSize
decl_stmt|;
specifier|public
name|BlockBucket
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|bytesToFree
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|long
name|bucketSize
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|bucketSize
operator|=
name|bucketSize
expr_stmt|;
name|queue
operator|=
operator|new
name|LruCachedBlockQueue
argument_list|(
name|bytesToFree
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
name|totalSize
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|LruCachedBlock
name|block
parameter_list|)
block|{
name|totalSize
operator|+=
name|block
operator|.
name|heapSize
argument_list|()
expr_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
specifier|public
name|long
name|free
parameter_list|(
name|long
name|toFree
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"freeing "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|toFree
argument_list|)
operator|+
literal|" from "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
name|LruCachedBlock
name|cb
decl_stmt|;
name|long
name|freedBytes
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|cb
operator|=
name|queue
operator|.
name|pollLast
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|freedBytes
operator|+=
name|evictBlock
argument_list|(
name|cb
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|freedBytes
operator|>=
name|toFree
condition|)
block|{
return|return
name|freedBytes
return|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"freed "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|freedBytes
argument_list|)
operator|+
literal|" from "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|freedBytes
return|;
block|}
specifier|public
name|long
name|overflow
parameter_list|()
block|{
return|return
name|totalSize
operator|-
name|bucketSize
return|;
block|}
specifier|public
name|long
name|totalSize
parameter_list|()
block|{
return|return
name|totalSize
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|BlockBucket
name|that
parameter_list|)
block|{
return|return
name|Long
operator|.
name|compare
argument_list|(
name|this
operator|.
name|overflow
argument_list|()
argument_list|,
name|that
operator|.
name|overflow
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|that
parameter_list|)
block|{
if|if
condition|(
name|that
operator|==
literal|null
operator|||
operator|!
operator|(
name|that
operator|instanceof
name|BlockBucket
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|compareTo
argument_list|(
operator|(
name|BlockBucket
operator|)
name|that
argument_list|)
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hashCode
argument_list|(
name|name
argument_list|,
name|bucketSize
argument_list|,
name|queue
argument_list|,
name|totalSize
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|MoreObjects
operator|.
name|toStringHelper
argument_list|(
name|this
argument_list|)
operator|.
name|add
argument_list|(
literal|"name"
argument_list|,
name|name
argument_list|)
operator|.
name|add
argument_list|(
literal|"totalSize"
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|totalSize
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"bucketSize"
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bucketSize
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Get the maximum size of this cache.    *    * @return max size in bytes    */
annotation|@
name|Override
specifier|public
name|long
name|getMaxSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|maxSize
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getCurrentSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|size
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getCurrentDataSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|dataBlockSize
operator|.
name|sum
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getFreeSize
parameter_list|()
block|{
return|return
name|getMaxSize
argument_list|()
operator|-
name|getCurrentSize
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|size
parameter_list|()
block|{
return|return
name|getMaxSize
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getBlockCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|elements
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getDataBlockCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|dataBlockElements
operator|.
name|sum
argument_list|()
return|;
block|}
name|EvictionThread
name|getEvictionThread
parameter_list|()
block|{
return|return
name|this
operator|.
name|evictionThread
return|;
block|}
comment|/*    * Eviction thread.  Sits in waiting state until an eviction is triggered    * when the cache size grows above the acceptable level.<p>    *    * Thread is triggered into action by {@link LruBlockCache#runEviction()}    */
specifier|static
class|class
name|EvictionThread
extends|extends
name|HasThread
block|{
specifier|private
name|WeakReference
argument_list|<
name|LruBlockCache
argument_list|>
name|cache
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|go
init|=
literal|true
decl_stmt|;
comment|// flag set after enter the run method, used for test
specifier|private
name|boolean
name|enteringRun
init|=
literal|false
decl_stmt|;
specifier|public
name|EvictionThread
parameter_list|(
name|LruBlockCache
name|cache
parameter_list|)
block|{
name|super
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|".LruBlockCache.EvictionThread"
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|cache
operator|=
operator|new
name|WeakReference
argument_list|<>
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|enteringRun
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|this
operator|.
name|go
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|this
operator|.
name|wait
argument_list|(
literal|1000
operator|*
literal|10
comment|/*Don't wait for ever*/
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted eviction thread "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
name|LruBlockCache
name|cache
init|=
name|this
operator|.
name|cache
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|cache
operator|==
literal|null
condition|)
break|break;
name|cache
operator|.
name|evict
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"NN_NAKED_NOTIFY"
argument_list|,
name|justification
operator|=
literal|"This is what we want"
argument_list|)
specifier|public
name|void
name|evict
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|synchronized
name|void
name|shutdown
parameter_list|()
block|{
name|this
operator|.
name|go
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/**      * Used for the test.      */
name|boolean
name|isEnteringRun
parameter_list|()
block|{
return|return
name|this
operator|.
name|enteringRun
return|;
block|}
block|}
comment|/*    * Statistics thread.  Periodically prints the cache statistics to the log.    */
specifier|static
class|class
name|StatisticsThread
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|LruBlockCache
name|lru
decl_stmt|;
specifier|public
name|StatisticsThread
parameter_list|(
name|LruBlockCache
name|lru
parameter_list|)
block|{
name|super
argument_list|(
literal|"LruBlockCacheStats"
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|lru
operator|=
name|lru
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|lru
operator|.
name|logStats
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|logStats
parameter_list|()
block|{
comment|// Log size
name|long
name|totalSize
init|=
name|heapSize
argument_list|()
decl_stmt|;
name|long
name|freeSize
init|=
name|maxSize
operator|-
name|totalSize
decl_stmt|;
name|LruBlockCache
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"totalSize="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|totalSize
argument_list|)
operator|+
literal|", "
operator|+
literal|"freeSize="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|freeSize
argument_list|)
operator|+
literal|", "
operator|+
literal|"max="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|this
operator|.
name|maxSize
argument_list|)
operator|+
literal|", "
operator|+
literal|"blockCount="
operator|+
name|getBlockCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"accesses="
operator|+
name|stats
operator|.
name|getRequestCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"hits="
operator|+
name|stats
operator|.
name|getHitCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"hitRatio="
operator|+
operator|(
name|stats
operator|.
name|getHitCount
argument_list|()
operator|==
literal|0
condition|?
literal|"0"
else|:
operator|(
name|StringUtils
operator|.
name|formatPercent
argument_list|(
name|stats
operator|.
name|getHitRatio
argument_list|()
argument_list|,
literal|2
argument_list|)
operator|+
literal|", "
operator|)
operator|)
operator|+
literal|", "
operator|+
literal|"cachingAccesses="
operator|+
name|stats
operator|.
name|getRequestCachingCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"cachingHits="
operator|+
name|stats
operator|.
name|getHitCachingCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"cachingHitsRatio="
operator|+
operator|(
name|stats
operator|.
name|getHitCachingCount
argument_list|()
operator|==
literal|0
condition|?
literal|"0,"
else|:
operator|(
name|StringUtils
operator|.
name|formatPercent
argument_list|(
name|stats
operator|.
name|getHitCachingRatio
argument_list|()
argument_list|,
literal|2
argument_list|)
operator|+
literal|", "
operator|)
operator|)
operator|+
literal|"evictions="
operator|+
name|stats
operator|.
name|getEvictionCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"evicted="
operator|+
name|stats
operator|.
name|getEvictedCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"evictedPerRun="
operator|+
name|stats
operator|.
name|evictedPerEviction
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get counter statistics for this cache.    *    *<p>Includes: total accesses, hits, misses, evicted blocks, and runs    * of the eviction processes.    */
annotation|@
name|Override
specifier|public
name|CacheStats
name|getStats
parameter_list|()
block|{
return|return
name|this
operator|.
name|stats
return|;
block|}
specifier|public
specifier|final
specifier|static
name|long
name|CACHE_FIXED_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
operator|(
literal|4
operator|*
name|Bytes
operator|.
name|SIZEOF_LONG
operator|)
operator|+
operator|(
literal|11
operator|*
name|ClassSize
operator|.
name|REFERENCE
operator|)
operator|+
operator|(
literal|6
operator|*
name|Bytes
operator|.
name|SIZEOF_FLOAT
operator|)
operator|+
operator|(
literal|2
operator|*
name|Bytes
operator|.
name|SIZEOF_BOOLEAN
operator|)
operator|+
name|ClassSize
operator|.
name|OBJECT
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
return|return
name|getCurrentSize
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|long
name|calculateOverhead
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|int
name|concurrency
parameter_list|)
block|{
comment|// FindBugs ICAST_INTEGER_MULTIPLY_CAST_TO_LONG
return|return
name|CACHE_FIXED_OVERHEAD
operator|+
name|ClassSize
operator|.
name|CONCURRENT_HASHMAP
operator|+
operator|(
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|maxSize
operator|*
literal|1.2
operator|/
name|blockSize
argument_list|)
operator|*
name|ClassSize
operator|.
name|CONCURRENT_HASHMAP_ENTRY
operator|)
operator|+
operator|(
operator|(
name|long
operator|)
name|concurrency
operator|*
name|ClassSize
operator|.
name|CONCURRENT_HASHMAP_SEGMENT
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|CachedBlock
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|LruCachedBlock
argument_list|>
name|iterator
init|=
name|map
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|CachedBlock
argument_list|>
argument_list|()
block|{
specifier|private
specifier|final
name|long
name|now
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|CachedBlock
name|next
parameter_list|()
block|{
specifier|final
name|LruCachedBlock
name|b
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|new
name|CachedBlock
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|BlockCacheUtil
operator|.
name|toString
argument_list|(
name|this
argument_list|,
name|now
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BlockPriority
name|getBlockPriority
parameter_list|()
block|{
return|return
name|b
operator|.
name|getPriority
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|BlockType
name|getBlockType
parameter_list|()
block|{
return|return
name|b
operator|.
name|getBuffer
argument_list|()
operator|.
name|getBlockType
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getOffset
parameter_list|()
block|{
return|return
name|b
operator|.
name|getCacheKey
argument_list|()
operator|.
name|getOffset
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getSize
parameter_list|()
block|{
return|return
name|b
operator|.
name|getBuffer
argument_list|()
operator|.
name|heapSize
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getCachedTime
parameter_list|()
block|{
return|return
name|b
operator|.
name|getCachedTime
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getFilename
parameter_list|()
block|{
return|return
name|b
operator|.
name|getCacheKey
argument_list|()
operator|.
name|getHfileName
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|CachedBlock
name|other
parameter_list|)
block|{
name|int
name|diff
init|=
name|this
operator|.
name|getFilename
argument_list|()
operator|.
name|compareTo
argument_list|(
name|other
operator|.
name|getFilename
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
name|diff
operator|=
name|Long
operator|.
name|compare
argument_list|(
name|this
operator|.
name|getOffset
argument_list|()
argument_list|,
name|other
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
if|if
condition|(
name|other
operator|.
name|getCachedTime
argument_list|()
operator|<
literal|0
operator|||
name|this
operator|.
name|getCachedTime
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|this
operator|.
name|getCachedTime
argument_list|()
operator|+
literal|", "
operator|+
name|other
operator|.
name|getCachedTime
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|Long
operator|.
name|compare
argument_list|(
name|other
operator|.
name|getCachedTime
argument_list|()
argument_list|,
name|this
operator|.
name|getCachedTime
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|b
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|CachedBlock
condition|)
block|{
name|CachedBlock
name|cb
init|=
operator|(
name|CachedBlock
operator|)
name|obj
decl_stmt|;
return|return
name|compareTo
argument_list|(
name|cb
argument_list|)
operator|==
literal|0
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
comment|// Simple calculators of sizes given factors and maxSize
name|long
name|acceptableSize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|acceptableFactor
argument_list|)
return|;
block|}
specifier|private
name|long
name|minSize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|minFactor
argument_list|)
return|;
block|}
specifier|private
name|long
name|singleSize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|singleFactor
operator|*
name|this
operator|.
name|minFactor
argument_list|)
return|;
block|}
specifier|private
name|long
name|multiSize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|multiFactor
operator|*
name|this
operator|.
name|minFactor
argument_list|)
return|;
block|}
specifier|private
name|long
name|memorySize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|memoryFactor
operator|*
name|this
operator|.
name|minFactor
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|victimHandler
operator|!=
literal|null
condition|)
block|{
name|victimHandler
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|scheduleThreadPool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|scheduleThreadPool
operator|.
name|isShutdown
argument_list|()
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while sleeping"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|scheduleThreadPool
operator|.
name|isShutdown
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|Runnable
argument_list|>
name|runnables
init|=
name|this
operator|.
name|scheduleThreadPool
operator|.
name|shutdownNow
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Still running "
operator|+
name|runnables
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|evictionThread
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|/** Clears the cache. Used in tests. */
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|clearCache
parameter_list|()
block|{
name|this
operator|.
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|elements
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Used in testing. May be very inefficient.    *    * @return the set of cached file names    */
annotation|@
name|VisibleForTesting
name|SortedSet
argument_list|<
name|String
argument_list|>
name|getCachedFileNamesForTest
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|fileNames
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockCacheKey
name|cacheKey
range|:
name|map
operator|.
name|keySet
argument_list|()
control|)
block|{
name|fileNames
operator|.
name|add
argument_list|(
name|cacheKey
operator|.
name|getHfileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|fileNames
return|;
block|}
annotation|@
name|VisibleForTesting
name|Map
argument_list|<
name|BlockType
argument_list|,
name|Integer
argument_list|>
name|getBlockTypeCountsForTest
parameter_list|()
block|{
name|Map
argument_list|<
name|BlockType
argument_list|,
name|Integer
argument_list|>
name|counts
init|=
operator|new
name|EnumMap
argument_list|<>
argument_list|(
name|BlockType
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|LruCachedBlock
name|cb
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
name|BlockType
name|blockType
init|=
name|cb
operator|.
name|getBuffer
argument_list|()
operator|.
name|getBlockType
argument_list|()
decl_stmt|;
name|Integer
name|count
init|=
name|counts
operator|.
name|get
argument_list|(
name|blockType
argument_list|)
decl_stmt|;
name|counts
operator|.
name|put
argument_list|(
name|blockType
argument_list|,
operator|(
name|count
operator|==
literal|null
condition|?
literal|0
else|:
name|count
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|counts
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|Map
argument_list|<
name|DataBlockEncoding
argument_list|,
name|Integer
argument_list|>
name|getEncodingCountsForTest
parameter_list|()
block|{
name|Map
argument_list|<
name|DataBlockEncoding
argument_list|,
name|Integer
argument_list|>
name|counts
init|=
operator|new
name|EnumMap
argument_list|<>
argument_list|(
name|DataBlockEncoding
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|LruCachedBlock
name|block
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
name|DataBlockEncoding
name|encoding
init|=
operator|(
operator|(
name|HFileBlock
operator|)
name|block
operator|.
name|getBuffer
argument_list|()
operator|)
operator|.
name|getDataBlockEncoding
argument_list|()
decl_stmt|;
name|Integer
name|count
init|=
name|counts
operator|.
name|get
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
name|counts
operator|.
name|put
argument_list|(
name|encoding
argument_list|,
operator|(
name|count
operator|==
literal|null
condition|?
literal|0
else|:
name|count
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|counts
return|;
block|}
specifier|public
name|void
name|setVictimCache
parameter_list|(
name|BlockCache
name|handler
parameter_list|)
block|{
assert|assert
name|victimHandler
operator|==
literal|null
assert|;
name|victimHandler
operator|=
name|handler
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
name|Map
argument_list|<
name|BlockCacheKey
argument_list|,
name|LruCachedBlock
argument_list|>
name|getMapForTests
parameter_list|()
block|{
return|return
name|map
return|;
block|}
annotation|@
name|Override
annotation|@
name|JsonIgnore
specifier|public
name|BlockCache
index|[]
name|getBlockCaches
parameter_list|()
block|{
if|if
condition|(
name|victimHandler
operator|!=
literal|null
condition|)
return|return
operator|new
name|BlockCache
index|[]
block|{
name|this
block|,
name|this
operator|.
name|victimHandler
block|}
return|;
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

