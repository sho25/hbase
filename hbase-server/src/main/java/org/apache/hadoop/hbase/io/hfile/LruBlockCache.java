begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HeapSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|CachedBlock
operator|.
name|BlockPriority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|bucket
operator|.
name|BucketCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HasThread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_comment
comment|/**  * A block cache implementation that is memory-aware using {@link HeapSize},  * memory-bound using an LRU eviction algorithm, and concurrent: backed by a  * {@link ConcurrentHashMap} and with a non-blocking eviction thread giving  * constant-time {@link #cacheBlock} and {@link #getBlock} operations.<p>  *  * Contains three levels of block priority to allow for  * scan-resistance and in-memory families.  A block is added with an inMemory  * flag if necessary, otherwise a block becomes a single access priority.  Once  * a blocked is accessed again, it changes to multiple access.  This is used  * to prevent scans from thrashing the cache, adding a least-frequently-used  * element to the eviction algorithm.<p>  *  * Each priority is given its own chunk of the total cache to ensure  * fairness during eviction.  Each priority will retain close to its maximum  * size, however, if any priority is not using its entire chunk the others  * are able to grow beyond their chunk size.<p>  *  * Instantiated at a minimum with the total size and average block size.  * All sizes are in bytes.  The block size is not especially important as this  * cache is fully dynamic in its sizing of blocks.  It is only used for  * pre-allocating data structures and in initial heap estimation of the map.<p>  *  * The detailed constructor defines the sizes for the three priorities (they  * should total to the maximum size defined).  It also sets the levels that  * trigger and control the eviction thread.<p>  *  * The acceptable size is the cache size level which triggers the eviction  * process to start.  It evicts enough blocks to get the size below the  * minimum size specified.<p>  *  * Eviction happens in a separate thread and involves a single full-scan  * of the map.  It determines how many bytes must be freed to reach the minimum  * size, and then while scanning determines the fewest least-recently-used  * blocks necessary from each of the three priorities (would be 3 times bytes  * to free).  It then uses the priority chunk sizes to evict fairly according  * to the relative sizes and usage.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|LruBlockCache
implements|implements
name|BlockCache
implements|,
name|HeapSize
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|LruBlockCache
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|String
name|LRU_MIN_FACTOR_CONFIG_NAME
init|=
literal|"hbase.lru.blockcache.min.factor"
decl_stmt|;
specifier|static
specifier|final
name|String
name|LRU_ACCEPTABLE_FACTOR_CONFIG_NAME
init|=
literal|"hbase.lru.blockcache.acceptable.factor"
decl_stmt|;
comment|/** Default Configuration Parameters*/
comment|/** Backing Concurrent Map Configuration */
specifier|static
specifier|final
name|float
name|DEFAULT_LOAD_FACTOR
init|=
literal|0.75f
decl_stmt|;
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|16
decl_stmt|;
comment|/** Eviction thresholds */
specifier|static
specifier|final
name|float
name|DEFAULT_MIN_FACTOR
init|=
literal|0.95f
decl_stmt|;
specifier|static
specifier|final
name|float
name|DEFAULT_ACCEPTABLE_FACTOR
init|=
literal|0.99f
decl_stmt|;
comment|/** Priority buckets */
specifier|static
specifier|final
name|float
name|DEFAULT_SINGLE_FACTOR
init|=
literal|0.25f
decl_stmt|;
specifier|static
specifier|final
name|float
name|DEFAULT_MULTI_FACTOR
init|=
literal|0.50f
decl_stmt|;
specifier|static
specifier|final
name|float
name|DEFAULT_MEMORY_FACTOR
init|=
literal|0.25f
decl_stmt|;
comment|/** Statistics thread */
specifier|static
specifier|final
name|int
name|statThreadPeriod
init|=
literal|60
operator|*
literal|5
decl_stmt|;
comment|/** Concurrent map (the cache) */
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|BlockCacheKey
argument_list|,
name|CachedBlock
argument_list|>
name|map
decl_stmt|;
comment|/** Eviction lock (locked when eviction in process) */
specifier|private
specifier|final
name|ReentrantLock
name|evictionLock
init|=
operator|new
name|ReentrantLock
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/** Volatile boolean to track if we are in an eviction process or not */
specifier|private
specifier|volatile
name|boolean
name|evictionInProgress
init|=
literal|false
decl_stmt|;
comment|/** Eviction thread */
specifier|private
specifier|final
name|EvictionThread
name|evictionThread
decl_stmt|;
comment|/** Statistics thread schedule pool (for heavy debugging, could remove) */
specifier|private
specifier|final
name|ScheduledExecutorService
name|scheduleThreadPool
init|=
name|Executors
operator|.
name|newScheduledThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"LRU Statistics #%d"
argument_list|)
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Current size of cache */
specifier|private
specifier|final
name|AtomicLong
name|size
decl_stmt|;
comment|/** Current number of cached elements */
specifier|private
specifier|final
name|AtomicLong
name|elements
decl_stmt|;
comment|/** Cache access count (sequential ID) */
specifier|private
specifier|final
name|AtomicLong
name|count
decl_stmt|;
comment|/** Cache statistics */
specifier|private
specifier|final
name|CacheStats
name|stats
decl_stmt|;
comment|/** Maximum allowable size of cache (block put if size> max, evict) */
specifier|private
name|long
name|maxSize
decl_stmt|;
comment|/** Approximate block size */
specifier|private
name|long
name|blockSize
decl_stmt|;
comment|/** Acceptable size of cache (no evictions if size< acceptable) */
specifier|private
name|float
name|acceptableFactor
decl_stmt|;
comment|/** Minimum threshold of cache (when evicting, evict until size< min) */
specifier|private
name|float
name|minFactor
decl_stmt|;
comment|/** Single access bucket size */
specifier|private
name|float
name|singleFactor
decl_stmt|;
comment|/** Multiple access bucket size */
specifier|private
name|float
name|multiFactor
decl_stmt|;
comment|/** In-memory bucket size */
specifier|private
name|float
name|memoryFactor
decl_stmt|;
comment|/** Overhead of the structure itself */
specifier|private
name|long
name|overhead
decl_stmt|;
comment|/** Where to send victims (blocks evicted from the cache) */
specifier|private
name|BucketCache
name|victimHandler
init|=
literal|null
decl_stmt|;
comment|/**    * Default constructor.  Specify maximum size and expected average block    * size (approximation is fine).    *    *<p>All other factors will be calculated based on defaults specified in    * this class.    * @param maxSize maximum size of cache, in bytes    * @param blockSize approximate size of each block, in bytes    */
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|)
block|{
name|this
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor used for testing.  Allows disabling of the eviction thread.    */
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|boolean
name|evictionThread
parameter_list|)
block|{
name|this
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
name|evictionThread
argument_list|,
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
literal|1.2
operator|*
name|maxSize
operator|/
name|blockSize
argument_list|)
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|,
name|DEFAULT_CONCURRENCY_LEVEL
argument_list|,
name|DEFAULT_MIN_FACTOR
argument_list|,
name|DEFAULT_ACCEPTABLE_FACTOR
argument_list|,
name|DEFAULT_SINGLE_FACTOR
argument_list|,
name|DEFAULT_MULTI_FACTOR
argument_list|,
name|DEFAULT_MEMORY_FACTOR
argument_list|)
expr_stmt|;
block|}
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|boolean
name|evictionThread
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
name|evictionThread
argument_list|,
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
literal|1.2
operator|*
name|maxSize
operator|/
name|blockSize
argument_list|)
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|,
name|DEFAULT_CONCURRENCY_LEVEL
argument_list|,
name|conf
operator|.
name|getFloat
argument_list|(
name|LRU_MIN_FACTOR_CONFIG_NAME
argument_list|,
name|DEFAULT_MIN_FACTOR
argument_list|)
argument_list|,
name|conf
operator|.
name|getFloat
argument_list|(
name|LRU_ACCEPTABLE_FACTOR_CONFIG_NAME
argument_list|,
name|DEFAULT_ACCEPTABLE_FACTOR
argument_list|)
argument_list|,
name|DEFAULT_SINGLE_FACTOR
argument_list|,
name|DEFAULT_MULTI_FACTOR
argument_list|,
name|DEFAULT_MEMORY_FACTOR
argument_list|)
expr_stmt|;
block|}
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
literal|true
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Configurable constructor.  Use this constructor if not using defaults.    * @param maxSize maximum size of this cache, in bytes    * @param blockSize expected average size of blocks, in bytes    * @param evictionThread whether to run evictions in a bg thread or not    * @param mapInitialSize initial size of backing ConcurrentHashMap    * @param mapLoadFactor initial load factor of backing ConcurrentHashMap    * @param mapConcurrencyLevel initial concurrency factor for backing CHM    * @param minFactor percentage of total size that eviction will evict until    * @param acceptableFactor percentage of total size that triggers eviction    * @param singleFactor percentage of total size for single-access blocks    * @param multiFactor percentage of total size for multiple-access blocks    * @param memoryFactor percentage of total size for in-memory blocks    */
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|boolean
name|evictionThread
parameter_list|,
name|int
name|mapInitialSize
parameter_list|,
name|float
name|mapLoadFactor
parameter_list|,
name|int
name|mapConcurrencyLevel
parameter_list|,
name|float
name|minFactor
parameter_list|,
name|float
name|acceptableFactor
parameter_list|,
name|float
name|singleFactor
parameter_list|,
name|float
name|multiFactor
parameter_list|,
name|float
name|memoryFactor
parameter_list|)
block|{
if|if
condition|(
name|singleFactor
operator|+
name|multiFactor
operator|+
name|memoryFactor
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Single, multi, and memory factors "
operator|+
literal|" should total 1.0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|minFactor
operator|>=
name|acceptableFactor
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"minFactor must be smaller than acceptableFactor"
argument_list|)
throw|;
block|}
if|if
condition|(
name|minFactor
operator|>=
literal|1.0f
operator|||
name|acceptableFactor
operator|>=
literal|1.0f
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"all factors must be< 1"
argument_list|)
throw|;
block|}
name|this
operator|.
name|maxSize
operator|=
name|maxSize
expr_stmt|;
name|this
operator|.
name|blockSize
operator|=
name|blockSize
expr_stmt|;
name|map
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|BlockCacheKey
argument_list|,
name|CachedBlock
argument_list|>
argument_list|(
name|mapInitialSize
argument_list|,
name|mapLoadFactor
argument_list|,
name|mapConcurrencyLevel
argument_list|)
expr_stmt|;
name|this
operator|.
name|minFactor
operator|=
name|minFactor
expr_stmt|;
name|this
operator|.
name|acceptableFactor
operator|=
name|acceptableFactor
expr_stmt|;
name|this
operator|.
name|singleFactor
operator|=
name|singleFactor
expr_stmt|;
name|this
operator|.
name|multiFactor
operator|=
name|multiFactor
expr_stmt|;
name|this
operator|.
name|memoryFactor
operator|=
name|memoryFactor
expr_stmt|;
name|this
operator|.
name|stats
operator|=
operator|new
name|CacheStats
argument_list|()
expr_stmt|;
name|this
operator|.
name|count
operator|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|elements
operator|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|overhead
operator|=
name|calculateOverhead
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
name|mapConcurrencyLevel
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|=
operator|new
name|AtomicLong
argument_list|(
name|this
operator|.
name|overhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|evictionThread
condition|)
block|{
name|this
operator|.
name|evictionThread
operator|=
operator|new
name|EvictionThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|evictionThread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// FindBugs SC_START_IN_CTOR
block|}
else|else
block|{
name|this
operator|.
name|evictionThread
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|scheduleThreadPool
operator|.
name|scheduleAtFixedRate
argument_list|(
operator|new
name|StatisticsThread
argument_list|(
name|this
argument_list|)
argument_list|,
name|statThreadPeriod
argument_list|,
name|statThreadPeriod
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setMaxSize
parameter_list|(
name|long
name|maxSize
parameter_list|)
block|{
name|this
operator|.
name|maxSize
operator|=
name|maxSize
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|size
operator|.
name|get
argument_list|()
operator|>
name|acceptableSize
argument_list|()
operator|&&
operator|!
name|evictionInProgress
condition|)
block|{
name|runEviction
argument_list|()
expr_stmt|;
block|}
block|}
comment|// BlockCache implementation
comment|/**    * Cache the block with the specified name and buffer.    *<p>    * It is assumed this will NEVER be called on an already cached block.  If    * that is done, an exception will be thrown.    * @param cacheKey block's cache key    * @param buf block buffer    * @param inMemory if block is in-memory    */
specifier|public
name|void
name|cacheBlock
parameter_list|(
name|BlockCacheKey
name|cacheKey
parameter_list|,
name|Cacheable
name|buf
parameter_list|,
name|boolean
name|inMemory
parameter_list|)
block|{
name|CachedBlock
name|cb
init|=
name|map
operator|.
name|get
argument_list|(
name|cacheKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cached an already cached block"
argument_list|)
throw|;
block|}
name|cb
operator|=
operator|new
name|CachedBlock
argument_list|(
name|cacheKey
argument_list|,
name|buf
argument_list|,
name|count
operator|.
name|incrementAndGet
argument_list|()
argument_list|,
name|inMemory
argument_list|)
expr_stmt|;
name|long
name|newSize
init|=
name|updateSizeMetrics
argument_list|(
name|cb
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|cacheKey
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|elements
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|newSize
operator|>
name|acceptableSize
argument_list|()
operator|&&
operator|!
name|evictionInProgress
condition|)
block|{
name|runEviction
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Cache the block with the specified name and buffer.    *<p>    * It is assumed this will NEVER be called on an already cached block.  If    * that is done, it is assumed that you are reinserting the same exact    * block due to a race condition and will update the buffer but not modify    * the size of the cache.    * @param cacheKey block's cache key    * @param buf block buffer    */
specifier|public
name|void
name|cacheBlock
parameter_list|(
name|BlockCacheKey
name|cacheKey
parameter_list|,
name|Cacheable
name|buf
parameter_list|)
block|{
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|buf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Helper function that updates the local size counter and also updates any    * per-cf or per-blocktype metrics it can discern from given    * {@link CachedBlock}    *    * @param cb    * @param evict    */
specifier|protected
name|long
name|updateSizeMetrics
parameter_list|(
name|CachedBlock
name|cb
parameter_list|,
name|boolean
name|evict
parameter_list|)
block|{
name|long
name|heapsize
init|=
name|cb
operator|.
name|heapSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|evict
condition|)
block|{
name|heapsize
operator|*=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|size
operator|.
name|addAndGet
argument_list|(
name|heapsize
argument_list|)
return|;
block|}
comment|/**    * Get the buffer of the block with the specified name.    * @param cacheKey block's cache key    * @param caching true if the caller caches blocks on cache misses    * @param repeat Whether this is a repeat lookup for the same block    *        (used to avoid double counting cache misses when doing double-check locking)    * @return buffer of specified cache key, or null if not in cache    * @see HFileReaderV2#readBlock(long, long, boolean, boolean, boolean, BlockType)    */
annotation|@
name|Override
specifier|public
name|Cacheable
name|getBlock
parameter_list|(
name|BlockCacheKey
name|cacheKey
parameter_list|,
name|boolean
name|caching
parameter_list|,
name|boolean
name|repeat
parameter_list|)
block|{
name|CachedBlock
name|cb
init|=
name|map
operator|.
name|get
argument_list|(
name|cacheKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|repeat
condition|)
name|stats
operator|.
name|miss
argument_list|(
name|caching
argument_list|)
expr_stmt|;
if|if
condition|(
name|victimHandler
operator|!=
literal|null
condition|)
return|return
name|victimHandler
operator|.
name|getBlock
argument_list|(
name|cacheKey
argument_list|,
name|caching
argument_list|,
name|repeat
argument_list|)
return|;
return|return
literal|null
return|;
block|}
name|stats
operator|.
name|hit
argument_list|(
name|caching
argument_list|)
expr_stmt|;
name|cb
operator|.
name|access
argument_list|(
name|count
operator|.
name|incrementAndGet
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|cb
operator|.
name|getBuffer
argument_list|()
return|;
block|}
comment|/**    * Whether the cache contains block with specified cacheKey    * @param cacheKey    * @return true if contains the block    */
specifier|public
name|boolean
name|containsBlock
parameter_list|(
name|BlockCacheKey
name|cacheKey
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|cacheKey
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|evictBlock
parameter_list|(
name|BlockCacheKey
name|cacheKey
parameter_list|)
block|{
name|CachedBlock
name|cb
init|=
name|map
operator|.
name|get
argument_list|(
name|cacheKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|evictBlock
argument_list|(
name|cb
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Evicts all blocks for a specific HFile. This is an    * expensive operation implemented as a linear-time search through all blocks    * in the cache. Ideally this should be a search in a log-access-time map.    *    *<p>    * This is used for evict-on-close to remove all blocks of a specific HFile.    *    * @return the number of blocks evicted    */
annotation|@
name|Override
specifier|public
name|int
name|evictBlocksByHfileName
parameter_list|(
name|String
name|hfileName
parameter_list|)
block|{
name|int
name|numEvicted
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockCacheKey
name|key
range|:
name|map
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|key
operator|.
name|getHfileName
argument_list|()
operator|.
name|equals
argument_list|(
name|hfileName
argument_list|)
condition|)
block|{
if|if
condition|(
name|evictBlock
argument_list|(
name|key
argument_list|)
condition|)
operator|++
name|numEvicted
expr_stmt|;
block|}
block|}
if|if
condition|(
name|victimHandler
operator|!=
literal|null
condition|)
block|{
name|numEvicted
operator|+=
name|victimHandler
operator|.
name|evictBlocksByHfileName
argument_list|(
name|hfileName
argument_list|)
expr_stmt|;
block|}
return|return
name|numEvicted
return|;
block|}
comment|/**    * Evict the block, and it will be cached by the victim handler if exists&&    * block may be read again later    * @param block    * @param evictedByEvictionProcess true if the given block is evicted by    *          EvictionThread    * @return the heap size of evicted block    */
specifier|protected
name|long
name|evictBlock
parameter_list|(
name|CachedBlock
name|block
parameter_list|,
name|boolean
name|evictedByEvictionProcess
parameter_list|)
block|{
name|map
operator|.
name|remove
argument_list|(
name|block
operator|.
name|getCacheKey
argument_list|()
argument_list|)
expr_stmt|;
name|updateSizeMetrics
argument_list|(
name|block
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|elements
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|stats
operator|.
name|evicted
argument_list|()
expr_stmt|;
if|if
condition|(
name|evictedByEvictionProcess
operator|&&
name|victimHandler
operator|!=
literal|null
condition|)
block|{
name|boolean
name|wait
init|=
name|getCurrentSize
argument_list|()
operator|<
name|acceptableSize
argument_list|()
decl_stmt|;
name|boolean
name|inMemory
init|=
name|block
operator|.
name|getPriority
argument_list|()
operator|==
name|BlockPriority
operator|.
name|MEMORY
decl_stmt|;
name|victimHandler
operator|.
name|cacheBlockWithWait
argument_list|(
name|block
operator|.
name|getCacheKey
argument_list|()
argument_list|,
name|block
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|inMemory
argument_list|,
name|wait
argument_list|)
expr_stmt|;
block|}
return|return
name|block
operator|.
name|heapSize
argument_list|()
return|;
block|}
comment|/**    * Multi-threaded call to run the eviction process.    */
specifier|private
name|void
name|runEviction
parameter_list|()
block|{
if|if
condition|(
name|evictionThread
operator|==
literal|null
condition|)
block|{
name|evict
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|evictionThread
operator|.
name|evict
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Eviction method.    */
name|void
name|evict
parameter_list|()
block|{
comment|// Ensure only one eviction at a time
if|if
condition|(
operator|!
name|evictionLock
operator|.
name|tryLock
argument_list|()
condition|)
return|return;
try|try
block|{
name|evictionInProgress
operator|=
literal|true
expr_stmt|;
name|long
name|currentSize
init|=
name|this
operator|.
name|size
operator|.
name|get
argument_list|()
decl_stmt|;
name|long
name|bytesToFree
init|=
name|currentSize
operator|-
name|minSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block cache LRU eviction started; Attempting to free "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesToFree
argument_list|)
operator|+
literal|" of total="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|currentSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytesToFree
operator|<=
literal|0
condition|)
return|return;
comment|// Instantiate priority buckets
name|BlockBucket
name|bucketSingle
init|=
operator|new
name|BlockBucket
argument_list|(
name|bytesToFree
argument_list|,
name|blockSize
argument_list|,
name|singleSize
argument_list|()
argument_list|)
decl_stmt|;
name|BlockBucket
name|bucketMulti
init|=
operator|new
name|BlockBucket
argument_list|(
name|bytesToFree
argument_list|,
name|blockSize
argument_list|,
name|multiSize
argument_list|()
argument_list|)
decl_stmt|;
name|BlockBucket
name|bucketMemory
init|=
operator|new
name|BlockBucket
argument_list|(
name|bytesToFree
argument_list|,
name|blockSize
argument_list|,
name|memorySize
argument_list|()
argument_list|)
decl_stmt|;
comment|// Scan entire map putting into appropriate buckets
for|for
control|(
name|CachedBlock
name|cachedBlock
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
switch|switch
condition|(
name|cachedBlock
operator|.
name|getPriority
argument_list|()
condition|)
block|{
case|case
name|SINGLE
case|:
block|{
name|bucketSingle
operator|.
name|add
argument_list|(
name|cachedBlock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MULTI
case|:
block|{
name|bucketMulti
operator|.
name|add
argument_list|(
name|cachedBlock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MEMORY
case|:
block|{
name|bucketMemory
operator|.
name|add
argument_list|(
name|cachedBlock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|PriorityQueue
argument_list|<
name|BlockBucket
argument_list|>
name|bucketQueue
init|=
operator|new
name|PriorityQueue
argument_list|<
name|BlockBucket
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|bucketQueue
operator|.
name|add
argument_list|(
name|bucketSingle
argument_list|)
expr_stmt|;
name|bucketQueue
operator|.
name|add
argument_list|(
name|bucketMulti
argument_list|)
expr_stmt|;
name|bucketQueue
operator|.
name|add
argument_list|(
name|bucketMemory
argument_list|)
expr_stmt|;
name|int
name|remainingBuckets
init|=
literal|3
decl_stmt|;
name|long
name|bytesFreed
init|=
literal|0
decl_stmt|;
name|BlockBucket
name|bucket
decl_stmt|;
while|while
condition|(
operator|(
name|bucket
operator|=
name|bucketQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|overflow
init|=
name|bucket
operator|.
name|overflow
argument_list|()
decl_stmt|;
if|if
condition|(
name|overflow
operator|>
literal|0
condition|)
block|{
name|long
name|bucketBytesToFree
init|=
name|Math
operator|.
name|min
argument_list|(
name|overflow
argument_list|,
operator|(
name|bytesToFree
operator|-
name|bytesFreed
operator|)
operator|/
name|remainingBuckets
argument_list|)
decl_stmt|;
name|bytesFreed
operator|+=
name|bucket
operator|.
name|free
argument_list|(
name|bucketBytesToFree
argument_list|)
expr_stmt|;
block|}
name|remainingBuckets
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|long
name|single
init|=
name|bucketSingle
operator|.
name|totalSize
argument_list|()
decl_stmt|;
name|long
name|multi
init|=
name|bucketMulti
operator|.
name|totalSize
argument_list|()
decl_stmt|;
name|long
name|memory
init|=
name|bucketMemory
operator|.
name|totalSize
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block cache LRU eviction completed; "
operator|+
literal|"freed="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesFreed
argument_list|)
operator|+
literal|", "
operator|+
literal|"total="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|this
operator|.
name|size
operator|.
name|get
argument_list|()
argument_list|)
operator|+
literal|", "
operator|+
literal|"single="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|single
argument_list|)
operator|+
literal|", "
operator|+
literal|"multi="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|multi
argument_list|)
operator|+
literal|", "
operator|+
literal|"memory="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|memory
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|stats
operator|.
name|evict
argument_list|()
expr_stmt|;
name|evictionInProgress
operator|=
literal|false
expr_stmt|;
name|evictionLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Used to group blocks into priority buckets.  There will be a BlockBucket    * for each priority (single, multi, memory).  Once bucketed, the eviction    * algorithm takes the appropriate number of elements out of each according    * to configuration parameters and their relatives sizes.    */
specifier|private
class|class
name|BlockBucket
implements|implements
name|Comparable
argument_list|<
name|BlockBucket
argument_list|>
block|{
specifier|private
name|CachedBlockQueue
name|queue
decl_stmt|;
specifier|private
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|bucketSize
decl_stmt|;
specifier|public
name|BlockBucket
parameter_list|(
name|long
name|bytesToFree
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|long
name|bucketSize
parameter_list|)
block|{
name|this
operator|.
name|bucketSize
operator|=
name|bucketSize
expr_stmt|;
name|queue
operator|=
operator|new
name|CachedBlockQueue
argument_list|(
name|bytesToFree
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
name|totalSize
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|CachedBlock
name|block
parameter_list|)
block|{
name|totalSize
operator|+=
name|block
operator|.
name|heapSize
argument_list|()
expr_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
specifier|public
name|long
name|free
parameter_list|(
name|long
name|toFree
parameter_list|)
block|{
name|CachedBlock
name|cb
decl_stmt|;
name|long
name|freedBytes
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|cb
operator|=
name|queue
operator|.
name|pollLast
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|freedBytes
operator|+=
name|evictBlock
argument_list|(
name|cb
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|freedBytes
operator|>=
name|toFree
condition|)
block|{
return|return
name|freedBytes
return|;
block|}
block|}
return|return
name|freedBytes
return|;
block|}
specifier|public
name|long
name|overflow
parameter_list|()
block|{
return|return
name|totalSize
operator|-
name|bucketSize
return|;
block|}
specifier|public
name|long
name|totalSize
parameter_list|()
block|{
return|return
name|totalSize
return|;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
name|BlockBucket
name|that
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|overflow
argument_list|()
operator|==
name|that
operator|.
name|overflow
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|this
operator|.
name|overflow
argument_list|()
operator|>
name|that
operator|.
name|overflow
argument_list|()
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|that
parameter_list|)
block|{
if|if
condition|(
name|that
operator|==
literal|null
operator|||
operator|!
operator|(
name|that
operator|instanceof
name|BlockBucket
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|compareTo
argument_list|(
operator|(
name|BlockBucket
operator|)
name|that
argument_list|)
operator|==
literal|0
return|;
block|}
block|}
comment|/**    * Get the maximum size of this cache.    * @return max size in bytes    */
specifier|public
name|long
name|getMaxSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|maxSize
return|;
block|}
comment|/**    * Get the current size of this cache.    * @return current size in bytes    */
specifier|public
name|long
name|getCurrentSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|size
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Get the current size of this cache.    * @return current size in bytes    */
specifier|public
name|long
name|getFreeSize
parameter_list|()
block|{
return|return
name|getMaxSize
argument_list|()
operator|-
name|getCurrentSize
argument_list|()
return|;
block|}
comment|/**    * Get the size of this cache (number of cached blocks)    * @return number of cached blocks    */
specifier|public
name|long
name|size
parameter_list|()
block|{
return|return
name|this
operator|.
name|elements
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getBlockCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|elements
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Get the number of eviction runs that have occurred    */
specifier|public
name|long
name|getEvictionCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|stats
operator|.
name|getEvictionCount
argument_list|()
return|;
block|}
comment|/**    * Get the number of blocks that have been evicted during the lifetime    * of this cache.    */
specifier|public
name|long
name|getEvictedCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|stats
operator|.
name|getEvictedCount
argument_list|()
return|;
block|}
name|EvictionThread
name|getEvictionThread
parameter_list|()
block|{
return|return
name|this
operator|.
name|evictionThread
return|;
block|}
comment|/*    * Eviction thread.  Sits in waiting state until an eviction is triggered    * when the cache size grows above the acceptable level.<p>    *    * Thread is triggered into action by {@link LruBlockCache#runEviction()}    */
specifier|static
class|class
name|EvictionThread
extends|extends
name|HasThread
block|{
specifier|private
name|WeakReference
argument_list|<
name|LruBlockCache
argument_list|>
name|cache
decl_stmt|;
specifier|private
name|boolean
name|go
init|=
literal|true
decl_stmt|;
comment|// flag set after enter the run method, used for test
specifier|private
name|boolean
name|enteringRun
init|=
literal|false
decl_stmt|;
specifier|public
name|EvictionThread
parameter_list|(
name|LruBlockCache
name|cache
parameter_list|)
block|{
name|super
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|".LruBlockCache.EvictionThread"
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|cache
operator|=
operator|new
name|WeakReference
argument_list|<
name|LruBlockCache
argument_list|>
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|enteringRun
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|this
operator|.
name|go
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|this
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{}
block|}
name|LruBlockCache
name|cache
init|=
name|this
operator|.
name|cache
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|cache
operator|==
literal|null
condition|)
break|break;
name|cache
operator|.
name|evict
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|evict
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
comment|// FindBugs NN_NAKED_NOTIFY
block|}
block|}
specifier|synchronized
name|void
name|shutdown
parameter_list|()
block|{
name|this
operator|.
name|go
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/**      * Used for the test.      */
name|boolean
name|isEnteringRun
parameter_list|()
block|{
return|return
name|this
operator|.
name|enteringRun
return|;
block|}
block|}
comment|/*    * Statistics thread.  Periodically prints the cache statistics to the log.    */
specifier|static
class|class
name|StatisticsThread
extends|extends
name|Thread
block|{
name|LruBlockCache
name|lru
decl_stmt|;
specifier|public
name|StatisticsThread
parameter_list|(
name|LruBlockCache
name|lru
parameter_list|)
block|{
name|super
argument_list|(
literal|"LruBlockCache.StatisticsThread"
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|lru
operator|=
name|lru
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|lru
operator|.
name|logStats
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|logStats
parameter_list|()
block|{
if|if
condition|(
operator|!
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
return|return;
comment|// Log size
name|long
name|totalSize
init|=
name|heapSize
argument_list|()
decl_stmt|;
name|long
name|freeSize
init|=
name|maxSize
operator|-
name|totalSize
decl_stmt|;
name|LruBlockCache
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stats: "
operator|+
literal|"total="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|totalSize
argument_list|)
operator|+
literal|", "
operator|+
literal|"free="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|freeSize
argument_list|)
operator|+
literal|", "
operator|+
literal|"max="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|this
operator|.
name|maxSize
argument_list|)
operator|+
literal|", "
operator|+
literal|"blocks="
operator|+
name|size
argument_list|()
operator|+
literal|", "
operator|+
literal|"accesses="
operator|+
name|stats
operator|.
name|getRequestCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"hits="
operator|+
name|stats
operator|.
name|getHitCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"hitRatio="
operator|+
operator|(
name|stats
operator|.
name|getHitCount
argument_list|()
operator|==
literal|0
condition|?
literal|"0"
else|:
operator|(
name|StringUtils
operator|.
name|formatPercent
argument_list|(
name|stats
operator|.
name|getHitRatio
argument_list|()
argument_list|,
literal|2
argument_list|)
operator|+
literal|", "
operator|)
operator|)
operator|+
literal|", "
operator|+
literal|"cachingAccesses="
operator|+
name|stats
operator|.
name|getRequestCachingCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"cachingHits="
operator|+
name|stats
operator|.
name|getHitCachingCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"cachingHitsRatio="
operator|+
operator|(
name|stats
operator|.
name|getHitCachingCount
argument_list|()
operator|==
literal|0
condition|?
literal|"0"
else|:
operator|(
name|StringUtils
operator|.
name|formatPercent
argument_list|(
name|stats
operator|.
name|getHitCachingRatio
argument_list|()
argument_list|,
literal|2
argument_list|)
operator|+
literal|", "
operator|)
operator|)
operator|+
literal|", "
operator|+
literal|"evictions="
operator|+
name|stats
operator|.
name|getEvictionCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"evicted="
operator|+
name|stats
operator|.
name|getEvictedCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"evictedPerRun="
operator|+
name|stats
operator|.
name|evictedPerEviction
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get counter statistics for this cache.    *    *<p>Includes: total accesses, hits, misses, evicted blocks, and runs    * of the eviction processes.    */
specifier|public
name|CacheStats
name|getStats
parameter_list|()
block|{
return|return
name|this
operator|.
name|stats
return|;
block|}
specifier|public
specifier|final
specifier|static
name|long
name|CACHE_FIXED_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
operator|(
literal|3
operator|*
name|Bytes
operator|.
name|SIZEOF_LONG
operator|)
operator|+
operator|(
literal|9
operator|*
name|ClassSize
operator|.
name|REFERENCE
operator|)
operator|+
operator|(
literal|5
operator|*
name|Bytes
operator|.
name|SIZEOF_FLOAT
operator|)
operator|+
name|Bytes
operator|.
name|SIZEOF_BOOLEAN
operator|+
name|ClassSize
operator|.
name|OBJECT
argument_list|)
decl_stmt|;
comment|// HeapSize implementation
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
return|return
name|getCurrentSize
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|long
name|calculateOverhead
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|int
name|concurrency
parameter_list|)
block|{
comment|// FindBugs ICAST_INTEGER_MULTIPLY_CAST_TO_LONG
return|return
name|CACHE_FIXED_OVERHEAD
operator|+
name|ClassSize
operator|.
name|CONCURRENT_HASHMAP
operator|+
operator|(
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|maxSize
operator|*
literal|1.2
operator|/
name|blockSize
argument_list|)
operator|*
name|ClassSize
operator|.
name|CONCURRENT_HASHMAP_ENTRY
operator|)
operator|+
operator|(
operator|(
name|long
operator|)
name|concurrency
operator|*
name|ClassSize
operator|.
name|CONCURRENT_HASHMAP_SEGMENT
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|BlockCacheColumnFamilySummary
argument_list|>
name|getBlockCacheColumnFamilySummaries
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
name|sfMap
init|=
name|FSUtils
operator|.
name|getTableStoreFilePathMap
argument_list|(
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
argument_list|,
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
comment|// quirky, but it's a compound key and this is a shortcut taken instead of
comment|// creating a class that would represent only a key.
name|Map
argument_list|<
name|BlockCacheColumnFamilySummary
argument_list|,
name|BlockCacheColumnFamilySummary
argument_list|>
name|bcs
init|=
operator|new
name|HashMap
argument_list|<
name|BlockCacheColumnFamilySummary
argument_list|,
name|BlockCacheColumnFamilySummary
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|CachedBlock
name|cb
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
name|String
name|sf
init|=
name|cb
operator|.
name|getCacheKey
argument_list|()
operator|.
name|getHfileName
argument_list|()
decl_stmt|;
name|Path
name|path
init|=
name|sfMap
operator|.
name|get
argument_list|(
name|sf
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
name|BlockCacheColumnFamilySummary
name|lookup
init|=
name|BlockCacheColumnFamilySummary
operator|.
name|createFromStoreFilePath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|BlockCacheColumnFamilySummary
name|bcse
init|=
name|bcs
operator|.
name|get
argument_list|(
name|lookup
argument_list|)
decl_stmt|;
if|if
condition|(
name|bcse
operator|==
literal|null
condition|)
block|{
name|bcse
operator|=
name|BlockCacheColumnFamilySummary
operator|.
name|create
argument_list|(
name|lookup
argument_list|)
expr_stmt|;
name|bcs
operator|.
name|put
argument_list|(
name|lookup
argument_list|,
name|bcse
argument_list|)
expr_stmt|;
block|}
name|bcse
operator|.
name|incrementBlocks
argument_list|()
expr_stmt|;
name|bcse
operator|.
name|incrementHeapSize
argument_list|(
name|cb
operator|.
name|heapSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|BlockCacheColumnFamilySummary
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|BlockCacheColumnFamilySummary
argument_list|>
argument_list|(
name|bcs
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|// Simple calculators of sizes given factors and maxSize
specifier|private
name|long
name|acceptableSize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|acceptableFactor
argument_list|)
return|;
block|}
specifier|private
name|long
name|minSize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|minFactor
argument_list|)
return|;
block|}
specifier|private
name|long
name|singleSize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|singleFactor
operator|*
name|this
operator|.
name|minFactor
argument_list|)
return|;
block|}
specifier|private
name|long
name|multiSize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|multiFactor
operator|*
name|this
operator|.
name|minFactor
argument_list|)
return|;
block|}
specifier|private
name|long
name|memorySize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|memoryFactor
operator|*
name|this
operator|.
name|minFactor
argument_list|)
return|;
block|}
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|victimHandler
operator|!=
literal|null
condition|)
name|victimHandler
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|this
operator|.
name|scheduleThreadPool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|scheduleThreadPool
operator|.
name|isShutdown
argument_list|()
condition|)
name|Threads
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|scheduleThreadPool
operator|.
name|isShutdown
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|Runnable
argument_list|>
name|runnables
init|=
name|this
operator|.
name|scheduleThreadPool
operator|.
name|shutdownNow
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Still running "
operator|+
name|runnables
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|evictionThread
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|/** Clears the cache. Used in tests. */
specifier|public
name|void
name|clearCache
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Used in testing. May be very inefficient.    * @return the set of cached file names    */
name|SortedSet
argument_list|<
name|String
argument_list|>
name|getCachedFileNamesForTest
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|fileNames
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockCacheKey
name|cacheKey
range|:
name|map
operator|.
name|keySet
argument_list|()
control|)
block|{
name|fileNames
operator|.
name|add
argument_list|(
name|cacheKey
operator|.
name|getHfileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|fileNames
return|;
block|}
name|Map
argument_list|<
name|BlockType
argument_list|,
name|Integer
argument_list|>
name|getBlockTypeCountsForTest
parameter_list|()
block|{
name|Map
argument_list|<
name|BlockType
argument_list|,
name|Integer
argument_list|>
name|counts
init|=
operator|new
name|EnumMap
argument_list|<
name|BlockType
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|BlockType
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|CachedBlock
name|cb
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
name|BlockType
name|blockType
init|=
operator|(
operator|(
name|HFileBlock
operator|)
name|cb
operator|.
name|getBuffer
argument_list|()
operator|)
operator|.
name|getBlockType
argument_list|()
decl_stmt|;
name|Integer
name|count
init|=
name|counts
operator|.
name|get
argument_list|(
name|blockType
argument_list|)
decl_stmt|;
name|counts
operator|.
name|put
argument_list|(
name|blockType
argument_list|,
operator|(
name|count
operator|==
literal|null
condition|?
literal|0
else|:
name|count
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|counts
return|;
block|}
specifier|public
name|Map
argument_list|<
name|DataBlockEncoding
argument_list|,
name|Integer
argument_list|>
name|getEncodingCountsForTest
parameter_list|()
block|{
name|Map
argument_list|<
name|DataBlockEncoding
argument_list|,
name|Integer
argument_list|>
name|counts
init|=
operator|new
name|EnumMap
argument_list|<
name|DataBlockEncoding
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|DataBlockEncoding
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|BlockCacheKey
name|cacheKey
range|:
name|map
operator|.
name|keySet
argument_list|()
control|)
block|{
name|DataBlockEncoding
name|encoding
init|=
name|cacheKey
operator|.
name|getDataBlockEncoding
argument_list|()
decl_stmt|;
name|Integer
name|count
init|=
name|counts
operator|.
name|get
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
name|counts
operator|.
name|put
argument_list|(
name|encoding
argument_list|,
operator|(
name|count
operator|==
literal|null
condition|?
literal|0
else|:
name|count
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|counts
return|;
block|}
specifier|public
name|void
name|setVictimCache
parameter_list|(
name|BucketCache
name|handler
parameter_list|)
block|{
assert|assert
name|victimHandler
operator|==
literal|null
assert|;
name|victimHandler
operator|=
name|handler
expr_stmt|;
block|}
block|}
end_class

end_unit

