begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaMutationAnnotation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ColumnFamilyDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|DoNotRetryRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MasterSwitchType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Mutation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfoBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|MergeRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|CacheConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|CatalogJanitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterCoprocessorHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|NormalizationPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|AbstractStateMachineTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureEnv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureStateSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegionFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HStoreFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreFileInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALSplitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|GetRegionInfoResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProcedureProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsState
import|;
end_import

begin_comment
comment|/**  * The procedure to Merge a region in a table.  *<p/>  * This procedure takes an exclusive table lock since it is working over multiple regions.  *<p/>  * It holds the lock for the life of the procedure.  *<p/>  * Throws exception on construction if determines context hostile to merge (cluster going down or  * master is shutting down or table is disabled).  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|MergeTableRegionsProcedure
extends|extends
name|AbstractStateMachineTableProcedure
argument_list|<
name|MergeTableRegionsState
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MergeTableRegionsProcedure
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|Boolean
name|traceEnabled
decl_stmt|;
specifier|private
name|ServerName
name|regionLocation
decl_stmt|;
specifier|private
name|RegionInfo
index|[]
name|regionsToMerge
decl_stmt|;
specifier|private
name|RegionInfo
name|mergedRegion
decl_stmt|;
specifier|private
name|boolean
name|forcible
decl_stmt|;
specifier|public
name|MergeTableRegionsProcedure
parameter_list|()
block|{
comment|// Required by the Procedure framework to create the procedure on replay
block|}
specifier|public
name|MergeTableRegionsProcedure
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|RegionInfo
name|regionToMergeA
parameter_list|,
specifier|final
name|RegionInfo
name|regionToMergeB
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|env
argument_list|,
name|regionToMergeA
argument_list|,
name|regionToMergeB
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|MergeTableRegionsProcedure
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|RegionInfo
name|regionToMergeA
parameter_list|,
specifier|final
name|RegionInfo
name|regionToMergeB
parameter_list|,
specifier|final
name|boolean
name|forcible
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|env
argument_list|,
operator|new
name|RegionInfo
index|[]
block|{
name|regionToMergeA
block|,
name|regionToMergeB
block|}
argument_list|,
name|forcible
argument_list|)
expr_stmt|;
block|}
specifier|public
name|MergeTableRegionsProcedure
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|RegionInfo
index|[]
name|regionsToMerge
parameter_list|,
specifier|final
name|boolean
name|forcible
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|// Check daughter regions and make sure that we have valid daughter regions
comment|// before doing the real work. This check calls the super method #checkOnline also.
name|checkRegionsToMerge
argument_list|(
name|env
argument_list|,
name|regionsToMerge
argument_list|,
name|forcible
argument_list|)
expr_stmt|;
comment|// WARN: make sure there is no parent region of the two merging regions in
comment|// hbase:meta If exists, fixing up daughters would cause daughter regions(we
comment|// have merged one) online again when we restart master, so we should clear
comment|// the parent region to prevent the above case
comment|// Since HBASE-7721, we don't need fix up daughters any more. so here do nothing
name|this
operator|.
name|regionsToMerge
operator|=
name|regionsToMerge
expr_stmt|;
name|this
operator|.
name|mergedRegion
operator|=
name|createMergedRegionInfo
argument_list|(
name|regionsToMerge
argument_list|)
expr_stmt|;
name|preflightChecks
argument_list|(
name|env
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|forcible
operator|=
name|forcible
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|checkRegionsToMerge
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|RegionInfo
index|[]
name|regionsToMerge
parameter_list|,
specifier|final
name|boolean
name|forcible
parameter_list|)
throws|throws
name|MergeRegionException
block|{
comment|// For now, we only merge 2 regions.
comment|// It could be extended to more than 2 regions in the future.
if|if
condition|(
name|regionsToMerge
operator|==
literal|null
operator|||
name|regionsToMerge
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Expected to merge 2 regions, got: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|regionsToMerge
argument_list|)
argument_list|)
throw|;
block|}
name|checkRegionsToMerge
argument_list|(
name|env
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|,
name|forcible
argument_list|)
expr_stmt|;
block|}
comment|/**    * One time checks.    */
specifier|private
specifier|static
name|void
name|checkRegionsToMerge
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|RegionInfo
name|regionToMergeA
parameter_list|,
specifier|final
name|RegionInfo
name|regionToMergeB
parameter_list|,
specifier|final
name|boolean
name|forcible
parameter_list|)
throws|throws
name|MergeRegionException
block|{
if|if
condition|(
operator|!
name|regionToMergeA
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|regionToMergeB
operator|.
name|getTable
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Can't merge regions from two different tables: "
operator|+
name|regionToMergeA
operator|+
literal|", "
operator|+
name|regionToMergeB
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionToMergeA
operator|.
name|getReplicaId
argument_list|()
operator|!=
name|RegionInfo
operator|.
name|DEFAULT_REPLICA_ID
operator|||
name|regionToMergeB
operator|.
name|getReplicaId
argument_list|()
operator|!=
name|RegionInfo
operator|.
name|DEFAULT_REPLICA_ID
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Can't merge non-default replicas"
argument_list|)
throw|;
block|}
try|try
block|{
name|checkOnline
argument_list|(
name|env
argument_list|,
name|regionToMergeA
argument_list|)
expr_stmt|;
name|checkOnline
argument_list|(
name|env
argument_list|,
name|regionToMergeB
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DoNotRetryRegionException
name|dnrre
parameter_list|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
name|dnrre
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|RegionInfo
operator|.
name|areAdjacent
argument_list|(
name|regionToMergeA
argument_list|,
name|regionToMergeB
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Unable to merge non-adjacent regions "
operator|+
name|regionToMergeA
operator|.
name|getShortNameToLog
argument_list|()
operator|+
literal|", "
operator|+
name|regionToMergeB
operator|.
name|getShortNameToLog
argument_list|()
operator|+
literal|" where forcible = "
operator|+
name|forcible
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|forcible
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
specifier|static
name|RegionInfo
name|createMergedRegionInfo
parameter_list|(
specifier|final
name|RegionInfo
index|[]
name|regionsToMerge
parameter_list|)
block|{
return|return
name|createMergedRegionInfo
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
return|;
block|}
comment|/**    * Create merged region info through the specified two regions    */
specifier|private
specifier|static
name|RegionInfo
name|createMergedRegionInfo
parameter_list|(
specifier|final
name|RegionInfo
name|regionToMergeA
parameter_list|,
specifier|final
name|RegionInfo
name|regionToMergeB
parameter_list|)
block|{
comment|// Choose the smaller as start key
specifier|final
name|byte
index|[]
name|startKey
decl_stmt|;
if|if
condition|(
name|RegionInfo
operator|.
name|COMPARATOR
operator|.
name|compare
argument_list|(
name|regionToMergeA
argument_list|,
name|regionToMergeB
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|startKey
operator|=
name|regionToMergeA
operator|.
name|getStartKey
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|startKey
operator|=
name|regionToMergeB
operator|.
name|getStartKey
argument_list|()
expr_stmt|;
block|}
comment|// Choose the bigger as end key
specifier|final
name|byte
index|[]
name|endKey
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|regionToMergeA
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
operator|||
operator|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|regionToMergeB
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
operator|&&
name|Bytes
operator|.
name|compareTo
argument_list|(
name|regionToMergeA
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|regionToMergeB
operator|.
name|getEndKey
argument_list|()
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|endKey
operator|=
name|regionToMergeA
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|endKey
operator|=
name|regionToMergeB
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
block|}
comment|// Merged region is sorted between two merging regions in META
return|return
name|RegionInfoBuilder
operator|.
name|newBuilder
argument_list|(
name|regionToMergeA
operator|.
name|getTable
argument_list|()
argument_list|)
operator|.
name|setStartKey
argument_list|(
name|startKey
argument_list|)
operator|.
name|setEndKey
argument_list|(
name|endKey
argument_list|)
operator|.
name|setSplit
argument_list|(
literal|false
argument_list|)
operator|.
name|setRegionId
argument_list|(
name|getMergedRegionIdTimestamp
argument_list|(
name|regionToMergeA
argument_list|,
name|regionToMergeB
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|long
name|getMergedRegionIdTimestamp
parameter_list|(
specifier|final
name|RegionInfo
name|regionToMergeA
parameter_list|,
specifier|final
name|RegionInfo
name|regionToMergeB
parameter_list|)
block|{
name|long
name|rid
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
comment|// Region Id is a timestamp. Merged region's id can't be less than that of
comment|// merging regions else will insert at wrong location in hbase:meta (See HBASE-710).
if|if
condition|(
name|rid
operator|<
name|regionToMergeA
operator|.
name|getRegionId
argument_list|()
operator|||
name|rid
operator|<
name|regionToMergeB
operator|.
name|getRegionId
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Clock skew; merging regions id are "
operator|+
name|regionToMergeA
operator|.
name|getRegionId
argument_list|()
operator|+
literal|" and "
operator|+
name|regionToMergeB
operator|.
name|getRegionId
argument_list|()
operator|+
literal|", but current time here is "
operator|+
name|rid
argument_list|)
expr_stmt|;
name|rid
operator|=
name|Math
operator|.
name|max
argument_list|(
name|regionToMergeA
operator|.
name|getRegionId
argument_list|()
argument_list|,
name|regionToMergeB
operator|.
name|getRegionId
argument_list|()
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|rid
return|;
block|}
specifier|private
name|void
name|removeNonDefaultReplicas
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|AssignmentManagerUtil
operator|.
name|removeNonDefaultReplicas
argument_list|(
name|env
argument_list|,
name|Stream
operator|.
name|of
argument_list|(
name|regionsToMerge
argument_list|)
argument_list|,
name|getRegionReplication
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkClosedRegions
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
comment|// theoretically this should not happen any more after we use TRSP, but anyway let's add a check
comment|// here
for|for
control|(
name|RegionInfo
name|region
range|:
name|regionsToMerge
control|)
block|{
name|AssignmentManagerUtil
operator|.
name|checkClosedRegion
argument_list|(
name|env
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|Flow
name|executeFromState
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
name|MergeTableRegionsState
name|state
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{} execute state={}"
argument_list|,
name|this
argument_list|,
name|state
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MERGE_TABLE_REGIONS_PREPARE
case|:
if|if
condition|(
operator|!
name|prepareMergeRegion
argument_list|(
name|env
argument_list|)
condition|)
block|{
assert|assert
name|isFailed
argument_list|()
operator|:
literal|"Merge region should have an exception here"
assert|;
return|return
name|Flow
operator|.
name|NO_MORE_STATE
return|;
block|}
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_PRE_MERGE_OPERATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_PRE_MERGE_OPERATION
case|:
name|preMergeRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_CLOSE_REGIONS
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_CLOSE_REGIONS
case|:
name|addChildProcedure
argument_list|(
name|createUnassignProcedures
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_CHECK_CLOSED_REGIONS
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_CHECK_CLOSED_REGIONS
case|:
name|checkClosedRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_CREATE_MERGED_REGION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_CREATE_MERGED_REGION
case|:
name|removeNonDefaultReplicas
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|createMergedRegion
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_WRITE_MAX_SEQUENCE_ID_FILE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_WRITE_MAX_SEQUENCE_ID_FILE
case|:
name|writeMaxSequenceIdFile
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_PRE_MERGE_COMMIT_OPERATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_PRE_MERGE_COMMIT_OPERATION
case|:
name|preMergeRegionsCommit
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_UPDATE_META
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_UPDATE_META
case|:
name|updateMetaForMergedRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_POST_MERGE_COMMIT_OPERATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_POST_MERGE_COMMIT_OPERATION
case|:
name|postMergeRegionsCommit
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_OPEN_MERGED_REGION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_OPEN_MERGED_REGION
case|:
name|addChildProcedure
argument_list|(
name|createAssignProcedures
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_POST_OPERATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_POST_OPERATION
case|:
name|postCompletedMergeRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|NO_MORE_STATE
return|;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|this
operator|+
literal|" unhandled state="
operator|+
name|state
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Error trying to merge regions "
operator|+
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|regionsToMerge
argument_list|)
operator|+
literal|" in the table "
operator|+
name|getTableName
argument_list|()
operator|+
literal|" (in state="
operator|+
name|state
operator|+
literal|")"
decl_stmt|;
if|if
condition|(
operator|!
name|isRollbackSupported
argument_list|(
name|state
argument_list|)
condition|)
block|{
comment|// We reach a state that cannot be rolled back. We just need to keep retrying.
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setFailure
argument_list|(
literal|"master-merge-regions"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Flow
operator|.
name|HAS_MORE_STATE
return|;
block|}
comment|/**    * To rollback {@link MergeTableRegionsProcedure}, two AssignProcedures are asynchronously    * submitted for each region to be merged (rollback doesn't wait on the completion of the    * AssignProcedures) . This can be improved by changing rollback() to support sub-procedures.    * See HBASE-19851 for details.    */
annotation|@
name|Override
specifier|protected
name|void
name|rollbackState
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|MergeTableRegionsState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|this
operator|+
literal|" rollback state="
operator|+
name|state
argument_list|)
expr_stmt|;
block|}
try|try
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MERGE_TABLE_REGIONS_POST_OPERATION
case|:
case|case
name|MERGE_TABLE_REGIONS_OPEN_MERGED_REGION
case|:
case|case
name|MERGE_TABLE_REGIONS_POST_MERGE_COMMIT_OPERATION
case|:
case|case
name|MERGE_TABLE_REGIONS_UPDATE_META
case|:
name|String
name|msg
init|=
name|this
operator|+
literal|" We are in the "
operator|+
name|state
operator|+
literal|" state."
operator|+
literal|" It is complicated to rollback the merge operation that region server is working on."
operator|+
literal|" Rollback is not supported and we should let the merge operation to complete"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|// PONR
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|this
operator|+
literal|" unhandled state="
operator|+
name|state
argument_list|)
throw|;
case|case
name|MERGE_TABLE_REGIONS_PRE_MERGE_COMMIT_OPERATION
case|:
break|break;
case|case
name|MERGE_TABLE_REGIONS_CREATE_MERGED_REGION
case|:
case|case
name|MERGE_TABLE_REGIONS_WRITE_MAX_SEQUENCE_ID_FILE
case|:
name|cleanupMergedRegion
argument_list|(
name|env
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_CHECK_CLOSED_REGIONS
case|:
break|break;
case|case
name|MERGE_TABLE_REGIONS_CLOSE_REGIONS
case|:
name|rollbackCloseRegionsForMerge
argument_list|(
name|env
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_PRE_MERGE_OPERATION
case|:
name|postRollBackMergeRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_PREPARE
case|:
break|break;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|this
operator|+
literal|" unhandled state="
operator|+
name|state
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// This will be retried. Unless there is a bug in the code,
comment|// this should be just a "temporary error" (e.g. network down)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed rollback attempt step "
operator|+
name|state
operator|+
literal|" for merging the regions "
operator|+
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|regionsToMerge
argument_list|)
operator|+
literal|" in table "
operator|+
name|getTableName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/*    * Check whether we are in the state that can be rolled back    */
annotation|@
name|Override
specifier|protected
name|boolean
name|isRollbackSupported
parameter_list|(
specifier|final
name|MergeTableRegionsState
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MERGE_TABLE_REGIONS_POST_OPERATION
case|:
case|case
name|MERGE_TABLE_REGIONS_OPEN_MERGED_REGION
case|:
case|case
name|MERGE_TABLE_REGIONS_POST_MERGE_COMMIT_OPERATION
case|:
case|case
name|MERGE_TABLE_REGIONS_UPDATE_META
case|:
comment|// It is not safe to rollback in these states.
return|return
literal|false
return|;
default|default:
break|break;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|MergeTableRegionsState
name|getState
parameter_list|(
specifier|final
name|int
name|stateId
parameter_list|)
block|{
return|return
name|MergeTableRegionsState
operator|.
name|forNumber
argument_list|(
name|stateId
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|getStateId
parameter_list|(
specifier|final
name|MergeTableRegionsState
name|state
parameter_list|)
block|{
return|return
name|state
operator|.
name|getNumber
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|MergeTableRegionsState
name|getInitialState
parameter_list|()
block|{
return|return
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_PREPARE
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|serializeStateData
parameter_list|(
name|ProcedureStateSerializer
name|serializer
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|serializeStateData
argument_list|(
name|serializer
argument_list|)
expr_stmt|;
specifier|final
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsStateData
operator|.
name|Builder
name|mergeTableRegionsMsg
init|=
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsStateData
operator|.
name|newBuilder
argument_list|()
operator|.
name|setUserInfo
argument_list|(
name|MasterProcedureUtil
operator|.
name|toProtoUserInfo
argument_list|(
name|getUser
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setMergedRegionInfo
argument_list|(
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|mergedRegion
argument_list|)
argument_list|)
operator|.
name|setForcible
argument_list|(
name|forcible
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionsToMerge
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|mergeTableRegionsMsg
operator|.
name|addRegionInfo
argument_list|(
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|regionsToMerge
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|serializer
operator|.
name|serialize
argument_list|(
name|mergeTableRegionsMsg
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|deserializeStateData
parameter_list|(
name|ProcedureStateSerializer
name|serializer
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|deserializeStateData
argument_list|(
name|serializer
argument_list|)
expr_stmt|;
specifier|final
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsStateData
name|mergeTableRegionsMsg
init|=
name|serializer
operator|.
name|deserialize
argument_list|(
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsStateData
operator|.
name|class
argument_list|)
decl_stmt|;
name|setUser
argument_list|(
name|MasterProcedureUtil
operator|.
name|toUserInfo
argument_list|(
name|mergeTableRegionsMsg
operator|.
name|getUserInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|mergeTableRegionsMsg
operator|.
name|getRegionInfoCount
argument_list|()
operator|==
literal|2
operator|)
assert|;
name|regionsToMerge
operator|=
operator|new
name|RegionInfo
index|[
name|mergeTableRegionsMsg
operator|.
name|getRegionInfoCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionsToMerge
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|regionsToMerge
index|[
name|i
index|]
operator|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|mergeTableRegionsMsg
operator|.
name|getRegionInfo
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mergedRegion
operator|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|mergeTableRegionsMsg
operator|.
name|getMergedRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|toStringClassDetails
parameter_list|(
name|StringBuilder
name|sb
parameter_list|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" table="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", regions="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|regionsToMerge
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", forcibly="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|forcible
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|LockState
name|acquireLock
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
if|if
condition|(
name|env
operator|.
name|getProcedureScheduler
argument_list|()
operator|.
name|waitRegions
argument_list|(
name|this
argument_list|,
name|getTableName
argument_list|()
argument_list|,
name|mergedRegion
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|LockState
operator|.
name|LOCK_EVENT_WAIT
operator|+
literal|" "
operator|+
name|env
operator|.
name|getProcedureScheduler
argument_list|()
operator|.
name|dumpLocks
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Ignore, just for logging
block|}
return|return
name|LockState
operator|.
name|LOCK_EVENT_WAIT
return|;
block|}
return|return
name|LockState
operator|.
name|LOCK_ACQUIRED
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|releaseLock
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
name|env
operator|.
name|getProcedureScheduler
argument_list|()
operator|.
name|wakeRegions
argument_list|(
name|this
argument_list|,
name|getTableName
argument_list|()
argument_list|,
name|mergedRegion
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|holdLock
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
name|getTableName
parameter_list|()
block|{
return|return
name|mergedRegion
operator|.
name|getTable
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableOperationType
name|getTableOperationType
parameter_list|()
block|{
return|return
name|TableOperationType
operator|.
name|REGION_MERGE
return|;
block|}
annotation|@
name|Override
specifier|protected
name|ProcedureMetrics
name|getProcedureMetrics
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
return|return
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getAssignmentManagerMetrics
argument_list|()
operator|.
name|getMergeProcMetrics
argument_list|()
return|;
block|}
comment|/**    * Prepare merge and do some check    */
specifier|private
name|boolean
name|prepareMergeRegion
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Note: the following logic assumes that we only have 2 regions to merge.  In the future,
comment|// if we want to extend to more than 2 regions, the code needs to be modified a little bit.
name|CatalogJanitor
name|catalogJanitor
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getCatalogJanitor
argument_list|()
decl_stmt|;
name|boolean
name|regionAHasMergeQualifier
init|=
operator|!
name|catalogJanitor
operator|.
name|cleanMergeQualifier
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionAHasMergeQualifier
operator|||
operator|!
name|catalogJanitor
operator|.
name|cleanMergeQualifier
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Skip merging regions "
operator|+
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|regionsToMerge
argument_list|)
operator|+
literal|", because region "
operator|+
operator|(
name|regionAHasMergeQualifier
condition|?
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getEncodedName
argument_list|()
else|:
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getEncodedName
argument_list|()
operator|)
operator|+
literal|" has merge qualifier"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MergeRegionException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|RegionStates
name|regionStates
init|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
name|RegionState
name|regionStateA
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|RegionState
name|regionStateB
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionStateA
operator|==
literal|null
operator|||
name|regionStateB
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|regionStateA
operator|==
literal|null
condition|?
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getEncodedName
argument_list|()
else|:
name|regionsToMerge
index|[
literal|1
index|]
operator|.
name|getEncodedName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|regionStateA
operator|.
name|isOpened
argument_list|()
operator|||
operator|!
name|regionStateB
operator|.
name|isOpened
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Unable to merge regions that are not online "
operator|+
name|regionStateA
operator|+
literal|", "
operator|+
name|regionStateB
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|isSplitOrMergeEnabled
argument_list|(
name|MasterSwitchType
operator|.
name|MERGE
argument_list|)
condition|)
block|{
name|String
name|regionsStr
init|=
name|Arrays
operator|.
name|deepToString
argument_list|(
name|regionsToMerge
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"merge switch is off! skip merge of "
operator|+
name|regionsStr
argument_list|)
expr_stmt|;
name|super
operator|.
name|setFailure
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
operator|new
name|IOException
argument_list|(
literal|"Merge of "
operator|+
name|regionsStr
operator|+
literal|" failed because merge switch is off"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Ask the remote regionserver if regions are mergeable. If we get an IOE, report it
comment|// along with the failure, so we can see why regions are not mergeable at this time.
name|IOException
name|mergeableCheckIOE
init|=
literal|null
decl_stmt|;
name|boolean
name|mergeable
init|=
literal|false
decl_stmt|;
name|RegionState
name|current
init|=
name|regionStateA
decl_stmt|;
try|try
block|{
name|mergeable
operator|=
name|isMergeable
argument_list|(
name|env
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|mergeableCheckIOE
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|mergeable
operator|&&
name|mergeableCheckIOE
operator|==
literal|null
condition|)
block|{
name|current
operator|=
name|regionStateB
expr_stmt|;
try|try
block|{
name|mergeable
operator|=
name|isMergeable
argument_list|(
name|env
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|mergeableCheckIOE
operator|=
name|e
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|mergeable
condition|)
block|{
name|IOException
name|e
init|=
operator|new
name|IOException
argument_list|(
name|current
operator|.
name|getRegion
argument_list|()
operator|.
name|getShortNameToLog
argument_list|()
operator|+
literal|" NOT mergeable"
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergeableCheckIOE
operator|!=
literal|null
condition|)
name|e
operator|.
name|initCause
argument_list|(
name|mergeableCheckIOE
argument_list|)
expr_stmt|;
name|super
operator|.
name|setFailure
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Update region states to Merging
name|setRegionStateToMerging
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|isMergeable
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|RegionState
name|rs
parameter_list|)
throws|throws
name|IOException
block|{
name|GetRegionInfoResponse
name|response
init|=
name|AssignmentManagerUtil
operator|.
name|getRegionInfoResponse
argument_list|(
name|env
argument_list|,
name|rs
operator|.
name|getServerName
argument_list|()
argument_list|,
name|rs
operator|.
name|getRegion
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|response
operator|.
name|hasMergeable
argument_list|()
operator|&&
name|response
operator|.
name|getMergeable
argument_list|()
return|;
block|}
comment|/**    * Pre merge region action    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|preMergeRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preMergeRegionsAction
argument_list|(
name|regionsToMerge
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// TODO: Clean up split and merge. Currently all over the place.
try|try
block|{
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getMasterQuotaManager
argument_list|()
operator|.
name|onRegionMerged
argument_list|(
name|this
operator|.
name|mergedRegion
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getRegionNormalizer
argument_list|()
operator|.
name|planSkipped
argument_list|(
name|this
operator|.
name|mergedRegion
argument_list|,
name|NormalizationPlan
operator|.
name|PlanType
operator|.
name|MERGE
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Action after rollback a merge table regions action.    * @param env MasterProcedureEnv    * @throws IOException    */
specifier|private
name|void
name|postRollBackMergeRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postRollBackMergeRegionsAction
argument_list|(
name|regionsToMerge
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the region states to MERGING state    */
specifier|private
name|void
name|setRegionStateToMerging
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
comment|// Set State.MERGING to regions to be merged
name|RegionStates
name|regionStates
init|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|)
operator|.
name|setState
argument_list|(
name|State
operator|.
name|MERGING
argument_list|)
expr_stmt|;
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
operator|.
name|setState
argument_list|(
name|State
operator|.
name|MERGING
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a merged region    * @param env MasterProcedureEnv    */
specifier|private
name|void
name|createMergedRegion
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterFileSystem
name|mfs
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getMasterFileSystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|tabledir
init|=
name|FSUtils
operator|.
name|getTableDir
argument_list|(
name|mfs
operator|.
name|getRootDir
argument_list|()
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|FileSystem
name|fs
init|=
name|mfs
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|HRegionFileSystem
name|regionFs
init|=
name|HRegionFileSystem
operator|.
name|openRegionFromFileSystem
argument_list|(
name|env
operator|.
name|getMasterConfiguration
argument_list|()
argument_list|,
name|fs
argument_list|,
name|tabledir
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|regionFs
operator|.
name|createMergesDir
argument_list|()
expr_stmt|;
name|mergeStoreFiles
argument_list|(
name|env
argument_list|,
name|regionFs
argument_list|,
name|regionFs
operator|.
name|getMergesDir
argument_list|()
argument_list|)
expr_stmt|;
name|HRegionFileSystem
name|regionFs2
init|=
name|HRegionFileSystem
operator|.
name|openRegionFromFileSystem
argument_list|(
name|env
operator|.
name|getMasterConfiguration
argument_list|()
argument_list|,
name|fs
argument_list|,
name|tabledir
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|mergeStoreFiles
argument_list|(
name|env
argument_list|,
name|regionFs2
argument_list|,
name|regionFs
operator|.
name|getMergesDir
argument_list|()
argument_list|)
expr_stmt|;
name|regionFs
operator|.
name|commitMergedRegion
argument_list|(
name|mergedRegion
argument_list|)
expr_stmt|;
comment|//Prepare to create merged regions
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|mergedRegion
argument_list|)
operator|.
name|setState
argument_list|(
name|State
operator|.
name|MERGING_NEW
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create reference file(s) of merging regions under the merged directory    * @param env MasterProcedureEnv    * @param regionFs region file system    * @param mergedDir the temp directory of merged region    */
specifier|private
name|void
name|mergeStoreFiles
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|HRegionFileSystem
name|regionFs
parameter_list|,
specifier|final
name|Path
name|mergedDir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterFileSystem
name|mfs
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getMasterFileSystem
argument_list|()
decl_stmt|;
specifier|final
name|Configuration
name|conf
init|=
name|env
operator|.
name|getMasterConfiguration
argument_list|()
decl_stmt|;
specifier|final
name|TableDescriptor
name|htd
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|family
range|:
name|regionFs
operator|.
name|getFamilies
argument_list|()
control|)
block|{
specifier|final
name|ColumnFamilyDescriptor
name|hcd
init|=
name|htd
operator|.
name|getColumnFamily
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|family
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|StoreFileInfo
argument_list|>
name|storeFiles
init|=
name|regionFs
operator|.
name|getStoreFiles
argument_list|(
name|family
argument_list|)
decl_stmt|;
if|if
condition|(
name|storeFiles
operator|!=
literal|null
operator|&&
name|storeFiles
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|CacheConfig
name|cacheConf
init|=
operator|new
name|CacheConfig
argument_list|(
name|conf
argument_list|,
name|hcd
argument_list|)
decl_stmt|;
for|for
control|(
name|StoreFileInfo
name|storeFileInfo
range|:
name|storeFiles
control|)
block|{
comment|// Create reference file(s) of the region in mergedDir
name|regionFs
operator|.
name|mergeStoreFile
argument_list|(
name|mergedRegion
argument_list|,
name|family
argument_list|,
operator|new
name|HStoreFile
argument_list|(
name|mfs
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|storeFileInfo
argument_list|,
name|conf
argument_list|,
name|cacheConf
argument_list|,
name|hcd
operator|.
name|getBloomFilterType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|,
name|mergedDir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Clean up a merged region    * @param env MasterProcedureEnv    */
specifier|private
name|void
name|cleanupMergedRegion
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterFileSystem
name|mfs
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getMasterFileSystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|tabledir
init|=
name|FSUtils
operator|.
name|getTableDir
argument_list|(
name|mfs
operator|.
name|getRootDir
argument_list|()
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|FileSystem
name|fs
init|=
name|mfs
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|HRegionFileSystem
name|regionFs
init|=
name|HRegionFileSystem
operator|.
name|openRegionFromFileSystem
argument_list|(
name|env
operator|.
name|getMasterConfiguration
argument_list|()
argument_list|,
name|fs
argument_list|,
name|tabledir
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|regionFs
operator|.
name|cleanupMergedRegion
argument_list|(
name|mergedRegion
argument_list|)
expr_stmt|;
block|}
comment|/**    * Rollback close regions    **/
specifier|private
name|void
name|rollbackCloseRegionsForMerge
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|AssignmentManagerUtil
operator|.
name|reopenRegionsForRollback
argument_list|(
name|env
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|regionsToMerge
argument_list|)
argument_list|,
name|getRegionReplication
argument_list|(
name|env
argument_list|)
argument_list|,
name|getServerName
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|TransitRegionStateProcedure
index|[]
name|createUnassignProcedures
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|AssignmentManagerUtil
operator|.
name|createUnassignProceduresForSplitOrMerge
argument_list|(
name|env
argument_list|,
name|Stream
operator|.
name|of
argument_list|(
name|regionsToMerge
argument_list|)
argument_list|,
name|getRegionReplication
argument_list|(
name|env
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|TransitRegionStateProcedure
index|[]
name|createAssignProcedures
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|AssignmentManagerUtil
operator|.
name|createAssignProceduresForOpeningNewRegions
argument_list|(
name|env
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|mergedRegion
argument_list|)
argument_list|,
name|getRegionReplication
argument_list|(
name|env
argument_list|)
argument_list|,
name|getServerName
argument_list|(
name|env
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|int
name|getRegionReplication
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|TableDescriptor
name|htd
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|htd
operator|.
name|getRegionReplication
argument_list|()
return|;
block|}
comment|/**    * Post merge region action    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|preMergeRegionsCommit
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
annotation|@
name|MetaMutationAnnotation
specifier|final
name|List
argument_list|<
name|Mutation
argument_list|>
name|metaEntries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|cpHost
operator|.
name|preMergeRegionsCommit
argument_list|(
name|regionsToMerge
argument_list|,
name|metaEntries
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
for|for
control|(
name|Mutation
name|p
range|:
name|metaEntries
control|)
block|{
name|RegionInfo
operator|.
name|parseRegionName
argument_list|(
name|p
operator|.
name|getRow
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Row key of mutation from coprocessor is not parsable as region name. "
operator|+
literal|"Mutations from coprocessor should only be for hbase:meta table."
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * Add merged region to META and delete original regions.    */
specifier|private
name|void
name|updateMetaForMergedRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ServerName
name|serverName
init|=
name|getServerName
argument_list|(
name|env
argument_list|)
decl_stmt|;
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|markRegionAsMerged
argument_list|(
name|mergedRegion
argument_list|,
name|serverName
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
name|regionsToMerge
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Post merge region action    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|postMergeRegionsCommit
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postMergeRegionsCommit
argument_list|(
name|regionsToMerge
argument_list|,
name|mergedRegion
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Post merge region action    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|postCompletedMergeRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postCompletedMergeRegionsAction
argument_list|(
name|regionsToMerge
argument_list|,
name|mergedRegion
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The procedure could be restarted from a different machine. If the variable is null, we need to    * retrieve it.    * @param env MasterProcedureEnv    * @return serverName    */
specifier|private
name|ServerName
name|getServerName
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
if|if
condition|(
name|regionLocation
operator|==
literal|null
condition|)
block|{
name|regionLocation
operator|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionServerOfRegion
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// May still be null here but return null and let caller deal.
comment|// Means we lost the in-memory-only location. We are in recovery
comment|// or so. The caller should be able to deal w/ a null ServerName.
comment|// Let them go to the Balancer to find one to use instead.
block|}
return|return
name|regionLocation
return|;
block|}
specifier|private
name|void
name|writeMaxSequenceIdFile
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getMasterFileSystem
argument_list|()
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|long
name|maxSequenceId
init|=
operator|-
literal|1L
decl_stmt|;
for|for
control|(
name|RegionInfo
name|region
range|:
name|regionsToMerge
control|)
block|{
name|maxSequenceId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxSequenceId
argument_list|,
name|WALSplitter
operator|.
name|getMaxRegionSequenceId
argument_list|(
name|fs
argument_list|,
name|getRegionDir
argument_list|(
name|env
argument_list|,
name|region
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxSequenceId
operator|>
literal|0
condition|)
block|{
name|WALSplitter
operator|.
name|writeRegionSequenceIdFile
argument_list|(
name|fs
argument_list|,
name|getRegionDir
argument_list|(
name|env
argument_list|,
name|mergedRegion
argument_list|)
argument_list|,
name|maxSequenceId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The procedure could be restarted from a different machine. If the variable is null, we need to    * retrieve it.    * @return traceEnabled    */
specifier|private
name|Boolean
name|isTraceEnabled
parameter_list|()
block|{
if|if
condition|(
name|traceEnabled
operator|==
literal|null
condition|)
block|{
name|traceEnabled
operator|=
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
expr_stmt|;
block|}
return|return
name|traceEnabled
return|;
block|}
comment|/**    * @return The merged region. Maybe be null if called to early or we failed.    */
annotation|@
name|VisibleForTesting
specifier|public
name|RegionInfo
name|getMergedRegion
parameter_list|()
block|{
return|return
name|this
operator|.
name|mergedRegion
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|abort
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
comment|// Abort means rollback. We can't rollback all steps. HBASE-18018 added abort to all
comment|// Procedures. Here is a Procedure that has a PONR and cannot be aborted once it enters this
comment|// range of steps; what do we do for these should an operator want to cancel them? HBASE-20022.
return|return
name|isRollbackSupported
argument_list|(
name|getCurrentState
argument_list|()
argument_list|)
condition|?
name|super
operator|.
name|abort
argument_list|(
name|env
argument_list|)
else|:
literal|false
return|;
block|}
block|}
end_class

end_unit

