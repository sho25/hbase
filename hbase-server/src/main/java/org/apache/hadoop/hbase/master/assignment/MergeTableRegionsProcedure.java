begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaMutationAnnotation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ColumnFamilyDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|DoNotRetryRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MasterSwitchType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Mutation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfoBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|MergeRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|CacheConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|CatalogJanitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterCoprocessorHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|NormalizationPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|AbstractStateMachineTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureEnv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureStateSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegionFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HStoreFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreFileInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALSplitUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|GetRegionInfoResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProcedureProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsState
import|;
end_import

begin_comment
comment|/**  * The procedure to Merge regions in a table. This procedure takes an exclusive table  * lock since it is working over multiple regions. It holds the lock for the life of the procedure.  * Throws exception on construction if determines context hostile to merge (cluster going down or  * master is shutting down or table is disabled).  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|MergeTableRegionsProcedure
extends|extends
name|AbstractStateMachineTableProcedure
argument_list|<
name|MergeTableRegionsState
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MergeTableRegionsProcedure
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|ServerName
name|regionLocation
decl_stmt|;
comment|/**    * Two or more regions to merge, the 'merge parents'.    */
specifier|private
name|RegionInfo
index|[]
name|regionsToMerge
decl_stmt|;
comment|/**    * The resulting merged region.    */
specifier|private
name|RegionInfo
name|mergedRegion
decl_stmt|;
specifier|private
name|boolean
name|force
decl_stmt|;
specifier|public
name|MergeTableRegionsProcedure
parameter_list|()
block|{
comment|// Required by the Procedure framework to create the procedure on replay
block|}
specifier|public
name|MergeTableRegionsProcedure
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|RegionInfo
index|[]
name|regionsToMerge
parameter_list|,
specifier|final
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|// Check parent regions. Make sure valid before starting work.
comment|// This check calls the super method #checkOnline also.
name|checkRegionsToMerge
argument_list|(
name|env
argument_list|,
name|regionsToMerge
argument_list|,
name|force
argument_list|)
expr_stmt|;
comment|// Sort the regions going into the merge.
name|Arrays
operator|.
name|sort
argument_list|(
name|regionsToMerge
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionsToMerge
operator|=
name|regionsToMerge
expr_stmt|;
name|this
operator|.
name|mergedRegion
operator|=
name|createMergedRegionInfo
argument_list|(
name|regionsToMerge
argument_list|)
expr_stmt|;
comment|// Preflight depends on mergedRegion being set (at least).
name|preflightChecks
argument_list|(
name|env
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|force
operator|=
name|force
expr_stmt|;
block|}
comment|/**    * @throws MergeRegionException If unable to merge regions for whatever reasons.    */
specifier|private
specifier|static
name|void
name|checkRegionsToMerge
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|RegionInfo
index|[]
name|regions
parameter_list|,
specifier|final
name|boolean
name|force
parameter_list|)
throws|throws
name|MergeRegionException
block|{
name|long
name|count
init|=
name|Arrays
operator|.
name|stream
argument_list|(
name|regions
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|regions
operator|.
name|length
operator|!=
name|count
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Duplicate regions specified; cannot merge a region to "
operator|+
literal|"itself. Passed in "
operator|+
name|regions
operator|.
name|length
operator|+
literal|" but only "
operator|+
name|count
operator|+
literal|" unique."
argument_list|)
throw|;
block|}
if|if
condition|(
name|count
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Need two Regions at least to run a Merge"
argument_list|)
throw|;
block|}
name|RegionInfo
name|previous
init|=
literal|null
decl_stmt|;
for|for
control|(
name|RegionInfo
name|ri
range|:
name|regions
control|)
block|{
if|if
condition|(
name|previous
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|previous
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|ri
operator|.
name|getTable
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Can't merge regions from different tables: "
operator|+
name|previous
operator|+
literal|", "
operator|+
name|ri
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MergeRegionException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
name|ri
operator|.
name|isAdjacent
argument_list|(
name|previous
argument_list|)
operator|&&
operator|!
name|ri
operator|.
name|isOverlap
argument_list|(
name|previous
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Unable to merge non-adjacent or non-overlapping regions "
operator|+
name|previous
operator|.
name|getShortNameToLog
argument_list|()
operator|+
literal|", "
operator|+
name|ri
operator|.
name|getShortNameToLog
argument_list|()
operator|+
literal|" when force=false"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MergeRegionException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|ri
operator|.
name|getReplicaId
argument_list|()
operator|!=
name|RegionInfo
operator|.
name|DEFAULT_REPLICA_ID
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Can't merge non-default replicas; "
operator|+
name|ri
argument_list|)
throw|;
block|}
try|try
block|{
name|checkOnline
argument_list|(
name|env
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DoNotRetryRegionException
name|dnrre
parameter_list|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
name|dnrre
argument_list|)
throw|;
block|}
name|previous
operator|=
name|ri
expr_stmt|;
block|}
block|}
comment|/**    * Create merged region info by looking at passed in<code>regionsToMerge</code>    * to figure what extremes for start and end keys to use; merged region needs    * to have an extent sufficient to cover all regions-to-merge.    */
specifier|private
specifier|static
name|RegionInfo
name|createMergedRegionInfo
parameter_list|(
specifier|final
name|RegionInfo
index|[]
name|regionsToMerge
parameter_list|)
block|{
name|byte
index|[]
name|lowestStartKey
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|highestEndKey
init|=
literal|null
decl_stmt|;
comment|// Region Id is a timestamp. Merged region's id can't be less than that of
comment|// merging regions else will insert at wrong location in hbase:meta (See HBASE-710).
name|long
name|highestRegionId
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|RegionInfo
name|ri
range|:
name|regionsToMerge
control|)
block|{
if|if
condition|(
name|lowestStartKey
operator|==
literal|null
condition|)
block|{
name|lowestStartKey
operator|=
name|ri
operator|.
name|getStartKey
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|ri
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|lowestStartKey
argument_list|)
operator|<
literal|0
condition|)
block|{
name|lowestStartKey
operator|=
name|ri
operator|.
name|getStartKey
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|highestEndKey
operator|==
literal|null
condition|)
block|{
name|highestEndKey
operator|=
name|ri
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ri
operator|.
name|isLast
argument_list|()
operator|||
name|Bytes
operator|.
name|compareTo
argument_list|(
name|ri
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|highestEndKey
argument_list|)
operator|>
literal|0
condition|)
block|{
name|highestEndKey
operator|=
name|ri
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
block|}
name|highestRegionId
operator|=
name|ri
operator|.
name|getRegionId
argument_list|()
operator|>
name|highestRegionId
condition|?
name|ri
operator|.
name|getRegionId
argument_list|()
else|:
name|highestRegionId
expr_stmt|;
block|}
comment|// Merged region is sorted between two merging regions in META
return|return
name|RegionInfoBuilder
operator|.
name|newBuilder
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getTable
argument_list|()
argument_list|)
operator|.
name|setStartKey
argument_list|(
name|lowestStartKey
argument_list|)
operator|.
name|setEndKey
argument_list|(
name|highestEndKey
argument_list|)
operator|.
name|setSplit
argument_list|(
literal|false
argument_list|)
operator|.
name|setRegionId
argument_list|(
name|highestRegionId
operator|+
literal|1
comment|/*Add one so new merged region is highest*/
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Flow
name|executeFromState
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
name|MergeTableRegionsState
name|state
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{} execute state={}"
argument_list|,
name|this
argument_list|,
name|state
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MERGE_TABLE_REGIONS_PREPARE
case|:
if|if
condition|(
operator|!
name|prepareMergeRegion
argument_list|(
name|env
argument_list|)
condition|)
block|{
assert|assert
name|isFailed
argument_list|()
operator|:
literal|"Merge region should have an exception here"
assert|;
return|return
name|Flow
operator|.
name|NO_MORE_STATE
return|;
block|}
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_PRE_MERGE_OPERATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_PRE_MERGE_OPERATION
case|:
name|preMergeRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_CLOSE_REGIONS
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_CLOSE_REGIONS
case|:
name|addChildProcedure
argument_list|(
name|createUnassignProcedures
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_CHECK_CLOSED_REGIONS
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_CHECK_CLOSED_REGIONS
case|:
name|checkClosedRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_CREATE_MERGED_REGION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_CREATE_MERGED_REGION
case|:
name|removeNonDefaultReplicas
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|createMergedRegion
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_WRITE_MAX_SEQUENCE_ID_FILE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_WRITE_MAX_SEQUENCE_ID_FILE
case|:
name|writeMaxSequenceIdFile
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_PRE_MERGE_COMMIT_OPERATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_PRE_MERGE_COMMIT_OPERATION
case|:
name|preMergeRegionsCommit
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_UPDATE_META
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_UPDATE_META
case|:
name|updateMetaForMergedRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_POST_MERGE_COMMIT_OPERATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_POST_MERGE_COMMIT_OPERATION
case|:
name|postMergeRegionsCommit
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_OPEN_MERGED_REGION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_OPEN_MERGED_REGION
case|:
name|addChildProcedure
argument_list|(
name|createAssignProcedures
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
name|setNextState
argument_list|(
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_POST_OPERATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_POST_OPERATION
case|:
name|postCompletedMergeRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
name|Flow
operator|.
name|NO_MORE_STATE
return|;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|this
operator|+
literal|" unhandled state="
operator|+
name|state
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Error trying to merge "
operator|+
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|regionsToMerge
argument_list|)
operator|+
literal|" in "
operator|+
name|getTableName
argument_list|()
operator|+
literal|" (in state="
operator|+
name|state
operator|+
literal|")"
decl_stmt|;
if|if
condition|(
operator|!
name|isRollbackSupported
argument_list|(
name|state
argument_list|)
condition|)
block|{
comment|// We reach a state that cannot be rolled back. We just need to keep retrying.
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setFailure
argument_list|(
literal|"master-merge-regions"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Flow
operator|.
name|HAS_MORE_STATE
return|;
block|}
comment|/**    * To rollback {@link MergeTableRegionsProcedure}, two AssignProcedures are asynchronously    * submitted for each region to be merged (rollback doesn't wait on the completion of the    * AssignProcedures) . This can be improved by changing rollback() to support sub-procedures.    * See HBASE-19851 for details.    */
annotation|@
name|Override
specifier|protected
name|void
name|rollbackState
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|MergeTableRegionsState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{} rollback state={}"
argument_list|,
name|this
argument_list|,
name|state
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MERGE_TABLE_REGIONS_POST_OPERATION
case|:
case|case
name|MERGE_TABLE_REGIONS_OPEN_MERGED_REGION
case|:
case|case
name|MERGE_TABLE_REGIONS_POST_MERGE_COMMIT_OPERATION
case|:
case|case
name|MERGE_TABLE_REGIONS_UPDATE_META
case|:
name|String
name|msg
init|=
name|this
operator|+
literal|" We are in the "
operator|+
name|state
operator|+
literal|" state."
operator|+
literal|" It is complicated to rollback the merge operation that region server is working on."
operator|+
literal|" Rollback is not supported and we should let the merge operation to complete"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|// PONR
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|this
operator|+
literal|" unhandled state="
operator|+
name|state
argument_list|)
throw|;
case|case
name|MERGE_TABLE_REGIONS_PRE_MERGE_COMMIT_OPERATION
case|:
break|break;
case|case
name|MERGE_TABLE_REGIONS_CREATE_MERGED_REGION
case|:
case|case
name|MERGE_TABLE_REGIONS_WRITE_MAX_SEQUENCE_ID_FILE
case|:
name|cleanupMergedRegion
argument_list|(
name|env
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_CHECK_CLOSED_REGIONS
case|:
break|break;
case|case
name|MERGE_TABLE_REGIONS_CLOSE_REGIONS
case|:
name|rollbackCloseRegionsForMerge
argument_list|(
name|env
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_PRE_MERGE_OPERATION
case|:
name|postRollBackMergeRegions
argument_list|(
name|env
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE_TABLE_REGIONS_PREPARE
case|:
break|break;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|this
operator|+
literal|" unhandled state="
operator|+
name|state
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// This will be retried. Unless there is a bug in the code,
comment|// this should be just a "temporary error" (e.g. network down)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed rollback attempt step "
operator|+
name|state
operator|+
literal|" for merging the regions "
operator|+
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|regionsToMerge
argument_list|)
operator|+
literal|" in table "
operator|+
name|getTableName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/*    * Check whether we are in the state that can be rolled back    */
annotation|@
name|Override
specifier|protected
name|boolean
name|isRollbackSupported
parameter_list|(
specifier|final
name|MergeTableRegionsState
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MERGE_TABLE_REGIONS_POST_OPERATION
case|:
case|case
name|MERGE_TABLE_REGIONS_OPEN_MERGED_REGION
case|:
case|case
name|MERGE_TABLE_REGIONS_POST_MERGE_COMMIT_OPERATION
case|:
case|case
name|MERGE_TABLE_REGIONS_UPDATE_META
case|:
comment|// It is not safe to rollback in these states.
return|return
literal|false
return|;
default|default:
break|break;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|removeNonDefaultReplicas
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|AssignmentManagerUtil
operator|.
name|removeNonDefaultReplicas
argument_list|(
name|env
argument_list|,
name|Stream
operator|.
name|of
argument_list|(
name|regionsToMerge
argument_list|)
argument_list|,
name|getRegionReplication
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkClosedRegions
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Theoretically this should not happen any more after we use TRSP, but anyway
comment|// let's add a check here
for|for
control|(
name|RegionInfo
name|region
range|:
name|regionsToMerge
control|)
block|{
name|AssignmentManagerUtil
operator|.
name|checkClosedRegion
argument_list|(
name|env
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|MergeTableRegionsState
name|getState
parameter_list|(
specifier|final
name|int
name|stateId
parameter_list|)
block|{
return|return
name|MergeTableRegionsState
operator|.
name|forNumber
argument_list|(
name|stateId
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|getStateId
parameter_list|(
specifier|final
name|MergeTableRegionsState
name|state
parameter_list|)
block|{
return|return
name|state
operator|.
name|getNumber
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|MergeTableRegionsState
name|getInitialState
parameter_list|()
block|{
return|return
name|MergeTableRegionsState
operator|.
name|MERGE_TABLE_REGIONS_PREPARE
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|serializeStateData
parameter_list|(
name|ProcedureStateSerializer
name|serializer
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|serializeStateData
argument_list|(
name|serializer
argument_list|)
expr_stmt|;
specifier|final
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsStateData
operator|.
name|Builder
name|mergeTableRegionsMsg
init|=
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsStateData
operator|.
name|newBuilder
argument_list|()
operator|.
name|setUserInfo
argument_list|(
name|MasterProcedureUtil
operator|.
name|toProtoUserInfo
argument_list|(
name|getUser
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setMergedRegionInfo
argument_list|(
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|mergedRegion
argument_list|)
argument_list|)
operator|.
name|setForcible
argument_list|(
name|force
argument_list|)
decl_stmt|;
for|for
control|(
name|RegionInfo
name|ri
range|:
name|regionsToMerge
control|)
block|{
name|mergeTableRegionsMsg
operator|.
name|addRegionInfo
argument_list|(
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|ri
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|serializer
operator|.
name|serialize
argument_list|(
name|mergeTableRegionsMsg
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|deserializeStateData
parameter_list|(
name|ProcedureStateSerializer
name|serializer
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|deserializeStateData
argument_list|(
name|serializer
argument_list|)
expr_stmt|;
specifier|final
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsStateData
name|mergeTableRegionsMsg
init|=
name|serializer
operator|.
name|deserialize
argument_list|(
name|MasterProcedureProtos
operator|.
name|MergeTableRegionsStateData
operator|.
name|class
argument_list|)
decl_stmt|;
name|setUser
argument_list|(
name|MasterProcedureUtil
operator|.
name|toUserInfo
argument_list|(
name|mergeTableRegionsMsg
operator|.
name|getUserInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|mergeTableRegionsMsg
operator|.
name|getRegionInfoCount
argument_list|()
operator|==
literal|2
operator|)
assert|;
name|regionsToMerge
operator|=
operator|new
name|RegionInfo
index|[
name|mergeTableRegionsMsg
operator|.
name|getRegionInfoCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionsToMerge
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|regionsToMerge
index|[
name|i
index|]
operator|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|mergeTableRegionsMsg
operator|.
name|getRegionInfo
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mergedRegion
operator|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|mergeTableRegionsMsg
operator|.
name|getMergedRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|toStringClassDetails
parameter_list|(
name|StringBuilder
name|sb
parameter_list|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" table="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", regions="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|regionsToMerge
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", force="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|force
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|LockState
name|acquireLock
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
name|RegionInfo
index|[]
name|lockRegions
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|regionsToMerge
argument_list|,
name|regionsToMerge
operator|.
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|lockRegions
index|[
name|lockRegions
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|mergedRegion
expr_stmt|;
if|if
condition|(
name|env
operator|.
name|getProcedureScheduler
argument_list|()
operator|.
name|waitRegions
argument_list|(
name|this
argument_list|,
name|getTableName
argument_list|()
argument_list|,
name|lockRegions
argument_list|)
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|LockState
operator|.
name|LOCK_EVENT_WAIT
operator|+
literal|" "
operator|+
name|env
operator|.
name|getProcedureScheduler
argument_list|()
operator|.
name|dumpLocks
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Ignore, just for logging
block|}
return|return
name|LockState
operator|.
name|LOCK_EVENT_WAIT
return|;
block|}
return|return
name|LockState
operator|.
name|LOCK_ACQUIRED
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|releaseLock
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
name|RegionInfo
index|[]
name|lockRegions
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|regionsToMerge
argument_list|,
name|regionsToMerge
operator|.
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|lockRegions
index|[
name|lockRegions
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|mergedRegion
expr_stmt|;
name|env
operator|.
name|getProcedureScheduler
argument_list|()
operator|.
name|wakeRegions
argument_list|(
name|this
argument_list|,
name|getTableName
argument_list|()
argument_list|,
name|lockRegions
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|holdLock
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
name|getTableName
parameter_list|()
block|{
return|return
name|mergedRegion
operator|.
name|getTable
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableOperationType
name|getTableOperationType
parameter_list|()
block|{
return|return
name|TableOperationType
operator|.
name|REGION_MERGE
return|;
block|}
annotation|@
name|Override
specifier|protected
name|ProcedureMetrics
name|getProcedureMetrics
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
return|return
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getAssignmentManagerMetrics
argument_list|()
operator|.
name|getMergeProcMetrics
argument_list|()
return|;
block|}
comment|/**    * Prepare merge and do some check    */
specifier|private
name|boolean
name|prepareMergeRegion
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Fail if we are taking snapshot for the given table
name|TableName
name|tn
init|=
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getSnapshotManager
argument_list|()
operator|.
name|isTakingSnapshot
argument_list|(
name|tn
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Skip merging regions "
operator|+
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|regionsToMerge
argument_list|)
operator|+
literal|", because we are snapshotting "
operator|+
name|tn
argument_list|)
throw|;
block|}
comment|// Mostly this check is not used because we already check the switch before submit a merge
comment|// procedure. Just for safe, check the switch again. This procedure can be rollbacked if
comment|// the switch was set to false after submit.
if|if
condition|(
operator|!
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|isSplitOrMergeEnabled
argument_list|(
name|MasterSwitchType
operator|.
name|MERGE
argument_list|)
condition|)
block|{
name|String
name|regionsStr
init|=
name|Arrays
operator|.
name|deepToString
argument_list|(
name|this
operator|.
name|regionsToMerge
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Merge switch is off! skip merge of "
operator|+
name|regionsStr
argument_list|)
expr_stmt|;
name|super
operator|.
name|setFailure
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
operator|new
name|IOException
argument_list|(
literal|"Merge of "
operator|+
name|regionsStr
operator|+
literal|" failed because merge switch is off"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|getTableName
argument_list|()
argument_list|)
operator|.
name|isMergeEnabled
argument_list|()
condition|)
block|{
name|String
name|regionsStr
init|=
name|Arrays
operator|.
name|deepToString
argument_list|(
name|regionsToMerge
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Merge is disabled for the table! Skipping merge of {}"
argument_list|,
name|regionsStr
argument_list|)
expr_stmt|;
name|super
operator|.
name|setFailure
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
operator|new
name|IOException
argument_list|(
literal|"Merge of "
operator|+
name|regionsStr
operator|+
literal|" failed as region merge is disabled for the table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|CatalogJanitor
name|catalogJanitor
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getCatalogJanitor
argument_list|()
decl_stmt|;
name|RegionStates
name|regionStates
init|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
for|for
control|(
name|RegionInfo
name|ri
range|:
name|this
operator|.
name|regionsToMerge
control|)
block|{
if|if
condition|(
operator|!
name|catalogJanitor
operator|.
name|cleanMergeQualifier
argument_list|(
name|ri
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Skip merging "
operator|+
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|regionsToMerge
argument_list|)
operator|+
literal|", because parent "
operator|+
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|ri
argument_list|)
operator|+
literal|" has a merge qualifier"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MergeRegionException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|RegionState
name|state
init|=
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|ri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
literal|"No state for "
operator|+
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|ri
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|state
operator|.
name|isOpened
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Unable to merge regions that are not online: "
operator|+
name|ri
argument_list|)
throw|;
block|}
comment|// Ask the remote regionserver if regions are mergeable. If we get an IOE, report it
comment|// along with the failure, so we can see why regions are not mergeable at this time.
try|try
block|{
if|if
condition|(
operator|!
name|isMergeable
argument_list|(
name|env
argument_list|,
name|state
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOException
name|ioe
init|=
operator|new
name|IOException
argument_list|(
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|ri
argument_list|)
operator|+
literal|" NOT mergeable"
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|super
operator|.
name|setFailure
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// Update region states to Merging
name|setRegionStateToMerging
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|isMergeable
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|RegionState
name|rs
parameter_list|)
throws|throws
name|IOException
block|{
name|GetRegionInfoResponse
name|response
init|=
name|AssignmentManagerUtil
operator|.
name|getRegionInfoResponse
argument_list|(
name|env
argument_list|,
name|rs
operator|.
name|getServerName
argument_list|()
argument_list|,
name|rs
operator|.
name|getRegion
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|response
operator|.
name|hasMergeable
argument_list|()
operator|&&
name|response
operator|.
name|getMergeable
argument_list|()
return|;
block|}
comment|/**    * Pre merge region action    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|preMergeRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preMergeRegionsAction
argument_list|(
name|regionsToMerge
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// TODO: Clean up split and merge. Currently all over the place.
try|try
block|{
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getMasterQuotaManager
argument_list|()
operator|.
name|onRegionMerged
argument_list|(
name|this
operator|.
name|mergedRegion
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getRegionNormalizer
argument_list|()
operator|.
name|planSkipped
argument_list|(
name|this
operator|.
name|mergedRegion
argument_list|,
name|NormalizationPlan
operator|.
name|PlanType
operator|.
name|MERGE
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Action after rollback a merge table regions action.    */
specifier|private
name|void
name|postRollBackMergeRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postRollBackMergeRegionsAction
argument_list|(
name|regionsToMerge
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the region states to MERGING state    */
specifier|private
name|void
name|setRegionStateToMerging
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
comment|// Set State.MERGING to regions to be merged
name|RegionStates
name|regionStates
init|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
for|for
control|(
name|RegionInfo
name|ri
range|:
name|this
operator|.
name|regionsToMerge
control|)
block|{
name|regionStates
operator|.
name|getRegionStateNode
argument_list|(
name|ri
argument_list|)
operator|.
name|setState
argument_list|(
name|State
operator|.
name|MERGING
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create merged region.    * The way the merge works is that we make a 'merges' temporary    * directory in the FIRST parent region to merge (Do not change this without    * also changing the rollback where we look in this FIRST region for the    * merge dir). We then collect here references to all the store files in all    * the parent regions including those of the FIRST parent region into a    * subdirectory, named for the resultant merged region. We then call    * commitMergeRegion. It finds this subdirectory of storefile references    * and moves them under the new merge region (creating the region layout    * as side effect). After assign of the new merge region, we will run a    * compaction. This will undo the references but the reference files remain    * in place until the archiver runs (which it does on a period as a chore    * in the RegionServer that hosts the merge region -- see    * CompactedHFilesDischarger). Once the archiver has moved aside the    * no-longer used references, the merge region no longer has references.    * The catalog janitor will notice when it runs next and it will remove    * the old parent regions.    */
specifier|private
name|void
name|createMergedRegion
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterFileSystem
name|mfs
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getMasterFileSystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|tabledir
init|=
name|FSUtils
operator|.
name|getTableDir
argument_list|(
name|mfs
operator|.
name|getRootDir
argument_list|()
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|FileSystem
name|fs
init|=
name|mfs
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|HRegionFileSystem
name|mergeRegionFs
init|=
literal|null
decl_stmt|;
for|for
control|(
name|RegionInfo
name|ri
range|:
name|this
operator|.
name|regionsToMerge
control|)
block|{
name|HRegionFileSystem
name|regionFs
init|=
name|HRegionFileSystem
operator|.
name|openRegionFromFileSystem
argument_list|(
name|env
operator|.
name|getMasterConfiguration
argument_list|()
argument_list|,
name|fs
argument_list|,
name|tabledir
argument_list|,
name|ri
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergeRegionFs
operator|==
literal|null
condition|)
block|{
name|mergeRegionFs
operator|=
name|regionFs
expr_stmt|;
name|mergeRegionFs
operator|.
name|createMergesDir
argument_list|()
expr_stmt|;
block|}
name|mergeStoreFiles
argument_list|(
name|env
argument_list|,
name|regionFs
argument_list|,
name|mergeRegionFs
operator|.
name|getMergesDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|mergeRegionFs
operator|!=
literal|null
assert|;
name|mergeRegionFs
operator|.
name|commitMergedRegion
argument_list|(
name|mergedRegion
argument_list|)
expr_stmt|;
comment|// Prepare to create merged regions
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getOrCreateRegionStateNode
argument_list|(
name|mergedRegion
argument_list|)
operator|.
name|setState
argument_list|(
name|State
operator|.
name|MERGING_NEW
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create reference file(s) to parent region hfiles in the<code>mergeDir</code>    * @param regionFs merge parent region file system    * @param mergeDir the temp directory in which we are accumulating references.    */
specifier|private
name|void
name|mergeStoreFiles
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|,
specifier|final
name|HRegionFileSystem
name|regionFs
parameter_list|,
specifier|final
name|Path
name|mergeDir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|TableDescriptor
name|htd
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|ColumnFamilyDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
name|String
name|family
init|=
name|hcd
operator|.
name|getNameAsString
argument_list|()
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|StoreFileInfo
argument_list|>
name|storeFiles
init|=
name|regionFs
operator|.
name|getStoreFiles
argument_list|(
name|family
argument_list|)
decl_stmt|;
if|if
condition|(
name|storeFiles
operator|!=
literal|null
operator|&&
name|storeFiles
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|StoreFileInfo
name|storeFileInfo
range|:
name|storeFiles
control|)
block|{
comment|// Create reference file(s) to parent region file here in mergedDir.
comment|// As this procedure is running on master, use CacheConfig.DISABLED means
comment|// don't cache any block.
name|regionFs
operator|.
name|mergeStoreFile
argument_list|(
name|mergedRegion
argument_list|,
name|family
argument_list|,
operator|new
name|HStoreFile
argument_list|(
name|storeFileInfo
argument_list|,
name|hcd
operator|.
name|getBloomFilterType
argument_list|()
argument_list|,
name|CacheConfig
operator|.
name|DISABLED
argument_list|)
argument_list|,
name|mergeDir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Clean up a merged region on rollback after failure.    */
specifier|private
name|void
name|cleanupMergedRegion
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterFileSystem
name|mfs
init|=
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getMasterFileSystem
argument_list|()
decl_stmt|;
name|TableName
name|tn
init|=
name|this
operator|.
name|regionsToMerge
index|[
literal|0
index|]
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|tabledir
init|=
name|FSUtils
operator|.
name|getTableDir
argument_list|(
name|mfs
operator|.
name|getRootDir
argument_list|()
argument_list|,
name|tn
argument_list|)
decl_stmt|;
specifier|final
name|FileSystem
name|fs
init|=
name|mfs
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
comment|// See createMergedRegion above where we specify the merge dir as being in the
comment|// FIRST merge parent region.
name|HRegionFileSystem
name|regionFs
init|=
name|HRegionFileSystem
operator|.
name|openRegionFromFileSystem
argument_list|(
name|env
operator|.
name|getMasterConfiguration
argument_list|()
argument_list|,
name|fs
argument_list|,
name|tabledir
argument_list|,
name|regionsToMerge
index|[
literal|0
index|]
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|regionFs
operator|.
name|cleanupMergedRegion
argument_list|(
name|mergedRegion
argument_list|)
expr_stmt|;
block|}
comment|/**    * Rollback close regions    **/
specifier|private
name|void
name|rollbackCloseRegionsForMerge
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|AssignmentManagerUtil
operator|.
name|reopenRegionsForRollback
argument_list|(
name|env
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|regionsToMerge
argument_list|)
argument_list|,
name|getRegionReplication
argument_list|(
name|env
argument_list|)
argument_list|,
name|getServerName
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|TransitRegionStateProcedure
index|[]
name|createUnassignProcedures
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|AssignmentManagerUtil
operator|.
name|createUnassignProceduresForSplitOrMerge
argument_list|(
name|env
argument_list|,
name|Stream
operator|.
name|of
argument_list|(
name|regionsToMerge
argument_list|)
argument_list|,
name|getRegionReplication
argument_list|(
name|env
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|TransitRegionStateProcedure
index|[]
name|createAssignProcedures
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|AssignmentManagerUtil
operator|.
name|createAssignProceduresForOpeningNewRegions
argument_list|(
name|env
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|mergedRegion
argument_list|)
argument_list|,
name|getRegionReplication
argument_list|(
name|env
argument_list|)
argument_list|,
name|getServerName
argument_list|(
name|env
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|int
name|getRegionReplication
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|env
operator|.
name|getMasterServices
argument_list|()
operator|.
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|getTableName
argument_list|()
argument_list|)
operator|.
name|getRegionReplication
argument_list|()
return|;
block|}
comment|/**    * Post merge region action    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|preMergeRegionsCommit
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
annotation|@
name|MetaMutationAnnotation
specifier|final
name|List
argument_list|<
name|Mutation
argument_list|>
name|metaEntries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|cpHost
operator|.
name|preMergeRegionsCommit
argument_list|(
name|regionsToMerge
argument_list|,
name|metaEntries
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
for|for
control|(
name|Mutation
name|p
range|:
name|metaEntries
control|)
block|{
name|RegionInfo
operator|.
name|parseRegionName
argument_list|(
name|p
operator|.
name|getRow
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Row key of mutation from coprocessor is not parsable as region name. "
operator|+
literal|"Mutations from coprocessor should only be for hbase:meta table."
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * Add merged region to META and delete original regions.    */
specifier|private
name|void
name|updateMetaForMergedRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|markRegionAsMerged
argument_list|(
name|mergedRegion
argument_list|,
name|getServerName
argument_list|(
name|env
argument_list|)
argument_list|,
name|this
operator|.
name|regionsToMerge
argument_list|)
expr_stmt|;
block|}
comment|/**    * Post merge region action    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|postMergeRegionsCommit
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postMergeRegionsCommit
argument_list|(
name|regionsToMerge
argument_list|,
name|mergedRegion
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Post merge region action    * @param env MasterProcedureEnv    **/
specifier|private
name|void
name|postCompletedMergeRegions
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|MasterCoprocessorHost
name|cpHost
init|=
name|env
operator|.
name|getMasterCoprocessorHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postCompletedMergeRegionsAction
argument_list|(
name|regionsToMerge
argument_list|,
name|mergedRegion
argument_list|,
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The procedure could be restarted from a different machine. If the variable is null, we need to    * retrieve it.    * @param env MasterProcedureEnv    * @return serverName    */
specifier|private
name|ServerName
name|getServerName
parameter_list|(
specifier|final
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
if|if
condition|(
name|regionLocation
operator|==
literal|null
condition|)
block|{
name|regionLocation
operator|=
name|env
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionServerOfRegion
argument_list|(
name|regionsToMerge
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// May still be null here but return null and let caller deal.
comment|// Means we lost the in-memory-only location. We are in recovery
comment|// or so. The caller should be able to deal w/ a null ServerName.
comment|// Let them go to the Balancer to find one to use instead.
block|}
return|return
name|regionLocation
return|;
block|}
specifier|private
name|void
name|writeMaxSequenceIdFile
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|MasterFileSystem
name|fs
init|=
name|env
operator|.
name|getMasterFileSystem
argument_list|()
decl_stmt|;
name|long
name|maxSequenceId
init|=
operator|-
literal|1L
decl_stmt|;
for|for
control|(
name|RegionInfo
name|region
range|:
name|regionsToMerge
control|)
block|{
name|maxSequenceId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxSequenceId
argument_list|,
name|WALSplitUtil
operator|.
name|getMaxRegionSequenceId
argument_list|(
name|env
operator|.
name|getMasterConfiguration
argument_list|()
argument_list|,
name|region
argument_list|,
name|fs
operator|::
name|getFileSystem
argument_list|,
name|fs
operator|::
name|getWALFileSystem
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxSequenceId
operator|>
literal|0
condition|)
block|{
name|WALSplitUtil
operator|.
name|writeRegionSequenceIdFile
argument_list|(
name|fs
operator|.
name|getWALFileSystem
argument_list|()
argument_list|,
name|getWALRegionDir
argument_list|(
name|env
argument_list|,
name|mergedRegion
argument_list|)
argument_list|,
name|maxSequenceId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return The merged region. Maybe be null if called to early or we failed.    */
annotation|@
name|VisibleForTesting
name|RegionInfo
name|getMergedRegion
parameter_list|()
block|{
return|return
name|this
operator|.
name|mergedRegion
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|abort
parameter_list|(
name|MasterProcedureEnv
name|env
parameter_list|)
block|{
comment|// Abort means rollback. We can't rollback all steps. HBASE-18018 added abort to all
comment|// Procedures. Here is a Procedure that has a PONR and cannot be aborted once it enters this
comment|// range of steps; what do we do for these should an operator want to cancel them? HBASE-20022.
return|return
name|isRollbackSupported
argument_list|(
name|getCurrentState
argument_list|()
argument_list|)
operator|&&
name|super
operator|.
name|abort
argument_list|(
name|env
argument_list|)
return|;
block|}
block|}
end_class

end_unit

