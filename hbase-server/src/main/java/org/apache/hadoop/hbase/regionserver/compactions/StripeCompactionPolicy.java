begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|compactions
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StripeStoreFileManager
operator|.
name|OPEN_KEY
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreConfigInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StripeStoreConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StripeStoreFlusher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ConcatenatedLists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * Stripe store implementation of compaction policy.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|StripeCompactionPolicy
extends|extends
name|CompactionPolicy
block|{
specifier|private
specifier|final
specifier|static
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|StripeCompactionPolicy
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Policy used to compact individual stripes.
specifier|private
name|ExploringCompactionPolicy
name|stripePolicy
init|=
literal|null
decl_stmt|;
specifier|private
name|StripeStoreConfig
name|config
decl_stmt|;
specifier|public
name|StripeCompactionPolicy
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|StoreConfigInformation
name|storeConfigInfo
parameter_list|,
name|StripeStoreConfig
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|storeConfigInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|stripePolicy
operator|=
operator|new
name|ExploringCompactionPolicy
argument_list|(
name|conf
argument_list|,
name|storeConfigInfo
argument_list|)
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|StoreFile
argument_list|>
name|preSelectFilesForCoprocessor
parameter_list|(
name|StripeInformationProvider
name|si
parameter_list|,
name|List
argument_list|<
name|StoreFile
argument_list|>
name|filesCompacting
parameter_list|)
block|{
comment|// We sincerely hope nobody is messing with us with their coprocessors.
comment|// If they do, they are very likely to shoot themselves in the foot.
comment|// We'll just exclude all the filesCompacting from the list.
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|candidateFiles
init|=
operator|new
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
argument_list|(
name|si
operator|.
name|getStorefiles
argument_list|()
argument_list|)
decl_stmt|;
name|candidateFiles
operator|.
name|removeAll
argument_list|(
name|filesCompacting
argument_list|)
expr_stmt|;
return|return
name|candidateFiles
return|;
block|}
specifier|public
name|StripeCompactionRequest
name|createEmptyRequest
parameter_list|(
name|StripeInformationProvider
name|si
parameter_list|,
name|CompactionRequest
name|request
parameter_list|)
block|{
comment|// Treat as L0-ish compaction with fixed set of files, and hope for the best.
if|if
condition|(
name|si
operator|.
name|getStripeCount
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
operator|new
name|BoundaryStripeCompactionRequest
argument_list|(
name|request
argument_list|,
name|si
operator|.
name|getStripeBoundaries
argument_list|()
argument_list|)
return|;
block|}
name|Pair
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|targetKvsAndCount
init|=
name|estimateTargetKvs
argument_list|(
name|request
operator|.
name|getFiles
argument_list|()
argument_list|,
name|this
operator|.
name|config
operator|.
name|getInitialCount
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SplitStripeCompactionRequest
argument_list|(
name|request
argument_list|,
name|OPEN_KEY
argument_list|,
name|OPEN_KEY
argument_list|,
name|targetKvsAndCount
operator|.
name|getSecond
argument_list|()
argument_list|,
name|targetKvsAndCount
operator|.
name|getFirst
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|StripeStoreFlusher
operator|.
name|StripeFlushRequest
name|selectFlush
parameter_list|(
name|StripeInformationProvider
name|si
parameter_list|,
name|int
name|kvCount
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|config
operator|.
name|isUsingL0Flush
argument_list|()
condition|)
block|{
return|return
operator|new
name|StripeStoreFlusher
operator|.
name|StripeFlushRequest
argument_list|()
return|;
comment|// L0 is used, return dumb request.
block|}
if|if
condition|(
name|si
operator|.
name|getStripeCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// No stripes - start with the requisite count, derive KVs per stripe.
name|int
name|initialCount
init|=
name|this
operator|.
name|config
operator|.
name|getInitialCount
argument_list|()
decl_stmt|;
return|return
operator|new
name|StripeStoreFlusher
operator|.
name|SizeStripeFlushRequest
argument_list|(
name|initialCount
argument_list|,
name|kvCount
operator|/
name|initialCount
argument_list|)
return|;
block|}
comment|// There are stripes - do according to the boundaries.
return|return
operator|new
name|StripeStoreFlusher
operator|.
name|BoundaryStripeFlushRequest
argument_list|(
name|si
operator|.
name|getStripeBoundaries
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|StripeCompactionRequest
name|selectCompaction
parameter_list|(
name|StripeInformationProvider
name|si
parameter_list|,
name|List
argument_list|<
name|StoreFile
argument_list|>
name|filesCompacting
parameter_list|,
name|boolean
name|isOffpeak
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: first cut - no parallel compactions. To have more fine grained control we
comment|//       probably need structure more sophisticated than a list.
if|if
condition|(
operator|!
name|filesCompacting
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not selecting compaction: "
operator|+
name|filesCompacting
operator|.
name|size
argument_list|()
operator|+
literal|" files compacting"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// We are going to do variations of compaction in strict order of preference.
comment|// A better/more advanced approach is to use a heuristic to see which one is "more
comment|// necessary" at current time.
comment|// This can happen due to region split. We can skip it later; for now preserve
comment|// compact-all-things behavior.
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|allFiles
init|=
name|si
operator|.
name|getStorefiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|StoreUtils
operator|.
name|hasReferences
argument_list|(
name|allFiles
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"There are references in the store; compacting all files"
argument_list|)
expr_stmt|;
name|long
name|targetKvs
init|=
name|estimateTargetKvs
argument_list|(
name|allFiles
argument_list|,
name|config
operator|.
name|getInitialCount
argument_list|()
argument_list|)
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|SplitStripeCompactionRequest
name|request
init|=
operator|new
name|SplitStripeCompactionRequest
argument_list|(
name|allFiles
argument_list|,
name|OPEN_KEY
argument_list|,
name|OPEN_KEY
argument_list|,
name|targetKvs
argument_list|)
decl_stmt|;
name|request
operator|.
name|setMajorRangeFull
argument_list|()
expr_stmt|;
return|return
name|request
return|;
block|}
name|int
name|stripeCount
init|=
name|si
operator|.
name|getStripeCount
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|StoreFile
argument_list|>
name|l0Files
init|=
name|si
operator|.
name|getLevel0Files
argument_list|()
decl_stmt|;
comment|// See if we need to make new stripes.
name|boolean
name|shouldCompactL0
init|=
operator|(
name|this
operator|.
name|config
operator|.
name|getLevel0MinFiles
argument_list|()
operator|<=
name|l0Files
operator|.
name|size
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|stripeCount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|shouldCompactL0
condition|)
return|return
literal|null
return|;
comment|// nothing to do.
return|return
name|selectNewStripesCompaction
argument_list|(
name|si
argument_list|)
return|;
block|}
name|boolean
name|canDropDeletesNoL0
init|=
name|l0Files
operator|.
name|size
argument_list|()
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|shouldCompactL0
condition|)
block|{
if|if
condition|(
operator|!
name|canDropDeletesNoL0
condition|)
block|{
comment|// If we need to compact L0, see if we can add something to it, and drop deletes.
name|StripeCompactionRequest
name|result
init|=
name|selectSingleStripeCompaction
argument_list|(
name|si
argument_list|,
literal|true
argument_list|,
name|canDropDeletesNoL0
argument_list|,
name|isOffpeak
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
return|return
name|result
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Selecting L0 compaction with "
operator|+
name|l0Files
operator|.
name|size
argument_list|()
operator|+
literal|" files"
argument_list|)
expr_stmt|;
return|return
operator|new
name|BoundaryStripeCompactionRequest
argument_list|(
name|l0Files
argument_list|,
name|si
operator|.
name|getStripeBoundaries
argument_list|()
argument_list|)
return|;
block|}
comment|// Try to delete fully expired stripes
name|StripeCompactionRequest
name|result
init|=
name|selectExpiredMergeCompaction
argument_list|(
name|si
argument_list|,
name|canDropDeletesNoL0
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
return|return
name|result
return|;
comment|// Ok, nothing special here, let's see if we need to do a common compaction.
comment|// This will also split the stripes that are too big if needed.
return|return
name|selectSingleStripeCompaction
argument_list|(
name|si
argument_list|,
literal|false
argument_list|,
name|canDropDeletesNoL0
argument_list|,
name|isOffpeak
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|needsCompactions
parameter_list|(
name|StripeInformationProvider
name|si
parameter_list|,
name|List
argument_list|<
name|StoreFile
argument_list|>
name|filesCompacting
parameter_list|)
block|{
comment|// Approximation on whether we need compaction.
return|return
name|filesCompacting
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|StoreUtils
operator|.
name|hasReferences
argument_list|(
name|si
operator|.
name|getStorefiles
argument_list|()
argument_list|)
operator|||
operator|(
name|si
operator|.
name|getLevel0Files
argument_list|()
operator|.
name|size
argument_list|()
operator|>=
name|this
operator|.
name|config
operator|.
name|getLevel0MinFiles
argument_list|()
operator|)
operator|||
name|needsSingleStripeCompaction
argument_list|(
name|si
argument_list|)
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isMajorCompaction
parameter_list|(
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|filesToCompact
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|false
return|;
comment|// there's never a major compaction!
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|throttleCompaction
parameter_list|(
name|long
name|compactionSize
parameter_list|)
block|{
return|return
name|compactionSize
operator|>
name|comConf
operator|.
name|getThrottlePoint
argument_list|()
return|;
block|}
comment|/**    * @param si StoreFileManager.    * @return Whether any stripe potentially needs compaction.    */
specifier|protected
name|boolean
name|needsSingleStripeCompaction
parameter_list|(
name|StripeInformationProvider
name|si
parameter_list|)
block|{
name|int
name|minFiles
init|=
name|this
operator|.
name|config
operator|.
name|getStripeCompactMinFiles
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|StoreFile
argument_list|>
name|stripe
range|:
name|si
operator|.
name|getStripes
argument_list|()
control|)
block|{
if|if
condition|(
name|stripe
operator|.
name|size
argument_list|()
operator|>=
name|minFiles
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|protected
name|StripeCompactionRequest
name|selectSingleStripeCompaction
parameter_list|(
name|StripeInformationProvider
name|si
parameter_list|,
name|boolean
name|includeL0
parameter_list|,
name|boolean
name|canDropDeletesWithoutL0
parameter_list|,
name|boolean
name|isOffpeak
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|ImmutableList
argument_list|<
name|StoreFile
argument_list|>
argument_list|>
name|stripes
init|=
name|si
operator|.
name|getStripes
argument_list|()
decl_stmt|;
name|int
name|bqIndex
init|=
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|StoreFile
argument_list|>
name|bqSelection
init|=
literal|null
decl_stmt|;
name|int
name|stripeCount
init|=
name|stripes
operator|.
name|size
argument_list|()
decl_stmt|;
name|long
name|bqTotalSize
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stripeCount
condition|;
operator|++
name|i
control|)
block|{
comment|// If we want to compact L0 to drop deletes, we only want whole-stripe compactions.
comment|// So, pass includeL0 as 2nd parameter to indicate that.
name|List
argument_list|<
name|StoreFile
argument_list|>
name|selection
init|=
name|selectSimpleCompaction
argument_list|(
name|stripes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
operator|!
name|canDropDeletesWithoutL0
operator|&&
name|includeL0
argument_list|,
name|isOffpeak
argument_list|)
decl_stmt|;
if|if
condition|(
name|selection
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|StoreFile
name|sf
range|:
name|selection
control|)
block|{
name|size
operator|+=
name|sf
operator|.
name|getReader
argument_list|()
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bqSelection
operator|==
literal|null
operator|||
name|selection
operator|.
name|size
argument_list|()
operator|>
name|bqSelection
operator|.
name|size
argument_list|()
operator|||
operator|(
name|selection
operator|.
name|size
argument_list|()
operator|==
name|bqSelection
operator|.
name|size
argument_list|()
operator|&&
name|size
operator|<
name|bqTotalSize
operator|)
condition|)
block|{
name|bqSelection
operator|=
name|selection
expr_stmt|;
name|bqIndex
operator|=
name|i
expr_stmt|;
name|bqTotalSize
operator|=
name|size
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bqSelection
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No good compaction is possible in any stripe"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|StoreFile
argument_list|>
name|filesToCompact
init|=
operator|new
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
argument_list|(
name|bqSelection
argument_list|)
decl_stmt|;
comment|// See if we can, and need to, split this stripe.
name|int
name|targetCount
init|=
literal|1
decl_stmt|;
name|long
name|targetKvs
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|boolean
name|hasAllFiles
init|=
name|filesToCompact
operator|.
name|size
argument_list|()
operator|==
name|stripes
operator|.
name|get
argument_list|(
name|bqIndex
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
name|String
name|splitString
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|hasAllFiles
operator|&&
name|bqTotalSize
operator|>=
name|config
operator|.
name|getSplitSize
argument_list|()
condition|)
block|{
if|if
condition|(
name|includeL0
condition|)
block|{
comment|// We want to avoid the scenario where we compact a stripe w/L0 and then split it.
comment|// So, if we might split, don't compact the stripe with L0.
return|return
literal|null
return|;
block|}
name|Pair
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|kvsAndCount
init|=
name|estimateTargetKvs
argument_list|(
name|filesToCompact
argument_list|,
name|config
operator|.
name|getSplitCount
argument_list|()
argument_list|)
decl_stmt|;
name|targetKvs
operator|=
name|kvsAndCount
operator|.
name|getFirst
argument_list|()
expr_stmt|;
name|targetCount
operator|=
name|kvsAndCount
operator|.
name|getSecond
argument_list|()
expr_stmt|;
name|splitString
operator|=
literal|"; the stripe will be split into at most "
operator|+
name|targetCount
operator|+
literal|" stripes with "
operator|+
name|targetKvs
operator|+
literal|" target KVs"
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found compaction in a stripe with end key ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|si
operator|.
name|getEndRow
argument_list|(
name|bqIndex
argument_list|)
argument_list|)
operator|+
literal|"], with "
operator|+
name|filesToCompact
operator|.
name|size
argument_list|()
operator|+
literal|" files of total size "
operator|+
name|bqTotalSize
operator|+
name|splitString
argument_list|)
expr_stmt|;
comment|// See if we can drop deletes.
name|StripeCompactionRequest
name|req
decl_stmt|;
if|if
condition|(
name|includeL0
condition|)
block|{
assert|assert
name|hasAllFiles
assert|;
name|List
argument_list|<
name|StoreFile
argument_list|>
name|l0Files
init|=
name|si
operator|.
name|getLevel0Files
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding "
operator|+
name|l0Files
operator|.
name|size
argument_list|()
operator|+
literal|" files to compaction to be able to drop deletes"
argument_list|)
expr_stmt|;
name|ConcatenatedLists
argument_list|<
name|StoreFile
argument_list|>
name|sfs
init|=
operator|new
name|ConcatenatedLists
argument_list|<
name|StoreFile
argument_list|>
argument_list|()
decl_stmt|;
name|sfs
operator|.
name|addSublist
argument_list|(
name|filesToCompact
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|addSublist
argument_list|(
name|l0Files
argument_list|)
expr_stmt|;
name|req
operator|=
operator|new
name|BoundaryStripeCompactionRequest
argument_list|(
name|sfs
argument_list|,
name|si
operator|.
name|getStripeBoundaries
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|req
operator|=
operator|new
name|SplitStripeCompactionRequest
argument_list|(
name|filesToCompact
argument_list|,
name|si
operator|.
name|getStartRow
argument_list|(
name|bqIndex
argument_list|)
argument_list|,
name|si
operator|.
name|getEndRow
argument_list|(
name|bqIndex
argument_list|)
argument_list|,
name|targetCount
argument_list|,
name|targetKvs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|canDropDeletesWithoutL0
operator|||
name|includeL0
condition|)
block|{
name|req
operator|.
name|setMajorRange
argument_list|(
name|si
operator|.
name|getStartRow
argument_list|(
name|bqIndex
argument_list|)
argument_list|,
name|si
operator|.
name|getEndRow
argument_list|(
name|bqIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|req
operator|.
name|getRequest
argument_list|()
operator|.
name|setOffPeak
argument_list|(
name|isOffpeak
argument_list|)
expr_stmt|;
return|return
name|req
return|;
block|}
comment|/**    * Selects the compaction of a single stripe using default policy.    * @param sfs Files.    * @param allFilesOnly Whether a compaction of all-or-none files is needed.    * @return The resulting selection.    */
specifier|private
name|List
argument_list|<
name|StoreFile
argument_list|>
name|selectSimpleCompaction
parameter_list|(
name|List
argument_list|<
name|StoreFile
argument_list|>
name|sfs
parameter_list|,
name|boolean
name|allFilesOnly
parameter_list|,
name|boolean
name|isOffpeak
parameter_list|)
block|{
name|int
name|minFilesLocal
init|=
name|Math
operator|.
name|max
argument_list|(
name|allFilesOnly
condition|?
name|sfs
operator|.
name|size
argument_list|()
else|:
literal|0
argument_list|,
name|this
operator|.
name|config
operator|.
name|getStripeCompactMinFiles
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|maxFilesLocal
init|=
name|Math
operator|.
name|max
argument_list|(
name|this
operator|.
name|config
operator|.
name|getStripeCompactMaxFiles
argument_list|()
argument_list|,
name|minFilesLocal
argument_list|)
decl_stmt|;
return|return
name|stripePolicy
operator|.
name|applyCompactionPolicy
argument_list|(
name|sfs
argument_list|,
literal|false
argument_list|,
name|isOffpeak
argument_list|,
name|minFilesLocal
argument_list|,
name|maxFilesLocal
argument_list|)
return|;
block|}
comment|/**    * Selects the compaction that compacts all files (to be removed later).    * @param si StoreFileManager.    * @param targetStripeCount Target stripe count.    * @param targetSize Target stripe size.    * @return The compaction.    */
specifier|private
name|StripeCompactionRequest
name|selectCompactionOfAllFiles
parameter_list|(
name|StripeInformationProvider
name|si
parameter_list|,
name|int
name|targetStripeCount
parameter_list|,
name|long
name|targetSize
parameter_list|)
block|{
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|allFiles
init|=
name|si
operator|.
name|getStorefiles
argument_list|()
decl_stmt|;
name|SplitStripeCompactionRequest
name|request
init|=
operator|new
name|SplitStripeCompactionRequest
argument_list|(
name|allFiles
argument_list|,
name|OPEN_KEY
argument_list|,
name|OPEN_KEY
argument_list|,
name|targetStripeCount
argument_list|,
name|targetSize
argument_list|)
decl_stmt|;
name|request
operator|.
name|setMajorRangeFull
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Selecting a compaction that includes all "
operator|+
name|allFiles
operator|.
name|size
argument_list|()
operator|+
literal|" files"
argument_list|)
expr_stmt|;
return|return
name|request
return|;
block|}
specifier|private
name|StripeCompactionRequest
name|selectNewStripesCompaction
parameter_list|(
name|StripeInformationProvider
name|si
parameter_list|)
block|{
name|List
argument_list|<
name|StoreFile
argument_list|>
name|l0Files
init|=
name|si
operator|.
name|getLevel0Files
argument_list|()
decl_stmt|;
name|Pair
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|kvsAndCount
init|=
name|estimateTargetKvs
argument_list|(
name|l0Files
argument_list|,
name|config
operator|.
name|getInitialCount
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating "
operator|+
name|kvsAndCount
operator|.
name|getSecond
argument_list|()
operator|+
literal|" initial stripes with "
operator|+
name|kvsAndCount
operator|.
name|getFirst
argument_list|()
operator|+
literal|" kvs each via L0 compaction of "
operator|+
name|l0Files
operator|.
name|size
argument_list|()
operator|+
literal|" files"
argument_list|)
expr_stmt|;
name|SplitStripeCompactionRequest
name|request
init|=
operator|new
name|SplitStripeCompactionRequest
argument_list|(
name|si
operator|.
name|getLevel0Files
argument_list|()
argument_list|,
name|OPEN_KEY
argument_list|,
name|OPEN_KEY
argument_list|,
name|kvsAndCount
operator|.
name|getSecond
argument_list|()
argument_list|,
name|kvsAndCount
operator|.
name|getFirst
argument_list|()
argument_list|)
decl_stmt|;
name|request
operator|.
name|setMajorRangeFull
argument_list|()
expr_stmt|;
comment|// L0 only, can drop deletes.
return|return
name|request
return|;
block|}
specifier|private
name|StripeCompactionRequest
name|selectExpiredMergeCompaction
parameter_list|(
name|StripeInformationProvider
name|si
parameter_list|,
name|boolean
name|canDropDeletesNoL0
parameter_list|)
block|{
name|long
name|cfTtl
init|=
name|this
operator|.
name|storeConfigInfo
operator|.
name|getStoreFileTtl
argument_list|()
decl_stmt|;
if|if
condition|(
name|cfTtl
operator|==
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
literal|null
return|;
comment|// minversion might be set, cannot delete old files
block|}
name|long
name|timestampCutoff
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|cfTtl
decl_stmt|;
comment|// Merge the longest sequence of stripes where all files have expired, if any.
name|int
name|start
init|=
operator|-
literal|1
decl_stmt|,
name|bestStart
init|=
operator|-
literal|1
decl_stmt|,
name|length
init|=
literal|0
decl_stmt|,
name|bestLength
init|=
literal|0
decl_stmt|;
name|ArrayList
argument_list|<
name|ImmutableList
argument_list|<
name|StoreFile
argument_list|>
argument_list|>
name|stripes
init|=
name|si
operator|.
name|getStripes
argument_list|()
decl_stmt|;
name|OUTER
label|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stripes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|StoreFile
name|storeFile
range|:
name|stripes
operator|.
name|get
argument_list|(
name|i
argument_list|)
control|)
block|{
if|if
condition|(
name|storeFile
operator|.
name|getReader
argument_list|()
operator|.
name|getMaxTimestamp
argument_list|()
operator|<
name|timestampCutoff
condition|)
continue|continue;
comment|// Found non-expired file, this stripe has to stay.
if|if
condition|(
name|length
operator|>
name|bestLength
condition|)
block|{
name|bestStart
operator|=
name|start
expr_stmt|;
name|bestLength
operator|=
name|length
expr_stmt|;
block|}
name|start
operator|=
operator|-
literal|1
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
continue|continue
name|OUTER
continue|;
block|}
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
block|{
name|start
operator|=
name|i
expr_stmt|;
block|}
operator|++
name|length
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
name|bestLength
condition|)
block|{
name|bestStart
operator|=
name|start
expr_stmt|;
name|bestLength
operator|=
name|length
expr_stmt|;
block|}
if|if
condition|(
name|bestLength
operator|==
literal|0
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|bestLength
operator|==
literal|1
condition|)
block|{
comment|// This is currently inefficient. If only one stripe expired, we will rewrite some
comment|// entire stripe just to delete some expired files because we rely on metadata and it
comment|// cannot simply be updated in an old file. When we either determine stripe dynamically
comment|// or move metadata to manifest, we can just drop the "expired stripes".
if|if
condition|(
name|bestStart
operator|==
operator|(
name|stripes
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|)
return|return
literal|null
return|;
operator|++
name|bestLength
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Merging "
operator|+
name|bestLength
operator|+
literal|" stripes to delete expired store files"
argument_list|)
expr_stmt|;
name|int
name|endIndex
init|=
name|bestStart
operator|+
name|bestLength
operator|-
literal|1
decl_stmt|;
name|ConcatenatedLists
argument_list|<
name|StoreFile
argument_list|>
name|sfs
init|=
operator|new
name|ConcatenatedLists
argument_list|<
name|StoreFile
argument_list|>
argument_list|()
decl_stmt|;
name|sfs
operator|.
name|addAllSublists
argument_list|(
name|stripes
operator|.
name|subList
argument_list|(
name|bestStart
argument_list|,
name|endIndex
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SplitStripeCompactionRequest
name|result
init|=
operator|new
name|SplitStripeCompactionRequest
argument_list|(
name|sfs
argument_list|,
name|si
operator|.
name|getStartRow
argument_list|(
name|bestStart
argument_list|)
argument_list|,
name|si
operator|.
name|getEndRow
argument_list|(
name|endIndex
argument_list|)
argument_list|,
literal|1
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|canDropDeletesNoL0
condition|)
block|{
name|result
operator|.
name|setMajorRangeFull
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|long
name|getTotalKvCount
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|candidates
parameter_list|)
block|{
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|StoreFile
name|storeFile
range|:
name|candidates
control|)
block|{
name|totalSize
operator|+=
name|storeFile
operator|.
name|getReader
argument_list|()
operator|.
name|getEntries
argument_list|()
expr_stmt|;
block|}
return|return
name|totalSize
return|;
block|}
specifier|public
specifier|static
name|long
name|getTotalFileSize
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|candidates
parameter_list|)
block|{
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|StoreFile
name|storeFile
range|:
name|candidates
control|)
block|{
name|totalSize
operator|+=
name|storeFile
operator|.
name|getReader
argument_list|()
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
return|return
name|totalSize
return|;
block|}
specifier|private
name|Pair
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|estimateTargetKvs
parameter_list|(
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|files
parameter_list|,
name|double
name|splitCount
parameter_list|)
block|{
comment|// If the size is larger than what we target, we don't want to split into proportionally
comment|// larger parts and then have to split again very soon. So, we will increase the multiplier
comment|// by one until we get small enough parts. E.g. 5Gb stripe that should have been split into
comment|// 2 parts when it was 3Gb will be split into 3x1.67Gb parts, rather than 2x2.5Gb parts.
name|long
name|totalSize
init|=
name|getTotalFileSize
argument_list|(
name|files
argument_list|)
decl_stmt|;
name|long
name|targetPartSize
init|=
name|config
operator|.
name|getSplitPartSize
argument_list|()
decl_stmt|;
assert|assert
name|targetPartSize
operator|>
literal|0
operator|&&
name|splitCount
operator|>
literal|0
assert|;
name|double
name|ratio
init|=
name|totalSize
operator|/
operator|(
name|splitCount
operator|*
name|targetPartSize
operator|)
decl_stmt|;
comment|// ratio of real to desired size
while|while
condition|(
name|ratio
operator|>
literal|1.0
condition|)
block|{
comment|// Ratio of real to desired size if we increase the multiplier.
name|double
name|newRatio
init|=
name|totalSize
operator|/
operator|(
operator|(
name|splitCount
operator|+
literal|1.0
operator|)
operator|*
name|targetPartSize
operator|)
decl_stmt|;
if|if
condition|(
operator|(
literal|1.0
operator|/
name|newRatio
operator|)
operator|>=
name|ratio
condition|)
break|break;
comment|// New ratio is< 1.0, but further than the last one.
name|ratio
operator|=
name|newRatio
expr_stmt|;
name|splitCount
operator|+=
literal|1.0
expr_stmt|;
block|}
name|long
name|kvCount
init|=
call|(
name|long
call|)
argument_list|(
name|getTotalKvCount
argument_list|(
name|files
argument_list|)
operator|/
name|splitCount
argument_list|)
decl_stmt|;
return|return
operator|new
name|Pair
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|kvCount
argument_list|,
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|splitCount
argument_list|)
argument_list|)
return|;
block|}
comment|/** Stripe compaction request wrapper. */
specifier|public
specifier|abstract
specifier|static
class|class
name|StripeCompactionRequest
block|{
specifier|protected
name|CompactionRequest
name|request
decl_stmt|;
specifier|protected
name|byte
index|[]
name|majorRangeFromRow
init|=
literal|null
decl_stmt|,
name|majorRangeToRow
init|=
literal|null
decl_stmt|;
comment|/**      * Executes the request against compactor (essentially, just calls correct overload of      * compact method), to simulate more dynamic dispatch.      * @param compactor Compactor.      * @return result of compact(...)      */
specifier|public
specifier|abstract
name|List
argument_list|<
name|Path
argument_list|>
name|execute
parameter_list|(
name|StripeCompactor
name|compactor
parameter_list|)
throws|throws
name|IOException
function_decl|;
specifier|public
name|StripeCompactionRequest
parameter_list|(
name|CompactionRequest
name|request
parameter_list|)
block|{
name|this
operator|.
name|request
operator|=
name|request
expr_stmt|;
block|}
comment|/**      * Sets compaction "major range". Major range is the key range for which all      * the files are included, so they can be treated like major-compacted files.      * @param startRow Left boundary, inclusive.      * @param endRow Right boundary, exclusive.      */
specifier|public
name|void
name|setMajorRange
parameter_list|(
name|byte
index|[]
name|startRow
parameter_list|,
name|byte
index|[]
name|endRow
parameter_list|)
block|{
name|this
operator|.
name|majorRangeFromRow
operator|=
name|startRow
expr_stmt|;
name|this
operator|.
name|majorRangeToRow
operator|=
name|endRow
expr_stmt|;
block|}
specifier|public
name|CompactionRequest
name|getRequest
parameter_list|()
block|{
return|return
name|this
operator|.
name|request
return|;
block|}
specifier|public
name|void
name|setRequest
parameter_list|(
name|CompactionRequest
name|request
parameter_list|)
block|{
assert|assert
name|request
operator|!=
literal|null
assert|;
name|this
operator|.
name|request
operator|=
name|request
expr_stmt|;
name|this
operator|.
name|majorRangeFromRow
operator|=
name|this
operator|.
name|majorRangeToRow
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Request for stripe compactor that will cause it to split the source files into several    * separate files at the provided boundaries.    */
specifier|private
specifier|static
class|class
name|BoundaryStripeCompactionRequest
extends|extends
name|StripeCompactionRequest
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|targetBoundaries
decl_stmt|;
comment|/**      * @param request Original request.      * @param targetBoundaries New files should be written with these boundaries.      */
specifier|public
name|BoundaryStripeCompactionRequest
parameter_list|(
name|CompactionRequest
name|request
parameter_list|,
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|targetBoundaries
parameter_list|)
block|{
name|super
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|this
operator|.
name|targetBoundaries
operator|=
name|targetBoundaries
expr_stmt|;
block|}
specifier|public
name|BoundaryStripeCompactionRequest
parameter_list|(
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|files
parameter_list|,
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|targetBoundaries
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
name|files
argument_list|)
argument_list|,
name|targetBoundaries
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Path
argument_list|>
name|execute
parameter_list|(
name|StripeCompactor
name|compactor
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|compactor
operator|.
name|compact
argument_list|(
name|this
operator|.
name|request
argument_list|,
name|this
operator|.
name|targetBoundaries
argument_list|,
name|this
operator|.
name|majorRangeFromRow
argument_list|,
name|this
operator|.
name|majorRangeToRow
argument_list|)
return|;
block|}
block|}
comment|/**    * Request for stripe compactor that will cause it to split the source files into several    * separate files into based on key-value count, as well as file count limit.    * Most of the files will be roughly the same size. The last file may be smaller or larger    * depending on the interplay of the amount of data and maximum number of files allowed.    */
specifier|private
specifier|static
class|class
name|SplitStripeCompactionRequest
extends|extends
name|StripeCompactionRequest
block|{
specifier|private
specifier|final
name|byte
index|[]
name|startRow
decl_stmt|,
name|endRow
decl_stmt|;
specifier|private
specifier|final
name|int
name|targetCount
decl_stmt|;
specifier|private
specifier|final
name|long
name|targetKvs
decl_stmt|;
comment|/**      * @param request Original request.      * @param startRow Left boundary of the range to compact, inclusive.      * @param endRow Right boundary of the range to compact, exclusive.      * @param targetCount The maximum number of stripe to compact into.      * @param targetKvs The KV count of each segment. If targetKvs*targetCount is less than      *                  total number of kvs, all the overflow data goes into the last stripe.      */
specifier|public
name|SplitStripeCompactionRequest
parameter_list|(
name|CompactionRequest
name|request
parameter_list|,
name|byte
index|[]
name|startRow
parameter_list|,
name|byte
index|[]
name|endRow
parameter_list|,
name|int
name|targetCount
parameter_list|,
name|long
name|targetKvs
parameter_list|)
block|{
name|super
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|this
operator|.
name|startRow
operator|=
name|startRow
expr_stmt|;
name|this
operator|.
name|endRow
operator|=
name|endRow
expr_stmt|;
name|this
operator|.
name|targetCount
operator|=
name|targetCount
expr_stmt|;
name|this
operator|.
name|targetKvs
operator|=
name|targetKvs
expr_stmt|;
block|}
specifier|public
name|SplitStripeCompactionRequest
parameter_list|(
name|CompactionRequest
name|request
parameter_list|,
name|byte
index|[]
name|startRow
parameter_list|,
name|byte
index|[]
name|endRow
parameter_list|,
name|long
name|targetKvs
parameter_list|)
block|{
name|this
argument_list|(
name|request
argument_list|,
name|startRow
argument_list|,
name|endRow
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|targetKvs
argument_list|)
expr_stmt|;
block|}
specifier|public
name|SplitStripeCompactionRequest
parameter_list|(
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|files
parameter_list|,
name|byte
index|[]
name|startRow
parameter_list|,
name|byte
index|[]
name|endRow
parameter_list|,
name|long
name|targetKvs
parameter_list|)
block|{
name|this
argument_list|(
name|files
argument_list|,
name|startRow
argument_list|,
name|endRow
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|targetKvs
argument_list|)
expr_stmt|;
block|}
specifier|public
name|SplitStripeCompactionRequest
parameter_list|(
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|files
parameter_list|,
name|byte
index|[]
name|startRow
parameter_list|,
name|byte
index|[]
name|endRow
parameter_list|,
name|int
name|targetCount
parameter_list|,
name|long
name|targetKvs
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
name|files
argument_list|)
argument_list|,
name|startRow
argument_list|,
name|endRow
argument_list|,
name|targetCount
argument_list|,
name|targetKvs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Path
argument_list|>
name|execute
parameter_list|(
name|StripeCompactor
name|compactor
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|compactor
operator|.
name|compact
argument_list|(
name|this
operator|.
name|request
argument_list|,
name|this
operator|.
name|targetCount
argument_list|,
name|this
operator|.
name|targetKvs
argument_list|,
name|this
operator|.
name|startRow
argument_list|,
name|this
operator|.
name|endRow
argument_list|,
name|this
operator|.
name|majorRangeFromRow
argument_list|,
name|this
operator|.
name|majorRangeToRow
argument_list|)
return|;
block|}
comment|/** Set major range of the compaction to the entire compaction range.      * See {@link #setMajorRange(byte[], byte[])}. */
specifier|public
name|void
name|setMajorRangeFull
parameter_list|()
block|{
name|setMajorRange
argument_list|(
name|this
operator|.
name|startRow
argument_list|,
name|this
operator|.
name|endRow
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** The information about stripes that the policy needs to do its stuff */
specifier|public
specifier|static
interface|interface
name|StripeInformationProvider
block|{
specifier|public
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|getStorefiles
parameter_list|()
function_decl|;
comment|/**      * Gets the start row for a given stripe.      * @param stripeIndex Stripe index.      * @return Start row. May be an open key.      */
specifier|public
name|byte
index|[]
name|getStartRow
parameter_list|(
name|int
name|stripeIndex
parameter_list|)
function_decl|;
comment|/**      * Gets the end row for a given stripe.      * @param stripeIndex Stripe index.      * @return End row. May be an open key.      */
specifier|public
name|byte
index|[]
name|getEndRow
parameter_list|(
name|int
name|stripeIndex
parameter_list|)
function_decl|;
comment|/**      * @return Level 0 files.      */
specifier|public
name|List
argument_list|<
name|StoreFile
argument_list|>
name|getLevel0Files
parameter_list|()
function_decl|;
comment|/**      * @return All stripe boundaries; including the open ones on both ends.      */
specifier|public
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|getStripeBoundaries
parameter_list|()
function_decl|;
comment|/**      * @return The stripes.      */
specifier|public
name|ArrayList
argument_list|<
name|ImmutableList
argument_list|<
name|StoreFile
argument_list|>
argument_list|>
name|getStripes
parameter_list|()
function_decl|;
comment|/**      * @return Stripe count.      */
specifier|public
name|int
name|getStripeCount
parameter_list|()
function_decl|;
block|}
block|}
end_class

end_unit

