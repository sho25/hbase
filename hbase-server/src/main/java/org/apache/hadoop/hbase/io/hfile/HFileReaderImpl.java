begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configurable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ByteBufferKeyOnlyKeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ByteBufferKeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NoTagsByteBufferKeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|PrivateCellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|SizeCachedKeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|SizeCachedNoTagsKeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|compress
operator|.
name|Compression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|HFileBlockDecodingContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|ByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|KeyValueScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|trace
operator|.
name|TraceUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|IdLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ObjectIntPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Implementation that can handle all hfile versions of {@link HFile.Reader}.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"
argument_list|)
specifier|public
specifier|abstract
class|class
name|HFileReaderImpl
implements|implements
name|HFile
operator|.
name|Reader
implements|,
name|Configurable
block|{
comment|// This class is HFileReaderV3 + HFileReaderV2 + AbstractHFileReader all squashed together into
comment|// one file.  Ditto for all the HFileReader.ScannerV? implementations. I was running up against
comment|// the MaxInlineLevel limit because too many tiers involved reading from an hfile. Was also hard
comment|// to navigate the source code when so many classes participating in read.
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HFileReaderImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Data block index reader keeping the root data index in memory */
specifier|protected
name|HFileBlockIndex
operator|.
name|CellBasedKeyBlockIndexReader
name|dataBlockIndexReader
decl_stmt|;
comment|/** Meta block index reader -- always single level */
specifier|protected
name|HFileBlockIndex
operator|.
name|ByteArrayKeyBlockIndexReader
name|metaBlockIndexReader
decl_stmt|;
specifier|protected
name|FixedFileTrailer
name|trailer
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|primaryReplicaReader
decl_stmt|;
comment|/**    * What kind of data block encoding should be used while reading, writing,    * and handling cache.    */
specifier|protected
name|HFileDataBlockEncoder
name|dataBlockEncoder
init|=
name|NoOpDataBlockEncoder
operator|.
name|INSTANCE
decl_stmt|;
comment|/** Key comparator */
specifier|protected
name|CellComparator
name|comparator
init|=
name|CellComparator
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|/** Block cache configuration. */
specifier|protected
specifier|final
name|CacheConfig
name|cacheConf
decl_stmt|;
specifier|protected
name|ReaderContext
name|context
decl_stmt|;
specifier|protected
specifier|final
name|HFileInfo
name|fileInfo
decl_stmt|;
comment|/** Path of file */
specifier|protected
specifier|final
name|Path
name|path
decl_stmt|;
comment|/** File name to be used for block names */
specifier|protected
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|protected
name|HFileContext
name|hfileContext
decl_stmt|;
comment|/** Filesystem-level block reader. */
specifier|protected
name|HFileBlock
operator|.
name|FSReader
name|fsBlockReader
decl_stmt|;
comment|/**    * A "sparse lock" implementation allowing to lock on a particular block    * identified by offset. The purpose of this is to avoid two clients loading    * the same block, and have all but one client wait to get the block from the    * cache.    */
specifier|private
name|IdLock
name|offsetLock
init|=
operator|new
name|IdLock
argument_list|()
decl_stmt|;
comment|/** Minimum minor version supported by this HFile format */
specifier|static
specifier|final
name|int
name|MIN_MINOR_VERSION
init|=
literal|0
decl_stmt|;
comment|/** Maximum minor version supported by this HFile format */
comment|// We went to version 2 when we moved to pb'ing fileinfo and the trailer on
comment|// the file. This version can read Writables version 1.
specifier|static
specifier|final
name|int
name|MAX_MINOR_VERSION
init|=
literal|3
decl_stmt|;
comment|/** Minor versions starting with this number have faked index key */
specifier|static
specifier|final
name|int
name|MINOR_VERSION_WITH_FAKED_KEY
init|=
literal|3
decl_stmt|;
comment|/**    * Opens a HFile.    * @param context Reader context info    * @param fileInfo HFile info    * @param cacheConf Cache configuration.    * @param conf Configuration    */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"
argument_list|)
specifier|public
name|HFileReaderImpl
parameter_list|(
name|ReaderContext
name|context
parameter_list|,
name|HFileInfo
name|fileInfo
parameter_list|,
name|CacheConfig
name|cacheConf
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|cacheConf
operator|=
name|cacheConf
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|context
operator|.
name|getFilePath
argument_list|()
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|path
operator|.
name|getName
argument_list|()
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|primaryReplicaReader
operator|=
name|context
operator|.
name|isPrimaryReplicaReader
argument_list|()
expr_stmt|;
name|this
operator|.
name|fileInfo
operator|=
name|fileInfo
expr_stmt|;
name|this
operator|.
name|trailer
operator|=
name|fileInfo
operator|.
name|getTrailer
argument_list|()
expr_stmt|;
comment|// Comparator class name is stored in the trailer in version 2.
name|this
operator|.
name|comparator
operator|=
name|trailer
operator|.
name|createComparator
argument_list|()
expr_stmt|;
name|this
operator|.
name|hfileContext
operator|=
name|fileInfo
operator|.
name|getHFileContext
argument_list|()
expr_stmt|;
name|this
operator|.
name|fsBlockReader
operator|=
operator|new
name|HFileBlock
operator|.
name|FSReaderImpl
argument_list|(
name|context
argument_list|,
name|hfileContext
argument_list|,
name|cacheConf
operator|.
name|getByteBuffAllocator
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|dataBlockEncoder
operator|=
name|HFileDataBlockEncoderImpl
operator|.
name|createFromFileInfo
argument_list|(
name|fileInfo
argument_list|)
expr_stmt|;
name|fsBlockReader
operator|.
name|setDataBlockEncoder
argument_list|(
name|dataBlockEncoder
argument_list|)
expr_stmt|;
name|dataBlockIndexReader
operator|=
name|fileInfo
operator|.
name|getDataBlockIndexReader
argument_list|()
expr_stmt|;
name|metaBlockIndexReader
operator|=
name|fileInfo
operator|.
name|getMetaBlockIndexReader
argument_list|()
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|public
specifier|static
class|class
name|BlockIndexNotLoadedException
extends|extends
name|IllegalStateException
block|{
specifier|public
name|BlockIndexNotLoadedException
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
comment|// Add a message in case anyone relies on it as opposed to class name.
name|super
argument_list|(
name|path
operator|+
literal|" block index not loaded"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Optional
argument_list|<
name|String
argument_list|>
name|toStringFirstKey
parameter_list|()
block|{
return|return
name|getFirstKey
argument_list|()
operator|.
name|map
argument_list|(
name|CellUtil
operator|::
name|getCellKeyAsString
argument_list|)
return|;
block|}
specifier|private
name|Optional
argument_list|<
name|String
argument_list|>
name|toStringLastKey
parameter_list|()
block|{
return|return
name|getLastKey
argument_list|()
operator|.
name|map
argument_list|(
name|CellUtil
operator|::
name|getCellKeyAsString
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"reader="
operator|+
name|path
operator|.
name|toString
argument_list|()
operator|+
operator|(
operator|!
name|isFileInfoLoaded
argument_list|()
condition|?
literal|""
else|:
literal|", compression="
operator|+
name|trailer
operator|.
name|getCompressionCodec
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|", cacheConf="
operator|+
name|cacheConf
operator|+
literal|", firstKey="
operator|+
name|toStringFirstKey
argument_list|()
operator|+
literal|", lastKey="
operator|+
name|toStringLastKey
argument_list|()
operator|)
operator|+
literal|", avgKeyLen="
operator|+
name|fileInfo
operator|.
name|getAvgKeyLen
argument_list|()
operator|+
literal|", avgValueLen="
operator|+
name|fileInfo
operator|.
name|getAvgValueLen
argument_list|()
operator|+
literal|", entries="
operator|+
name|trailer
operator|.
name|getEntryCount
argument_list|()
operator|+
literal|", length="
operator|+
name|context
operator|.
name|getFileSize
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|length
parameter_list|()
block|{
return|return
name|context
operator|.
name|getFileSize
argument_list|()
return|;
block|}
comment|/**    * @return the first key in the file. May be null if file has no entries. Note    *         that this is not the first row key, but rather the byte form of the    *         first KeyValue.    */
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|Cell
argument_list|>
name|getFirstKey
parameter_list|()
block|{
if|if
condition|(
name|dataBlockIndexReader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|BlockIndexNotLoadedException
argument_list|(
name|path
argument_list|)
throw|;
block|}
return|return
name|dataBlockIndexReader
operator|.
name|isEmpty
argument_list|()
condition|?
name|Optional
operator|.
name|empty
argument_list|()
else|:
name|Optional
operator|.
name|of
argument_list|(
name|dataBlockIndexReader
operator|.
name|getRootBlockKey
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * TODO left from {@link HFile} version 1: move this to StoreFile after Ryan's    * patch goes in to eliminate {@link KeyValue} here.    *    * @return the first row key, or null if the file is empty.    */
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|byte
index|[]
argument_list|>
name|getFirstRowKey
parameter_list|()
block|{
comment|// We have to copy the row part to form the row key alone
return|return
name|getFirstKey
argument_list|()
operator|.
name|map
argument_list|(
name|CellUtil
operator|::
name|cloneRow
argument_list|)
return|;
block|}
comment|/**    * TODO left from {@link HFile} version 1: move this to StoreFile after    * Ryan's patch goes in to eliminate {@link KeyValue} here.    *    * @return the last row key, or null if the file is empty.    */
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|byte
index|[]
argument_list|>
name|getLastRowKey
parameter_list|()
block|{
comment|// We have to copy the row part to form the row key alone
return|return
name|getLastKey
argument_list|()
operator|.
name|map
argument_list|(
name|CellUtil
operator|::
name|cloneRow
argument_list|)
return|;
block|}
comment|/** @return number of KV entries in this HFile */
annotation|@
name|Override
specifier|public
name|long
name|getEntries
parameter_list|()
block|{
return|return
name|trailer
operator|.
name|getEntryCount
argument_list|()
return|;
block|}
comment|/** @return comparator */
annotation|@
name|Override
specifier|public
name|CellComparator
name|getComparator
parameter_list|()
block|{
return|return
name|comparator
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|Compression
operator|.
name|Algorithm
name|getCompressionAlgorithm
parameter_list|()
block|{
return|return
name|trailer
operator|.
name|getCompressionCodec
argument_list|()
return|;
block|}
comment|/**    * @return the total heap size of data and meta block indexes in bytes. Does    *         not take into account non-root blocks of a multilevel data index.    */
annotation|@
name|Override
specifier|public
name|long
name|indexSize
parameter_list|()
block|{
return|return
operator|(
name|dataBlockIndexReader
operator|!=
literal|null
condition|?
name|dataBlockIndexReader
operator|.
name|heapSize
argument_list|()
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|metaBlockIndexReader
operator|!=
literal|null
operator|)
condition|?
name|metaBlockIndexReader
operator|.
name|heapSize
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setDataBlockEncoder
parameter_list|(
name|HFileDataBlockEncoder
name|dataBlockEncoder
parameter_list|)
block|{
name|this
operator|.
name|dataBlockEncoder
operator|=
name|dataBlockEncoder
expr_stmt|;
name|this
operator|.
name|fsBlockReader
operator|.
name|setDataBlockEncoder
argument_list|(
name|dataBlockEncoder
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setDataBlockIndexReader
parameter_list|(
name|HFileBlockIndex
operator|.
name|CellBasedKeyBlockIndexReader
name|reader
parameter_list|)
block|{
name|this
operator|.
name|dataBlockIndexReader
operator|=
name|reader
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|HFileBlockIndex
operator|.
name|CellBasedKeyBlockIndexReader
name|getDataBlockIndexReader
parameter_list|()
block|{
return|return
name|dataBlockIndexReader
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setMetaBlockIndexReader
parameter_list|(
name|HFileBlockIndex
operator|.
name|ByteArrayKeyBlockIndexReader
name|reader
parameter_list|)
block|{
name|this
operator|.
name|metaBlockIndexReader
operator|=
name|reader
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|HFileBlockIndex
operator|.
name|ByteArrayKeyBlockIndexReader
name|getMetaBlockIndexReader
parameter_list|()
block|{
return|return
name|metaBlockIndexReader
return|;
block|}
annotation|@
name|Override
specifier|public
name|FixedFileTrailer
name|getTrailer
parameter_list|()
block|{
return|return
name|trailer
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReaderContext
name|getContext
parameter_list|()
block|{
return|return
name|this
operator|.
name|context
return|;
block|}
annotation|@
name|Override
specifier|public
name|HFileInfo
name|getHFileInfo
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileInfo
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isPrimaryReplicaReader
parameter_list|()
block|{
return|return
name|primaryReplicaReader
return|;
block|}
comment|/**    * An exception thrown when an operation requiring a scanner to be seeked    * is invoked on a scanner that is not seeked.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|public
specifier|static
class|class
name|NotSeekedException
extends|extends
name|IllegalStateException
block|{
specifier|public
name|NotSeekedException
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|super
argument_list|(
name|path
operator|+
literal|" not seeked to a key/value"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
specifier|static
class|class
name|HFileScannerImpl
implements|implements
name|HFileScanner
block|{
specifier|private
name|ByteBuff
name|blockBuffer
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|cacheBlocks
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|pread
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|isCompaction
decl_stmt|;
specifier|private
name|int
name|currKeyLen
decl_stmt|;
specifier|private
name|int
name|currValueLen
decl_stmt|;
specifier|private
name|int
name|currMemstoreTSLen
decl_stmt|;
specifier|private
name|long
name|currMemstoreTS
decl_stmt|;
specifier|protected
specifier|final
name|HFile
operator|.
name|Reader
name|reader
decl_stmt|;
specifier|private
name|int
name|currTagsLen
decl_stmt|;
comment|// buffer backed keyonlyKV
specifier|private
name|ByteBufferKeyOnlyKeyValue
name|bufBackedKeyOnlyKv
init|=
operator|new
name|ByteBufferKeyOnlyKeyValue
argument_list|()
decl_stmt|;
comment|// A pair for reusing in blockSeek() so that we don't garbage lot of objects
specifier|final
name|ObjectIntPair
argument_list|<
name|ByteBuffer
argument_list|>
name|pair
init|=
operator|new
name|ObjectIntPair
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * The next indexed key is to keep track of the indexed key of the next data block.      * If the nextIndexedKey is HConstants.NO_NEXT_INDEXED_KEY, it means that the      * current data block is the last data block.      *      * If the nextIndexedKey is null, it means the nextIndexedKey has not been loaded yet.      */
specifier|protected
name|Cell
name|nextIndexedKey
decl_stmt|;
comment|// Current block being used. NOTICE: DON't release curBlock separately except in shipped() or
comment|// close() methods. Because the shipped() or close() will do the release finally, even if any
comment|// exception occur the curBlock will be released by the close() method (see
comment|// RegionScannerImpl#handleException). Call the releaseIfNotCurBlock() to release the
comment|// unreferenced block please.
specifier|protected
name|HFileBlock
name|curBlock
decl_stmt|;
comment|// Previous blocks that were used in the course of the read
specifier|protected
specifier|final
name|ArrayList
argument_list|<
name|HFileBlock
argument_list|>
name|prevBlocks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|HFileScannerImpl
parameter_list|(
specifier|final
name|HFile
operator|.
name|Reader
name|reader
parameter_list|,
specifier|final
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
block|{
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
name|this
operator|.
name|cacheBlocks
operator|=
name|cacheBlocks
expr_stmt|;
name|this
operator|.
name|pread
operator|=
name|pread
expr_stmt|;
name|this
operator|.
name|isCompaction
operator|=
name|isCompaction
expr_stmt|;
block|}
name|void
name|updateCurrBlockRef
parameter_list|(
name|HFileBlock
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|!=
literal|null
operator|&&
name|curBlock
operator|!=
literal|null
operator|&&
name|block
operator|.
name|getOffset
argument_list|()
operator|==
name|curBlock
operator|.
name|getOffset
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|curBlock
operator|!=
literal|null
operator|&&
name|this
operator|.
name|curBlock
operator|.
name|isSharedMem
argument_list|()
condition|)
block|{
name|prevBlocks
operator|.
name|add
argument_list|(
name|this
operator|.
name|curBlock
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|curBlock
operator|=
name|block
expr_stmt|;
block|}
name|void
name|reset
parameter_list|()
block|{
comment|// We don't have to keep ref to heap block
if|if
condition|(
name|this
operator|.
name|curBlock
operator|!=
literal|null
operator|&&
name|this
operator|.
name|curBlock
operator|.
name|isSharedMem
argument_list|()
condition|)
block|{
name|this
operator|.
name|prevBlocks
operator|.
name|add
argument_list|(
name|this
operator|.
name|curBlock
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|curBlock
operator|=
literal|null
expr_stmt|;
block|}
specifier|private
name|void
name|returnBlocks
parameter_list|(
name|boolean
name|returnAll
parameter_list|)
block|{
name|this
operator|.
name|prevBlocks
operator|.
name|forEach
argument_list|(
name|HFileBlock
operator|::
name|release
argument_list|)
expr_stmt|;
name|this
operator|.
name|prevBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|returnAll
operator|&&
name|this
operator|.
name|curBlock
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|curBlock
operator|.
name|release
argument_list|()
expr_stmt|;
name|this
operator|.
name|curBlock
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isSeeked
parameter_list|()
block|{
return|return
name|blockBuffer
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"HFileScanner for reader "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|getReader
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|void
name|assertSeeked
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSeeked
argument_list|()
condition|)
throw|throw
operator|new
name|NotSeekedException
argument_list|(
name|reader
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|HFile
operator|.
name|Reader
name|getReader
parameter_list|()
block|{
return|return
name|reader
return|;
block|}
comment|// From non encoded HFiles, we always read back KeyValue or its descendant.(Note: When HFile
comment|// block is in DBB, it will be OffheapKV). So all parts of the Cell is in a contiguous
comment|// array/buffer. How many bytes we should wrap to make the KV is what this method returns.
specifier|private
name|int
name|getKVBufSize
parameter_list|()
block|{
name|int
name|kvBufSize
init|=
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
operator|+
name|currValueLen
decl_stmt|;
if|if
condition|(
name|currTagsLen
operator|>
literal|0
condition|)
block|{
name|kvBufSize
operator|+=
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|+
name|currTagsLen
expr_stmt|;
block|}
return|return
name|kvBufSize
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
name|pread
condition|)
block|{
comment|// For seek + pread stream socket should be closed when the scanner is closed. HBASE-9393
name|reader
operator|.
name|unbufferStream
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|returnBlocks
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Returns the #bytes in HFile for the current cell. Used to skip these many bytes in current
comment|// HFile block's buffer so as to position to the next cell.
specifier|private
name|int
name|getCurCellSerializedSize
parameter_list|()
block|{
name|int
name|curCellSize
init|=
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
operator|+
name|currValueLen
operator|+
name|currMemstoreTSLen
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|getFileContext
argument_list|()
operator|.
name|isIncludesTags
argument_list|()
condition|)
block|{
name|curCellSize
operator|+=
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|+
name|currTagsLen
expr_stmt|;
block|}
return|return
name|curCellSize
return|;
block|}
specifier|protected
name|void
name|readKeyValueLen
parameter_list|()
block|{
comment|// This is a hot method. We go out of our way to make this method short so it can be
comment|// inlined and is not too big to compile. We also manage position in ByteBuffer ourselves
comment|// because it is faster than going via range-checked ByteBuffer methods or going through a
comment|// byte buffer array a byte at a time.
comment|// Get a long at a time rather than read two individual ints. In micro-benchmarking, even
comment|// with the extra bit-fiddling, this is order-of-magnitude faster than getting two ints.
comment|// Trying to imitate what was done - need to profile if this is better or
comment|// earlier way is better by doing mark and reset?
comment|// But ensure that you read long instead of two ints
name|long
name|ll
init|=
name|blockBuffer
operator|.
name|getLongAfterPosition
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Read top half as an int of key length and bottom int as value length
name|this
operator|.
name|currKeyLen
operator|=
call|(
name|int
call|)
argument_list|(
name|ll
operator|>>
name|Integer
operator|.
name|SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|currValueLen
operator|=
call|(
name|int
call|)
argument_list|(
name|Bytes
operator|.
name|MASK_FOR_LOWER_INT_IN_LONG
operator|^
name|ll
argument_list|)
expr_stmt|;
name|checkKeyValueLen
argument_list|()
expr_stmt|;
comment|// Move position past the key and value lengths and then beyond the key and value
name|int
name|p
init|=
operator|(
name|Bytes
operator|.
name|SIZEOF_LONG
operator|+
name|currKeyLen
operator|+
name|currValueLen
operator|)
decl_stmt|;
if|if
condition|(
name|reader
operator|.
name|getFileContext
argument_list|()
operator|.
name|isIncludesTags
argument_list|()
condition|)
block|{
comment|// Tags length is a short.
name|this
operator|.
name|currTagsLen
operator|=
name|blockBuffer
operator|.
name|getShortAfterPosition
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|checkTagsLen
argument_list|()
expr_stmt|;
name|p
operator|+=
operator|(
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|+
name|currTagsLen
operator|)
expr_stmt|;
block|}
name|readMvccVersion
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
name|void
name|checkTagsLen
parameter_list|()
block|{
if|if
condition|(
name|checkLen
argument_list|(
name|this
operator|.
name|currTagsLen
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid currTagsLen "
operator|+
name|this
operator|.
name|currTagsLen
operator|+
literal|". Block offset: "
operator|+
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
literal|", block length: "
operator|+
name|this
operator|.
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|", position: "
operator|+
name|this
operator|.
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|" (without header)."
operator|+
literal|" path="
operator|+
name|reader
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Read mvcc. Does checks to see if we even need to read the mvcc at all.      * @param offsetFromPos      */
specifier|protected
name|void
name|readMvccVersion
parameter_list|(
specifier|final
name|int
name|offsetFromPos
parameter_list|)
block|{
comment|// See if we even need to decode mvcc.
if|if
condition|(
operator|!
name|this
operator|.
name|reader
operator|.
name|getHFileInfo
argument_list|()
operator|.
name|shouldIncludeMemStoreTS
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|reader
operator|.
name|getHFileInfo
argument_list|()
operator|.
name|isDecodeMemstoreTS
argument_list|()
condition|)
block|{
name|currMemstoreTS
operator|=
literal|0
expr_stmt|;
name|currMemstoreTSLen
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|_readMvccVersion
argument_list|(
name|offsetFromPos
argument_list|)
expr_stmt|;
block|}
comment|/**      * Actually do the mvcc read. Does no checks.      * @param offsetFromPos      */
specifier|private
name|void
name|_readMvccVersion
parameter_list|(
name|int
name|offsetFromPos
parameter_list|)
block|{
comment|// This is Bytes#bytesToVint inlined so can save a few instructions in this hot method; i.e.
comment|// previous if one-byte vint, we'd redo the vint call to find int size.
comment|// Also the method is kept small so can be inlined.
name|byte
name|firstByte
init|=
name|blockBuffer
operator|.
name|getByteAfterPosition
argument_list|(
name|offsetFromPos
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|WritableUtils
operator|.
name|decodeVIntSize
argument_list|(
name|firstByte
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|this
operator|.
name|currMemstoreTS
operator|=
name|firstByte
expr_stmt|;
block|}
else|else
block|{
name|int
name|remaining
init|=
name|len
operator|-
literal|1
decl_stmt|;
name|long
name|i
init|=
literal|0
decl_stmt|;
name|offsetFromPos
operator|++
expr_stmt|;
if|if
condition|(
name|remaining
operator|>=
name|Bytes
operator|.
name|SIZEOF_INT
condition|)
block|{
comment|// The int read has to be converted to unsigned long so the& op
name|i
operator|=
operator|(
name|blockBuffer
operator|.
name|getIntAfterPosition
argument_list|(
name|offsetFromPos
argument_list|)
operator|&
literal|0x00000000ffffffffL
operator|)
expr_stmt|;
name|remaining
operator|-=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
name|offsetFromPos
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
block|}
if|if
condition|(
name|remaining
operator|>=
name|Bytes
operator|.
name|SIZEOF_SHORT
condition|)
block|{
name|short
name|s
init|=
name|blockBuffer
operator|.
name|getShortAfterPosition
argument_list|(
name|offsetFromPos
argument_list|)
decl_stmt|;
name|i
operator|=
name|i
operator|<<
literal|16
expr_stmt|;
name|i
operator|=
name|i
operator||
operator|(
name|s
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
name|remaining
operator|-=
name|Bytes
operator|.
name|SIZEOF_SHORT
expr_stmt|;
name|offsetFromPos
operator|+=
name|Bytes
operator|.
name|SIZEOF_SHORT
expr_stmt|;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|remaining
condition|;
name|idx
operator|++
control|)
block|{
name|byte
name|b
init|=
name|blockBuffer
operator|.
name|getByteAfterPosition
argument_list|(
name|offsetFromPos
operator|+
name|idx
argument_list|)
decl_stmt|;
name|i
operator|=
name|i
operator|<<
literal|8
expr_stmt|;
name|i
operator|=
name|i
operator||
operator|(
name|b
operator|&
literal|0xFF
operator|)
expr_stmt|;
block|}
name|currMemstoreTS
operator|=
operator|(
name|WritableUtils
operator|.
name|isNegativeVInt
argument_list|(
name|firstByte
argument_list|)
condition|?
operator|~
name|i
else|:
name|i
operator|)
expr_stmt|;
block|}
name|this
operator|.
name|currMemstoreTSLen
operator|=
name|len
expr_stmt|;
block|}
comment|/**      * Within a loaded block, seek looking for the last key that is smaller than      * (or equal to?) the key we are interested in.      * A note on the seekBefore: if you have seekBefore = true, AND the first      * key in the block = key, then you'll get thrown exceptions. The caller has      * to check for that case and load the previous block as appropriate.      * @param key      *          the key to find      * @param seekBefore      *          find the key before the given key in case of exact match.      * @return 0 in case of an exact key match, 1 in case of an inexact match,      *         -2 in case of an inexact match and furthermore, the input key      *         less than the first key of current block(e.g. using a faked index      *         key)      */
specifier|protected
name|int
name|blockSeek
parameter_list|(
name|Cell
name|key
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
block|{
name|int
name|klen
decl_stmt|,
name|vlen
decl_stmt|,
name|tlen
init|=
literal|0
decl_stmt|;
name|int
name|lastKeyValueSize
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|offsetFromPos
decl_stmt|;
do|do
block|{
name|offsetFromPos
operator|=
literal|0
expr_stmt|;
comment|// Better to ensure that we use the BB Utils here
name|long
name|ll
init|=
name|blockBuffer
operator|.
name|getLongAfterPosition
argument_list|(
name|offsetFromPos
argument_list|)
decl_stmt|;
name|klen
operator|=
call|(
name|int
call|)
argument_list|(
name|ll
operator|>>
name|Integer
operator|.
name|SIZE
argument_list|)
expr_stmt|;
name|vlen
operator|=
call|(
name|int
call|)
argument_list|(
name|Bytes
operator|.
name|MASK_FOR_LOWER_INT_IN_LONG
operator|^
name|ll
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkKeyLen
argument_list|(
name|klen
argument_list|)
operator|||
name|checkLen
argument_list|(
name|vlen
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid klen "
operator|+
name|klen
operator|+
literal|" or vlen "
operator|+
name|vlen
operator|+
literal|". Block offset: "
operator|+
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
literal|", block length: "
operator|+
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|", position: "
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|" (without header)."
operator|+
literal|" path="
operator|+
name|reader
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
name|offsetFromPos
operator|+=
name|Bytes
operator|.
name|SIZEOF_LONG
expr_stmt|;
name|blockBuffer
operator|.
name|asSubByteBuffer
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|offsetFromPos
argument_list|,
name|klen
argument_list|,
name|pair
argument_list|)
expr_stmt|;
name|bufBackedKeyOnlyKv
operator|.
name|setKey
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|int
name|comp
init|=
name|PrivateCellUtil
operator|.
name|compareKeyIgnoresMvcc
argument_list|(
name|reader
operator|.
name|getComparator
argument_list|()
argument_list|,
name|key
argument_list|,
name|bufBackedKeyOnlyKv
argument_list|)
decl_stmt|;
name|offsetFromPos
operator|+=
name|klen
operator|+
name|vlen
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|getFileContext
argument_list|()
operator|.
name|isIncludesTags
argument_list|()
condition|)
block|{
comment|// Read short as unsigned, high byte first
name|tlen
operator|=
operator|(
operator|(
name|blockBuffer
operator|.
name|getByteAfterPosition
argument_list|(
name|offsetFromPos
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|^
operator|(
name|blockBuffer
operator|.
name|getByteAfterPosition
argument_list|(
name|offsetFromPos
operator|+
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
name|checkLen
argument_list|(
name|tlen
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid tlen "
operator|+
name|tlen
operator|+
literal|". Block offset: "
operator|+
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
literal|", block length: "
operator|+
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|", position: "
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|" (without header)."
operator|+
literal|" path="
operator|+
name|reader
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
comment|// add the two bytes read for the tags.
name|offsetFromPos
operator|+=
name|tlen
operator|+
operator|(
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|getHFileInfo
argument_list|()
operator|.
name|shouldIncludeMemStoreTS
argument_list|()
condition|)
block|{
comment|// Directly read the mvcc based on current position
name|readMvccVersion
argument_list|(
name|offsetFromPos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|seekBefore
condition|)
block|{
if|if
condition|(
name|lastKeyValueSize
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"blockSeek with seekBefore "
operator|+
literal|"at the first key of the block: key="
operator|+
name|CellUtil
operator|.
name|getCellKeyAsString
argument_list|(
name|key
argument_list|)
operator|+
literal|", blockOffset="
operator|+
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
literal|", onDiskSize="
operator|+
name|curBlock
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
operator|+
literal|", path="
operator|+
name|reader
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
name|blockBuffer
operator|.
name|moveBack
argument_list|(
name|lastKeyValueSize
argument_list|)
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// non exact match.
block|}
name|currKeyLen
operator|=
name|klen
expr_stmt|;
name|currValueLen
operator|=
name|vlen
expr_stmt|;
name|currTagsLen
operator|=
name|tlen
expr_stmt|;
return|return
literal|0
return|;
comment|// indicate exact match
block|}
elseif|else
if|if
condition|(
name|comp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|lastKeyValueSize
operator|>
literal|0
condition|)
block|{
name|blockBuffer
operator|.
name|moveBack
argument_list|(
name|lastKeyValueSize
argument_list|)
expr_stmt|;
block|}
name|readKeyValueLen
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastKeyValueSize
operator|==
operator|-
literal|1
operator|&&
name|blockBuffer
operator|.
name|position
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|HConstants
operator|.
name|INDEX_KEY_MAGIC
return|;
block|}
return|return
literal|1
return|;
block|}
comment|// The size of this key/value tuple, including key/value length fields.
name|lastKeyValueSize
operator|=
name|klen
operator|+
name|vlen
operator|+
name|currMemstoreTSLen
operator|+
name|KEY_VALUE_LEN_SIZE
expr_stmt|;
comment|// include tag length also if tags included with KV
if|if
condition|(
name|reader
operator|.
name|getFileContext
argument_list|()
operator|.
name|isIncludesTags
argument_list|()
condition|)
block|{
name|lastKeyValueSize
operator|+=
name|tlen
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
expr_stmt|;
block|}
name|blockBuffer
operator|.
name|skip
argument_list|(
name|lastKeyValueSize
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|blockBuffer
operator|.
name|hasRemaining
argument_list|()
condition|)
do|;
comment|// Seek to the last key we successfully read. This will happen if this is
comment|// the last key/value pair in the file, in which case the following call
comment|// to next() has to return false.
name|blockBuffer
operator|.
name|moveBack
argument_list|(
name|lastKeyValueSize
argument_list|)
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// didn't exactly find it.
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|getNextIndexedKey
parameter_list|()
block|{
return|return
name|nextIndexedKey
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|seekTo
parameter_list|(
name|Cell
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|seekTo
argument_list|(
name|key
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|reseekTo
parameter_list|(
name|Cell
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|compared
decl_stmt|;
if|if
condition|(
name|isSeeked
argument_list|()
condition|)
block|{
name|compared
operator|=
name|compareKey
argument_list|(
name|reader
operator|.
name|getComparator
argument_list|()
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|compared
operator|<
literal|1
condition|)
block|{
comment|// If the required key is less than or equal to current key, then
comment|// don't do anything.
return|return
name|compared
return|;
block|}
else|else
block|{
comment|// The comparison with no_next_index_key has to be checked
if|if
condition|(
name|this
operator|.
name|nextIndexedKey
operator|!=
literal|null
operator|&&
operator|(
name|this
operator|.
name|nextIndexedKey
operator|==
name|KeyValueScanner
operator|.
name|NO_NEXT_INDEXED_KEY
operator|||
name|PrivateCellUtil
operator|.
name|compareKeyIgnoresMvcc
argument_list|(
name|reader
operator|.
name|getComparator
argument_list|()
argument_list|,
name|key
argument_list|,
name|nextIndexedKey
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
comment|// The reader shall continue to scan the current data block instead
comment|// of querying the
comment|// block index as long as it knows the target key is strictly
comment|// smaller than
comment|// the next indexed key or the current data block is the last data
comment|// block.
return|return
name|loadBlockAndSeekToKey
argument_list|(
name|this
operator|.
name|curBlock
argument_list|,
name|nextIndexedKey
argument_list|,
literal|false
argument_list|,
name|key
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
comment|// Don't rewind on a reseek operation, because reseek implies that we are
comment|// always going forward in the file.
return|return
name|seekTo
argument_list|(
name|key
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * An internal API function. Seek to the given key, optionally rewinding to      * the first key of the block before doing the seek.      *      * @param key - a cell representing the key that we need to fetch      * @param rewind whether to rewind to the first key of the block before      *        doing the seek. If this is false, we are assuming we never go      *        back, otherwise the result is undefined.      * @return -1 if the key is earlier than the first key of the file,      *         0 if we are at the given key, 1 if we are past the given key      *         -2 if the key is earlier than the first key of the file while      *         using a faked index key      * @throws IOException      */
specifier|public
name|int
name|seekTo
parameter_list|(
name|Cell
name|key
parameter_list|,
name|boolean
name|rewind
parameter_list|)
throws|throws
name|IOException
block|{
name|HFileBlockIndex
operator|.
name|BlockIndexReader
name|indexReader
init|=
name|reader
operator|.
name|getDataBlockIndexReader
argument_list|()
decl_stmt|;
name|BlockWithScanInfo
name|blockWithScanInfo
init|=
name|indexReader
operator|.
name|loadDataBlockWithScanInfo
argument_list|(
name|key
argument_list|,
name|curBlock
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
name|getEffectiveDataBlockEncoding
argument_list|()
argument_list|,
name|reader
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockWithScanInfo
operator|==
literal|null
operator|||
name|blockWithScanInfo
operator|.
name|getHFileBlock
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// This happens if the key e.g. falls before the beginning of the file.
return|return
operator|-
literal|1
return|;
block|}
return|return
name|loadBlockAndSeekToKey
argument_list|(
name|blockWithScanInfo
operator|.
name|getHFileBlock
argument_list|()
argument_list|,
name|blockWithScanInfo
operator|.
name|getNextIndexedKey
argument_list|()
argument_list|,
name|rewind
argument_list|,
name|key
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|seekBefore
parameter_list|(
name|Cell
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|HFileBlock
name|seekToBlock
init|=
name|reader
operator|.
name|getDataBlockIndexReader
argument_list|()
operator|.
name|seekToDataBlock
argument_list|(
name|key
argument_list|,
name|curBlock
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
name|reader
operator|.
name|getEffectiveEncodingInCache
argument_list|(
name|isCompaction
argument_list|)
argument_list|,
name|reader
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekToBlock
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Cell
name|firstKey
init|=
name|getFirstKeyCellInBlock
argument_list|(
name|seekToBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|PrivateCellUtil
operator|.
name|compareKeyIgnoresMvcc
argument_list|(
name|reader
operator|.
name|getComparator
argument_list|()
argument_list|,
name|firstKey
argument_list|,
name|key
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|long
name|previousBlockOffset
init|=
name|seekToBlock
operator|.
name|getPrevBlockOffset
argument_list|()
decl_stmt|;
comment|// The key we are interested in
if|if
condition|(
name|previousBlockOffset
operator|==
operator|-
literal|1
condition|)
block|{
comment|// we have a 'problem', the key we want is the first of the file.
name|releaseIfNotCurBlock
argument_list|(
name|seekToBlock
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// The first key in the current block 'seekToBlock' is greater than the given
comment|// seekBefore key. We will go ahead by reading the next block that satisfies the
comment|// given key. Return the current block before reading the next one.
name|releaseIfNotCurBlock
argument_list|(
name|seekToBlock
argument_list|)
expr_stmt|;
comment|// It is important that we compute and pass onDiskSize to the block
comment|// reader so that it does not have to read the header separately to
comment|// figure out the size. Currently, we do not have a way to do this
comment|// correctly in the general case however.
comment|// TODO: See https://issues.apache.org/jira/browse/HBASE-14576
name|int
name|prevBlockSize
init|=
operator|-
literal|1
decl_stmt|;
name|seekToBlock
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|previousBlockOffset
argument_list|,
name|prevBlockSize
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
literal|true
argument_list|,
name|BlockType
operator|.
name|DATA
argument_list|,
name|getEffectiveDataBlockEncoding
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO shortcut: seek forward in this block to the last key of the
comment|// block.
block|}
name|loadBlockAndSeekToKey
argument_list|(
name|seekToBlock
argument_list|,
name|firstKey
argument_list|,
literal|true
argument_list|,
name|key
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * The curBlock will be released by shipping or close method, so only need to consider releasing      * the block, which was read from HFile before and not referenced by curBlock.      */
specifier|protected
name|void
name|releaseIfNotCurBlock
parameter_list|(
name|HFileBlock
name|block
parameter_list|)
block|{
if|if
condition|(
name|curBlock
operator|!=
name|block
condition|)
block|{
name|block
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Scans blocks in the "scanned" section of the {@link HFile} until the next      * data block is found.      *      * @return the next block, or null if there are no more data blocks      * @throws IOException      */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"NP_NULL_ON_SOME_PATH"
argument_list|,
name|justification
operator|=
literal|"Yeah, unnecessary null check; could do w/ clean up"
argument_list|)
specifier|protected
name|HFileBlock
name|readNextDataBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|lastDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getLastDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|curBlock
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|HFileBlock
name|block
init|=
name|this
operator|.
name|curBlock
decl_stmt|;
do|do
block|{
if|if
condition|(
name|block
operator|.
name|getOffset
argument_list|()
operator|>=
name|lastDataBlockOffset
condition|)
block|{
name|releaseIfNotCurBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|block
operator|.
name|getOffset
argument_list|()
operator|<
literal|0
condition|)
block|{
name|releaseIfNotCurBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid block file offset: "
operator|+
name|block
operator|+
literal|", path="
operator|+
name|reader
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
comment|// We are reading the next block without block type validation, because
comment|// it might turn out to be a non-data block.
name|block
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|block
operator|.
name|getOffset
argument_list|()
operator|+
name|block
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
argument_list|,
name|block
operator|.
name|getNextBlockOnDiskSize
argument_list|()
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|getEffectiveDataBlockEncoding
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|!=
literal|null
operator|&&
operator|!
name|block
operator|.
name|getBlockType
argument_list|()
operator|.
name|isData
argument_list|()
condition|)
block|{
comment|// Whatever block we read we will be returning it unless
comment|// it is a datablock. Just in case the blocks are non data blocks
name|block
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|block
operator|.
name|getBlockType
argument_list|()
operator|.
name|isData
argument_list|()
condition|)
do|;
return|return
name|block
return|;
block|}
specifier|public
name|DataBlockEncoding
name|getEffectiveDataBlockEncoding
parameter_list|()
block|{
return|return
name|this
operator|.
name|reader
operator|.
name|getEffectiveEncodingInCache
argument_list|(
name|isCompaction
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|getCell
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSeeked
argument_list|()
condition|)
return|return
literal|null
return|;
name|Cell
name|ret
decl_stmt|;
name|int
name|cellBufSize
init|=
name|getKVBufSize
argument_list|()
decl_stmt|;
name|long
name|seqId
init|=
literal|0L
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|getHFileInfo
argument_list|()
operator|.
name|shouldIncludeMemStoreTS
argument_list|()
condition|)
block|{
name|seqId
operator|=
name|currMemstoreTS
expr_stmt|;
block|}
if|if
condition|(
name|blockBuffer
operator|.
name|hasArray
argument_list|()
condition|)
block|{
comment|// TODO : reduce the varieties of KV here. Check if based on a boolean
comment|// we can handle the 'no tags' case.
if|if
condition|(
name|currTagsLen
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
operator|new
name|SizeCachedKeyValue
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
argument_list|,
name|cellBufSize
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|new
name|SizeCachedNoTagsKeyValue
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
argument_list|,
name|cellBufSize
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ByteBuffer
name|buf
init|=
name|blockBuffer
operator|.
name|asSubByteBuffer
argument_list|(
name|cellBufSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|.
name|isDirect
argument_list|()
condition|)
block|{
name|ret
operator|=
name|currTagsLen
operator|>
literal|0
condition|?
operator|new
name|ByteBufferKeyValue
argument_list|(
name|buf
argument_list|,
name|buf
operator|.
name|position
argument_list|()
argument_list|,
name|cellBufSize
argument_list|,
name|seqId
argument_list|)
else|:
operator|new
name|NoTagsByteBufferKeyValue
argument_list|(
name|buf
argument_list|,
name|buf
operator|.
name|position
argument_list|()
argument_list|,
name|cellBufSize
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currTagsLen
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
operator|new
name|SizeCachedKeyValue
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|buf
operator|.
name|position
argument_list|()
argument_list|,
name|cellBufSize
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|new
name|SizeCachedNoTagsKeyValue
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|buf
operator|.
name|position
argument_list|()
argument_list|,
name|cellBufSize
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|getKey
parameter_list|()
block|{
name|assertSeeked
argument_list|()
expr_stmt|;
comment|// Create a new object so that this getKey is cached as firstKey, lastKey
name|ObjectIntPair
argument_list|<
name|ByteBuffer
argument_list|>
name|keyPair
init|=
operator|new
name|ObjectIntPair
argument_list|<>
argument_list|()
decl_stmt|;
name|blockBuffer
operator|.
name|asSubByteBuffer
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
argument_list|,
name|currKeyLen
argument_list|,
name|keyPair
argument_list|)
expr_stmt|;
name|ByteBuffer
name|keyBuf
init|=
name|keyPair
operator|.
name|getFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyBuf
operator|.
name|hasArray
argument_list|()
condition|)
block|{
return|return
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|keyBuf
operator|.
name|array
argument_list|()
argument_list|,
name|keyBuf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|keyPair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|currKeyLen
argument_list|)
return|;
block|}
else|else
block|{
comment|// Better to do a copy here instead of holding on to this BB so that
comment|// we could release the blocks referring to this key. This key is specifically used
comment|// in HalfStoreFileReader to get the firstkey and lastkey by creating a new scanner
comment|// every time. So holding onto the BB (incase of DBB) is not advised here.
name|byte
index|[]
name|key
init|=
operator|new
name|byte
index|[
name|currKeyLen
index|]
decl_stmt|;
name|ByteBufferUtils
operator|.
name|copyFromBufferToArray
argument_list|(
name|key
argument_list|,
name|keyBuf
argument_list|,
name|keyPair
operator|.
name|getSecond
argument_list|()
argument_list|,
literal|0
argument_list|,
name|currKeyLen
argument_list|)
expr_stmt|;
return|return
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|currKeyLen
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getValue
parameter_list|()
block|{
name|assertSeeked
argument_list|()
expr_stmt|;
comment|// Okie to create new Pair. Not used in hot path
name|ObjectIntPair
argument_list|<
name|ByteBuffer
argument_list|>
name|valuePair
init|=
operator|new
name|ObjectIntPair
argument_list|<>
argument_list|()
decl_stmt|;
name|this
operator|.
name|blockBuffer
operator|.
name|asSubByteBuffer
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
argument_list|,
name|currValueLen
argument_list|,
name|valuePair
argument_list|)
expr_stmt|;
name|ByteBuffer
name|valBuf
init|=
name|valuePair
operator|.
name|getFirst
argument_list|()
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|valBuf
operator|.
name|position
argument_list|(
name|valuePair
operator|.
name|getSecond
argument_list|()
argument_list|)
expr_stmt|;
name|valBuf
operator|.
name|limit
argument_list|(
name|currValueLen
operator|+
name|valuePair
operator|.
name|getSecond
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|valBuf
operator|.
name|slice
argument_list|()
return|;
block|}
specifier|protected
name|void
name|setNonSeekedState
parameter_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
name|blockBuffer
operator|=
literal|null
expr_stmt|;
name|currKeyLen
operator|=
literal|0
expr_stmt|;
name|currValueLen
operator|=
literal|0
expr_stmt|;
name|currMemstoreTS
operator|=
literal|0
expr_stmt|;
name|currMemstoreTSLen
operator|=
literal|0
expr_stmt|;
name|currTagsLen
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Set the position on current backing blockBuffer.      */
specifier|private
name|void
name|positionThisBlockBuffer
parameter_list|()
block|{
try|try
block|{
name|blockBuffer
operator|.
name|skip
argument_list|(
name|getCurCellSerializedSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Current pos = "
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|"; currKeyLen = "
operator|+
name|currKeyLen
operator|+
literal|"; currValLen = "
operator|+
name|currValueLen
operator|+
literal|"; block limit = "
operator|+
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|"; currBlock currBlockOffset = "
operator|+
name|this
operator|.
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
literal|"; path="
operator|+
name|reader
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**      * Set our selves up for the next 'next' invocation, set up next block.      * @return True is more to read else false if at the end.      * @throws IOException      */
specifier|private
name|boolean
name|positionForNextBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Methods are small so they get inlined because they are 'hot'.
name|long
name|lastDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getLastDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|>=
name|lastDataBlockOffset
condition|)
block|{
name|setNonSeekedState
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|isNextBlock
argument_list|()
return|;
block|}
specifier|private
name|boolean
name|isNextBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Methods are small so they get inlined because they are 'hot'.
name|HFileBlock
name|nextBlock
init|=
name|readNextDataBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextBlock
operator|==
literal|null
condition|)
block|{
name|setNonSeekedState
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|updateCurrentBlock
argument_list|(
name|nextBlock
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
specifier|final
name|boolean
name|_next
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Small method so can be inlined. It is a hot one.
if|if
condition|(
name|blockBuffer
operator|.
name|remaining
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
name|positionForNextBlock
argument_list|()
return|;
block|}
comment|// We are still in the same block.
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Go to the next key/value in the block section. Loads the next block if      * necessary. If successful, {@link #getKey()} and {@link #getValue()} can      * be called.      *      * @return true if successfully navigated to the next key/value      */
annotation|@
name|Override
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
comment|// This is a hot method so extreme measures taken to ensure it is small and inlineable.
comment|// Checked by setting: -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining -XX:+PrintCompilation
name|assertSeeked
argument_list|()
expr_stmt|;
name|positionThisBlockBuffer
argument_list|()
expr_stmt|;
return|return
name|_next
argument_list|()
return|;
block|}
comment|/**      * Positions this scanner at the start of the file.      *      * @return false if empty file; i.e. a call to next would return false and      *         the current key and value are undefined.      * @throws IOException      */
annotation|@
name|Override
specifier|public
name|boolean
name|seekTo
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|reader
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getEntryCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// No data blocks.
return|return
literal|false
return|;
block|}
name|long
name|firstDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getFirstDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|curBlock
operator|!=
literal|null
operator|&&
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|==
name|firstDataBlockOffset
condition|)
block|{
return|return
name|processFirstDataBlock
argument_list|()
return|;
block|}
name|readAndUpdateNewBlock
argument_list|(
name|firstDataBlockOffset
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|protected
name|boolean
name|processFirstDataBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|blockBuffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|protected
name|void
name|readAndUpdateNewBlock
parameter_list|(
name|long
name|firstDataBlockOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|HFileBlock
name|newBlock
init|=
name|reader
operator|.
name|readBlock
argument_list|(
name|firstDataBlockOffset
argument_list|,
operator|-
literal|1
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
literal|true
argument_list|,
name|BlockType
operator|.
name|DATA
argument_list|,
name|getEffectiveDataBlockEncoding
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newBlock
operator|.
name|getOffset
argument_list|()
operator|<
literal|0
condition|)
block|{
name|releaseIfNotCurBlock
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid block offset: "
operator|+
name|newBlock
operator|.
name|getOffset
argument_list|()
operator|+
literal|", path="
operator|+
name|reader
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
name|updateCurrentBlock
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|int
name|loadBlockAndSeekToKey
parameter_list|(
name|HFileBlock
name|seekToBlock
parameter_list|,
name|Cell
name|nextIndexedKey
parameter_list|,
name|boolean
name|rewind
parameter_list|,
name|Cell
name|key
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|curBlock
operator|==
literal|null
operator|||
name|this
operator|.
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|!=
name|seekToBlock
operator|.
name|getOffset
argument_list|()
condition|)
block|{
name|updateCurrentBlock
argument_list|(
name|seekToBlock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rewind
condition|)
block|{
name|blockBuffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
comment|// Update the nextIndexedKey
name|this
operator|.
name|nextIndexedKey
operator|=
name|nextIndexedKey
expr_stmt|;
return|return
name|blockSeek
argument_list|(
name|key
argument_list|,
name|seekBefore
argument_list|)
return|;
block|}
comment|/**      * @param v      * @return True if v&lt;= 0 or v&gt; current block buffer limit.      */
specifier|protected
specifier|final
name|boolean
name|checkKeyLen
parameter_list|(
specifier|final
name|int
name|v
parameter_list|)
block|{
return|return
name|v
operator|<=
literal|0
operator|||
name|v
operator|>
name|this
operator|.
name|blockBuffer
operator|.
name|limit
argument_list|()
return|;
block|}
comment|/**      * @param v      * @return True if v&lt; 0 or v&gt; current block buffer limit.      */
specifier|protected
specifier|final
name|boolean
name|checkLen
parameter_list|(
specifier|final
name|int
name|v
parameter_list|)
block|{
return|return
name|v
argument_list|<
literal|0
operator|||
name|v
argument_list|>
name|this
operator|.
name|blockBuffer
operator|.
name|limit
argument_list|()
return|;
block|}
comment|/**      * Check key and value lengths are wholesome.      */
specifier|protected
specifier|final
name|void
name|checkKeyValueLen
parameter_list|()
block|{
if|if
condition|(
name|checkKeyLen
argument_list|(
name|this
operator|.
name|currKeyLen
argument_list|)
operator|||
name|checkLen
argument_list|(
name|this
operator|.
name|currValueLen
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid currKeyLen "
operator|+
name|this
operator|.
name|currKeyLen
operator|+
literal|" or currValueLen "
operator|+
name|this
operator|.
name|currValueLen
operator|+
literal|". Block offset: "
operator|+
name|this
operator|.
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
literal|", block length: "
operator|+
name|this
operator|.
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|", position: "
operator|+
name|this
operator|.
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|" (without header)."
operator|+
literal|", path="
operator|+
name|reader
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Updates the current block to be the given {@link HFileBlock}. Seeks to the the first      * key/value pair.      * @param newBlock the block read by {@link HFileReaderImpl#readBlock}, it's a totally new block      *          with new allocated {@link ByteBuff}, so if no further reference to this block, we      *          should release it carefully.      */
specifier|protected
name|void
name|updateCurrentBlock
parameter_list|(
name|HFileBlock
name|newBlock
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|newBlock
operator|.
name|getBlockType
argument_list|()
operator|!=
name|BlockType
operator|.
name|DATA
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"ScannerV2 works only on data blocks, got "
operator|+
name|newBlock
operator|.
name|getBlockType
argument_list|()
operator|+
literal|"; "
operator|+
literal|"HFileName="
operator|+
name|reader
operator|.
name|getPath
argument_list|()
operator|+
literal|", "
operator|+
literal|"dataBlockEncoder="
operator|+
name|reader
operator|.
name|getDataBlockEncoding
argument_list|()
operator|+
literal|", "
operator|+
literal|"isCompaction="
operator|+
name|isCompaction
argument_list|)
throw|;
block|}
name|updateCurrBlockRef
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
name|blockBuffer
operator|=
name|newBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|releaseIfNotCurBlock
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
block|}
comment|// Reset the next indexed key
name|this
operator|.
name|nextIndexedKey
operator|=
literal|null
expr_stmt|;
block|}
specifier|protected
name|Cell
name|getFirstKeyCellInBlock
parameter_list|(
name|HFileBlock
name|curBlock
parameter_list|)
block|{
name|ByteBuff
name|buffer
init|=
name|curBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
decl_stmt|;
comment|// It is safe to manipulate this buffer because we own the buffer object.
name|buffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|int
name|klen
init|=
name|buffer
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|skip
argument_list|(
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|)
expr_stmt|;
comment|// Skip value len part
name|ByteBuffer
name|keyBuff
init|=
name|buffer
operator|.
name|asSubByteBuffer
argument_list|(
name|klen
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyBuff
operator|.
name|hasArray
argument_list|()
condition|)
block|{
return|return
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|keyBuff
operator|.
name|array
argument_list|()
argument_list|,
name|keyBuff
operator|.
name|arrayOffset
argument_list|()
operator|+
name|keyBuff
operator|.
name|position
argument_list|()
argument_list|,
name|klen
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ByteBufferKeyOnlyKeyValue
argument_list|(
name|keyBuff
argument_list|,
name|keyBuff
operator|.
name|position
argument_list|()
argument_list|,
name|klen
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|getKeyString
parameter_list|()
block|{
return|return
name|CellUtil
operator|.
name|toString
argument_list|(
name|getKey
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getValueString
parameter_list|()
block|{
return|return
name|ByteBufferUtils
operator|.
name|toStringBinary
argument_list|(
name|getValue
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|int
name|compareKey
parameter_list|(
name|CellComparator
name|comparator
parameter_list|,
name|Cell
name|key
parameter_list|)
block|{
name|blockBuffer
operator|.
name|asSubByteBuffer
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
argument_list|,
name|currKeyLen
argument_list|,
name|pair
argument_list|)
expr_stmt|;
name|this
operator|.
name|bufBackedKeyOnlyKv
operator|.
name|setKey
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|currKeyLen
argument_list|)
expr_stmt|;
return|return
name|PrivateCellUtil
operator|.
name|compareKeyIgnoresMvcc
argument_list|(
name|comparator
argument_list|,
name|key
argument_list|,
name|this
operator|.
name|bufBackedKeyOnlyKv
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|shipped
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|returnBlocks
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Path
name|getPath
parameter_list|()
block|{
return|return
name|path
return|;
block|}
annotation|@
name|Override
specifier|public
name|DataBlockEncoding
name|getDataBlockEncoding
parameter_list|()
block|{
return|return
name|dataBlockEncoder
operator|.
name|getDataBlockEncoding
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
comment|/** Minor versions in HFile starting with this number have hbase checksums */
specifier|public
specifier|static
specifier|final
name|int
name|MINOR_VERSION_WITH_CHECKSUM
init|=
literal|1
decl_stmt|;
comment|/** In HFile minor version that does not support checksums */
specifier|public
specifier|static
specifier|final
name|int
name|MINOR_VERSION_NO_CHECKSUM
init|=
literal|0
decl_stmt|;
comment|/** HFile minor version that introduced pbuf filetrailer */
specifier|public
specifier|static
specifier|final
name|int
name|PBUF_TRAILER_MINOR_VERSION
init|=
literal|2
decl_stmt|;
comment|/**    * The size of a (key length, value length) tuple that prefixes each entry in    * a data block.    */
specifier|public
specifier|final
specifier|static
name|int
name|KEY_VALUE_LEN_SIZE
init|=
literal|2
operator|*
name|Bytes
operator|.
name|SIZEOF_INT
decl_stmt|;
comment|/**    * Retrieve block from cache. Validates the retrieved block's type vs {@code expectedBlockType}    * and its encoding vs. {@code expectedDataBlockEncoding}. Unpacks the block as necessary.    */
specifier|private
name|HFileBlock
name|getCachedBlock
parameter_list|(
name|BlockCacheKey
name|cacheKey
parameter_list|,
name|boolean
name|cacheBlock
parameter_list|,
name|boolean
name|useLock
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|boolean
name|updateCacheMetrics
parameter_list|,
name|BlockType
name|expectedBlockType
parameter_list|,
name|DataBlockEncoding
name|expectedDataBlockEncoding
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Check cache for block. If found return.
name|BlockCache
name|cache
init|=
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache
operator|!=
literal|null
condition|)
block|{
name|HFileBlock
name|cachedBlock
init|=
operator|(
name|HFileBlock
operator|)
name|cache
operator|.
name|getBlock
argument_list|(
name|cacheKey
argument_list|,
name|cacheBlock
argument_list|,
name|useLock
argument_list|,
name|updateCacheMetrics
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBlock
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cacheConf
operator|.
name|shouldCacheCompressed
argument_list|(
name|cachedBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|getCategory
argument_list|()
argument_list|)
condition|)
block|{
name|HFileBlock
name|compressedBlock
init|=
name|cachedBlock
decl_stmt|;
name|cachedBlock
operator|=
name|compressedBlock
operator|.
name|unpack
argument_list|(
name|hfileContext
argument_list|,
name|fsBlockReader
argument_list|)
expr_stmt|;
comment|// In case of compressed block after unpacking we can release the compressed block
if|if
condition|(
name|compressedBlock
operator|!=
name|cachedBlock
condition|)
block|{
name|compressedBlock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
try|try
block|{
name|validateBlockType
argument_list|(
name|cachedBlock
argument_list|,
name|expectedBlockType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|returnAndEvictBlock
argument_list|(
name|cache
argument_list|,
name|cacheKey
argument_list|,
name|cachedBlock
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
name|expectedDataBlockEncoding
operator|==
literal|null
condition|)
block|{
return|return
name|cachedBlock
return|;
block|}
name|DataBlockEncoding
name|actualDataBlockEncoding
init|=
name|cachedBlock
operator|.
name|getDataBlockEncoding
argument_list|()
decl_stmt|;
comment|// Block types other than data blocks always have
comment|// DataBlockEncoding.NONE. To avoid false negative cache misses, only
comment|// perform this check if cached block is a data block.
if|if
condition|(
name|cachedBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|isData
argument_list|()
operator|&&
operator|!
name|actualDataBlockEncoding
operator|.
name|equals
argument_list|(
name|expectedDataBlockEncoding
argument_list|)
condition|)
block|{
comment|// This mismatch may happen if a Scanner, which is used for say a
comment|// compaction, tries to read an encoded block from the block cache.
comment|// The reverse might happen when an EncodedScanner tries to read
comment|// un-encoded blocks which were cached earlier.
comment|//
comment|// Because returning a data block with an implicit BlockType mismatch
comment|// will cause the requesting scanner to throw a disk read should be
comment|// forced here. This will potentially cause a significant number of
comment|// cache misses, so update so we should keep track of this as it might
comment|// justify the work on a CompoundScanner.
if|if
condition|(
operator|!
name|expectedDataBlockEncoding
operator|.
name|equals
argument_list|(
name|DataBlockEncoding
operator|.
name|NONE
argument_list|)
operator|&&
operator|!
name|actualDataBlockEncoding
operator|.
name|equals
argument_list|(
name|DataBlockEncoding
operator|.
name|NONE
argument_list|)
condition|)
block|{
comment|// If the block is encoded but the encoding does not match the
comment|// expected encoding it is likely the encoding was changed but the
comment|// block was not yet evicted. Evictions on file close happen async
comment|// so blocks with the old encoding still linger in cache for some
comment|// period of time. This event should be rare as it only happens on
comment|// schema definition change.
name|LOG
operator|.
name|info
argument_list|(
literal|"Evicting cached block with key "
operator|+
name|cacheKey
operator|+
literal|" because of a data block encoding mismatch"
operator|+
literal|"; expected: "
operator|+
name|expectedDataBlockEncoding
operator|+
literal|", actual: "
operator|+
name|actualDataBlockEncoding
operator|+
literal|", path="
operator|+
name|path
argument_list|)
expr_stmt|;
comment|// This is an error scenario. so here we need to release the block.
name|returnAndEvictBlock
argument_list|(
name|cache
argument_list|,
name|cacheKey
argument_list|,
name|cachedBlock
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
return|return
name|cachedBlock
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|returnAndEvictBlock
parameter_list|(
name|BlockCache
name|cache
parameter_list|,
name|BlockCacheKey
name|cacheKey
parameter_list|,
name|Cacheable
name|block
parameter_list|)
block|{
name|block
operator|.
name|release
argument_list|()
expr_stmt|;
name|cache
operator|.
name|evictBlock
argument_list|(
name|cacheKey
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param metaBlockName    * @param cacheBlock Add block to cache, if found    * @return block wrapped in a ByteBuffer, with header skipped    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|HFileBlock
name|getMetaBlock
parameter_list|(
name|String
name|metaBlockName
parameter_list|,
name|boolean
name|cacheBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|trailer
operator|.
name|getMetaIndexCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
comment|// there are no meta blocks
block|}
if|if
condition|(
name|metaBlockIndexReader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|path
operator|+
literal|" meta index not loaded"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|mbname
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|metaBlockName
argument_list|)
decl_stmt|;
name|int
name|block
init|=
name|metaBlockIndexReader
operator|.
name|rootBlockContainingKey
argument_list|(
name|mbname
argument_list|,
literal|0
argument_list|,
name|mbname
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|==
operator|-
literal|1
condition|)
return|return
literal|null
return|;
name|long
name|blockSize
init|=
name|metaBlockIndexReader
operator|.
name|getRootBlockDataSize
argument_list|(
name|block
argument_list|)
decl_stmt|;
comment|// Per meta key from any given file, synchronize reads for said block. This
comment|// is OK to do for meta blocks because the meta block index is always
comment|// single-level.
synchronized|synchronized
init|(
name|metaBlockIndexReader
operator|.
name|getRootBlockKey
argument_list|(
name|block
argument_list|)
init|)
block|{
comment|// Check cache for block. If found return.
name|long
name|metaBlockOffset
init|=
name|metaBlockIndexReader
operator|.
name|getRootBlockOffset
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|BlockCacheKey
name|cacheKey
init|=
operator|new
name|BlockCacheKey
argument_list|(
name|name
argument_list|,
name|metaBlockOffset
argument_list|,
name|this
operator|.
name|isPrimaryReplicaReader
argument_list|()
argument_list|,
name|BlockType
operator|.
name|META
argument_list|)
decl_stmt|;
name|cacheBlock
operator|&=
name|cacheConf
operator|.
name|shouldCacheBlockOnRead
argument_list|(
name|BlockType
operator|.
name|META
operator|.
name|getCategory
argument_list|()
argument_list|)
expr_stmt|;
name|HFileBlock
name|cachedBlock
init|=
name|getCachedBlock
argument_list|(
name|cacheKey
argument_list|,
name|cacheBlock
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|BlockType
operator|.
name|META
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBlock
operator|!=
literal|null
condition|)
block|{
assert|assert
name|cachedBlock
operator|.
name|isUnpacked
argument_list|()
operator|:
literal|"Packed block leak."
assert|;
comment|// Return a distinct 'shallow copy' of the block,
comment|// so pos does not get messed by the scanner
return|return
name|cachedBlock
return|;
block|}
comment|// Cache Miss, please load.
name|HFileBlock
name|compressedBlock
init|=
name|fsBlockReader
operator|.
name|readBlockData
argument_list|(
name|metaBlockOffset
argument_list|,
name|blockSize
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|HFileBlock
name|uncompressedBlock
init|=
name|compressedBlock
operator|.
name|unpack
argument_list|(
name|hfileContext
argument_list|,
name|fsBlockReader
argument_list|)
decl_stmt|;
if|if
condition|(
name|compressedBlock
operator|!=
name|uncompressedBlock
condition|)
block|{
name|compressedBlock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|// Cache the block
if|if
condition|(
name|cacheBlock
condition|)
block|{
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|ifPresent
argument_list|(
name|cache
lambda|->
name|cache
operator|.
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|uncompressedBlock
argument_list|,
name|cacheConf
operator|.
name|isInMemory
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|uncompressedBlock
return|;
block|}
block|}
comment|/**    * If expected block is data block, we'll allocate the ByteBuff of block from    * {@link org.apache.hadoop.hbase.io.ByteBuffAllocator} and it's usually an off-heap one,    * otherwise it will allocate from heap.    * @see org.apache.hadoop.hbase.io.hfile.HFileBlock.FSReader#readBlockData(long, long, boolean,    *      boolean, boolean)    */
specifier|private
name|boolean
name|shouldUseHeap
parameter_list|(
name|BlockType
name|expectedBlockType
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cacheConf
operator|.
name|isCombinedBlockCache
argument_list|()
condition|)
block|{
comment|// Block to cache in LruBlockCache must be an heap one. So just allocate block memory from
comment|// heap for saving an extra off-heap to heap copying.
return|return
literal|true
return|;
block|}
return|return
name|expectedBlockType
operator|!=
literal|null
operator|&&
operator|!
name|expectedBlockType
operator|.
name|isData
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|HFileBlock
name|readBlock
parameter_list|(
name|long
name|dataBlockOffset
parameter_list|,
name|long
name|onDiskBlockSize
parameter_list|,
specifier|final
name|boolean
name|cacheBlock
parameter_list|,
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|,
name|boolean
name|updateCacheMetrics
parameter_list|,
name|BlockType
name|expectedBlockType
parameter_list|,
name|DataBlockEncoding
name|expectedDataBlockEncoding
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dataBlockIndexReader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|path
operator|+
literal|" block index not loaded"
argument_list|)
throw|;
block|}
name|long
name|trailerOffset
init|=
name|trailer
operator|.
name|getLoadOnOpenDataOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataBlockOffset
operator|<
literal|0
operator|||
name|dataBlockOffset
operator|>=
name|trailerOffset
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Requested block is out of range: "
operator|+
name|dataBlockOffset
operator|+
literal|", lastDataBlockOffset: "
operator|+
name|trailer
operator|.
name|getLastDataBlockOffset
argument_list|()
operator|+
literal|", trailer.getLoadOnOpenDataOffset: "
operator|+
name|trailerOffset
operator|+
literal|", path="
operator|+
name|path
argument_list|)
throw|;
block|}
comment|// For any given block from any given file, synchronize reads for said
comment|// block.
comment|// Without a cache, this synchronizing is needless overhead, but really
comment|// the other choice is to duplicate work (which the cache would prevent you
comment|// from doing).
name|BlockCacheKey
name|cacheKey
init|=
operator|new
name|BlockCacheKey
argument_list|(
name|name
argument_list|,
name|dataBlockOffset
argument_list|,
name|this
operator|.
name|isPrimaryReplicaReader
argument_list|()
argument_list|,
name|expectedBlockType
argument_list|)
decl_stmt|;
name|boolean
name|useLock
init|=
literal|false
decl_stmt|;
name|IdLock
operator|.
name|Entry
name|lockEntry
init|=
literal|null
decl_stmt|;
try|try
init|(
name|TraceScope
name|traceScope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"HFileReaderImpl.readBlock"
argument_list|)
init|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|// Check cache for block. If found return.
if|if
condition|(
name|cacheConf
operator|.
name|shouldReadBlockFromCache
argument_list|(
name|expectedBlockType
argument_list|)
condition|)
block|{
if|if
condition|(
name|useLock
condition|)
block|{
name|lockEntry
operator|=
name|offsetLock
operator|.
name|getLockEntry
argument_list|(
name|dataBlockOffset
argument_list|)
expr_stmt|;
block|}
comment|// Try and get the block from the block cache. If the useLock variable is true then this
comment|// is the second time through the loop and it should not be counted as a block cache miss.
name|HFileBlock
name|cachedBlock
init|=
name|getCachedBlock
argument_list|(
name|cacheKey
argument_list|,
name|cacheBlock
argument_list|,
name|useLock
argument_list|,
name|isCompaction
argument_list|,
name|updateCacheMetrics
argument_list|,
name|expectedBlockType
argument_list|,
name|expectedDataBlockEncoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBlock
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"From Cache "
operator|+
name|cachedBlock
argument_list|)
expr_stmt|;
block|}
name|TraceUtil
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"blockCacheHit"
argument_list|)
expr_stmt|;
assert|assert
name|cachedBlock
operator|.
name|isUnpacked
argument_list|()
operator|:
literal|"Packed block leak."
assert|;
if|if
condition|(
name|cachedBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|isData
argument_list|()
condition|)
block|{
if|if
condition|(
name|updateCacheMetrics
condition|)
block|{
name|HFile
operator|.
name|DATABLOCK_READ_COUNT
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
comment|// Validate encoding type for data blocks. We include encoding
comment|// type in the cache key, and we expect it to match on a cache hit.
if|if
condition|(
name|cachedBlock
operator|.
name|getDataBlockEncoding
argument_list|()
operator|!=
name|dataBlockEncoder
operator|.
name|getDataBlockEncoding
argument_list|()
condition|)
block|{
comment|// Remember to release the block when in exceptional path.
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|ifPresent
argument_list|(
name|cache
lambda|->
block|{
name|returnAndEvictBlock
argument_list|(
name|cache
argument_list|,
name|cacheKey
argument_list|,
name|cachedBlock
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cached block under key "
operator|+
name|cacheKey
operator|+
literal|" "
operator|+
literal|"has wrong encoding: "
operator|+
name|cachedBlock
operator|.
name|getDataBlockEncoding
argument_list|()
operator|+
literal|" (expected: "
operator|+
name|dataBlockEncoder
operator|.
name|getDataBlockEncoding
argument_list|()
operator|+
literal|"), path="
operator|+
name|path
argument_list|)
throw|;
block|}
block|}
comment|// Cache-hit. Return!
return|return
name|cachedBlock
return|;
block|}
if|if
condition|(
operator|!
name|useLock
operator|&&
name|cacheBlock
operator|&&
name|cacheConf
operator|.
name|shouldLockOnCacheMiss
argument_list|(
name|expectedBlockType
argument_list|)
condition|)
block|{
comment|// check cache again with lock
name|useLock
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
comment|// Carry on, please load.
block|}
name|TraceUtil
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"blockCacheMiss"
argument_list|)
expr_stmt|;
comment|// Load block from filesystem.
name|HFileBlock
name|hfileBlock
init|=
name|fsBlockReader
operator|.
name|readBlockData
argument_list|(
name|dataBlockOffset
argument_list|,
name|onDiskBlockSize
argument_list|,
name|pread
argument_list|,
operator|!
name|isCompaction
argument_list|,
name|shouldUseHeap
argument_list|(
name|expectedBlockType
argument_list|)
argument_list|)
decl_stmt|;
name|validateBlockType
argument_list|(
name|hfileBlock
argument_list|,
name|expectedBlockType
argument_list|)
expr_stmt|;
name|HFileBlock
name|unpacked
init|=
name|hfileBlock
operator|.
name|unpack
argument_list|(
name|hfileContext
argument_list|,
name|fsBlockReader
argument_list|)
decl_stmt|;
name|BlockType
operator|.
name|BlockCategory
name|category
init|=
name|hfileBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|getCategory
argument_list|()
decl_stmt|;
comment|// Cache the block if necessary
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|ifPresent
argument_list|(
name|cache
lambda|->
block|{
if|if
condition|(
name|cacheBlock
operator|&&
name|cacheConf
operator|.
name|shouldCacheBlockOnRead
argument_list|(
name|category
argument_list|)
condition|)
block|{
name|cache
operator|.
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|cacheConf
operator|.
name|shouldCacheCompressed
argument_list|(
name|category
argument_list|)
condition|?
name|hfileBlock
else|:
name|unpacked
argument_list|,
name|cacheConf
operator|.
name|isInMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpacked
operator|!=
name|hfileBlock
condition|)
block|{
comment|// End of life here if hfileBlock is an independent block.
name|hfileBlock
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|updateCacheMetrics
operator|&&
name|hfileBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|isData
argument_list|()
condition|)
block|{
name|HFile
operator|.
name|DATABLOCK_READ_COUNT
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
return|return
name|unpacked
return|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|lockEntry
operator|!=
literal|null
condition|)
block|{
name|offsetLock
operator|.
name|releaseLockEntry
argument_list|(
name|lockEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasMVCCInfo
parameter_list|()
block|{
return|return
name|fileInfo
operator|.
name|shouldIncludeMemStoreTS
argument_list|()
operator|&&
name|fileInfo
operator|.
name|isDecodeMemstoreTS
argument_list|()
return|;
block|}
comment|/**    * Compares the actual type of a block retrieved from cache or disk with its    * expected type and throws an exception in case of a mismatch. Expected    * block type of {@link BlockType#DATA} is considered to match the actual    * block type [@link {@link BlockType#ENCODED_DATA} as well.    * @param block a block retrieved from cache or disk    * @param expectedBlockType the expected block type, or null to skip the    *          check    */
specifier|private
name|void
name|validateBlockType
parameter_list|(
name|HFileBlock
name|block
parameter_list|,
name|BlockType
name|expectedBlockType
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|expectedBlockType
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|BlockType
name|actualBlockType
init|=
name|block
operator|.
name|getBlockType
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectedBlockType
operator|.
name|isData
argument_list|()
operator|&&
name|actualBlockType
operator|.
name|isData
argument_list|()
condition|)
block|{
comment|// We consider DATA to match ENCODED_DATA for the purpose of this
comment|// verification.
return|return;
block|}
if|if
condition|(
name|actualBlockType
operator|!=
name|expectedBlockType
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected block type "
operator|+
name|expectedBlockType
operator|+
literal|", "
operator|+
literal|"but got "
operator|+
name|actualBlockType
operator|+
literal|": "
operator|+
name|block
operator|+
literal|", path="
operator|+
name|path
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return Last key as cell in the file. May be null if file has no entries. Note that    *         this is not the last row key, but it is the Cell representation of the last    *         key    */
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|Cell
argument_list|>
name|getLastKey
parameter_list|()
block|{
return|return
name|dataBlockIndexReader
operator|.
name|isEmpty
argument_list|()
condition|?
name|Optional
operator|.
name|empty
argument_list|()
else|:
name|Optional
operator|.
name|of
argument_list|(
name|fileInfo
operator|.
name|getLastKeyCell
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return Midkey for this file. We work with block boundaries only so    *         returned midkey is an approximation only.    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|Cell
argument_list|>
name|midKey
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Optional
operator|.
name|ofNullable
argument_list|(
name|dataBlockIndexReader
operator|.
name|midkey
argument_list|(
name|this
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|close
argument_list|(
name|cacheConf
operator|.
name|shouldEvictOnClose
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|DataBlockEncoding
name|getEffectiveEncodingInCache
parameter_list|(
name|boolean
name|isCompaction
parameter_list|)
block|{
return|return
name|dataBlockEncoder
operator|.
name|getEffectiveEncodingInCache
argument_list|(
name|isCompaction
argument_list|)
return|;
block|}
comment|/** For testing */
annotation|@
name|Override
specifier|public
name|HFileBlock
operator|.
name|FSReader
name|getUncachedBlockReader
parameter_list|()
block|{
return|return
name|fsBlockReader
return|;
block|}
comment|/**    * Scanner that operates on encoded data blocks.    */
specifier|protected
specifier|static
class|class
name|EncodedScanner
extends|extends
name|HFileScannerImpl
block|{
specifier|private
specifier|final
name|HFileBlockDecodingContext
name|decodingCtx
decl_stmt|;
specifier|private
specifier|final
name|DataBlockEncoder
operator|.
name|EncodedSeeker
name|seeker
decl_stmt|;
specifier|private
specifier|final
name|DataBlockEncoder
name|dataBlockEncoder
decl_stmt|;
specifier|public
name|EncodedScanner
parameter_list|(
name|HFile
operator|.
name|Reader
name|reader
parameter_list|,
name|boolean
name|cacheBlocks
parameter_list|,
name|boolean
name|pread
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|HFileContext
name|meta
parameter_list|)
block|{
name|super
argument_list|(
name|reader
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
name|DataBlockEncoding
name|encoding
init|=
name|reader
operator|.
name|getDataBlockEncoding
argument_list|()
decl_stmt|;
name|dataBlockEncoder
operator|=
name|encoding
operator|.
name|getEncoder
argument_list|()
expr_stmt|;
name|decodingCtx
operator|=
name|dataBlockEncoder
operator|.
name|newDataBlockDecodingContext
argument_list|(
name|meta
argument_list|)
expr_stmt|;
name|seeker
operator|=
name|dataBlockEncoder
operator|.
name|createSeeker
argument_list|(
name|reader
operator|.
name|getComparator
argument_list|()
argument_list|,
name|decodingCtx
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isSeeked
parameter_list|()
block|{
return|return
name|curBlock
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNonSeekedState
parameter_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
comment|/**      * Updates the current block to be the given {@link HFileBlock}. Seeks to the the first      * key/value pair.      * @param newBlock the block to make current, and read by {@link HFileReaderImpl#readBlock},      *          it's a totally new block with new allocated {@link ByteBuff}, so if no further      *          reference to this block, we should release it carefully.      * @throws CorruptHFileException      */
annotation|@
name|Override
specifier|protected
name|void
name|updateCurrentBlock
parameter_list|(
name|HFileBlock
name|newBlock
parameter_list|)
throws|throws
name|CorruptHFileException
block|{
try|try
block|{
comment|// sanity checks
if|if
condition|(
name|newBlock
operator|.
name|getBlockType
argument_list|()
operator|!=
name|BlockType
operator|.
name|ENCODED_DATA
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"EncodedScanner works only on encoded data blocks"
argument_list|)
throw|;
block|}
name|short
name|dataBlockEncoderId
init|=
name|newBlock
operator|.
name|getDataBlockEncodingId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|DataBlockEncoding
operator|.
name|isCorrectEncoder
argument_list|(
name|dataBlockEncoder
argument_list|,
name|dataBlockEncoderId
argument_list|)
condition|)
block|{
name|String
name|encoderCls
init|=
name|dataBlockEncoder
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|CorruptHFileException
argument_list|(
literal|"Encoder "
operator|+
name|encoderCls
operator|+
literal|" doesn't support data block encoding "
operator|+
name|DataBlockEncoding
operator|.
name|getNameFromId
argument_list|(
name|dataBlockEncoderId
argument_list|)
operator|+
literal|",path="
operator|+
name|reader
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
name|updateCurrBlockRef
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
name|ByteBuff
name|encodedBuffer
init|=
name|getEncodedBuffer
argument_list|(
name|newBlock
argument_list|)
decl_stmt|;
name|seeker
operator|.
name|setCurrentBuffer
argument_list|(
name|encodedBuffer
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|releaseIfNotCurBlock
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
block|}
comment|// Reset the next indexed key
name|this
operator|.
name|nextIndexedKey
operator|=
literal|null
expr_stmt|;
block|}
specifier|private
name|ByteBuff
name|getEncodedBuffer
parameter_list|(
name|HFileBlock
name|newBlock
parameter_list|)
block|{
name|ByteBuff
name|origBlock
init|=
name|newBlock
operator|.
name|getBufferReadOnly
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|newBlock
operator|.
name|headerSize
argument_list|()
operator|+
name|DataBlockEncoding
operator|.
name|ID_SIZE
decl_stmt|;
name|origBlock
operator|.
name|position
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|origBlock
operator|.
name|limit
argument_list|(
name|pos
operator|+
name|newBlock
operator|.
name|getUncompressedSizeWithoutHeader
argument_list|()
operator|-
name|DataBlockEncoding
operator|.
name|ID_SIZE
argument_list|)
expr_stmt|;
return|return
name|origBlock
operator|.
name|slice
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|processFirstDataBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|seeker
operator|.
name|rewind
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|isValid
init|=
name|seeker
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isValid
condition|)
block|{
name|HFileBlock
name|newBlock
init|=
name|readNextDataBlock
argument_list|()
decl_stmt|;
name|isValid
operator|=
name|newBlock
operator|!=
literal|null
expr_stmt|;
if|if
condition|(
name|isValid
condition|)
block|{
name|updateCurrentBlock
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setNonSeekedState
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|isValid
return|;
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|getKey
parameter_list|()
block|{
name|assertValidSeek
argument_list|()
expr_stmt|;
return|return
name|seeker
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getValue
parameter_list|()
block|{
name|assertValidSeek
argument_list|()
expr_stmt|;
return|return
name|seeker
operator|.
name|getValueShallowCopy
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|getCell
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|curBlock
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|seeker
operator|.
name|getCell
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getKeyString
parameter_list|()
block|{
return|return
name|CellUtil
operator|.
name|toString
argument_list|(
name|getKey
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getValueString
parameter_list|()
block|{
name|ByteBuffer
name|valueBuffer
init|=
name|getValue
argument_list|()
decl_stmt|;
return|return
name|ByteBufferUtils
operator|.
name|toStringBinary
argument_list|(
name|valueBuffer
argument_list|)
return|;
block|}
specifier|private
name|void
name|assertValidSeek
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|curBlock
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NotSeekedException
argument_list|(
name|reader
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|Cell
name|getFirstKeyCellInBlock
parameter_list|(
name|HFileBlock
name|curBlock
parameter_list|)
block|{
return|return
name|dataBlockEncoder
operator|.
name|getFirstKeyCellInBlock
argument_list|(
name|getEncodedBuffer
argument_list|(
name|curBlock
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|loadBlockAndSeekToKey
parameter_list|(
name|HFileBlock
name|seekToBlock
parameter_list|,
name|Cell
name|nextIndexedKey
parameter_list|,
name|boolean
name|rewind
parameter_list|,
name|Cell
name|key
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|curBlock
operator|==
literal|null
operator|||
name|this
operator|.
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|!=
name|seekToBlock
operator|.
name|getOffset
argument_list|()
condition|)
block|{
name|updateCurrentBlock
argument_list|(
name|seekToBlock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rewind
condition|)
block|{
name|seeker
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|nextIndexedKey
operator|=
name|nextIndexedKey
expr_stmt|;
return|return
name|seeker
operator|.
name|seekToKeyInBlock
argument_list|(
name|key
argument_list|,
name|seekBefore
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareKey
parameter_list|(
name|CellComparator
name|comparator
parameter_list|,
name|Cell
name|key
parameter_list|)
block|{
return|return
name|seeker
operator|.
name|compareKey
argument_list|(
name|comparator
argument_list|,
name|key
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a buffer with the Bloom filter metadata. The caller takes    * ownership of the buffer.    */
annotation|@
name|Override
specifier|public
name|DataInput
name|getGeneralBloomFilterMetadata
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|getBloomFilterMetadata
argument_list|(
name|BlockType
operator|.
name|GENERAL_BLOOM_META
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|DataInput
name|getDeleteBloomFilterMetadata
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|getBloomFilterMetadata
argument_list|(
name|BlockType
operator|.
name|DELETE_FAMILY_BLOOM_META
argument_list|)
return|;
block|}
specifier|private
name|DataInput
name|getBloomFilterMetadata
parameter_list|(
name|BlockType
name|blockType
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blockType
operator|!=
name|BlockType
operator|.
name|GENERAL_BLOOM_META
operator|&&
name|blockType
operator|!=
name|BlockType
operator|.
name|DELETE_FAMILY_BLOOM_META
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Block Type: "
operator|+
name|blockType
operator|.
name|toString
argument_list|()
operator|+
literal|" is not supported, path="
operator|+
name|path
argument_list|)
throw|;
block|}
for|for
control|(
name|HFileBlock
name|b
range|:
name|fileInfo
operator|.
name|getLoadOnOpenBlocks
argument_list|()
control|)
block|{
if|if
condition|(
name|b
operator|.
name|getBlockType
argument_list|()
operator|==
name|blockType
condition|)
block|{
return|return
name|b
operator|.
name|getByteStream
argument_list|()
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|boolean
name|isFileInfoLoaded
parameter_list|()
block|{
return|return
literal|true
return|;
comment|// We load file info in constructor in version 2.
block|}
annotation|@
name|Override
specifier|public
name|HFileContext
name|getFileContext
parameter_list|()
block|{
return|return
name|hfileContext
return|;
block|}
comment|/**    * Returns false if block prefetching was requested for this file and has    * not completed, true otherwise    */
annotation|@
name|Override
annotation|@
name|VisibleForTesting
specifier|public
name|boolean
name|prefetchComplete
parameter_list|()
block|{
return|return
name|PrefetchExecutor
operator|.
name|isCompleted
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/**    * Create a Scanner on this file. No seeks or reads are done on creation. Call    * {@link HFileScanner#seekTo(Cell)} to position an start the read. There is    * nothing to clean up in a Scanner. Letting go of your references to the    * scanner is sufficient. NOTE: Do not use this overload of getScanner for    * compactions. See {@link #getScanner(boolean, boolean, boolean)}    *    * @param cacheBlocks True if we should cache blocks read in by this scanner.    * @param pread Use positional read rather than seek+read if true (pread is    *          better for random reads, seek+read is better scanning).    * @return Scanner on this file.    */
annotation|@
name|Override
annotation|@
name|VisibleForTesting
specifier|public
name|HFileScanner
name|getScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|)
block|{
return|return
name|getScanner
argument_list|(
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Create a Scanner on this file. No seeks or reads are done on creation. Call    * {@link HFileScanner#seekTo(Cell)} to position an start the read. There is    * nothing to clean up in a Scanner. Letting go of your references to the    * scanner is sufficient.    * @param cacheBlocks    *          True if we should cache blocks read in by this scanner.    * @param pread    *          Use positional read rather than seek+read if true (pread is better    *          for random reads, seek+read is better scanning).    * @param isCompaction    *          is scanner being used for a compaction?    * @return Scanner on this file.    */
annotation|@
name|Override
specifier|public
name|HFileScanner
name|getScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
block|{
if|if
condition|(
name|dataBlockEncoder
operator|.
name|useEncodedScanner
argument_list|()
condition|)
block|{
return|return
operator|new
name|EncodedScanner
argument_list|(
name|this
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
name|this
operator|.
name|hfileContext
argument_list|)
return|;
block|}
return|return
operator|new
name|HFileScannerImpl
argument_list|(
name|this
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
return|;
block|}
specifier|public
name|int
name|getMajorVersion
parameter_list|()
block|{
return|return
literal|3
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|unbufferStream
parameter_list|()
block|{
name|fsBlockReader
operator|.
name|unbufferStream
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

