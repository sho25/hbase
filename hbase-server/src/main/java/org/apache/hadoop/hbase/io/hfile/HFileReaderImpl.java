begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Key
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configurable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ByteBufferKeyOnlyKeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|PrivateCellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ByteBufferKeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|SizeCachedKeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|SizeCachedNoTagsKeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|trace
operator|.
name|TraceUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|fs
operator|.
name|HFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|FSDataInputStreamWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|compress
operator|.
name|Compression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|crypto
operator|.
name|Cipher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|crypto
operator|.
name|Encryption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|HFileBlockDecodingContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
operator|.
name|FileInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|ByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|KeyValueScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|EncryptionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|IdLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ObjectIntPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Implementation that can handle all hfile versions of {@link HFile.Reader}.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"
argument_list|)
specifier|public
class|class
name|HFileReaderImpl
implements|implements
name|HFile
operator|.
name|Reader
implements|,
name|Configurable
block|{
comment|// This class is HFileReaderV3 + HFileReaderV2 + AbstractHFileReader all squashed together into
comment|// one file.  Ditto for all the HFileReader.ScannerV? implementations. I was running up against
comment|// the MaxInlineLevel limit because too many tiers involved reading from an hfile. Was also hard
comment|// to navigate the source code when so many classes participating in read.
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HFileReaderImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Data block index reader keeping the root data index in memory */
specifier|private
name|HFileBlockIndex
operator|.
name|CellBasedKeyBlockIndexReader
name|dataBlockIndexReader
decl_stmt|;
comment|/** Meta block index reader -- always single level */
specifier|private
name|HFileBlockIndex
operator|.
name|ByteArrayKeyBlockIndexReader
name|metaBlockIndexReader
decl_stmt|;
specifier|private
specifier|final
name|FixedFileTrailer
name|trailer
decl_stmt|;
comment|/** Filled when we read in the trailer. */
specifier|private
specifier|final
name|Compression
operator|.
name|Algorithm
name|compressAlgo
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|primaryReplicaReader
decl_stmt|;
comment|/**    * What kind of data block encoding should be used while reading, writing,    * and handling cache.    */
specifier|private
name|HFileDataBlockEncoder
name|dataBlockEncoder
init|=
name|NoOpDataBlockEncoder
operator|.
name|INSTANCE
decl_stmt|;
comment|/** Last key in the file. Filled in when we read in the file info */
specifier|private
name|Cell
name|lastKeyCell
init|=
literal|null
decl_stmt|;
comment|/** Average key length read from file info */
specifier|private
name|int
name|avgKeyLen
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Average value length read from file info */
specifier|private
name|int
name|avgValueLen
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Key comparator */
specifier|private
name|CellComparator
name|comparator
init|=
name|CellComparator
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|/** Size of this file. */
specifier|private
specifier|final
name|long
name|fileSize
decl_stmt|;
comment|/** Block cache configuration. */
specifier|private
specifier|final
name|CacheConfig
name|cacheConf
decl_stmt|;
comment|/** Path of file */
specifier|private
specifier|final
name|Path
name|path
decl_stmt|;
comment|/** File name to be used for block names */
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
name|FileInfo
name|fileInfo
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|HFileContext
name|hfileContext
decl_stmt|;
comment|/** Filesystem-level block reader. */
specifier|private
name|HFileBlock
operator|.
name|FSReader
name|fsBlockReader
decl_stmt|;
comment|/**    * A "sparse lock" implementation allowing to lock on a particular block    * identified by offset. The purpose of this is to avoid two clients loading    * the same block, and have all but one client wait to get the block from the    * cache.    */
specifier|private
name|IdLock
name|offsetLock
init|=
operator|new
name|IdLock
argument_list|()
decl_stmt|;
comment|/**    * Blocks read from the load-on-open section, excluding data root index, meta    * index, and file info.    */
specifier|private
name|List
argument_list|<
name|HFileBlock
argument_list|>
name|loadOnOpenBlocks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Minimum minor version supported by this HFile format */
specifier|static
specifier|final
name|int
name|MIN_MINOR_VERSION
init|=
literal|0
decl_stmt|;
comment|/** Maximum minor version supported by this HFile format */
comment|// We went to version 2 when we moved to pb'ing fileinfo and the trailer on
comment|// the file. This version can read Writables version 1.
specifier|static
specifier|final
name|int
name|MAX_MINOR_VERSION
init|=
literal|3
decl_stmt|;
comment|/**    * We can read files whose major version is v2 IFF their minor version is at least 3.    */
specifier|private
specifier|static
specifier|final
name|int
name|MIN_V2_MINOR_VERSION_WITH_PB
init|=
literal|3
decl_stmt|;
comment|/** Minor versions starting with this number have faked index key */
specifier|static
specifier|final
name|int
name|MINOR_VERSION_WITH_FAKED_KEY
init|=
literal|3
decl_stmt|;
annotation|@
name|VisibleForTesting
annotation|@
name|Deprecated
specifier|public
name|HFileReaderImpl
parameter_list|(
name|Path
name|path
parameter_list|,
name|FixedFileTrailer
name|trailer
parameter_list|,
name|FSDataInputStreamWrapper
name|fsdis
parameter_list|,
name|long
name|fileSize
parameter_list|,
name|CacheConfig
name|cacheConf
parameter_list|,
name|HFileSystem
name|hfs
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|path
argument_list|,
name|trailer
argument_list|,
name|fsdis
argument_list|,
name|fileSize
argument_list|,
name|cacheConf
argument_list|,
name|hfs
argument_list|,
literal|true
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Opens a HFile. You must load the index before you can use it by calling    * {@link #loadFileInfo()}.    * @param path    *          Path to HFile.    * @param trailer    *          File trailer.    * @param fsdis    *          input stream.    * @param fileSize    *          Length of the stream.    * @param cacheConf    *          Cache configuration.    * @param hfs    *          The file system.    * @param conf    *          Configuration    */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"
argument_list|)
specifier|public
name|HFileReaderImpl
parameter_list|(
name|Path
name|path
parameter_list|,
name|FixedFileTrailer
name|trailer
parameter_list|,
name|FSDataInputStreamWrapper
name|fsdis
parameter_list|,
name|long
name|fileSize
parameter_list|,
name|CacheConfig
name|cacheConf
parameter_list|,
name|HFileSystem
name|hfs
parameter_list|,
name|boolean
name|primaryReplicaReader
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|trailer
operator|=
name|trailer
expr_stmt|;
name|this
operator|.
name|compressAlgo
operator|=
name|trailer
operator|.
name|getCompressionCodec
argument_list|()
expr_stmt|;
name|this
operator|.
name|cacheConf
operator|=
name|cacheConf
expr_stmt|;
name|this
operator|.
name|fileSize
operator|=
name|fileSize
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|path
operator|.
name|getName
argument_list|()
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|primaryReplicaReader
operator|=
name|primaryReplicaReader
expr_stmt|;
name|checkFileVersion
argument_list|()
expr_stmt|;
name|this
operator|.
name|hfileContext
operator|=
name|createHFileContext
argument_list|(
name|fsdis
argument_list|,
name|fileSize
argument_list|,
name|hfs
argument_list|,
name|path
argument_list|,
name|trailer
argument_list|)
expr_stmt|;
name|this
operator|.
name|fsBlockReader
operator|=
operator|new
name|HFileBlock
operator|.
name|FSReaderImpl
argument_list|(
name|fsdis
argument_list|,
name|fileSize
argument_list|,
name|hfs
argument_list|,
name|path
argument_list|,
name|hfileContext
argument_list|)
expr_stmt|;
comment|// Comparator class name is stored in the trailer in version 2.
name|comparator
operator|=
name|trailer
operator|.
name|createComparator
argument_list|()
expr_stmt|;
name|dataBlockIndexReader
operator|=
operator|new
name|HFileBlockIndex
operator|.
name|CellBasedKeyBlockIndexReader
argument_list|(
name|comparator
argument_list|,
name|trailer
operator|.
name|getNumDataIndexLevels
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|metaBlockIndexReader
operator|=
operator|new
name|HFileBlockIndex
operator|.
name|ByteArrayKeyBlockIndexReader
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Parse load-on-open data.
name|HFileBlock
operator|.
name|BlockIterator
name|blockIter
init|=
name|fsBlockReader
operator|.
name|blockRange
argument_list|(
name|trailer
operator|.
name|getLoadOnOpenDataOffset
argument_list|()
argument_list|,
name|fileSize
operator|-
name|trailer
operator|.
name|getTrailerSize
argument_list|()
argument_list|)
decl_stmt|;
comment|// Data index. We also read statistics about the block index written after
comment|// the root level.
name|dataBlockIndexReader
operator|.
name|readMultiLevelIndexRoot
argument_list|(
name|blockIter
operator|.
name|nextBlockWithBlockType
argument_list|(
name|BlockType
operator|.
name|ROOT_INDEX
argument_list|)
argument_list|,
name|trailer
operator|.
name|getDataIndexCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// Meta index.
name|metaBlockIndexReader
operator|.
name|readRootIndex
argument_list|(
name|blockIter
operator|.
name|nextBlockWithBlockType
argument_list|(
name|BlockType
operator|.
name|ROOT_INDEX
argument_list|)
argument_list|,
name|trailer
operator|.
name|getMetaIndexCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// File info
name|fileInfo
operator|=
operator|new
name|FileInfo
argument_list|()
expr_stmt|;
name|fileInfo
operator|.
name|read
argument_list|(
name|blockIter
operator|.
name|nextBlockWithBlockType
argument_list|(
name|BlockType
operator|.
name|FILE_INFO
argument_list|)
operator|.
name|getByteStream
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|creationTimeBytes
init|=
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|CREATE_TIME_TS
argument_list|)
decl_stmt|;
name|this
operator|.
name|hfileContext
operator|.
name|setFileCreateTime
argument_list|(
name|creationTimeBytes
operator|==
literal|null
condition|?
literal|0
else|:
name|Bytes
operator|.
name|toLong
argument_list|(
name|creationTimeBytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|LASTKEY
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|lastKeyCell
operator|=
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|LASTKEY
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|avgKeyLen
operator|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|AVG_KEY_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|avgValueLen
operator|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|AVG_VALUE_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|keyValueFormatVersion
init|=
name|fileInfo
operator|.
name|get
argument_list|(
name|HFileWriterImpl
operator|.
name|KEY_VALUE_VERSION
argument_list|)
decl_stmt|;
name|includesMemstoreTS
operator|=
name|keyValueFormatVersion
operator|!=
literal|null
operator|&&
name|Bytes
operator|.
name|toInt
argument_list|(
name|keyValueFormatVersion
argument_list|)
operator|==
name|HFileWriterImpl
operator|.
name|KEY_VALUE_VER_WITH_MEMSTORE
expr_stmt|;
name|fsBlockReader
operator|.
name|setIncludesMemStoreTS
argument_list|(
name|includesMemstoreTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|includesMemstoreTS
condition|)
block|{
name|decodeMemstoreTS
operator|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|fileInfo
operator|.
name|get
argument_list|(
name|HFileWriterImpl
operator|.
name|MAX_MEMSTORE_TS_KEY
argument_list|)
argument_list|)
operator|>
literal|0
expr_stmt|;
block|}
comment|// Read data block encoding algorithm name from file info.
name|dataBlockEncoder
operator|=
name|HFileDataBlockEncoderImpl
operator|.
name|createFromFileInfo
argument_list|(
name|fileInfo
argument_list|)
expr_stmt|;
name|fsBlockReader
operator|.
name|setDataBlockEncoder
argument_list|(
name|dataBlockEncoder
argument_list|)
expr_stmt|;
comment|// Store all other load-on-open blocks for further consumption.
name|HFileBlock
name|b
decl_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
name|blockIter
operator|.
name|nextBlock
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|loadOnOpenBlocks
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|// Prefetch file blocks upon open if requested
if|if
condition|(
name|cacheConf
operator|.
name|shouldPrefetchOnOpen
argument_list|()
condition|)
block|{
name|PrefetchExecutor
operator|.
name|request
argument_list|(
name|path
argument_list|,
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|long
name|end
init|=
literal|0
decl_stmt|;
try|try
block|{
name|end
operator|=
name|getTrailer
argument_list|()
operator|.
name|getLoadOnOpenDataOffset
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Prefetch start "
operator|+
name|getPathOffsetEndStr
argument_list|(
name|path
argument_list|,
name|offset
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// TODO: Could we use block iterator in here? Would that get stuff into the cache?
name|HFileBlock
name|prevBlock
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
break|break;
block|}
comment|// Perhaps we got our block from cache? Unlikely as this may be, if it happens, then
comment|// the internal-to-hfileblock thread local which holds the overread that gets the
comment|// next header, will not have happened...so, pass in the onDiskSize gotten from the
comment|// cached block. This 'optimization' triggers extremely rarely I'd say.
name|long
name|onDiskSize
init|=
name|prevBlock
operator|!=
literal|null
condition|?
name|prevBlock
operator|.
name|getNextBlockOnDiskSize
argument_list|()
else|:
operator|-
literal|1
decl_stmt|;
name|HFileBlock
name|block
init|=
name|readBlock
argument_list|(
name|offset
argument_list|,
name|onDiskSize
argument_list|,
comment|/*cacheBlock=*/
literal|true
argument_list|,
comment|/*pread=*/
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Need not update the current block. Ideally here the readBlock won't find the
comment|// block in cache. We call this readBlock so that block data is read from FS and
comment|// cached in BC. So there is no reference count increment that happens here.
comment|// The return will ideally be a noop because the block is not of MemoryType SHARED.
name|returnBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|prevBlock
operator|=
name|block
expr_stmt|;
name|offset
operator|+=
name|block
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// IOExceptions are probably due to region closes (relocation, etc.)
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Prefetch "
operator|+
name|getPathOffsetEndStr
argument_list|(
name|path
argument_list|,
name|offset
argument_list|,
name|end
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Stream moved/closed or prefetch cancelled?"
operator|+
name|getPathOffsetEndStr
argument_list|(
name|path
argument_list|,
name|offset
argument_list|,
name|end
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Other exceptions are interesting
name|LOG
operator|.
name|warn
argument_list|(
literal|"Prefetch "
operator|+
name|getPathOffsetEndStr
argument_list|(
name|path
argument_list|,
name|offset
argument_list|,
name|end
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|PrefetchExecutor
operator|.
name|complete
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|tmp
init|=
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|MAX_TAGS_LEN
argument_list|)
decl_stmt|;
comment|// max tag length is not present in the HFile means tags were not at all written to file.
if|if
condition|(
name|tmp
operator|!=
literal|null
condition|)
block|{
name|hfileContext
operator|.
name|setIncludesTags
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|TAGS_COMPRESSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|null
operator|&&
name|Bytes
operator|.
name|toBoolean
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|hfileContext
operator|.
name|setCompressTags
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|String
name|getPathOffsetEndStr
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|long
name|end
parameter_list|)
block|{
return|return
literal|"path="
operator|+
name|path
operator|.
name|toString
argument_list|()
operator|+
literal|", offset="
operator|+
name|offset
operator|+
literal|", end="
operator|+
name|end
return|;
block|}
comment|/**    * File version check is a little sloppy. We read v3 files but can also read v2 files if their    * content has been pb'd; files written with 0.98.    */
specifier|private
name|void
name|checkFileVersion
parameter_list|()
block|{
name|int
name|majorVersion
init|=
name|trailer
operator|.
name|getMajorVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|majorVersion
operator|==
name|getMajorVersion
argument_list|()
condition|)
return|return;
name|int
name|minorVersion
init|=
name|trailer
operator|.
name|getMinorVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|majorVersion
operator|==
literal|2
operator|&&
name|minorVersion
operator|>=
name|MIN_V2_MINOR_VERSION_WITH_PB
condition|)
return|return;
comment|// We can read v3 or v2 versions of hfile.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid HFile version: major="
operator|+
name|trailer
operator|.
name|getMajorVersion
argument_list|()
operator|+
literal|", minor="
operator|+
name|trailer
operator|.
name|getMinorVersion
argument_list|()
operator|+
literal|": expected at least "
operator|+
literal|"major=2 and minor="
operator|+
name|MAX_MINOR_VERSION
argument_list|)
throw|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|public
specifier|static
class|class
name|BlockIndexNotLoadedException
extends|extends
name|IllegalStateException
block|{
specifier|public
name|BlockIndexNotLoadedException
parameter_list|()
block|{
comment|// Add a message in case anyone relies on it as opposed to class name.
name|super
argument_list|(
literal|"Block index not loaded"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Optional
argument_list|<
name|String
argument_list|>
name|toStringFirstKey
parameter_list|()
block|{
return|return
name|getFirstKey
argument_list|()
operator|.
name|map
argument_list|(
name|CellUtil
operator|::
name|getCellKeyAsString
argument_list|)
return|;
block|}
specifier|private
name|Optional
argument_list|<
name|String
argument_list|>
name|toStringLastKey
parameter_list|()
block|{
return|return
name|getLastKey
argument_list|()
operator|.
name|map
argument_list|(
name|CellUtil
operator|::
name|getCellKeyAsString
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"reader="
operator|+
name|path
operator|.
name|toString
argument_list|()
operator|+
operator|(
operator|!
name|isFileInfoLoaded
argument_list|()
condition|?
literal|""
else|:
literal|", compression="
operator|+
name|compressAlgo
operator|.
name|getName
argument_list|()
operator|+
literal|", cacheConf="
operator|+
name|cacheConf
operator|+
literal|", firstKey="
operator|+
name|toStringFirstKey
argument_list|()
operator|+
literal|", lastKey="
operator|+
name|toStringLastKey
argument_list|()
operator|)
operator|+
literal|", avgKeyLen="
operator|+
name|avgKeyLen
operator|+
literal|", avgValueLen="
operator|+
name|avgValueLen
operator|+
literal|", entries="
operator|+
name|trailer
operator|.
name|getEntryCount
argument_list|()
operator|+
literal|", length="
operator|+
name|fileSize
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|length
parameter_list|()
block|{
return|return
name|fileSize
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|returnBlock
parameter_list|(
name|HFileBlock
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|ifPresent
argument_list|(
name|blockCache
lambda|->
block|{
name|BlockCacheKey
name|cacheKey
init|=
operator|new
name|BlockCacheKey
argument_list|(
name|this
operator|.
name|getFileContext
argument_list|()
operator|.
name|getHFileName
argument_list|()
argument_list|,
name|block
operator|.
name|getOffset
argument_list|()
argument_list|,
name|this
operator|.
name|isPrimaryReplicaReader
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockType
argument_list|()
argument_list|)
decl_stmt|;
name|blockCache
operator|.
name|returnBlock
argument_list|(
name|cacheKey
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return the first key in the file. May be null if file has no entries. Note    *         that this is not the first row key, but rather the byte form of the    *         first KeyValue.    */
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|Cell
argument_list|>
name|getFirstKey
parameter_list|()
block|{
if|if
condition|(
name|dataBlockIndexReader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|BlockIndexNotLoadedException
argument_list|()
throw|;
block|}
return|return
name|dataBlockIndexReader
operator|.
name|isEmpty
argument_list|()
condition|?
name|Optional
operator|.
name|empty
argument_list|()
else|:
name|Optional
operator|.
name|of
argument_list|(
name|dataBlockIndexReader
operator|.
name|getRootBlockKey
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * TODO left from {@link HFile} version 1: move this to StoreFile after Ryan's    * patch goes in to eliminate {@link KeyValue} here.    *    * @return the first row key, or null if the file is empty.    */
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|byte
index|[]
argument_list|>
name|getFirstRowKey
parameter_list|()
block|{
comment|// We have to copy the row part to form the row key alone
return|return
name|getFirstKey
argument_list|()
operator|.
name|map
argument_list|(
name|CellUtil
operator|::
name|cloneRow
argument_list|)
return|;
block|}
comment|/**    * TODO left from {@link HFile} version 1: move this to StoreFile after    * Ryan's patch goes in to eliminate {@link KeyValue} here.    *    * @return the last row key, or null if the file is empty.    */
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|byte
index|[]
argument_list|>
name|getLastRowKey
parameter_list|()
block|{
comment|// We have to copy the row part to form the row key alone
return|return
name|getLastKey
argument_list|()
operator|.
name|map
argument_list|(
name|CellUtil
operator|::
name|cloneRow
argument_list|)
return|;
block|}
comment|/** @return number of KV entries in this HFile */
annotation|@
name|Override
specifier|public
name|long
name|getEntries
parameter_list|()
block|{
return|return
name|trailer
operator|.
name|getEntryCount
argument_list|()
return|;
block|}
comment|/** @return comparator */
annotation|@
name|Override
specifier|public
name|CellComparator
name|getComparator
parameter_list|()
block|{
return|return
name|comparator
return|;
block|}
comment|/** @return compression algorithm */
annotation|@
name|Override
specifier|public
name|Compression
operator|.
name|Algorithm
name|getCompressionAlgorithm
parameter_list|()
block|{
return|return
name|compressAlgo
return|;
block|}
comment|/**    * @return the total heap size of data and meta block indexes in bytes. Does    *         not take into account non-root blocks of a multilevel data index.    */
annotation|@
name|Override
specifier|public
name|long
name|indexSize
parameter_list|()
block|{
return|return
operator|(
name|dataBlockIndexReader
operator|!=
literal|null
condition|?
name|dataBlockIndexReader
operator|.
name|heapSize
argument_list|()
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|metaBlockIndexReader
operator|!=
literal|null
operator|)
condition|?
name|metaBlockIndexReader
operator|.
name|heapSize
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
annotation|@
name|Override
specifier|public
name|HFileBlockIndex
operator|.
name|BlockIndexReader
name|getDataBlockIndexReader
parameter_list|()
block|{
return|return
name|dataBlockIndexReader
return|;
block|}
annotation|@
name|Override
specifier|public
name|FixedFileTrailer
name|getTrailer
parameter_list|()
block|{
return|return
name|trailer
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isPrimaryReplicaReader
parameter_list|()
block|{
return|return
name|primaryReplicaReader
return|;
block|}
annotation|@
name|Override
specifier|public
name|FileInfo
name|loadFileInfo
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|fileInfo
return|;
block|}
comment|/**    * An exception thrown when an operation requiring a scanner to be seeked    * is invoked on a scanner that is not seeked.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|public
specifier|static
class|class
name|NotSeekedException
extends|extends
name|IllegalStateException
block|{
specifier|public
name|NotSeekedException
parameter_list|()
block|{
name|super
argument_list|(
literal|"Not seeked to a key/value"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
specifier|static
class|class
name|HFileScannerImpl
implements|implements
name|HFileScanner
block|{
specifier|private
name|ByteBuff
name|blockBuffer
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|cacheBlocks
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|pread
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|isCompaction
decl_stmt|;
specifier|private
name|int
name|currKeyLen
decl_stmt|;
specifier|private
name|int
name|currValueLen
decl_stmt|;
specifier|private
name|int
name|currMemstoreTSLen
decl_stmt|;
specifier|private
name|long
name|currMemstoreTS
decl_stmt|;
comment|// Updated but never read?
specifier|protected
name|AtomicInteger
name|blockFetches
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|HFile
operator|.
name|Reader
name|reader
decl_stmt|;
specifier|private
name|int
name|currTagsLen
decl_stmt|;
comment|// buffer backed keyonlyKV
specifier|private
name|ByteBufferKeyOnlyKeyValue
name|bufBackedKeyOnlyKv
init|=
operator|new
name|ByteBufferKeyOnlyKeyValue
argument_list|()
decl_stmt|;
comment|// A pair for reusing in blockSeek() so that we don't garbage lot of objects
specifier|final
name|ObjectIntPair
argument_list|<
name|ByteBuffer
argument_list|>
name|pair
init|=
operator|new
name|ObjectIntPair
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * The next indexed key is to keep track of the indexed key of the next data block.      * If the nextIndexedKey is HConstants.NO_NEXT_INDEXED_KEY, it means that the      * current data block is the last data block.      *      * If the nextIndexedKey is null, it means the nextIndexedKey has not been loaded yet.      */
specifier|protected
name|Cell
name|nextIndexedKey
decl_stmt|;
comment|// Current block being used
specifier|protected
name|HFileBlock
name|curBlock
decl_stmt|;
comment|// Previous blocks that were used in the course of the read
specifier|protected
specifier|final
name|ArrayList
argument_list|<
name|HFileBlock
argument_list|>
name|prevBlocks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|HFileScannerImpl
parameter_list|(
specifier|final
name|HFile
operator|.
name|Reader
name|reader
parameter_list|,
specifier|final
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
block|{
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
name|this
operator|.
name|cacheBlocks
operator|=
name|cacheBlocks
expr_stmt|;
name|this
operator|.
name|pread
operator|=
name|pread
expr_stmt|;
name|this
operator|.
name|isCompaction
operator|=
name|isCompaction
expr_stmt|;
block|}
name|void
name|updateCurrBlockRef
parameter_list|(
name|HFileBlock
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|!=
literal|null
operator|&&
name|this
operator|.
name|curBlock
operator|!=
literal|null
operator|&&
name|block
operator|.
name|getOffset
argument_list|()
operator|==
name|this
operator|.
name|curBlock
operator|.
name|getOffset
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// We don't have to keep ref to EXCLUSIVE type of block
if|if
condition|(
name|this
operator|.
name|curBlock
operator|!=
literal|null
operator|&&
name|this
operator|.
name|curBlock
operator|.
name|usesSharedMemory
argument_list|()
condition|)
block|{
name|prevBlocks
operator|.
name|add
argument_list|(
name|this
operator|.
name|curBlock
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|curBlock
operator|=
name|block
expr_stmt|;
block|}
name|void
name|reset
parameter_list|()
block|{
comment|// We don't have to keep ref to EXCLUSIVE type of block
if|if
condition|(
name|this
operator|.
name|curBlock
operator|!=
literal|null
operator|&&
name|this
operator|.
name|curBlock
operator|.
name|usesSharedMemory
argument_list|()
condition|)
block|{
name|this
operator|.
name|prevBlocks
operator|.
name|add
argument_list|(
name|this
operator|.
name|curBlock
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|curBlock
operator|=
literal|null
expr_stmt|;
block|}
specifier|private
name|void
name|returnBlockToCache
parameter_list|(
name|HFileBlock
name|block
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Returning the block : "
operator|+
name|block
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|reader
operator|.
name|returnBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|returnBlocks
parameter_list|(
name|boolean
name|returnAll
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|prevBlocks
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|returnBlockToCache
argument_list|(
name|this
operator|.
name|prevBlocks
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|prevBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|returnAll
operator|&&
name|this
operator|.
name|curBlock
operator|!=
literal|null
condition|)
block|{
name|returnBlockToCache
argument_list|(
name|this
operator|.
name|curBlock
argument_list|)
expr_stmt|;
name|this
operator|.
name|curBlock
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isSeeked
parameter_list|()
block|{
return|return
name|blockBuffer
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"HFileScanner for reader "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|getReader
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|void
name|assertSeeked
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSeeked
argument_list|()
condition|)
throw|throw
operator|new
name|NotSeekedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|HFile
operator|.
name|Reader
name|getReader
parameter_list|()
block|{
return|return
name|reader
return|;
block|}
comment|// From non encoded HFiles, we always read back KeyValue or its descendant.(Note: When HFile
comment|// block is in DBB, it will be OffheapKV). So all parts of the Cell is in a contiguous
comment|// array/buffer. How many bytes we should wrap to make the KV is what this method returns.
specifier|private
name|int
name|getKVBufSize
parameter_list|()
block|{
name|int
name|kvBufSize
init|=
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
operator|+
name|currValueLen
decl_stmt|;
if|if
condition|(
name|currTagsLen
operator|>
literal|0
condition|)
block|{
name|kvBufSize
operator|+=
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|+
name|currTagsLen
expr_stmt|;
block|}
return|return
name|kvBufSize
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
name|pread
condition|)
block|{
comment|// For seek + pread stream socket should be closed when the scanner is closed. HBASE-9393
name|reader
operator|.
name|unbufferStream
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|returnBlocks
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Returns the #bytes in HFile for the current cell. Used to skip these many bytes in current
comment|// HFile block's buffer so as to position to the next cell.
specifier|private
name|int
name|getCurCellSerializedSize
parameter_list|()
block|{
name|int
name|curCellSize
init|=
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
operator|+
name|currValueLen
operator|+
name|currMemstoreTSLen
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|getFileContext
argument_list|()
operator|.
name|isIncludesTags
argument_list|()
condition|)
block|{
name|curCellSize
operator|+=
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|+
name|currTagsLen
expr_stmt|;
block|}
return|return
name|curCellSize
return|;
block|}
specifier|protected
name|void
name|readKeyValueLen
parameter_list|()
block|{
comment|// This is a hot method. We go out of our way to make this method short so it can be
comment|// inlined and is not too big to compile. We also manage position in ByteBuffer ourselves
comment|// because it is faster than going via range-checked ByteBuffer methods or going through a
comment|// byte buffer array a byte at a time.
comment|// Get a long at a time rather than read two individual ints. In micro-benchmarking, even
comment|// with the extra bit-fiddling, this is order-of-magnitude faster than getting two ints.
comment|// Trying to imitate what was done - need to profile if this is better or
comment|// earlier way is better by doing mark and reset?
comment|// But ensure that you read long instead of two ints
name|long
name|ll
init|=
name|blockBuffer
operator|.
name|getLongAfterPosition
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Read top half as an int of key length and bottom int as value length
name|this
operator|.
name|currKeyLen
operator|=
call|(
name|int
call|)
argument_list|(
name|ll
operator|>>
name|Integer
operator|.
name|SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|currValueLen
operator|=
call|(
name|int
call|)
argument_list|(
name|Bytes
operator|.
name|MASK_FOR_LOWER_INT_IN_LONG
operator|^
name|ll
argument_list|)
expr_stmt|;
name|checkKeyValueLen
argument_list|()
expr_stmt|;
comment|// Move position past the key and value lengths and then beyond the key and value
name|int
name|p
init|=
operator|(
name|Bytes
operator|.
name|SIZEOF_LONG
operator|+
name|currKeyLen
operator|+
name|currValueLen
operator|)
decl_stmt|;
if|if
condition|(
name|reader
operator|.
name|getFileContext
argument_list|()
operator|.
name|isIncludesTags
argument_list|()
condition|)
block|{
comment|// Tags length is a short.
name|this
operator|.
name|currTagsLen
operator|=
name|blockBuffer
operator|.
name|getShortAfterPosition
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|checkTagsLen
argument_list|()
expr_stmt|;
name|p
operator|+=
operator|(
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|+
name|currTagsLen
operator|)
expr_stmt|;
block|}
name|readMvccVersion
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
name|void
name|checkTagsLen
parameter_list|()
block|{
if|if
condition|(
name|checkLen
argument_list|(
name|this
operator|.
name|currTagsLen
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid currTagsLen "
operator|+
name|this
operator|.
name|currTagsLen
operator|+
literal|". Block offset: "
operator|+
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
literal|", block length: "
operator|+
name|this
operator|.
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|", position: "
operator|+
name|this
operator|.
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|" (without header)."
argument_list|)
throw|;
block|}
block|}
comment|/**      * Read mvcc. Does checks to see if we even need to read the mvcc at all.      * @param offsetFromPos      */
specifier|protected
name|void
name|readMvccVersion
parameter_list|(
specifier|final
name|int
name|offsetFromPos
parameter_list|)
block|{
comment|// See if we even need to decode mvcc.
if|if
condition|(
operator|!
name|this
operator|.
name|reader
operator|.
name|shouldIncludeMemStoreTS
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|this
operator|.
name|reader
operator|.
name|isDecodeMemStoreTS
argument_list|()
condition|)
block|{
name|currMemstoreTS
operator|=
literal|0
expr_stmt|;
name|currMemstoreTSLen
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|_readMvccVersion
argument_list|(
name|offsetFromPos
argument_list|)
expr_stmt|;
block|}
comment|/**      * Actually do the mvcc read. Does no checks.      * @param offsetFromPos      */
specifier|private
name|void
name|_readMvccVersion
parameter_list|(
name|int
name|offsetFromPos
parameter_list|)
block|{
comment|// This is Bytes#bytesToVint inlined so can save a few instructions in this hot method; i.e.
comment|// previous if one-byte vint, we'd redo the vint call to find int size.
comment|// Also the method is kept small so can be inlined.
name|byte
name|firstByte
init|=
name|blockBuffer
operator|.
name|getByteAfterPosition
argument_list|(
name|offsetFromPos
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|WritableUtils
operator|.
name|decodeVIntSize
argument_list|(
name|firstByte
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|this
operator|.
name|currMemstoreTS
operator|=
name|firstByte
expr_stmt|;
block|}
else|else
block|{
name|int
name|remaining
init|=
name|len
operator|-
literal|1
decl_stmt|;
name|long
name|i
init|=
literal|0
decl_stmt|;
name|offsetFromPos
operator|++
expr_stmt|;
if|if
condition|(
name|remaining
operator|>=
name|Bytes
operator|.
name|SIZEOF_INT
condition|)
block|{
comment|// The int read has to be converted to unsigned long so the& op
name|i
operator|=
operator|(
name|blockBuffer
operator|.
name|getIntAfterPosition
argument_list|(
name|offsetFromPos
argument_list|)
operator|&
literal|0x00000000ffffffffL
operator|)
expr_stmt|;
name|remaining
operator|-=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
name|offsetFromPos
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
block|}
if|if
condition|(
name|remaining
operator|>=
name|Bytes
operator|.
name|SIZEOF_SHORT
condition|)
block|{
name|short
name|s
init|=
name|blockBuffer
operator|.
name|getShortAfterPosition
argument_list|(
name|offsetFromPos
argument_list|)
decl_stmt|;
name|i
operator|=
name|i
operator|<<
literal|16
expr_stmt|;
name|i
operator|=
name|i
operator||
operator|(
name|s
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
name|remaining
operator|-=
name|Bytes
operator|.
name|SIZEOF_SHORT
expr_stmt|;
name|offsetFromPos
operator|+=
name|Bytes
operator|.
name|SIZEOF_SHORT
expr_stmt|;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|remaining
condition|;
name|idx
operator|++
control|)
block|{
name|byte
name|b
init|=
name|blockBuffer
operator|.
name|getByteAfterPosition
argument_list|(
name|offsetFromPos
operator|+
name|idx
argument_list|)
decl_stmt|;
name|i
operator|=
name|i
operator|<<
literal|8
expr_stmt|;
name|i
operator|=
name|i
operator||
operator|(
name|b
operator|&
literal|0xFF
operator|)
expr_stmt|;
block|}
name|currMemstoreTS
operator|=
operator|(
name|WritableUtils
operator|.
name|isNegativeVInt
argument_list|(
name|firstByte
argument_list|)
condition|?
operator|~
name|i
else|:
name|i
operator|)
expr_stmt|;
block|}
name|this
operator|.
name|currMemstoreTSLen
operator|=
name|len
expr_stmt|;
block|}
comment|/**      * Within a loaded block, seek looking for the last key that is smaller than      * (or equal to?) the key we are interested in.      * A note on the seekBefore: if you have seekBefore = true, AND the first      * key in the block = key, then you'll get thrown exceptions. The caller has      * to check for that case and load the previous block as appropriate.      * @param key      *          the key to find      * @param seekBefore      *          find the key before the given key in case of exact match.      * @return 0 in case of an exact key match, 1 in case of an inexact match,      *         -2 in case of an inexact match and furthermore, the input key      *         less than the first key of current block(e.g. using a faked index      *         key)      */
specifier|protected
name|int
name|blockSeek
parameter_list|(
name|Cell
name|key
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
block|{
name|int
name|klen
decl_stmt|,
name|vlen
decl_stmt|,
name|tlen
init|=
literal|0
decl_stmt|;
name|int
name|lastKeyValueSize
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|offsetFromPos
decl_stmt|;
do|do
block|{
name|offsetFromPos
operator|=
literal|0
expr_stmt|;
comment|// Better to ensure that we use the BB Utils here
name|long
name|ll
init|=
name|blockBuffer
operator|.
name|getLongAfterPosition
argument_list|(
name|offsetFromPos
argument_list|)
decl_stmt|;
name|klen
operator|=
call|(
name|int
call|)
argument_list|(
name|ll
operator|>>
name|Integer
operator|.
name|SIZE
argument_list|)
expr_stmt|;
name|vlen
operator|=
call|(
name|int
call|)
argument_list|(
name|Bytes
operator|.
name|MASK_FOR_LOWER_INT_IN_LONG
operator|^
name|ll
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkKeyLen
argument_list|(
name|klen
argument_list|)
operator|||
name|checkLen
argument_list|(
name|vlen
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid klen "
operator|+
name|klen
operator|+
literal|" or vlen "
operator|+
name|vlen
operator|+
literal|". Block offset: "
operator|+
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
literal|", block length: "
operator|+
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|", position: "
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|" (without header)."
argument_list|)
throw|;
block|}
name|offsetFromPos
operator|+=
name|Bytes
operator|.
name|SIZEOF_LONG
expr_stmt|;
name|blockBuffer
operator|.
name|asSubByteBuffer
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|offsetFromPos
argument_list|,
name|klen
argument_list|,
name|pair
argument_list|)
expr_stmt|;
name|bufBackedKeyOnlyKv
operator|.
name|setKey
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|int
name|comp
init|=
name|PrivateCellUtil
operator|.
name|compareKeyIgnoresMvcc
argument_list|(
name|reader
operator|.
name|getComparator
argument_list|()
argument_list|,
name|key
argument_list|,
name|bufBackedKeyOnlyKv
argument_list|)
decl_stmt|;
name|offsetFromPos
operator|+=
name|klen
operator|+
name|vlen
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|getFileContext
argument_list|()
operator|.
name|isIncludesTags
argument_list|()
condition|)
block|{
comment|// Read short as unsigned, high byte first
name|tlen
operator|=
operator|(
operator|(
name|blockBuffer
operator|.
name|getByteAfterPosition
argument_list|(
name|offsetFromPos
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|^
operator|(
name|blockBuffer
operator|.
name|getByteAfterPosition
argument_list|(
name|offsetFromPos
operator|+
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
name|checkLen
argument_list|(
name|tlen
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid tlen "
operator|+
name|tlen
operator|+
literal|". Block offset: "
operator|+
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
literal|", block length: "
operator|+
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|", position: "
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|" (without header)."
argument_list|)
throw|;
block|}
comment|// add the two bytes read for the tags.
name|offsetFromPos
operator|+=
name|tlen
operator|+
operator|(
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|shouldIncludeMemStoreTS
argument_list|()
condition|)
block|{
comment|// Directly read the mvcc based on current position
name|readMvccVersion
argument_list|(
name|offsetFromPos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|seekBefore
condition|)
block|{
if|if
condition|(
name|lastKeyValueSize
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"blockSeek with seekBefore "
operator|+
literal|"at the first key of the block: key="
operator|+
name|CellUtil
operator|.
name|getCellKeyAsString
argument_list|(
name|key
argument_list|)
operator|+
literal|", blockOffset="
operator|+
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
literal|", onDiskSize="
operator|+
name|curBlock
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
argument_list|)
throw|;
block|}
name|blockBuffer
operator|.
name|moveBack
argument_list|(
name|lastKeyValueSize
argument_list|)
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// non exact match.
block|}
name|currKeyLen
operator|=
name|klen
expr_stmt|;
name|currValueLen
operator|=
name|vlen
expr_stmt|;
name|currTagsLen
operator|=
name|tlen
expr_stmt|;
return|return
literal|0
return|;
comment|// indicate exact match
block|}
elseif|else
if|if
condition|(
name|comp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|lastKeyValueSize
operator|>
literal|0
condition|)
block|{
name|blockBuffer
operator|.
name|moveBack
argument_list|(
name|lastKeyValueSize
argument_list|)
expr_stmt|;
block|}
name|readKeyValueLen
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastKeyValueSize
operator|==
operator|-
literal|1
operator|&&
name|blockBuffer
operator|.
name|position
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|HConstants
operator|.
name|INDEX_KEY_MAGIC
return|;
block|}
return|return
literal|1
return|;
block|}
comment|// The size of this key/value tuple, including key/value length fields.
name|lastKeyValueSize
operator|=
name|klen
operator|+
name|vlen
operator|+
name|currMemstoreTSLen
operator|+
name|KEY_VALUE_LEN_SIZE
expr_stmt|;
comment|// include tag length also if tags included with KV
if|if
condition|(
name|reader
operator|.
name|getFileContext
argument_list|()
operator|.
name|isIncludesTags
argument_list|()
condition|)
block|{
name|lastKeyValueSize
operator|+=
name|tlen
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
expr_stmt|;
block|}
name|blockBuffer
operator|.
name|skip
argument_list|(
name|lastKeyValueSize
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|blockBuffer
operator|.
name|hasRemaining
argument_list|()
condition|)
do|;
comment|// Seek to the last key we successfully read. This will happen if this is
comment|// the last key/value pair in the file, in which case the following call
comment|// to next() has to return false.
name|blockBuffer
operator|.
name|moveBack
argument_list|(
name|lastKeyValueSize
argument_list|)
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// didn't exactly find it.
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|getNextIndexedKey
parameter_list|()
block|{
return|return
name|nextIndexedKey
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|seekTo
parameter_list|(
name|Cell
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|seekTo
argument_list|(
name|key
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|reseekTo
parameter_list|(
name|Cell
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|compared
decl_stmt|;
if|if
condition|(
name|isSeeked
argument_list|()
condition|)
block|{
name|compared
operator|=
name|compareKey
argument_list|(
name|reader
operator|.
name|getComparator
argument_list|()
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|compared
operator|<
literal|1
condition|)
block|{
comment|// If the required key is less than or equal to current key, then
comment|// don't do anything.
return|return
name|compared
return|;
block|}
else|else
block|{
comment|// The comparison with no_next_index_key has to be checked
if|if
condition|(
name|this
operator|.
name|nextIndexedKey
operator|!=
literal|null
operator|&&
operator|(
name|this
operator|.
name|nextIndexedKey
operator|==
name|KeyValueScanner
operator|.
name|NO_NEXT_INDEXED_KEY
operator|||
name|PrivateCellUtil
operator|.
name|compareKeyIgnoresMvcc
argument_list|(
name|reader
operator|.
name|getComparator
argument_list|()
argument_list|,
name|key
argument_list|,
name|nextIndexedKey
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
comment|// The reader shall continue to scan the current data block instead
comment|// of querying the
comment|// block index as long as it knows the target key is strictly
comment|// smaller than
comment|// the next indexed key or the current data block is the last data
comment|// block.
return|return
name|loadBlockAndSeekToKey
argument_list|(
name|this
operator|.
name|curBlock
argument_list|,
name|nextIndexedKey
argument_list|,
literal|false
argument_list|,
name|key
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
comment|// Don't rewind on a reseek operation, because reseek implies that we are
comment|// always going forward in the file.
return|return
name|seekTo
argument_list|(
name|key
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * An internal API function. Seek to the given key, optionally rewinding to      * the first key of the block before doing the seek.      *      * @param key - a cell representing the key that we need to fetch      * @param rewind whether to rewind to the first key of the block before      *        doing the seek. If this is false, we are assuming we never go      *        back, otherwise the result is undefined.      * @return -1 if the key is earlier than the first key of the file,      *         0 if we are at the given key, 1 if we are past the given key      *         -2 if the key is earlier than the first key of the file while      *         using a faked index key      * @throws IOException      */
specifier|public
name|int
name|seekTo
parameter_list|(
name|Cell
name|key
parameter_list|,
name|boolean
name|rewind
parameter_list|)
throws|throws
name|IOException
block|{
name|HFileBlockIndex
operator|.
name|BlockIndexReader
name|indexReader
init|=
name|reader
operator|.
name|getDataBlockIndexReader
argument_list|()
decl_stmt|;
name|BlockWithScanInfo
name|blockWithScanInfo
init|=
name|indexReader
operator|.
name|loadDataBlockWithScanInfo
argument_list|(
name|key
argument_list|,
name|curBlock
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
name|getEffectiveDataBlockEncoding
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockWithScanInfo
operator|==
literal|null
operator|||
name|blockWithScanInfo
operator|.
name|getHFileBlock
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// This happens if the key e.g. falls before the beginning of the
comment|// file.
return|return
operator|-
literal|1
return|;
block|}
return|return
name|loadBlockAndSeekToKey
argument_list|(
name|blockWithScanInfo
operator|.
name|getHFileBlock
argument_list|()
argument_list|,
name|blockWithScanInfo
operator|.
name|getNextIndexedKey
argument_list|()
argument_list|,
name|rewind
argument_list|,
name|key
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|seekBefore
parameter_list|(
name|Cell
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|HFileBlock
name|seekToBlock
init|=
name|reader
operator|.
name|getDataBlockIndexReader
argument_list|()
operator|.
name|seekToDataBlock
argument_list|(
name|key
argument_list|,
name|curBlock
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
name|reader
operator|.
name|getEffectiveEncodingInCache
argument_list|(
name|isCompaction
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekToBlock
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Cell
name|firstKey
init|=
name|getFirstKeyCellInBlock
argument_list|(
name|seekToBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|PrivateCellUtil
operator|.
name|compareKeyIgnoresMvcc
argument_list|(
name|reader
operator|.
name|getComparator
argument_list|()
argument_list|,
name|firstKey
argument_list|,
name|key
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|long
name|previousBlockOffset
init|=
name|seekToBlock
operator|.
name|getPrevBlockOffset
argument_list|()
decl_stmt|;
comment|// The key we are interested in
if|if
condition|(
name|previousBlockOffset
operator|==
operator|-
literal|1
condition|)
block|{
comment|// we have a 'problem', the key we want is the first of the file.
return|return
literal|false
return|;
block|}
comment|// The first key in the current block 'seekToBlock' is greater than the given
comment|// seekBefore key. We will go ahead by reading the next block that satisfies the
comment|// given key. Return the current block before reading the next one.
name|reader
operator|.
name|returnBlock
argument_list|(
name|seekToBlock
argument_list|)
expr_stmt|;
comment|// It is important that we compute and pass onDiskSize to the block
comment|// reader so that it does not have to read the header separately to
comment|// figure out the size.  Currently, we do not have a way to do this
comment|// correctly in the general case however.
comment|// TODO: See https://issues.apache.org/jira/browse/HBASE-14576
name|int
name|prevBlockSize
init|=
operator|-
literal|1
decl_stmt|;
name|seekToBlock
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|previousBlockOffset
argument_list|,
name|prevBlockSize
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
literal|true
argument_list|,
name|BlockType
operator|.
name|DATA
argument_list|,
name|getEffectiveDataBlockEncoding
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO shortcut: seek forward in this block to the last key of the
comment|// block.
block|}
name|loadBlockAndSeekToKey
argument_list|(
name|seekToBlock
argument_list|,
name|firstKey
argument_list|,
literal|true
argument_list|,
name|key
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Scans blocks in the "scanned" section of the {@link HFile} until the next      * data block is found.      *      * @return the next block, or null if there are no more data blocks      * @throws IOException      */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"NP_NULL_ON_SOME_PATH"
argument_list|,
name|justification
operator|=
literal|"Yeah, unnecessary null check; could do w/ clean up"
argument_list|)
specifier|protected
name|HFileBlock
name|readNextDataBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|lastDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getLastDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|curBlock
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|HFileBlock
name|block
init|=
name|this
operator|.
name|curBlock
decl_stmt|;
do|do
block|{
if|if
condition|(
name|block
operator|.
name|getOffset
argument_list|()
operator|>=
name|lastDataBlockOffset
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|block
operator|.
name|getOffset
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid block file offset: "
operator|+
name|block
argument_list|)
throw|;
block|}
comment|// We are reading the next block without block type validation, because
comment|// it might turn out to be a non-data block.
name|block
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|block
operator|.
name|getOffset
argument_list|()
operator|+
name|block
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
argument_list|,
name|block
operator|.
name|getNextBlockOnDiskSize
argument_list|()
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|getEffectiveDataBlockEncoding
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|!=
literal|null
operator|&&
operator|!
name|block
operator|.
name|getBlockType
argument_list|()
operator|.
name|isData
argument_list|()
condition|)
block|{
comment|// Findbugs: NP_NULL_ON_SOME_PATH
comment|// Whatever block we read we will be returning it unless
comment|// it is a datablock. Just in case the blocks are non data blocks
name|reader
operator|.
name|returnBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|block
operator|.
name|getBlockType
argument_list|()
operator|.
name|isData
argument_list|()
condition|)
do|;
return|return
name|block
return|;
block|}
specifier|public
name|DataBlockEncoding
name|getEffectiveDataBlockEncoding
parameter_list|()
block|{
return|return
name|this
operator|.
name|reader
operator|.
name|getEffectiveEncodingInCache
argument_list|(
name|isCompaction
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|getCell
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSeeked
argument_list|()
condition|)
return|return
literal|null
return|;
name|Cell
name|ret
decl_stmt|;
name|int
name|cellBufSize
init|=
name|getKVBufSize
argument_list|()
decl_stmt|;
name|long
name|seqId
init|=
literal|0L
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|shouldIncludeMemStoreTS
argument_list|()
condition|)
block|{
name|seqId
operator|=
name|currMemstoreTS
expr_stmt|;
block|}
if|if
condition|(
name|blockBuffer
operator|.
name|hasArray
argument_list|()
condition|)
block|{
comment|// TODO : reduce the varieties of KV here. Check if based on a boolean
comment|// we can handle the 'no tags' case.
if|if
condition|(
name|currTagsLen
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
operator|new
name|SizeCachedKeyValue
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
argument_list|,
name|cellBufSize
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|new
name|SizeCachedNoTagsKeyValue
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
argument_list|,
name|cellBufSize
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ByteBuffer
name|buf
init|=
name|blockBuffer
operator|.
name|asSubByteBuffer
argument_list|(
name|cellBufSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|.
name|isDirect
argument_list|()
condition|)
block|{
name|ret
operator|=
operator|new
name|ByteBufferKeyValue
argument_list|(
name|buf
argument_list|,
name|buf
operator|.
name|position
argument_list|()
argument_list|,
name|cellBufSize
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|currTagsLen
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
operator|new
name|SizeCachedKeyValue
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|buf
operator|.
name|position
argument_list|()
argument_list|,
name|cellBufSize
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|new
name|SizeCachedNoTagsKeyValue
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|buf
operator|.
name|position
argument_list|()
argument_list|,
name|cellBufSize
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|getKey
parameter_list|()
block|{
name|assertSeeked
argument_list|()
expr_stmt|;
comment|// Create a new object so that this getKey is cached as firstKey, lastKey
name|ObjectIntPair
argument_list|<
name|ByteBuffer
argument_list|>
name|keyPair
init|=
operator|new
name|ObjectIntPair
argument_list|<>
argument_list|()
decl_stmt|;
name|blockBuffer
operator|.
name|asSubByteBuffer
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
argument_list|,
name|currKeyLen
argument_list|,
name|keyPair
argument_list|)
expr_stmt|;
name|ByteBuffer
name|keyBuf
init|=
name|keyPair
operator|.
name|getFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyBuf
operator|.
name|hasArray
argument_list|()
condition|)
block|{
return|return
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|keyBuf
operator|.
name|array
argument_list|()
argument_list|,
name|keyBuf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|keyPair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|currKeyLen
argument_list|)
return|;
block|}
else|else
block|{
comment|// Better to do a copy here instead of holding on to this BB so that
comment|// we could release the blocks referring to this key. This key is specifically used
comment|// in HalfStoreFileReader to get the firstkey and lastkey by creating a new scanner
comment|// every time. So holding onto the BB (incase of DBB) is not advised here.
name|byte
index|[]
name|key
init|=
operator|new
name|byte
index|[
name|currKeyLen
index|]
decl_stmt|;
name|ByteBufferUtils
operator|.
name|copyFromBufferToArray
argument_list|(
name|key
argument_list|,
name|keyBuf
argument_list|,
name|keyPair
operator|.
name|getSecond
argument_list|()
argument_list|,
literal|0
argument_list|,
name|currKeyLen
argument_list|)
expr_stmt|;
return|return
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|currKeyLen
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getValue
parameter_list|()
block|{
name|assertSeeked
argument_list|()
expr_stmt|;
comment|// Okie to create new Pair. Not used in hot path
name|ObjectIntPair
argument_list|<
name|ByteBuffer
argument_list|>
name|valuePair
init|=
operator|new
name|ObjectIntPair
argument_list|<>
argument_list|()
decl_stmt|;
name|this
operator|.
name|blockBuffer
operator|.
name|asSubByteBuffer
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
argument_list|,
name|currValueLen
argument_list|,
name|valuePair
argument_list|)
expr_stmt|;
name|ByteBuffer
name|valBuf
init|=
name|valuePair
operator|.
name|getFirst
argument_list|()
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|valBuf
operator|.
name|position
argument_list|(
name|valuePair
operator|.
name|getSecond
argument_list|()
argument_list|)
expr_stmt|;
name|valBuf
operator|.
name|limit
argument_list|(
name|currValueLen
operator|+
name|valuePair
operator|.
name|getSecond
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|valBuf
operator|.
name|slice
argument_list|()
return|;
block|}
specifier|protected
name|void
name|setNonSeekedState
parameter_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
name|blockBuffer
operator|=
literal|null
expr_stmt|;
name|currKeyLen
operator|=
literal|0
expr_stmt|;
name|currValueLen
operator|=
literal|0
expr_stmt|;
name|currMemstoreTS
operator|=
literal|0
expr_stmt|;
name|currMemstoreTSLen
operator|=
literal|0
expr_stmt|;
name|currTagsLen
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Set the position on current backing blockBuffer.      */
specifier|private
name|void
name|positionThisBlockBuffer
parameter_list|()
block|{
try|try
block|{
name|blockBuffer
operator|.
name|skip
argument_list|(
name|getCurCellSerializedSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Current pos = "
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|"; currKeyLen = "
operator|+
name|currKeyLen
operator|+
literal|"; currValLen = "
operator|+
name|currValueLen
operator|+
literal|"; block limit = "
operator|+
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|"; HFile name = "
operator|+
name|reader
operator|.
name|getName
argument_list|()
operator|+
literal|"; currBlock currBlockOffset = "
operator|+
name|this
operator|.
name|curBlock
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**      * Set our selves up for the next 'next' invocation, set up next block.      * @return True is more to read else false if at the end.      * @throws IOException      */
specifier|private
name|boolean
name|positionForNextBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Methods are small so they get inlined because they are 'hot'.
name|long
name|lastDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getLastDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|>=
name|lastDataBlockOffset
condition|)
block|{
name|setNonSeekedState
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|isNextBlock
argument_list|()
return|;
block|}
specifier|private
name|boolean
name|isNextBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Methods are small so they get inlined because they are 'hot'.
name|HFileBlock
name|nextBlock
init|=
name|readNextDataBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextBlock
operator|==
literal|null
condition|)
block|{
name|setNonSeekedState
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|updateCurrentBlock
argument_list|(
name|nextBlock
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
specifier|final
name|boolean
name|_next
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Small method so can be inlined. It is a hot one.
if|if
condition|(
name|blockBuffer
operator|.
name|remaining
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
name|positionForNextBlock
argument_list|()
return|;
block|}
comment|// We are still in the same block.
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Go to the next key/value in the block section. Loads the next block if      * necessary. If successful, {@link #getKey()} and {@link #getValue()} can      * be called.      *      * @return true if successfully navigated to the next key/value      */
annotation|@
name|Override
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
comment|// This is a hot method so extreme measures taken to ensure it is small and inlineable.
comment|// Checked by setting: -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining -XX:+PrintCompilation
name|assertSeeked
argument_list|()
expr_stmt|;
name|positionThisBlockBuffer
argument_list|()
expr_stmt|;
return|return
name|_next
argument_list|()
return|;
block|}
comment|/**      * Positions this scanner at the start of the file.      *      * @return false if empty file; i.e. a call to next would return false and      *         the current key and value are undefined.      * @throws IOException      */
annotation|@
name|Override
specifier|public
name|boolean
name|seekTo
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|reader
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getEntryCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// No data blocks.
return|return
literal|false
return|;
block|}
name|long
name|firstDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getFirstDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|curBlock
operator|!=
literal|null
operator|&&
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|==
name|firstDataBlockOffset
condition|)
block|{
return|return
name|processFirstDataBlock
argument_list|()
return|;
block|}
name|readAndUpdateNewBlock
argument_list|(
name|firstDataBlockOffset
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|protected
name|boolean
name|processFirstDataBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|blockBuffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|protected
name|void
name|readAndUpdateNewBlock
parameter_list|(
name|long
name|firstDataBlockOffset
parameter_list|)
throws|throws
name|IOException
throws|,
name|CorruptHFileException
block|{
name|HFileBlock
name|newBlock
init|=
name|reader
operator|.
name|readBlock
argument_list|(
name|firstDataBlockOffset
argument_list|,
operator|-
literal|1
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
literal|true
argument_list|,
name|BlockType
operator|.
name|DATA
argument_list|,
name|getEffectiveDataBlockEncoding
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newBlock
operator|.
name|getOffset
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid block offset: "
operator|+
name|newBlock
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
name|updateCurrentBlock
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|int
name|loadBlockAndSeekToKey
parameter_list|(
name|HFileBlock
name|seekToBlock
parameter_list|,
name|Cell
name|nextIndexedKey
parameter_list|,
name|boolean
name|rewind
parameter_list|,
name|Cell
name|key
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|curBlock
operator|==
literal|null
operator|||
name|this
operator|.
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|!=
name|seekToBlock
operator|.
name|getOffset
argument_list|()
condition|)
block|{
name|updateCurrentBlock
argument_list|(
name|seekToBlock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rewind
condition|)
block|{
name|blockBuffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
comment|// Update the nextIndexedKey
name|this
operator|.
name|nextIndexedKey
operator|=
name|nextIndexedKey
expr_stmt|;
return|return
name|blockSeek
argument_list|(
name|key
argument_list|,
name|seekBefore
argument_list|)
return|;
block|}
comment|/**      * @param v      * @return True if v&lt;= 0 or v&gt; current block buffer limit.      */
specifier|protected
specifier|final
name|boolean
name|checkKeyLen
parameter_list|(
specifier|final
name|int
name|v
parameter_list|)
block|{
return|return
name|v
operator|<=
literal|0
operator|||
name|v
operator|>
name|this
operator|.
name|blockBuffer
operator|.
name|limit
argument_list|()
return|;
block|}
comment|/**      * @param v      * @return True if v&lt; 0 or v&gt; current block buffer limit.      */
specifier|protected
specifier|final
name|boolean
name|checkLen
parameter_list|(
specifier|final
name|int
name|v
parameter_list|)
block|{
return|return
name|v
argument_list|<
literal|0
operator|||
name|v
argument_list|>
name|this
operator|.
name|blockBuffer
operator|.
name|limit
argument_list|()
return|;
block|}
comment|/**      * Check key and value lengths are wholesome.      */
specifier|protected
specifier|final
name|void
name|checkKeyValueLen
parameter_list|()
block|{
if|if
condition|(
name|checkKeyLen
argument_list|(
name|this
operator|.
name|currKeyLen
argument_list|)
operator|||
name|checkLen
argument_list|(
name|this
operator|.
name|currValueLen
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid currKeyLen "
operator|+
name|this
operator|.
name|currKeyLen
operator|+
literal|" or currValueLen "
operator|+
name|this
operator|.
name|currValueLen
operator|+
literal|". Block offset: "
operator|+
name|this
operator|.
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
literal|", block length: "
operator|+
name|this
operator|.
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|", position: "
operator|+
name|this
operator|.
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|" (without header)."
argument_list|)
throw|;
block|}
block|}
comment|/**      * Updates the current block to be the given {@link HFileBlock}. Seeks to      * the the first key/value pair.      *      * @param newBlock the block to make current      */
specifier|protected
name|void
name|updateCurrentBlock
parameter_list|(
name|HFileBlock
name|newBlock
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Set the active block on the reader
comment|// sanity check
if|if
condition|(
name|newBlock
operator|.
name|getBlockType
argument_list|()
operator|!=
name|BlockType
operator|.
name|DATA
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"ScannerV2 works only on data "
operator|+
literal|"blocks, got "
operator|+
name|newBlock
operator|.
name|getBlockType
argument_list|()
operator|+
literal|"; "
operator|+
literal|"fileName="
operator|+
name|reader
operator|.
name|getName
argument_list|()
operator|+
literal|", "
operator|+
literal|"dataBlockEncoder="
operator|+
name|reader
operator|.
name|getDataBlockEncoding
argument_list|()
operator|+
literal|", "
operator|+
literal|"isCompaction="
operator|+
name|isCompaction
argument_list|)
throw|;
block|}
name|updateCurrBlockRef
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
name|blockBuffer
operator|=
name|newBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
name|blockFetches
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Reset the next indexed key
name|this
operator|.
name|nextIndexedKey
operator|=
literal|null
expr_stmt|;
block|}
specifier|protected
name|Cell
name|getFirstKeyCellInBlock
parameter_list|(
name|HFileBlock
name|curBlock
parameter_list|)
block|{
name|ByteBuff
name|buffer
init|=
name|curBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
decl_stmt|;
comment|// It is safe to manipulate this buffer because we own the buffer object.
name|buffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|int
name|klen
init|=
name|buffer
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|skip
argument_list|(
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|)
expr_stmt|;
comment|// Skip value len part
name|ByteBuffer
name|keyBuff
init|=
name|buffer
operator|.
name|asSubByteBuffer
argument_list|(
name|klen
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyBuff
operator|.
name|hasArray
argument_list|()
condition|)
block|{
return|return
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|keyBuff
operator|.
name|array
argument_list|()
argument_list|,
name|keyBuff
operator|.
name|arrayOffset
argument_list|()
operator|+
name|keyBuff
operator|.
name|position
argument_list|()
argument_list|,
name|klen
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ByteBufferKeyOnlyKeyValue
argument_list|(
name|keyBuff
argument_list|,
name|keyBuff
operator|.
name|position
argument_list|()
argument_list|,
name|klen
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|getKeyString
parameter_list|()
block|{
return|return
name|CellUtil
operator|.
name|toString
argument_list|(
name|getKey
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getValueString
parameter_list|()
block|{
return|return
name|ByteBufferUtils
operator|.
name|toStringBinary
argument_list|(
name|getValue
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|int
name|compareKey
parameter_list|(
name|CellComparator
name|comparator
parameter_list|,
name|Cell
name|key
parameter_list|)
block|{
name|blockBuffer
operator|.
name|asSubByteBuffer
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
argument_list|,
name|currKeyLen
argument_list|,
name|pair
argument_list|)
expr_stmt|;
name|this
operator|.
name|bufBackedKeyOnlyKv
operator|.
name|setKey
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|currKeyLen
argument_list|)
expr_stmt|;
return|return
name|PrivateCellUtil
operator|.
name|compareKeyIgnoresMvcc
argument_list|(
name|comparator
argument_list|,
name|key
argument_list|,
name|this
operator|.
name|bufBackedKeyOnlyKv
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|shipped
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|returnBlocks
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Path
name|getPath
parameter_list|()
block|{
return|return
name|path
return|;
block|}
annotation|@
name|Override
specifier|public
name|DataBlockEncoding
name|getDataBlockEncoding
parameter_list|()
block|{
return|return
name|dataBlockEncoder
operator|.
name|getDataBlockEncoding
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
comment|/** Minor versions in HFile starting with this number have hbase checksums */
specifier|public
specifier|static
specifier|final
name|int
name|MINOR_VERSION_WITH_CHECKSUM
init|=
literal|1
decl_stmt|;
comment|/** In HFile minor version that does not support checksums */
specifier|public
specifier|static
specifier|final
name|int
name|MINOR_VERSION_NO_CHECKSUM
init|=
literal|0
decl_stmt|;
comment|/** HFile minor version that introduced pbuf filetrailer */
specifier|public
specifier|static
specifier|final
name|int
name|PBUF_TRAILER_MINOR_VERSION
init|=
literal|2
decl_stmt|;
comment|/**    * The size of a (key length, value length) tuple that prefixes each entry in    * a data block.    */
specifier|public
specifier|final
specifier|static
name|int
name|KEY_VALUE_LEN_SIZE
init|=
literal|2
operator|*
name|Bytes
operator|.
name|SIZEOF_INT
decl_stmt|;
specifier|private
name|boolean
name|includesMemstoreTS
init|=
literal|false
decl_stmt|;
specifier|protected
name|boolean
name|decodeMemstoreTS
init|=
literal|false
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|isDecodeMemStoreTS
parameter_list|()
block|{
return|return
name|this
operator|.
name|decodeMemstoreTS
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|shouldIncludeMemStoreTS
parameter_list|()
block|{
return|return
name|includesMemstoreTS
return|;
block|}
comment|/**    * Retrieve block from cache. Validates the retrieved block's type vs {@code expectedBlockType}    * and its encoding vs. {@code expectedDataBlockEncoding}. Unpacks the block as necessary.    */
specifier|private
name|HFileBlock
name|getCachedBlock
parameter_list|(
name|BlockCacheKey
name|cacheKey
parameter_list|,
name|boolean
name|cacheBlock
parameter_list|,
name|boolean
name|useLock
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|boolean
name|updateCacheMetrics
parameter_list|,
name|BlockType
name|expectedBlockType
parameter_list|,
name|DataBlockEncoding
name|expectedDataBlockEncoding
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Check cache for block. If found return.
if|if
condition|(
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|BlockCache
name|cache
init|=
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
name|HFileBlock
name|cachedBlock
init|=
operator|(
name|HFileBlock
operator|)
name|cache
operator|.
name|getBlock
argument_list|(
name|cacheKey
argument_list|,
name|cacheBlock
argument_list|,
name|useLock
argument_list|,
name|updateCacheMetrics
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBlock
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cacheConf
operator|.
name|shouldCacheCompressed
argument_list|(
name|cachedBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|getCategory
argument_list|()
argument_list|)
condition|)
block|{
name|HFileBlock
name|compressedBlock
init|=
name|cachedBlock
decl_stmt|;
name|cachedBlock
operator|=
name|compressedBlock
operator|.
name|unpack
argument_list|(
name|hfileContext
argument_list|,
name|fsBlockReader
argument_list|)
expr_stmt|;
comment|// In case of compressed block after unpacking we can return the compressed block
if|if
condition|(
name|compressedBlock
operator|!=
name|cachedBlock
condition|)
block|{
name|cache
operator|.
name|returnBlock
argument_list|(
name|cacheKey
argument_list|,
name|compressedBlock
argument_list|)
expr_stmt|;
block|}
block|}
name|validateBlockType
argument_list|(
name|cachedBlock
argument_list|,
name|expectedBlockType
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedDataBlockEncoding
operator|==
literal|null
condition|)
block|{
return|return
name|cachedBlock
return|;
block|}
name|DataBlockEncoding
name|actualDataBlockEncoding
init|=
name|cachedBlock
operator|.
name|getDataBlockEncoding
argument_list|()
decl_stmt|;
comment|// Block types other than data blocks always have
comment|// DataBlockEncoding.NONE. To avoid false negative cache misses, only
comment|// perform this check if cached block is a data block.
if|if
condition|(
name|cachedBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|isData
argument_list|()
operator|&&
operator|!
name|actualDataBlockEncoding
operator|.
name|equals
argument_list|(
name|expectedDataBlockEncoding
argument_list|)
condition|)
block|{
comment|// This mismatch may happen if a Scanner, which is used for say a
comment|// compaction, tries to read an encoded block from the block cache.
comment|// The reverse might happen when an EncodedScanner tries to read
comment|// un-encoded blocks which were cached earlier.
comment|//
comment|// Because returning a data block with an implicit BlockType mismatch
comment|// will cause the requesting scanner to throw a disk read should be
comment|// forced here. This will potentially cause a significant number of
comment|// cache misses, so update so we should keep track of this as it might
comment|// justify the work on a CompoundScanner.
if|if
condition|(
operator|!
name|expectedDataBlockEncoding
operator|.
name|equals
argument_list|(
name|DataBlockEncoding
operator|.
name|NONE
argument_list|)
operator|&&
operator|!
name|actualDataBlockEncoding
operator|.
name|equals
argument_list|(
name|DataBlockEncoding
operator|.
name|NONE
argument_list|)
condition|)
block|{
comment|// If the block is encoded but the encoding does not match the
comment|// expected encoding it is likely the encoding was changed but the
comment|// block was not yet evicted. Evictions on file close happen async
comment|// so blocks with the old encoding still linger in cache for some
comment|// period of time. This event should be rare as it only happens on
comment|// schema definition change.
name|LOG
operator|.
name|info
argument_list|(
literal|"Evicting cached block with key "
operator|+
name|cacheKey
operator|+
literal|" because of a data block encoding mismatch"
operator|+
literal|"; expected: "
operator|+
name|expectedDataBlockEncoding
operator|+
literal|", actual: "
operator|+
name|actualDataBlockEncoding
argument_list|)
expr_stmt|;
comment|// This is an error scenario. so here we need to decrement the
comment|// count.
name|cache
operator|.
name|returnBlock
argument_list|(
name|cacheKey
argument_list|,
name|cachedBlock
argument_list|)
expr_stmt|;
name|cache
operator|.
name|evictBlock
argument_list|(
name|cacheKey
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
return|return
name|cachedBlock
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @param metaBlockName    * @param cacheBlock Add block to cache, if found    * @return block wrapped in a ByteBuffer, with header skipped    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|HFileBlock
name|getMetaBlock
parameter_list|(
name|String
name|metaBlockName
parameter_list|,
name|boolean
name|cacheBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|trailer
operator|.
name|getMetaIndexCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
comment|// there are no meta blocks
block|}
if|if
condition|(
name|metaBlockIndexReader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Meta index not loaded"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|mbname
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|metaBlockName
argument_list|)
decl_stmt|;
name|int
name|block
init|=
name|metaBlockIndexReader
operator|.
name|rootBlockContainingKey
argument_list|(
name|mbname
argument_list|,
literal|0
argument_list|,
name|mbname
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|==
operator|-
literal|1
condition|)
return|return
literal|null
return|;
name|long
name|blockSize
init|=
name|metaBlockIndexReader
operator|.
name|getRootBlockDataSize
argument_list|(
name|block
argument_list|)
decl_stmt|;
comment|// Per meta key from any given file, synchronize reads for said block. This
comment|// is OK to do for meta blocks because the meta block index is always
comment|// single-level.
synchronized|synchronized
init|(
name|metaBlockIndexReader
operator|.
name|getRootBlockKey
argument_list|(
name|block
argument_list|)
init|)
block|{
comment|// Check cache for block. If found return.
name|long
name|metaBlockOffset
init|=
name|metaBlockIndexReader
operator|.
name|getRootBlockOffset
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|BlockCacheKey
name|cacheKey
init|=
operator|new
name|BlockCacheKey
argument_list|(
name|name
argument_list|,
name|metaBlockOffset
argument_list|,
name|this
operator|.
name|isPrimaryReplicaReader
argument_list|()
argument_list|,
name|BlockType
operator|.
name|META
argument_list|)
decl_stmt|;
name|cacheBlock
operator|&=
name|cacheConf
operator|.
name|shouldCacheBlockOnRead
argument_list|(
name|BlockType
operator|.
name|META
operator|.
name|getCategory
argument_list|()
argument_list|)
expr_stmt|;
name|HFileBlock
name|cachedBlock
init|=
name|getCachedBlock
argument_list|(
name|cacheKey
argument_list|,
name|cacheBlock
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|BlockType
operator|.
name|META
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBlock
operator|!=
literal|null
condition|)
block|{
assert|assert
name|cachedBlock
operator|.
name|isUnpacked
argument_list|()
operator|:
literal|"Packed block leak."
assert|;
comment|// Return a distinct 'shallow copy' of the block,
comment|// so pos does not get messed by the scanner
return|return
name|cachedBlock
return|;
block|}
comment|// Cache Miss, please load.
name|HFileBlock
name|metaBlock
init|=
name|fsBlockReader
operator|.
name|readBlockData
argument_list|(
name|metaBlockOffset
argument_list|,
name|blockSize
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
operator|.
name|unpack
argument_list|(
name|hfileContext
argument_list|,
name|fsBlockReader
argument_list|)
decl_stmt|;
comment|// Cache the block
if|if
condition|(
name|cacheBlock
condition|)
block|{
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|ifPresent
argument_list|(
name|cache
lambda|->
name|cache
operator|.
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|metaBlock
argument_list|,
name|cacheConf
operator|.
name|isInMemory
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|metaBlock
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|HFileBlock
name|readBlock
parameter_list|(
name|long
name|dataBlockOffset
parameter_list|,
name|long
name|onDiskBlockSize
parameter_list|,
specifier|final
name|boolean
name|cacheBlock
parameter_list|,
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|,
name|boolean
name|updateCacheMetrics
parameter_list|,
name|BlockType
name|expectedBlockType
parameter_list|,
name|DataBlockEncoding
name|expectedDataBlockEncoding
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dataBlockIndexReader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block index not loaded"
argument_list|)
throw|;
block|}
name|long
name|trailerOffset
init|=
name|trailer
operator|.
name|getLoadOnOpenDataOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataBlockOffset
operator|<
literal|0
operator|||
name|dataBlockOffset
operator|>=
name|trailerOffset
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Requested block is out of range: "
operator|+
name|dataBlockOffset
operator|+
literal|", lastDataBlockOffset: "
operator|+
name|trailer
operator|.
name|getLastDataBlockOffset
argument_list|()
operator|+
literal|", trailer.getLoadOnOpenDataOffset: "
operator|+
name|trailerOffset
argument_list|)
throw|;
block|}
comment|// For any given block from any given file, synchronize reads for said
comment|// block.
comment|// Without a cache, this synchronizing is needless overhead, but really
comment|// the other choice is to duplicate work (which the cache would prevent you
comment|// from doing).
name|BlockCacheKey
name|cacheKey
init|=
operator|new
name|BlockCacheKey
argument_list|(
name|name
argument_list|,
name|dataBlockOffset
argument_list|,
name|this
operator|.
name|isPrimaryReplicaReader
argument_list|()
argument_list|,
name|expectedBlockType
argument_list|)
decl_stmt|;
name|boolean
name|useLock
init|=
literal|false
decl_stmt|;
name|IdLock
operator|.
name|Entry
name|lockEntry
init|=
literal|null
decl_stmt|;
try|try
init|(
name|TraceScope
name|traceScope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"HFileReaderImpl.readBlock"
argument_list|)
init|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|// Check cache for block. If found return.
if|if
condition|(
name|cacheConf
operator|.
name|shouldReadBlockFromCache
argument_list|(
name|expectedBlockType
argument_list|)
condition|)
block|{
if|if
condition|(
name|useLock
condition|)
block|{
name|lockEntry
operator|=
name|offsetLock
operator|.
name|getLockEntry
argument_list|(
name|dataBlockOffset
argument_list|)
expr_stmt|;
block|}
comment|// Try and get the block from the block cache. If the useLock variable is true then this
comment|// is the second time through the loop and it should not be counted as a block cache miss.
name|HFileBlock
name|cachedBlock
init|=
name|getCachedBlock
argument_list|(
name|cacheKey
argument_list|,
name|cacheBlock
argument_list|,
name|useLock
argument_list|,
name|isCompaction
argument_list|,
name|updateCacheMetrics
argument_list|,
name|expectedBlockType
argument_list|,
name|expectedDataBlockEncoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBlock
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"From Cache "
operator|+
name|cachedBlock
argument_list|)
expr_stmt|;
block|}
name|TraceUtil
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"blockCacheHit"
argument_list|)
expr_stmt|;
assert|assert
name|cachedBlock
operator|.
name|isUnpacked
argument_list|()
operator|:
literal|"Packed block leak."
assert|;
if|if
condition|(
name|cachedBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|isData
argument_list|()
condition|)
block|{
if|if
condition|(
name|updateCacheMetrics
condition|)
block|{
name|HFile
operator|.
name|DATABLOCK_READ_COUNT
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
comment|// Validate encoding type for data blocks. We include encoding
comment|// type in the cache key, and we expect it to match on a cache hit.
if|if
condition|(
name|cachedBlock
operator|.
name|getDataBlockEncoding
argument_list|()
operator|!=
name|dataBlockEncoder
operator|.
name|getDataBlockEncoding
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cached block under key "
operator|+
name|cacheKey
operator|+
literal|" "
operator|+
literal|"has wrong encoding: "
operator|+
name|cachedBlock
operator|.
name|getDataBlockEncoding
argument_list|()
operator|+
literal|" (expected: "
operator|+
name|dataBlockEncoder
operator|.
name|getDataBlockEncoding
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
comment|// Cache-hit. Return!
return|return
name|cachedBlock
return|;
block|}
if|if
condition|(
operator|!
name|useLock
operator|&&
name|cacheBlock
operator|&&
name|cacheConf
operator|.
name|shouldLockOnCacheMiss
argument_list|(
name|expectedBlockType
argument_list|)
condition|)
block|{
comment|// check cache again with lock
name|useLock
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
comment|// Carry on, please load.
block|}
name|TraceUtil
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"blockCacheMiss"
argument_list|)
expr_stmt|;
comment|// Load block from filesystem.
name|HFileBlock
name|hfileBlock
init|=
name|fsBlockReader
operator|.
name|readBlockData
argument_list|(
name|dataBlockOffset
argument_list|,
name|onDiskBlockSize
argument_list|,
name|pread
argument_list|,
operator|!
name|isCompaction
argument_list|)
decl_stmt|;
name|validateBlockType
argument_list|(
name|hfileBlock
argument_list|,
name|expectedBlockType
argument_list|)
expr_stmt|;
name|HFileBlock
name|unpacked
init|=
name|hfileBlock
operator|.
name|unpack
argument_list|(
name|hfileContext
argument_list|,
name|fsBlockReader
argument_list|)
decl_stmt|;
name|BlockType
operator|.
name|BlockCategory
name|category
init|=
name|hfileBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|getCategory
argument_list|()
decl_stmt|;
comment|// Cache the block if necessary
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|ifPresent
argument_list|(
name|cache
lambda|->
block|{
if|if
condition|(
name|cacheBlock
operator|&&
name|cacheConf
operator|.
name|shouldCacheBlockOnRead
argument_list|(
name|category
argument_list|)
condition|)
block|{
name|cache
operator|.
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|cacheConf
operator|.
name|shouldCacheCompressed
argument_list|(
name|category
argument_list|)
condition|?
name|hfileBlock
else|:
name|unpacked
argument_list|,
name|cacheConf
operator|.
name|isInMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|updateCacheMetrics
operator|&&
name|hfileBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|isData
argument_list|()
condition|)
block|{
name|HFile
operator|.
name|DATABLOCK_READ_COUNT
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
return|return
name|unpacked
return|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|lockEntry
operator|!=
literal|null
condition|)
block|{
name|offsetLock
operator|.
name|releaseLockEntry
argument_list|(
name|lockEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasMVCCInfo
parameter_list|()
block|{
return|return
name|includesMemstoreTS
operator|&&
name|decodeMemstoreTS
return|;
block|}
comment|/**    * Compares the actual type of a block retrieved from cache or disk with its    * expected type and throws an exception in case of a mismatch. Expected    * block type of {@link BlockType#DATA} is considered to match the actual    * block type [@link {@link BlockType#ENCODED_DATA} as well.    * @param block a block retrieved from cache or disk    * @param expectedBlockType the expected block type, or null to skip the    *          check    */
specifier|private
name|void
name|validateBlockType
parameter_list|(
name|HFileBlock
name|block
parameter_list|,
name|BlockType
name|expectedBlockType
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|expectedBlockType
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|BlockType
name|actualBlockType
init|=
name|block
operator|.
name|getBlockType
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectedBlockType
operator|.
name|isData
argument_list|()
operator|&&
name|actualBlockType
operator|.
name|isData
argument_list|()
condition|)
block|{
comment|// We consider DATA to match ENCODED_DATA for the purpose of this
comment|// verification.
return|return;
block|}
if|if
condition|(
name|actualBlockType
operator|!=
name|expectedBlockType
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected block type "
operator|+
name|expectedBlockType
operator|+
literal|", "
operator|+
literal|"but got "
operator|+
name|actualBlockType
operator|+
literal|": "
operator|+
name|block
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return Last key as cell in the file. May be null if file has no entries. Note that    *         this is not the last row key, but it is the Cell representation of the last    *         key    */
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|Cell
argument_list|>
name|getLastKey
parameter_list|()
block|{
return|return
name|dataBlockIndexReader
operator|.
name|isEmpty
argument_list|()
condition|?
name|Optional
operator|.
name|empty
argument_list|()
else|:
name|Optional
operator|.
name|of
argument_list|(
name|lastKeyCell
argument_list|)
return|;
block|}
comment|/**    * @return Midkey for this file. We work with block boundaries only so    *         returned midkey is an approximation only.    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|Cell
argument_list|>
name|midKey
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Optional
operator|.
name|ofNullable
argument_list|(
name|dataBlockIndexReader
operator|.
name|midkey
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|close
argument_list|(
name|cacheConf
operator|.
name|shouldEvictOnClose
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|evictOnClose
parameter_list|)
throws|throws
name|IOException
block|{
name|PrefetchExecutor
operator|.
name|cancel
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
operator|.
name|ifPresent
argument_list|(
name|cache
lambda|->
block|{
if|if
condition|(
name|evictOnClose
condition|)
block|{
name|int
name|numEvicted
init|=
name|cache
operator|.
name|evictBlocksByHfileName
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"On close, file="
operator|+
name|name
operator|+
literal|" evicted="
operator|+
name|numEvicted
operator|+
literal|" block(s)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|fsBlockReader
operator|.
name|closeStreams
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|DataBlockEncoding
name|getEffectiveEncodingInCache
parameter_list|(
name|boolean
name|isCompaction
parameter_list|)
block|{
return|return
name|dataBlockEncoder
operator|.
name|getEffectiveEncodingInCache
argument_list|(
name|isCompaction
argument_list|)
return|;
block|}
comment|/** For testing */
annotation|@
name|Override
specifier|public
name|HFileBlock
operator|.
name|FSReader
name|getUncachedBlockReader
parameter_list|()
block|{
return|return
name|fsBlockReader
return|;
block|}
comment|/**    * Scanner that operates on encoded data blocks.    */
specifier|protected
specifier|static
class|class
name|EncodedScanner
extends|extends
name|HFileScannerImpl
block|{
specifier|private
specifier|final
name|HFileBlockDecodingContext
name|decodingCtx
decl_stmt|;
specifier|private
specifier|final
name|DataBlockEncoder
operator|.
name|EncodedSeeker
name|seeker
decl_stmt|;
specifier|private
specifier|final
name|DataBlockEncoder
name|dataBlockEncoder
decl_stmt|;
specifier|public
name|EncodedScanner
parameter_list|(
name|HFile
operator|.
name|Reader
name|reader
parameter_list|,
name|boolean
name|cacheBlocks
parameter_list|,
name|boolean
name|pread
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|HFileContext
name|meta
parameter_list|)
block|{
name|super
argument_list|(
name|reader
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
name|DataBlockEncoding
name|encoding
init|=
name|reader
operator|.
name|getDataBlockEncoding
argument_list|()
decl_stmt|;
name|dataBlockEncoder
operator|=
name|encoding
operator|.
name|getEncoder
argument_list|()
expr_stmt|;
name|decodingCtx
operator|=
name|dataBlockEncoder
operator|.
name|newDataBlockDecodingContext
argument_list|(
name|meta
argument_list|)
expr_stmt|;
name|seeker
operator|=
name|dataBlockEncoder
operator|.
name|createSeeker
argument_list|(
name|reader
operator|.
name|getComparator
argument_list|()
argument_list|,
name|decodingCtx
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isSeeked
parameter_list|()
block|{
return|return
name|curBlock
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNonSeekedState
parameter_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
comment|/**      * Updates the current block to be the given {@link HFileBlock}. Seeks to      * the the first key/value pair.      *      * @param newBlock the block to make current      * @throws CorruptHFileException      */
annotation|@
name|Override
specifier|protected
name|void
name|updateCurrentBlock
parameter_list|(
name|HFileBlock
name|newBlock
parameter_list|)
throws|throws
name|CorruptHFileException
block|{
comment|// sanity checks
if|if
condition|(
name|newBlock
operator|.
name|getBlockType
argument_list|()
operator|!=
name|BlockType
operator|.
name|ENCODED_DATA
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"EncodedScanner works only on encoded data blocks"
argument_list|)
throw|;
block|}
name|short
name|dataBlockEncoderId
init|=
name|newBlock
operator|.
name|getDataBlockEncodingId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|DataBlockEncoding
operator|.
name|isCorrectEncoder
argument_list|(
name|dataBlockEncoder
argument_list|,
name|dataBlockEncoderId
argument_list|)
condition|)
block|{
name|String
name|encoderCls
init|=
name|dataBlockEncoder
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|CorruptHFileException
argument_list|(
literal|"Encoder "
operator|+
name|encoderCls
operator|+
literal|" doesn't support data block encoding "
operator|+
name|DataBlockEncoding
operator|.
name|getNameFromId
argument_list|(
name|dataBlockEncoderId
argument_list|)
argument_list|)
throw|;
block|}
name|updateCurrBlockRef
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
name|ByteBuff
name|encodedBuffer
init|=
name|getEncodedBuffer
argument_list|(
name|newBlock
argument_list|)
decl_stmt|;
name|seeker
operator|.
name|setCurrentBuffer
argument_list|(
name|encodedBuffer
argument_list|)
expr_stmt|;
name|blockFetches
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Reset the next indexed key
name|this
operator|.
name|nextIndexedKey
operator|=
literal|null
expr_stmt|;
block|}
specifier|private
name|ByteBuff
name|getEncodedBuffer
parameter_list|(
name|HFileBlock
name|newBlock
parameter_list|)
block|{
name|ByteBuff
name|origBlock
init|=
name|newBlock
operator|.
name|getBufferReadOnly
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|newBlock
operator|.
name|headerSize
argument_list|()
operator|+
name|DataBlockEncoding
operator|.
name|ID_SIZE
decl_stmt|;
name|origBlock
operator|.
name|position
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|origBlock
operator|.
name|limit
argument_list|(
name|pos
operator|+
name|newBlock
operator|.
name|getUncompressedSizeWithoutHeader
argument_list|()
operator|-
name|DataBlockEncoding
operator|.
name|ID_SIZE
argument_list|)
expr_stmt|;
return|return
name|origBlock
operator|.
name|slice
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|processFirstDataBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|seeker
operator|.
name|rewind
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|isValid
init|=
name|seeker
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isValid
condition|)
block|{
name|HFileBlock
name|newBlock
init|=
name|readNextDataBlock
argument_list|()
decl_stmt|;
name|isValid
operator|=
name|newBlock
operator|!=
literal|null
expr_stmt|;
if|if
condition|(
name|isValid
condition|)
block|{
name|updateCurrentBlock
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setNonSeekedState
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|isValid
return|;
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|getKey
parameter_list|()
block|{
name|assertValidSeek
argument_list|()
expr_stmt|;
return|return
name|seeker
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getValue
parameter_list|()
block|{
name|assertValidSeek
argument_list|()
expr_stmt|;
return|return
name|seeker
operator|.
name|getValueShallowCopy
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|getCell
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|curBlock
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|seeker
operator|.
name|getCell
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getKeyString
parameter_list|()
block|{
return|return
name|CellUtil
operator|.
name|toString
argument_list|(
name|getKey
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getValueString
parameter_list|()
block|{
name|ByteBuffer
name|valueBuffer
init|=
name|getValue
argument_list|()
decl_stmt|;
return|return
name|ByteBufferUtils
operator|.
name|toStringBinary
argument_list|(
name|valueBuffer
argument_list|)
return|;
block|}
specifier|private
name|void
name|assertValidSeek
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|curBlock
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NotSeekedException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|Cell
name|getFirstKeyCellInBlock
parameter_list|(
name|HFileBlock
name|curBlock
parameter_list|)
block|{
return|return
name|dataBlockEncoder
operator|.
name|getFirstKeyCellInBlock
argument_list|(
name|getEncodedBuffer
argument_list|(
name|curBlock
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|loadBlockAndSeekToKey
parameter_list|(
name|HFileBlock
name|seekToBlock
parameter_list|,
name|Cell
name|nextIndexedKey
parameter_list|,
name|boolean
name|rewind
parameter_list|,
name|Cell
name|key
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|curBlock
operator|==
literal|null
operator|||
name|this
operator|.
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|!=
name|seekToBlock
operator|.
name|getOffset
argument_list|()
condition|)
block|{
name|updateCurrentBlock
argument_list|(
name|seekToBlock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rewind
condition|)
block|{
name|seeker
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|nextIndexedKey
operator|=
name|nextIndexedKey
expr_stmt|;
return|return
name|seeker
operator|.
name|seekToKeyInBlock
argument_list|(
name|key
argument_list|,
name|seekBefore
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareKey
parameter_list|(
name|CellComparator
name|comparator
parameter_list|,
name|Cell
name|key
parameter_list|)
block|{
return|return
name|seeker
operator|.
name|compareKey
argument_list|(
name|comparator
argument_list|,
name|key
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a buffer with the Bloom filter metadata. The caller takes    * ownership of the buffer.    */
annotation|@
name|Override
specifier|public
name|DataInput
name|getGeneralBloomFilterMetadata
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|getBloomFilterMetadata
argument_list|(
name|BlockType
operator|.
name|GENERAL_BLOOM_META
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|DataInput
name|getDeleteBloomFilterMetadata
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|getBloomFilterMetadata
argument_list|(
name|BlockType
operator|.
name|DELETE_FAMILY_BLOOM_META
argument_list|)
return|;
block|}
specifier|private
name|DataInput
name|getBloomFilterMetadata
parameter_list|(
name|BlockType
name|blockType
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blockType
operator|!=
name|BlockType
operator|.
name|GENERAL_BLOOM_META
operator|&&
name|blockType
operator|!=
name|BlockType
operator|.
name|DELETE_FAMILY_BLOOM_META
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Block Type: "
operator|+
name|blockType
operator|.
name|toString
argument_list|()
operator|+
literal|" is not supported"
argument_list|)
throw|;
block|}
for|for
control|(
name|HFileBlock
name|b
range|:
name|loadOnOpenBlocks
control|)
if|if
condition|(
name|b
operator|.
name|getBlockType
argument_list|()
operator|==
name|blockType
condition|)
return|return
name|b
operator|.
name|getByteStream
argument_list|()
return|;
return|return
literal|null
return|;
block|}
specifier|public
name|boolean
name|isFileInfoLoaded
parameter_list|()
block|{
return|return
literal|true
return|;
comment|// We load file info in constructor in version 2.
block|}
annotation|@
name|Override
specifier|public
name|HFileContext
name|getFileContext
parameter_list|()
block|{
return|return
name|hfileContext
return|;
block|}
comment|/**    * Returns false if block prefetching was requested for this file and has    * not completed, true otherwise    */
annotation|@
name|Override
annotation|@
name|VisibleForTesting
specifier|public
name|boolean
name|prefetchComplete
parameter_list|()
block|{
return|return
name|PrefetchExecutor
operator|.
name|isCompleted
argument_list|(
name|path
argument_list|)
return|;
block|}
specifier|protected
name|HFileContext
name|createHFileContext
parameter_list|(
name|FSDataInputStreamWrapper
name|fsdis
parameter_list|,
name|long
name|fileSize
parameter_list|,
name|HFileSystem
name|hfs
parameter_list|,
name|Path
name|path
parameter_list|,
name|FixedFileTrailer
name|trailer
parameter_list|)
throws|throws
name|IOException
block|{
name|HFileContextBuilder
name|builder
init|=
operator|new
name|HFileContextBuilder
argument_list|()
operator|.
name|withIncludesMvcc
argument_list|(
name|shouldIncludeMemStoreTS
argument_list|()
argument_list|)
operator|.
name|withHBaseCheckSum
argument_list|(
literal|true
argument_list|)
operator|.
name|withHFileName
argument_list|(
name|this
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|withCompression
argument_list|(
name|this
operator|.
name|compressAlgo
argument_list|)
decl_stmt|;
comment|// Check for any key material available
name|byte
index|[]
name|keyBytes
init|=
name|trailer
operator|.
name|getEncryptionKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyBytes
operator|!=
literal|null
condition|)
block|{
name|Encryption
operator|.
name|Context
name|cryptoContext
init|=
name|Encryption
operator|.
name|newContext
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Key
name|key
decl_stmt|;
name|key
operator|=
name|EncryptionUtil
operator|.
name|unwrapKey
argument_list|(
name|conf
argument_list|,
name|keyBytes
argument_list|)
expr_stmt|;
comment|// Use the algorithm the key wants
name|Cipher
name|cipher
init|=
name|Encryption
operator|.
name|getCipher
argument_list|(
name|conf
argument_list|,
name|key
operator|.
name|getAlgorithm
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cipher
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cipher '"
operator|+
name|key
operator|.
name|getAlgorithm
argument_list|()
operator|+
literal|"' is not available"
argument_list|)
throw|;
block|}
name|cryptoContext
operator|.
name|setCipher
argument_list|(
name|cipher
argument_list|)
expr_stmt|;
name|cryptoContext
operator|.
name|setKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|builder
operator|.
name|withEncryptionContext
argument_list|(
name|cryptoContext
argument_list|)
expr_stmt|;
block|}
name|HFileContext
name|context
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Reader"
operator|+
operator|(
name|path
operator|!=
literal|null
condition|?
literal|" for "
operator|+
name|path
else|:
literal|""
operator|)
operator|+
literal|" initialized with cacheConf: "
operator|+
name|cacheConf
operator|+
literal|" comparator: "
operator|+
name|comparator
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" fileContext: "
operator|+
name|context
argument_list|)
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
comment|/**    * Create a Scanner on this file. No seeks or reads are done on creation. Call    * {@link HFileScanner#seekTo(Cell)} to position an start the read. There is    * nothing to clean up in a Scanner. Letting go of your references to the    * scanner is sufficient. NOTE: Do not use this overload of getScanner for    * compactions. See {@link #getScanner(boolean, boolean, boolean)}    *    * @param cacheBlocks True if we should cache blocks read in by this scanner.    * @param pread Use positional read rather than seek+read if true (pread is    *          better for random reads, seek+read is better scanning).    * @return Scanner on this file.    */
annotation|@
name|Override
annotation|@
name|VisibleForTesting
specifier|public
name|HFileScanner
name|getScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|)
block|{
return|return
name|getScanner
argument_list|(
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Create a Scanner on this file. No seeks or reads are done on creation. Call    * {@link HFileScanner#seekTo(Cell)} to position an start the read. There is    * nothing to clean up in a Scanner. Letting go of your references to the    * scanner is sufficient.    * @param cacheBlocks    *          True if we should cache blocks read in by this scanner.    * @param pread    *          Use positional read rather than seek+read if true (pread is better    *          for random reads, seek+read is better scanning).    * @param isCompaction    *          is scanner being used for a compaction?    * @return Scanner on this file.    */
annotation|@
name|Override
specifier|public
name|HFileScanner
name|getScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
block|{
if|if
condition|(
name|dataBlockEncoder
operator|.
name|useEncodedScanner
argument_list|()
condition|)
block|{
return|return
operator|new
name|EncodedScanner
argument_list|(
name|this
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
name|this
operator|.
name|hfileContext
argument_list|)
return|;
block|}
return|return
operator|new
name|HFileScannerImpl
argument_list|(
name|this
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
return|;
block|}
specifier|public
name|int
name|getMajorVersion
parameter_list|()
block|{
return|return
literal|3
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|unbufferStream
parameter_list|()
block|{
name|fsBlockReader
operator|.
name|unbufferStream
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

