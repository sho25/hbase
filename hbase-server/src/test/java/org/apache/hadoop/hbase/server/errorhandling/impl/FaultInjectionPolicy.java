begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|server
operator|.
name|errorhandling
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_comment
comment|/**  * Decoratable policy for if a fault should be injected for a given stack trace.  *<p>  * Passed in policies are combined with the current policy via a {@link PolicyCombination}.  *<p>  * Using {@link PolicyCombination#AND} means that<i>all</i> policies must agree to inject a fault  * (including the current implemented) before a fault is injected.  *<p>  * Using {@link PolicyCombination#OR} means that if<i>any</i> of the policies may assert that a  * fault be injected, in which case all remaining injectors will be ignored.  *<p>  * Order of operations occurs in reverse order of the operations added via  * {@link #and(FaultInjectionPolicy)} or {@link #or(FaultInjectionPolicy)}. For example, if this is  * the default policy 'a', which we {@link #and(FaultInjectionPolicy)} with 'b' and then 'c', we get  * the following policy chain:  *<p>  * a&& (b&& c)  *<p>  * Similarly, if this is the default policy 'a', which we {@link #or(FaultInjectionPolicy)} with 'b'  * and then 'c', we get the following policy chain:  *<p>  * a || (b || c).  *<p>  * Naturally, more complex policies can then be built using this style. Suppose we have policy A,  * which is actually the 'and' of two policies, a and b:  *<p>  * A = a&& b  *<p>  * and similarly we also have B which is an 'or' of c and d:  *<p>  * B = c || d  *<p>  * then we could combine the two by calling A {@link #and(FaultInjectionPolicy)} B, to get:  *<p>  * A&& B = (a&& b)&& (c || d)  */
end_comment

begin_class
specifier|public
class|class
name|FaultInjectionPolicy
block|{
specifier|public
enum|enum
name|PolicyCombination
block|{
name|AND
block|,
name|OR
block|;
comment|/**      * Apply the combination to the policy outputs      * @param current current policy value      * @param next next policy to value to consider      * @return<tt>true</tt> if the logical combination is valid,<tt>false</tt> otherwise      */
specifier|public
name|boolean
name|apply
parameter_list|(
name|boolean
name|current
parameter_list|,
name|boolean
name|next
parameter_list|)
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|AND
case|:
return|return
name|current
operator|&&
name|next
return|;
case|case
name|OR
case|:
return|return
name|current
operator|||
name|next
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unrecognized policy!"
operator|+
name|this
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|List
argument_list|<
name|Pair
argument_list|<
name|PolicyCombination
argument_list|,
name|FaultInjectionPolicy
argument_list|>
argument_list|>
name|policies
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|PolicyCombination
argument_list|,
name|FaultInjectionPolicy
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * And the current chain with another policy.    *<p>    * For example, if this is the default policy 'a', which we {@link #and(FaultInjectionPolicy)}    * with 'b' and then 'c', we get the following policy chain:    *<p>    * a&& (b&& c)    * @param policy policy to logical AND with the current policies    * @return<tt>this</tt> for chaining    */
specifier|public
name|FaultInjectionPolicy
name|and
parameter_list|(
name|FaultInjectionPolicy
name|policy
parameter_list|)
block|{
return|return
name|addPolicy
argument_list|(
name|PolicyCombination
operator|.
name|AND
argument_list|,
name|policy
argument_list|)
return|;
block|}
comment|/**    * And the current chain with another policy.    *<p>    * For example, if this is the default policy 'a', which we {@link #or(FaultInjectionPolicy)} with    * 'b' and then 'c', we get the following policy chain:    *<p>    * a || (b || c)    * @param policy policy to logical OR with the current policies    * @return<tt>this</tt> for chaining    */
specifier|public
name|FaultInjectionPolicy
name|or
parameter_list|(
name|FaultInjectionPolicy
name|policy
parameter_list|)
block|{
return|return
name|addPolicy
argument_list|(
name|PolicyCombination
operator|.
name|OR
argument_list|,
name|policy
argument_list|)
return|;
block|}
specifier|private
name|FaultInjectionPolicy
name|addPolicy
parameter_list|(
name|PolicyCombination
name|combinator
parameter_list|,
name|FaultInjectionPolicy
name|policy
parameter_list|)
block|{
name|policies
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<
name|PolicyCombination
argument_list|,
name|FaultInjectionPolicy
argument_list|>
argument_list|(
name|combinator
argument_list|,
name|policy
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Check to see if this, or any of the policies this decorates, find that a fault should be    * injected .    * @param stack    * @return<tt>true</tt> if a fault should be injected,<tt>false</tt> otherwise.    */
specifier|public
specifier|final
name|boolean
name|shouldFault
parameter_list|(
name|StackTraceElement
index|[]
name|stack
parameter_list|)
block|{
name|boolean
name|current
init|=
name|checkForFault
argument_list|(
name|stack
argument_list|)
decl_stmt|;
return|return
name|eval
argument_list|(
name|current
argument_list|,
name|policies
argument_list|,
name|stack
argument_list|)
return|;
block|}
comment|/**    * @param current    * @param policies2    * @param stack    * @return    */
specifier|private
name|boolean
name|eval
parameter_list|(
name|boolean
name|current
parameter_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|PolicyCombination
argument_list|,
name|FaultInjectionPolicy
argument_list|>
argument_list|>
name|policies
parameter_list|,
name|StackTraceElement
index|[]
name|stack
parameter_list|)
block|{
comment|// base condition: if there are no more to evaluate, the comparison is the last
if|if
condition|(
name|policies
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
name|current
return|;
comment|// otherwise we have to evaluate the rest of chain
name|Pair
argument_list|<
name|PolicyCombination
argument_list|,
name|FaultInjectionPolicy
argument_list|>
name|policy
init|=
name|policies
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|boolean
name|next
init|=
name|policy
operator|.
name|getSecond
argument_list|()
operator|.
name|shouldFault
argument_list|(
name|stack
argument_list|)
decl_stmt|;
return|return
name|policy
operator|.
name|getFirst
argument_list|()
operator|.
name|apply
argument_list|(
name|current
argument_list|,
name|eval
argument_list|(
name|next
argument_list|,
name|policies
operator|.
name|subList
argument_list|(
literal|1
argument_list|,
name|policies
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|stack
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Check to see if we should generate a fault for the given stacktrace.    *<p>    * Subclass hook for providing custom fault checking behavior    * @param stack    * @return if a fault should be injected for this error check request.<tt>false</tt> by default    */
specifier|protected
name|boolean
name|checkForFault
parameter_list|(
name|StackTraceElement
index|[]
name|stack
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

