begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mapreduce
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|LargeTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|VerySlowMapReduceTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_comment
comment|/**  * TestTableInputFormatScan part 1.  * @see TestTableInputFormatScanBase  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
block|{
name|VerySlowMapReduceTests
operator|.
name|class
block|,
name|LargeTests
operator|.
name|class
block|}
argument_list|)
specifier|public
class|class
name|TestTableInputFormatScan1
extends|extends
name|TestTableInputFormatScanBase
block|{
comment|/**    * Tests a MR scan using specific start and stop rows.    *    * @throws IOException    * @throws ClassNotFoundException    * @throws InterruptedException    */
annotation|@
name|Test
specifier|public
name|void
name|testScanEmptyToEmpty
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|testScan
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests a MR scan using specific start and stop rows.    *    * @throws IOException    * @throws ClassNotFoundException    * @throws InterruptedException    */
annotation|@
name|Test
specifier|public
name|void
name|testScanEmptyToAPP
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|testScan
argument_list|(
literal|null
argument_list|,
literal|"app"
argument_list|,
literal|"apo"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests a MR scan using specific start and stop rows.    *    * @throws IOException    * @throws ClassNotFoundException    * @throws InterruptedException    */
annotation|@
name|Test
specifier|public
name|void
name|testScanEmptyToBBA
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|testScan
argument_list|(
literal|null
argument_list|,
literal|"bba"
argument_list|,
literal|"baz"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests a MR scan using specific start and stop rows.    *    * @throws IOException    * @throws ClassNotFoundException    * @throws InterruptedException    */
annotation|@
name|Test
specifier|public
name|void
name|testScanEmptyToBBB
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|testScan
argument_list|(
literal|null
argument_list|,
literal|"bbb"
argument_list|,
literal|"bba"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests a MR scan using specific start and stop rows.    *    * @throws IOException    * @throws ClassNotFoundException    * @throws InterruptedException    */
annotation|@
name|Test
specifier|public
name|void
name|testScanEmptyToOPP
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|testScan
argument_list|(
literal|null
argument_list|,
literal|"opp"
argument_list|,
literal|"opo"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests a MR scan using specific number of mappers. The test table has 25 regions,    * and all region sizes are set as 0 as default. The average region size is 1 (the smallest    * positive). When we set hbase.mapreduce.input.ratio as -1, all regions will be cut into two    * MapRedcue input splits, the number of MR input splits should be 50; when we set hbase    * .mapreduce.input.ratio as 100, the sum of all region sizes is less then the average region    * size, all regions will be combined into 1 MapRedcue input split.    *    * @throws IOException    * @throws ClassNotFoundException    * @throws InterruptedException    */
annotation|@
name|Test
specifier|public
name|void
name|testGetSplits
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|testNumOfSplits
argument_list|(
literal|"-1"
argument_list|,
literal|52
argument_list|)
expr_stmt|;
name|testNumOfSplits
argument_list|(
literal|"100"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests the getSplitKey() method in TableInputFormatBase.java    *    * @throws IOException    * @throws ClassNotFoundException    * @throws InterruptedException    */
annotation|@
name|Test
specifier|public
name|void
name|testGetSplitsPoint
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|byte
index|[]
name|start1
init|=
block|{
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
name|byte
index|[]
name|end1
init|=
block|{
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|,
literal|'f'
block|,
literal|'f'
block|}
decl_stmt|;
name|byte
index|[]
name|splitPoint1
init|=
block|{
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|,
literal|'d'
block|,
literal|'d'
block|,
operator|-
literal|78
block|,
literal|50
block|,
operator|-
literal|77
block|}
decl_stmt|;
name|testGetSplitKey
argument_list|(
name|start1
argument_list|,
name|end1
argument_list|,
name|splitPoint1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|byte
index|[]
name|start2
init|=
block|{
literal|'1'
block|,
literal|'1'
block|,
literal|'1'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|}
decl_stmt|;
name|byte
index|[]
name|end2
init|=
block|{
literal|'1'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'5'
block|,
literal|'7'
block|,
literal|'9'
block|,
literal|'0'
block|}
decl_stmt|;
name|byte
index|[]
name|splitPoint2
init|=
block|{
literal|'1'
block|,
literal|'1'
block|,
literal|'1'
block|,
operator|-
literal|78
block|,
operator|-
literal|77
block|,
operator|-
literal|76
block|,
operator|-
literal|104
block|}
decl_stmt|;
name|testGetSplitKey
argument_list|(
name|start2
argument_list|,
name|end2
argument_list|,
name|splitPoint2
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|byte
index|[]
name|start3
init|=
block|{
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|}
decl_stmt|;
name|byte
index|[]
name|end3
init|=
block|{
literal|'a'
block|,
literal|'a'
block|,
literal|'b'
block|}
decl_stmt|;
name|byte
index|[]
name|splitPoint3
init|=
block|{
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|,
operator|-
literal|80
block|,
operator|-
literal|80
block|,
operator|-
literal|80
block|}
decl_stmt|;
name|testGetSplitKey
argument_list|(
name|start3
argument_list|,
name|end3
argument_list|,
name|splitPoint3
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|byte
index|[]
name|start4
init|=
block|{
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|}
decl_stmt|;
name|byte
index|[]
name|end4
init|=
block|{
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|,
literal|'z'
block|}
decl_stmt|;
name|byte
index|[]
name|splitPoint4
init|=
block|{
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|,
literal|'='
block|}
decl_stmt|;
name|testGetSplitKey
argument_list|(
name|start4
argument_list|,
name|end4
argument_list|,
name|splitPoint4
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|byte
index|[]
name|start5
init|=
block|{
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|}
decl_stmt|;
name|byte
index|[]
name|end5
init|=
block|{
literal|'a'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'a'
block|}
decl_stmt|;
name|byte
index|[]
name|splitPoint5
init|=
block|{
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|,
operator|-
literal|80
block|}
decl_stmt|;
name|testGetSplitKey
argument_list|(
name|start5
argument_list|,
name|end5
argument_list|,
name|splitPoint5
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Test Case 6: empty key and "hhhqqqwww", split point is "h"
name|byte
index|[]
name|start6
init|=
block|{}
decl_stmt|;
name|byte
index|[]
name|end6
init|=
block|{
literal|'h'
block|,
literal|'h'
block|,
literal|'h'
block|,
literal|'q'
block|,
literal|'q'
block|,
literal|'q'
block|,
literal|'w'
block|,
literal|'w'
block|}
decl_stmt|;
name|byte
index|[]
name|splitPointText6
init|=
block|{
literal|'h'
block|}
decl_stmt|;
name|byte
index|[]
name|splitPointBinary6
init|=
block|{
literal|104
block|}
decl_stmt|;
name|testGetSplitKey
argument_list|(
name|start6
argument_list|,
name|end6
argument_list|,
name|splitPointText6
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|testGetSplitKey
argument_list|(
name|start6
argument_list|,
name|end6
argument_list|,
name|splitPointBinary6
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Test Case 7: "ffffaaa" and empty key, split point depends on the mode we choose(text key or
comment|// binary key).
name|byte
index|[]
name|start7
init|=
block|{
literal|'f'
block|,
literal|'f'
block|,
literal|'f'
block|,
literal|'f'
block|,
literal|'a'
block|,
literal|'a'
block|,
literal|'a'
block|}
decl_stmt|;
name|byte
index|[]
name|end7
init|=
block|{}
decl_stmt|;
name|byte
index|[]
name|splitPointText7
init|=
block|{
literal|'f'
block|,
literal|'~'
block|,
literal|'~'
block|,
literal|'~'
block|,
literal|'~'
block|,
literal|'~'
block|,
literal|'~'
block|}
decl_stmt|;
name|byte
index|[]
name|splitPointBinary7
init|=
block|{
literal|'f'
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|testGetSplitKey
argument_list|(
name|start7
argument_list|,
name|end7
argument_list|,
name|splitPointText7
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|testGetSplitKey
argument_list|(
name|start7
argument_list|,
name|end7
argument_list|,
name|splitPointBinary7
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Test Case 8: both start key and end key are empty. Split point depends on the mode we
comment|// choose (text key or binary key).
name|byte
index|[]
name|start8
init|=
block|{}
decl_stmt|;
name|byte
index|[]
name|end8
init|=
block|{}
decl_stmt|;
name|byte
index|[]
name|splitPointText8
init|=
block|{
literal|'O'
block|}
decl_stmt|;
name|byte
index|[]
name|splitPointBinary8
init|=
block|{
literal|0
block|}
decl_stmt|;
name|testGetSplitKey
argument_list|(
name|start8
argument_list|,
name|end8
argument_list|,
name|splitPointText8
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|testGetSplitKey
argument_list|(
name|start8
argument_list|,
name|end8
argument_list|,
name|splitPointBinary8
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Test Case 9: Binary Key example
name|byte
index|[]
name|start9
init|=
block|{
literal|13
block|,
operator|-
literal|19
block|,
literal|126
block|,
literal|127
block|}
decl_stmt|;
name|byte
index|[]
name|end9
init|=
block|{
literal|13
block|,
operator|-
literal|19
block|,
literal|127
block|,
literal|0
block|}
decl_stmt|;
name|byte
index|[]
name|splitPoint9
init|=
block|{
literal|13
block|,
operator|-
literal|19
block|,
literal|126
block|,
operator|-
literal|65
block|}
decl_stmt|;
name|testGetSplitKey
argument_list|(
name|start9
argument_list|,
name|end9
argument_list|,
name|splitPoint9
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Test Case 10: Binary key split when the start key is an unsigned byte and the end byte is a
comment|// signed byte
name|byte
index|[]
name|start10
init|=
block|{
literal|'x'
block|}
decl_stmt|;
name|byte
index|[]
name|end10
init|=
block|{
operator|-
literal|128
block|}
decl_stmt|;
name|byte
index|[]
name|splitPoint10
init|=
block|{
literal|'|'
block|}
decl_stmt|;
name|testGetSplitKey
argument_list|(
name|start10
argument_list|,
name|end10
argument_list|,
name|splitPoint10
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Test Case 11: Binary key split when the start key is an signed byte and the end byte is a
comment|// signed byte
name|byte
index|[]
name|start11
init|=
block|{
operator|-
literal|100
block|}
decl_stmt|;
name|byte
index|[]
name|end11
init|=
block|{
operator|-
literal|90
block|}
decl_stmt|;
name|byte
index|[]
name|splitPoint11
init|=
block|{
operator|-
literal|95
block|}
decl_stmt|;
name|testGetSplitKey
argument_list|(
name|start11
argument_list|,
name|end11
argument_list|,
name|splitPoint11
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

