begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StripeStoreFileManager
operator|.
name|OPEN_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|RegionServerTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|SmallTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_class
annotation|@
name|Category
argument_list|(
block|{
name|RegionServerTests
operator|.
name|class
block|,
name|SmallTests
operator|.
name|class
block|}
argument_list|)
specifier|public
class|class
name|TestStripeStoreFileManager
block|{
specifier|private
specifier|static
specifier|final
name|HBaseTestingUtility
name|TEST_UTIL
init|=
operator|new
name|HBaseTestingUtility
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Path
name|BASEDIR
init|=
name|TEST_UTIL
operator|.
name|getDataTestDir
argument_list|(
name|TestStripeStoreFileManager
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Path
name|CFDIR
init|=
name|HStore
operator|.
name|getStoreHomedir
argument_list|(
name|BASEDIR
argument_list|,
literal|"region"
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cf"
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|KEY_A
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"aaa"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|KEY_B
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"bbb"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|KEY_C
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"ccc"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|KEY_D
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"ddd"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|KeyValue
name|KV_A
init|=
operator|new
name|KeyValue
argument_list|(
name|KEY_A
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|KeyValue
name|KV_B
init|=
operator|new
name|KeyValue
argument_list|(
name|KEY_B
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|KeyValue
name|KV_C
init|=
operator|new
name|KeyValue
argument_list|(
name|KEY_C
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|KeyValue
name|KV_D
init|=
operator|new
name|KeyValue
argument_list|(
name|KEY_D
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|TEST_UTIL
operator|.
name|getTestFileSystem
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|mkdirs
argument_list|(
name|CFDIR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot create test directory "
operator|+
name|CFDIR
argument_list|)
throw|;
block|}
block|}
annotation|@
name|After
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|TEST_UTIL
operator|.
name|getTestFileSystem
argument_list|()
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|CFDIR
argument_list|)
operator|&&
operator|!
name|fs
operator|.
name|delete
argument_list|(
name|CFDIR
argument_list|,
literal|true
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot delete test directory "
operator|+
name|CFDIR
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInsertFilesIntoL0
parameter_list|()
throws|throws
name|Exception
block|{
name|StripeStoreFileManager
name|manager
init|=
name|createManager
argument_list|()
decl_stmt|;
name|MockStoreFile
name|sf
init|=
name|createFile
argument_list|()
decl_stmt|;
name|manager
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|sf
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|manager
operator|.
name|getStorefileCount
argument_list|()
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|filesForGet
init|=
name|manager
operator|.
name|getFilesForScan
argument_list|(
name|KEY_A
argument_list|,
literal|true
argument_list|,
name|KEY_A
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|filesForGet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|filesForGet
operator|.
name|contains
argument_list|(
name|sf
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add some stripes and make sure we get this file for every stripe.
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|()
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|manager
operator|.
name|getFilesForScan
argument_list|(
name|KEY_A
argument_list|,
literal|true
argument_list|,
name|KEY_A
argument_list|,
literal|true
argument_list|)
operator|.
name|contains
argument_list|(
name|sf
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|manager
operator|.
name|getFilesForScan
argument_list|(
name|KEY_C
argument_list|,
literal|true
argument_list|,
name|KEY_C
argument_list|,
literal|true
argument_list|)
operator|.
name|contains
argument_list|(
name|sf
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testClearFiles
parameter_list|()
throws|throws
name|Exception
block|{
name|StripeStoreFileManager
name|manager
init|=
name|createManager
argument_list|()
decl_stmt|;
name|manager
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|createFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|createFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|()
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|manager
operator|.
name|getStorefileCount
argument_list|()
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|allFiles
init|=
name|manager
operator|.
name|clearFiles
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|allFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|manager
operator|.
name|getStorefileCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|manager
operator|.
name|getStorefiles
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|dumpIterator
parameter_list|(
name|Iterator
argument_list|<
name|StoreFile
argument_list|>
name|iter
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
name|result
operator|.
name|add
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
control|)
empty_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowKeyBefore
parameter_list|()
throws|throws
name|Exception
block|{
name|StripeStoreFileManager
name|manager
init|=
name|createManager
argument_list|()
decl_stmt|;
name|StoreFile
name|l0File
init|=
name|createFile
argument_list|()
decl_stmt|,
name|l0File2
init|=
name|createFile
argument_list|()
decl_stmt|;
name|manager
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|l0File
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|l0File2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Get candidate files.
name|Iterator
argument_list|<
name|StoreFile
argument_list|>
name|sfs
init|=
name|manager
operator|.
name|getCandidateFilesForRowKeyBefore
argument_list|(
name|KV_B
argument_list|)
decl_stmt|;
name|sfs
operator|.
name|next
argument_list|()
expr_stmt|;
name|sfs
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|// Suppose we found a candidate in this file... make sure L0 file remaining is not removed.
name|sfs
operator|=
name|manager
operator|.
name|updateCandidateFilesForRowKeyBefore
argument_list|(
name|sfs
argument_list|,
name|KV_B
argument_list|,
name|KV_A
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|sfs
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now add some stripes (remove L0 file too)
name|MockStoreFile
name|stripe0a
init|=
name|createFile
argument_list|(
literal|0
argument_list|,
literal|100
argument_list|,
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
decl_stmt|,
name|stripe1
init|=
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|OPEN_KEY
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|l0File
argument_list|)
argument_list|,
name|al
argument_list|(
name|stripe0a
argument_list|,
name|stripe1
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|l0File
argument_list|)
argument_list|)
expr_stmt|;
comment|// If we want a key<= KEY_A, we should get everything except stripe1.
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|sfsDump
init|=
name|dumpIterator
argument_list|(
name|manager
operator|.
name|getCandidateFilesForRowKeyBefore
argument_list|(
name|KV_A
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|sfsDump
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|sfsDump
operator|.
name|contains
argument_list|(
name|stripe0a
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|sfsDump
operator|.
name|contains
argument_list|(
name|stripe1
argument_list|)
argument_list|)
expr_stmt|;
comment|// If we want a key<= KEY_B, we should get everything since lower bound is inclusive.
name|sfsDump
operator|=
name|dumpIterator
argument_list|(
name|manager
operator|.
name|getCandidateFilesForRowKeyBefore
argument_list|(
name|KV_B
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|sfsDump
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|sfsDump
operator|.
name|contains
argument_list|(
name|stripe1
argument_list|)
argument_list|)
expr_stmt|;
comment|// For KEY_D, we should also get everything.
name|sfsDump
operator|=
name|dumpIterator
argument_list|(
name|manager
operator|.
name|getCandidateFilesForRowKeyBefore
argument_list|(
name|KV_D
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|sfsDump
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Suppose in the first file we found candidate with KEY_C.
comment|// Then, stripe0 no longer matters and should be removed, but stripe1 should stay.
name|sfs
operator|=
name|manager
operator|.
name|getCandidateFilesForRowKeyBefore
argument_list|(
name|KV_D
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// Skip L0 file.
name|sfs
operator|.
name|remove
argument_list|()
expr_stmt|;
name|sfs
operator|=
name|manager
operator|.
name|updateCandidateFilesForRowKeyBefore
argument_list|(
name|sfs
argument_list|,
name|KV_D
argument_list|,
name|KV_C
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|stripe1
argument_list|,
name|sfs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|sfs
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|// Add one more, later, file to stripe0, remove the last annoying L0 file.
comment|// This file should be returned in preference to older L0 file; also, after we get
comment|// a candidate from the first file, the old one should not be removed.
name|StoreFile
name|stripe0b
init|=
name|createFile
argument_list|(
literal|0
argument_list|,
literal|101
argument_list|,
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|l0File2
argument_list|)
argument_list|,
name|al
argument_list|(
name|stripe0b
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|l0File2
argument_list|)
argument_list|)
expr_stmt|;
name|sfs
operator|=
name|manager
operator|.
name|getCandidateFilesForRowKeyBefore
argument_list|(
name|KV_A
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|stripe0b
argument_list|,
name|sfs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|remove
argument_list|()
expr_stmt|;
name|sfs
operator|=
name|manager
operator|.
name|updateCandidateFilesForRowKeyBefore
argument_list|(
name|sfs
argument_list|,
name|KV_A
argument_list|,
name|KV_A
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|stripe0a
argument_list|,
name|sfs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGetSplitPointEdgeCases
parameter_list|()
throws|throws
name|Exception
block|{
name|StripeStoreFileManager
name|manager
init|=
name|createManager
argument_list|()
decl_stmt|;
comment|// No files => no split.
name|assertNull
argument_list|(
name|manager
operator|.
name|getSplitPoint
argument_list|()
argument_list|)
expr_stmt|;
comment|// If there are no stripes, should pick midpoint from the biggest file in L0.
name|MockStoreFile
name|sf5
init|=
name|createFile
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sf5
operator|.
name|splitPoint
operator|=
operator|new
name|byte
index|[
literal|1
index|]
expr_stmt|;
name|manager
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|sf5
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|createFile
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|sf5
operator|.
name|splitPoint
argument_list|,
name|manager
operator|.
name|getSplitPoint
argument_list|()
argument_list|)
expr_stmt|;
comment|// Same if there's one stripe but the biggest file is still in L0.
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|()
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|OPEN_KEY
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|sf5
operator|.
name|splitPoint
argument_list|,
name|manager
operator|.
name|getSplitPoint
argument_list|()
argument_list|)
expr_stmt|;
comment|// If the biggest file is in the stripe, should get from it.
name|MockStoreFile
name|sf6
init|=
name|createFile
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|,
name|OPEN_KEY
argument_list|,
name|OPEN_KEY
argument_list|)
decl_stmt|;
name|sf6
operator|.
name|splitPoint
operator|=
operator|new
name|byte
index|[
literal|1
index|]
expr_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|()
argument_list|,
name|al
argument_list|(
name|sf6
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|sf6
operator|.
name|splitPoint
argument_list|,
name|manager
operator|.
name|getSplitPoint
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGetStripeBoundarySplits
parameter_list|()
throws|throws
name|Exception
block|{
comment|/* First number - split must be after this stripe; further numbers - stripes */
name|verifySplitPointScenario
argument_list|(
literal|5
argument_list|,
literal|false
argument_list|,
literal|0f
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|verifySplitPointScenario
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|,
literal|0f
argument_list|,
literal|6
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|verifySplitPointScenario
argument_list|(
literal|2
argument_list|,
literal|false
argument_list|,
literal|0f
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|verifySplitPointScenario
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|,
literal|0f
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|verifySplitPointScenario
argument_list|(
literal|2
argument_list|,
literal|false
argument_list|,
literal|0f
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGetUnbalancedSplits
parameter_list|()
throws|throws
name|Exception
block|{
comment|/* First number - split must be inside/after this stripe; further numbers - stripes */
name|verifySplitPointScenario
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|,
literal|2.1f
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// 8/4 is less than 2.1f
name|verifySplitPointScenario
argument_list|(
literal|1
argument_list|,
literal|true
argument_list|,
literal|1.5f
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// 8/4> 6/6
name|verifySplitPointScenario
argument_list|(
literal|1
argument_list|,
literal|false
argument_list|,
literal|1.1f
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// 7/6< 8/5
name|verifySplitPointScenario
argument_list|(
literal|1
argument_list|,
literal|false
argument_list|,
literal|1.1f
argument_list|,
literal|3
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// 9/6 == 9/6
name|verifySplitPointScenario
argument_list|(
literal|1
argument_list|,
literal|true
argument_list|,
literal|1.1f
argument_list|,
literal|3
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// 11/6> 10/7
name|verifySplitPointScenario
argument_list|(
literal|3
argument_list|,
literal|false
argument_list|,
literal|1.1f
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|// reverse order
name|verifySplitPointScenario
argument_list|(
literal|4
argument_list|,
literal|true
argument_list|,
literal|1.1f
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|// reverse order
name|verifySplitPointScenario
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|,
literal|1.5f
argument_list|,
literal|10
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// 10/4> 9/5
name|verifySplitPointScenario
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|,
literal|1.4f
argument_list|,
literal|6
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// 6/4 == 6/4
name|verifySplitPointScenario
argument_list|(
literal|1
argument_list|,
literal|true
argument_list|,
literal|1.5f
argument_list|,
literal|4
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|// reverse just in case
name|verifySplitPointScenario
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|,
literal|1.4f
argument_list|,
literal|4
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|// reverse just in case
block|}
comment|/**    * Verifies scenario for finding a split point.    * @param splitPointAfter Stripe to expect the split point at/after.    * @param shouldSplitStripe If true, the split point is expected in the middle of the above    *                          stripe; if false, should be at the end.    * @param splitRatioToVerify Maximum split imbalance ratio.    * @param sizes Stripe sizes.    */
specifier|private
name|void
name|verifySplitPointScenario
parameter_list|(
name|int
name|splitPointAfter
parameter_list|,
name|boolean
name|shouldSplitStripe
parameter_list|,
name|float
name|splitRatioToVerify
parameter_list|,
name|int
modifier|...
name|sizes
parameter_list|)
throws|throws
name|Exception
block|{
name|assertTrue
argument_list|(
name|sizes
operator|.
name|length
operator|>
literal|1
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|sfs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|sizeIx
init|=
literal|0
init|;
name|sizeIx
operator|<
name|sizes
operator|.
name|length
condition|;
operator|++
name|sizeIx
control|)
block|{
name|byte
index|[]
name|startKey
init|=
operator|(
name|sizeIx
operator|==
literal|0
operator|)
condition|?
name|OPEN_KEY
else|:
name|Bytes
operator|.
name|toBytes
argument_list|(
name|sizeIx
operator|-
literal|1
argument_list|)
decl_stmt|;
name|byte
index|[]
name|endKey
init|=
operator|(
name|sizeIx
operator|==
name|sizes
operator|.
name|length
operator|-
literal|1
operator|)
condition|?
name|OPEN_KEY
else|:
name|Bytes
operator|.
name|toBytes
argument_list|(
name|sizeIx
argument_list|)
decl_stmt|;
name|MockStoreFile
name|sf
init|=
name|createFile
argument_list|(
name|sizes
index|[
name|sizeIx
index|]
argument_list|,
literal|0
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|)
decl_stmt|;
name|sf
operator|.
name|splitPoint
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
operator|-
name|sizeIx
argument_list|)
expr_stmt|;
comment|// set split point to the negative index
name|sfs
operator|.
name|add
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
if|if
condition|(
name|splitRatioToVerify
operator|!=
literal|0
condition|)
block|{
name|conf
operator|.
name|setFloat
argument_list|(
name|StripeStoreConfig
operator|.
name|MAX_REGION_SPLIT_IMBALANCE_KEY
argument_list|,
name|splitRatioToVerify
argument_list|)
expr_stmt|;
block|}
name|StripeStoreFileManager
name|manager
init|=
name|createManager
argument_list|(
name|al
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|()
argument_list|,
name|sfs
argument_list|)
expr_stmt|;
name|int
name|result
init|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|manager
operator|.
name|getSplitPoint
argument_list|()
argument_list|)
decl_stmt|;
comment|// Either end key and thus positive index, or "middle" of the file and thus negative index.
name|assertEquals
argument_list|(
name|splitPointAfter
operator|*
operator|(
name|shouldSplitStripe
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|byte
index|[]
name|keyAfter
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|copyOf
argument_list|(
name|key
argument_list|,
name|key
operator|.
name|length
operator|+
literal|1
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGetFilesForGetAndScan
parameter_list|()
throws|throws
name|Exception
block|{
name|StripeStoreFileManager
name|manager
init|=
name|createManager
argument_list|()
decl_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
name|KEY_B
argument_list|,
name|KEY_C
argument_list|)
expr_stmt|;
comment|// Populate one L0 file.
name|MockStoreFile
name|sf0
init|=
name|createFile
argument_list|()
decl_stmt|;
name|manager
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|sf0
argument_list|)
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|sf0
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
literal|null
argument_list|,
name|KEY_C
argument_list|,
name|sf0
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
name|KEY_B
argument_list|,
literal|null
argument_list|,
name|sf0
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
name|KEY_B
argument_list|,
name|KEY_C
argument_list|,
name|sf0
argument_list|)
expr_stmt|;
comment|// Populate a bunch of files for stripes, keep L0.
name|MockStoreFile
name|sfA
init|=
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_A
argument_list|)
decl_stmt|;
name|MockStoreFile
name|sfB
init|=
name|createFile
argument_list|(
name|KEY_A
argument_list|,
name|KEY_B
argument_list|)
decl_stmt|;
name|MockStoreFile
name|sfC
init|=
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|KEY_C
argument_list|)
decl_stmt|;
name|MockStoreFile
name|sfD
init|=
name|createFile
argument_list|(
name|KEY_C
argument_list|,
name|KEY_D
argument_list|)
decl_stmt|;
name|MockStoreFile
name|sfE
init|=
name|createFile
argument_list|(
name|KEY_D
argument_list|,
name|OPEN_KEY
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|()
argument_list|,
name|al
argument_list|(
name|sfA
argument_list|,
name|sfB
argument_list|,
name|sfC
argument_list|,
name|sfD
argument_list|,
name|sfE
argument_list|)
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|sf0
argument_list|,
name|sfA
argument_list|,
name|sfB
argument_list|,
name|sfC
argument_list|,
name|sfD
argument_list|,
name|sfE
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
name|keyAfter
argument_list|(
name|KEY_A
argument_list|)
argument_list|,
literal|null
argument_list|,
name|sf0
argument_list|,
name|sfB
argument_list|,
name|sfC
argument_list|,
name|sfD
argument_list|,
name|sfE
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
literal|null
argument_list|,
name|keyAfter
argument_list|(
name|KEY_C
argument_list|)
argument_list|,
name|sf0
argument_list|,
name|sfA
argument_list|,
name|sfB
argument_list|,
name|sfC
argument_list|,
name|sfD
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
name|KEY_B
argument_list|,
literal|null
argument_list|,
name|sf0
argument_list|,
name|sfC
argument_list|,
name|sfD
argument_list|,
name|sfE
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
literal|null
argument_list|,
name|KEY_C
argument_list|,
name|sf0
argument_list|,
name|sfA
argument_list|,
name|sfB
argument_list|,
name|sfC
argument_list|,
name|sfD
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
name|KEY_B
argument_list|,
name|keyAfter
argument_list|(
name|KEY_B
argument_list|)
argument_list|,
name|sf0
argument_list|,
name|sfC
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
name|keyAfter
argument_list|(
name|KEY_A
argument_list|)
argument_list|,
name|KEY_B
argument_list|,
name|sf0
argument_list|,
name|sfB
argument_list|,
name|sfC
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
name|KEY_D
argument_list|,
name|KEY_D
argument_list|,
name|sf0
argument_list|,
name|sfE
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|manager
argument_list|,
name|keyAfter
argument_list|(
name|KEY_B
argument_list|)
argument_list|,
name|keyAfter
argument_list|(
name|KEY_C
argument_list|)
argument_list|,
name|sf0
argument_list|,
name|sfC
argument_list|,
name|sfD
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|verifyGetAndScanScenario
parameter_list|(
name|StripeStoreFileManager
name|manager
parameter_list|,
name|byte
index|[]
name|start
parameter_list|,
name|byte
index|[]
name|end
parameter_list|,
name|StoreFile
modifier|...
name|results
parameter_list|)
throws|throws
name|Exception
block|{
name|verifyGetOrScanScenario
argument_list|(
name|manager
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|testLoadFilesWithRecoverableBadFiles
parameter_list|()
throws|throws
name|Exception
block|{
comment|// In L0, there will be file w/o metadata (real L0, 3 files with invalid metadata, and 3
comment|// files that overlap valid stripes in various ways). Note that the 4th way to overlap the
comment|// stripes will cause the structure to be mostly scraped, and is tested separately.
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|validStripeFiles
init|=
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|KEY_C
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_C
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_C
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|filesToGoToL0
init|=
name|al
argument_list|(
name|createFile
argument_list|()
argument_list|,
name|createFile
argument_list|(
literal|null
argument_list|,
name|KEY_A
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_D
argument_list|,
literal|null
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_D
argument_list|,
name|KEY_A
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|keyAfter
argument_list|(
name|KEY_A
argument_list|)
argument_list|,
name|KEY_C
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_D
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_D
argument_list|,
name|keyAfter
argument_list|(
name|KEY_D
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|allFilesToGo
init|=
name|flattenLists
argument_list|(
name|validStripeFiles
argument_list|,
name|filesToGoToL0
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|allFilesToGo
argument_list|)
expr_stmt|;
name|StripeStoreFileManager
name|manager
init|=
name|createManager
argument_list|(
name|allFilesToGo
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|StoreFile
argument_list|>
name|l0Files
init|=
name|manager
operator|.
name|getLevel0Files
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|filesToGoToL0
operator|.
name|size
argument_list|()
argument_list|,
name|l0Files
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|StoreFile
name|sf
range|:
name|filesToGoToL0
control|)
block|{
name|assertTrue
argument_list|(
name|l0Files
operator|.
name|contains
argument_list|(
name|sf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|allFilesToGo
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLoadFilesWithBadStripe
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Current "algorithm" will see the after-B key before C key, add it as valid stripe,
comment|// and then fail all other stripes. So everything would end up in L0.
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|allFilesToGo
init|=
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|KEY_C
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_C
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|keyAfter
argument_list|(
name|KEY_B
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|allFilesToGo
argument_list|)
expr_stmt|;
name|StripeStoreFileManager
name|manager
init|=
name|createManager
argument_list|(
name|allFilesToGo
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|allFilesToGo
operator|.
name|size
argument_list|()
argument_list|,
name|manager
operator|.
name|getLevel0Files
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLoadFilesWithGaps
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Stripes must not have gaps. If they do, everything goes to L0.
name|StripeStoreFileManager
name|manager
init|=
name|createManager
argument_list|(
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_C
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|manager
operator|.
name|getLevel0Files
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Just one open stripe should be ok.
name|manager
operator|=
name|createManager
argument_list|(
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|manager
operator|.
name|getLevel0Files
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|manager
operator|.
name|getStorefileCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLoadFilesAfterSplit
parameter_list|()
throws|throws
name|Exception
block|{
comment|// If stripes are good but have non-open ends, they must be treated as open ends.
name|MockStoreFile
name|sf
init|=
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|KEY_C
argument_list|)
decl_stmt|;
name|StripeStoreFileManager
name|manager
init|=
name|createManager
argument_list|(
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
argument_list|,
name|sf
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|manager
operator|.
name|getLevel0Files
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Here, [B, C] is logically [B, inf), so we should be able to compact it to that only.
name|verifyInvalidCompactionScenario
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf
argument_list|)
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|KEY_C
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf
argument_list|)
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf
argument_list|)
argument_list|)
expr_stmt|;
comment|// Do the same for other variants.
name|manager
operator|=
name|createManager
argument_list|(
name|al
argument_list|(
name|sf
argument_list|,
name|createFile
argument_list|(
name|KEY_C
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|verifyInvalidCompactionScenario
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf
argument_list|)
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|KEY_C
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf
argument_list|)
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_C
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|=
name|createManager
argument_list|(
name|al
argument_list|(
name|sf
argument_list|)
argument_list|)
expr_stmt|;
name|verifyInvalidCompactionScenario
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf
argument_list|)
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|KEY_C
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf
argument_list|)
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAddingCompactionResults
parameter_list|()
throws|throws
name|Exception
block|{
name|StripeStoreFileManager
name|manager
init|=
name|createManager
argument_list|()
decl_stmt|;
comment|// First, add some L0 files and "compact" one with new stripe creation.
name|StoreFile
name|sf_L0_0a
init|=
name|createFile
argument_list|()
decl_stmt|,
name|sf_L0_0b
init|=
name|createFile
argument_list|()
decl_stmt|;
name|manager
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|sf_L0_0a
argument_list|,
name|sf_L0_0b
argument_list|)
argument_list|)
expr_stmt|;
comment|// Try compacting with invalid new branches (gaps, overlaps) - no effect.
name|verifyInvalidCompactionScenario
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_L0_0a
argument_list|)
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|verifyInvalidCompactionScenario
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_L0_0a
argument_list|)
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_C
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|verifyInvalidCompactionScenario
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_L0_0a
argument_list|)
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_A
argument_list|,
name|KEY_D
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|verifyInvalidCompactionScenario
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_L0_0a
argument_list|)
argument_list|,
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_A
argument_list|,
name|KEY_B
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|StoreFile
name|sf_i2B_0
init|=
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
decl_stmt|;
name|StoreFile
name|sf_B2C_0
init|=
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|KEY_C
argument_list|)
decl_stmt|;
name|StoreFile
name|sf_C2i_0
init|=
name|createFile
argument_list|(
name|KEY_C
argument_list|,
name|OPEN_KEY
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf_L0_0a
argument_list|)
argument_list|,
name|al
argument_list|(
name|sf_i2B_0
argument_list|,
name|sf_B2C_0
argument_list|,
name|sf_C2i_0
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf_L0_0a
argument_list|)
argument_list|)
expr_stmt|;
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_L0_0b
argument_list|,
name|sf_i2B_0
argument_list|,
name|sf_B2C_0
argument_list|,
name|sf_C2i_0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add another l0 file, "compact" both L0 into two stripes
name|StoreFile
name|sf_L0_1
init|=
name|createFile
argument_list|()
decl_stmt|;
name|StoreFile
name|sf_i2B_1
init|=
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
decl_stmt|;
name|StoreFile
name|sf_B2C_1
init|=
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|KEY_C
argument_list|)
decl_stmt|;
name|manager
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|sf_L0_1
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf_L0_0b
argument_list|,
name|sf_L0_1
argument_list|)
argument_list|,
name|al
argument_list|(
name|sf_i2B_1
argument_list|,
name|sf_B2C_1
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf_L0_0b
argument_list|,
name|sf_L0_1
argument_list|)
argument_list|)
expr_stmt|;
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_i2B_0
argument_list|,
name|sf_B2C_0
argument_list|,
name|sf_C2i_0
argument_list|,
name|sf_i2B_1
argument_list|,
name|sf_B2C_1
argument_list|)
argument_list|)
expr_stmt|;
comment|// Try compacting with invalid file (no metadata) - should add files to L0.
name|StoreFile
name|sf_L0_2
init|=
name|createFile
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|()
argument_list|,
name|al
argument_list|(
name|sf_L0_2
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|()
argument_list|)
expr_stmt|;
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_i2B_0
argument_list|,
name|sf_B2C_0
argument_list|,
name|sf_C2i_0
argument_list|,
name|sf_i2B_1
argument_list|,
name|sf_B2C_1
argument_list|,
name|sf_L0_2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Remove it...
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf_L0_2
argument_list|)
argument_list|,
name|al
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf_L0_2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Do regular compaction in the first stripe.
name|StoreFile
name|sf_i2B_3
init|=
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf_i2B_0
argument_list|,
name|sf_i2B_1
argument_list|)
argument_list|,
name|al
argument_list|(
name|sf_i2B_3
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf_i2B_0
argument_list|,
name|sf_i2B_1
argument_list|)
argument_list|)
expr_stmt|;
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_B2C_0
argument_list|,
name|sf_C2i_0
argument_list|,
name|sf_B2C_1
argument_list|,
name|sf_i2B_3
argument_list|)
argument_list|)
expr_stmt|;
comment|// Rebalance two stripes.
name|StoreFile
name|sf_B2D_4
init|=
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|KEY_D
argument_list|)
decl_stmt|;
name|StoreFile
name|sf_D2i_4
init|=
name|createFile
argument_list|(
name|KEY_D
argument_list|,
name|OPEN_KEY
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf_B2C_0
argument_list|,
name|sf_C2i_0
argument_list|,
name|sf_B2C_1
argument_list|)
argument_list|,
name|al
argument_list|(
name|sf_B2D_4
argument_list|,
name|sf_D2i_4
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf_B2C_0
argument_list|,
name|sf_C2i_0
argument_list|,
name|sf_B2C_1
argument_list|)
argument_list|)
expr_stmt|;
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_i2B_3
argument_list|,
name|sf_B2D_4
argument_list|,
name|sf_D2i_4
argument_list|)
argument_list|)
expr_stmt|;
comment|// Split the first stripe.
name|StoreFile
name|sf_i2A_5
init|=
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_A
argument_list|)
decl_stmt|;
name|StoreFile
name|sf_A2B_5
init|=
name|createFile
argument_list|(
name|KEY_A
argument_list|,
name|KEY_B
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf_i2B_3
argument_list|)
argument_list|,
name|al
argument_list|(
name|sf_i2A_5
argument_list|,
name|sf_A2B_5
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf_i2B_3
argument_list|)
argument_list|)
expr_stmt|;
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_B2D_4
argument_list|,
name|sf_D2i_4
argument_list|,
name|sf_i2A_5
argument_list|,
name|sf_A2B_5
argument_list|)
argument_list|)
expr_stmt|;
comment|// Split the middle stripe.
name|StoreFile
name|sf_B2C_6
init|=
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|KEY_C
argument_list|)
decl_stmt|;
name|StoreFile
name|sf_C2D_6
init|=
name|createFile
argument_list|(
name|KEY_C
argument_list|,
name|KEY_D
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf_B2D_4
argument_list|)
argument_list|,
name|al
argument_list|(
name|sf_B2C_6
argument_list|,
name|sf_C2D_6
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf_B2D_4
argument_list|)
argument_list|)
expr_stmt|;
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_D2i_4
argument_list|,
name|sf_i2A_5
argument_list|,
name|sf_A2B_5
argument_list|,
name|sf_B2C_6
argument_list|,
name|sf_C2D_6
argument_list|)
argument_list|)
expr_stmt|;
comment|// Merge two different middle stripes.
name|StoreFile
name|sf_A2C_7
init|=
name|createFile
argument_list|(
name|KEY_A
argument_list|,
name|KEY_C
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf_A2B_5
argument_list|,
name|sf_B2C_6
argument_list|)
argument_list|,
name|al
argument_list|(
name|sf_A2C_7
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf_A2B_5
argument_list|,
name|sf_B2C_6
argument_list|)
argument_list|)
expr_stmt|;
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_D2i_4
argument_list|,
name|sf_i2A_5
argument_list|,
name|sf_C2D_6
argument_list|,
name|sf_A2C_7
argument_list|)
argument_list|)
expr_stmt|;
comment|// Merge lower half.
name|StoreFile
name|sf_i2C_8
init|=
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_C
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf_i2A_5
argument_list|,
name|sf_A2C_7
argument_list|)
argument_list|,
name|al
argument_list|(
name|sf_i2C_8
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf_i2A_5
argument_list|,
name|sf_A2C_7
argument_list|)
argument_list|)
expr_stmt|;
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_D2i_4
argument_list|,
name|sf_C2D_6
argument_list|,
name|sf_i2C_8
argument_list|)
argument_list|)
expr_stmt|;
comment|// Merge all.
name|StoreFile
name|sf_i2i_9
init|=
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|OPEN_KEY
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf_D2i_4
argument_list|,
name|sf_C2D_6
argument_list|,
name|sf_i2C_8
argument_list|)
argument_list|,
name|al
argument_list|(
name|sf_i2i_9
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf_D2i_4
argument_list|,
name|sf_C2D_6
argument_list|,
name|sf_i2C_8
argument_list|)
argument_list|)
expr_stmt|;
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|al
argument_list|(
name|sf_i2i_9
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCompactionAndFlushConflict
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Add file flush into stripes
name|StripeStoreFileManager
name|sfm
init|=
name|createManager
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|sfm
operator|.
name|getStripeCount
argument_list|()
argument_list|)
expr_stmt|;
name|StoreFile
name|sf_i2c
init|=
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_C
argument_list|)
decl_stmt|,
name|sf_c2i
init|=
name|createFile
argument_list|(
name|KEY_C
argument_list|,
name|OPEN_KEY
argument_list|)
decl_stmt|;
name|sfm
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|sf_i2c
argument_list|,
name|sf_c2i
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|sfm
operator|.
name|getStripeCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now try to add conflicting flush - should throw.
name|StoreFile
name|sf_i2d
init|=
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_D
argument_list|)
decl_stmt|,
name|sf_d2i
init|=
name|createFile
argument_list|(
name|KEY_D
argument_list|,
name|OPEN_KEY
argument_list|)
decl_stmt|;
name|sfm
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|sf_i2d
argument_list|,
name|sf_d2i
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|sfm
operator|.
name|getStripeCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|sfm
operator|.
name|getLevel0Files
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|sfm
argument_list|,
name|KEY_C
argument_list|,
name|KEY_C
argument_list|,
name|sf_i2d
argument_list|,
name|sf_d2i
argument_list|,
name|sf_c2i
argument_list|)
expr_stmt|;
comment|// Remove these files.
name|sfm
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf_i2d
argument_list|,
name|sf_d2i
argument_list|)
argument_list|,
name|al
argument_list|()
argument_list|)
expr_stmt|;
name|sfm
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf_i2d
argument_list|,
name|sf_d2i
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|sfm
operator|.
name|getLevel0Files
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Add another file to stripe; then "rebalance" stripes w/o it - the file, which was
comment|// presumably flushed during compaction, should go to L0.
name|StoreFile
name|sf_i2c_2
init|=
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_C
argument_list|)
decl_stmt|;
name|sfm
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|sf_i2c_2
argument_list|)
argument_list|)
expr_stmt|;
name|sfm
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf_i2c
argument_list|,
name|sf_c2i
argument_list|)
argument_list|,
name|al
argument_list|(
name|sf_i2d
argument_list|,
name|sf_d2i
argument_list|)
argument_list|)
expr_stmt|;
name|sfm
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf_i2c
argument_list|,
name|sf_c2i
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|sfm
operator|.
name|getLevel0Files
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|verifyGetAndScanScenario
argument_list|(
name|sfm
argument_list|,
name|KEY_C
argument_list|,
name|KEY_C
argument_list|,
name|sf_i2d
argument_list|,
name|sf_i2c_2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyResultsForStripes
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Test that we can compact L0 into a subset of stripes.
name|StripeStoreFileManager
name|manager
init|=
name|createManager
argument_list|()
decl_stmt|;
name|StoreFile
name|sf0a
init|=
name|createFile
argument_list|()
decl_stmt|;
name|StoreFile
name|sf0b
init|=
name|createFile
argument_list|()
decl_stmt|;
name|manager
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|sf0a
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|sf0b
argument_list|)
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|compacted
init|=
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_B
argument_list|,
name|KEY_C
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_C
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf0a
argument_list|)
argument_list|,
name|compacted
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf0a
argument_list|)
argument_list|)
expr_stmt|;
comment|// Next L0 compaction only produces file for the first and last stripe.
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|compacted2
init|=
name|al
argument_list|(
name|createFile
argument_list|(
name|OPEN_KEY
argument_list|,
name|KEY_B
argument_list|)
argument_list|,
name|createFile
argument_list|(
name|KEY_C
argument_list|,
name|OPEN_KEY
argument_list|)
argument_list|)
decl_stmt|;
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|(
name|sf0b
argument_list|)
argument_list|,
name|compacted2
argument_list|)
expr_stmt|;
name|manager
operator|.
name|removeCompactedFiles
argument_list|(
name|al
argument_list|(
name|sf0b
argument_list|)
argument_list|)
expr_stmt|;
name|compacted
operator|.
name|addAll
argument_list|(
name|compacted2
argument_list|)
expr_stmt|;
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|compacted
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPriority
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Expected priority, file limit, stripe count, files per stripe, l0 files.
name|testPriorityScenario
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|testPriorityScenario
argument_list|(
literal|2
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|testPriorityScenario
argument_list|(
literal|4
argument_list|,
literal|25
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// example case.
name|testPriorityScenario
argument_list|(
literal|3
argument_list|,
literal|25
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// L0 files counts for all stripes.
name|testPriorityScenario
argument_list|(
literal|3
argument_list|,
literal|25
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// file to each stripe - same as one L0 file.
name|testPriorityScenario
argument_list|(
literal|2
argument_list|,
literal|25
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// 1 is priority user, so 2 is returned.
name|testPriorityScenario
argument_list|(
literal|2
argument_list|,
literal|25
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// don't return higher than user unless over limit.
name|testPriorityScenario
argument_list|(
literal|2
argument_list|,
literal|25
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|// same.
name|testPriorityScenario
argument_list|(
literal|0
argument_list|,
literal|25
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|// at limit.
name|testPriorityScenario
argument_list|(
operator|-
literal|5
argument_list|,
literal|25
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// over limit!
name|testPriorityScenario
argument_list|(
operator|-
literal|1
argument_list|,
literal|25
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|26
argument_list|)
expr_stmt|;
comment|// over limit with just L0
block|}
specifier|private
name|void
name|testPriorityScenario
parameter_list|(
name|int
name|expectedPriority
parameter_list|,
name|int
name|limit
parameter_list|,
name|int
name|stripes
parameter_list|,
name|int
name|filesInStripe
parameter_list|,
name|int
name|l0Files
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|byte
index|[]
index|[]
name|keys
init|=
block|{
name|KEY_A
block|,
name|KEY_B
block|,
name|KEY_C
block|,
name|KEY_D
block|}
decl_stmt|;
name|assertTrue
argument_list|(
name|stripes
operator|<=
name|keys
operator|.
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
literal|"hbase.hstore.blockingStoreFiles"
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|StripeStoreFileManager
name|sfm
init|=
name|createManager
argument_list|(
name|al
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l0Files
condition|;
operator|++
name|i
control|)
block|{
name|sfm
operator|.
name|insertNewFiles
argument_list|(
name|al
argument_list|(
name|createFile
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|filesInStripe
condition|;
operator|++
name|i
control|)
block|{
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|stripe
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|stripes
condition|;
operator|++
name|j
control|)
block|{
name|stripe
operator|.
name|add
argument_list|(
name|createFile
argument_list|(
operator|(
name|j
operator|==
literal|0
operator|)
condition|?
name|OPEN_KEY
else|:
name|keys
index|[
name|j
operator|-
literal|1
index|]
argument_list|,
operator|(
name|j
operator|==
name|stripes
operator|-
literal|1
operator|)
condition|?
name|OPEN_KEY
else|:
name|keys
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sfm
operator|.
name|addCompactionResults
argument_list|(
name|al
argument_list|()
argument_list|,
name|stripe
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expectedPriority
argument_list|,
name|sfm
operator|.
name|getStoreCompactionPriority
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|verifyInvalidCompactionScenario
parameter_list|(
name|StripeStoreFileManager
name|manager
parameter_list|,
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|filesToCompact
parameter_list|,
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|filesToInsert
parameter_list|)
throws|throws
name|Exception
block|{
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|allFiles
init|=
name|manager
operator|.
name|getStorefiles
argument_list|()
decl_stmt|;
try|try
block|{
name|manager
operator|.
name|addCompactionResults
argument_list|(
name|filesToCompact
argument_list|,
name|filesToInsert
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Should have thrown"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// Ignore it.
block|}
name|verifyAllFiles
argument_list|(
name|manager
argument_list|,
name|allFiles
argument_list|)
expr_stmt|;
comment|// must have the same files.
block|}
specifier|private
name|void
name|verifyGetOrScanScenario
parameter_list|(
name|StripeStoreFileManager
name|manager
parameter_list|,
name|byte
index|[]
name|start
parameter_list|,
name|byte
index|[]
name|end
parameter_list|,
name|StoreFile
modifier|...
name|results
parameter_list|)
throws|throws
name|Exception
block|{
name|verifyGetOrScanScenario
argument_list|(
name|manager
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|results
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|verifyGetOrScanScenario
parameter_list|(
name|StripeStoreFileManager
name|manager
parameter_list|,
name|byte
index|[]
name|start
parameter_list|,
name|byte
index|[]
name|end
parameter_list|,
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|results
parameter_list|)
throws|throws
name|Exception
block|{
name|start
operator|=
name|start
operator|!=
literal|null
condition|?
name|start
else|:
name|HConstants
operator|.
name|EMPTY_START_ROW
expr_stmt|;
name|end
operator|=
name|end
operator|!=
literal|null
condition|?
name|end
else|:
name|HConstants
operator|.
name|EMPTY_END_ROW
expr_stmt|;
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|sfs
init|=
name|manager
operator|.
name|getFilesForScan
argument_list|(
name|start
argument_list|,
literal|true
argument_list|,
name|end
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|results
operator|.
name|size
argument_list|()
argument_list|,
name|sfs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|StoreFile
name|result
range|:
name|results
control|)
block|{
name|assertTrue
argument_list|(
name|sfs
operator|.
name|contains
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|verifyAllFiles
parameter_list|(
name|StripeStoreFileManager
name|manager
parameter_list|,
name|Collection
argument_list|<
name|StoreFile
argument_list|>
name|results
parameter_list|)
throws|throws
name|Exception
block|{
name|verifyGetOrScanScenario
argument_list|(
name|manager
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
comment|// TODO: replace with Mockito?
specifier|private
specifier|static
name|MockStoreFile
name|createFile
parameter_list|(
name|long
name|size
parameter_list|,
name|long
name|seqNum
parameter_list|,
name|byte
index|[]
name|startKey
parameter_list|,
name|byte
index|[]
name|endKey
parameter_list|)
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|TEST_UTIL
operator|.
name|getTestFileSystem
argument_list|()
decl_stmt|;
name|Path
name|testFilePath
init|=
name|StoreFile
operator|.
name|getUniqueFile
argument_list|(
name|fs
argument_list|,
name|CFDIR
argument_list|)
decl_stmt|;
name|fs
operator|.
name|create
argument_list|(
name|testFilePath
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|MockStoreFile
name|sf
init|=
operator|new
name|MockStoreFile
argument_list|(
name|TEST_UTIL
argument_list|,
name|testFilePath
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|seqNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|startKey
operator|!=
literal|null
condition|)
block|{
name|sf
operator|.
name|setMetadataValue
argument_list|(
name|StripeStoreFileManager
operator|.
name|STRIPE_START_KEY
argument_list|,
name|startKey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|endKey
operator|!=
literal|null
condition|)
block|{
name|sf
operator|.
name|setMetadataValue
argument_list|(
name|StripeStoreFileManager
operator|.
name|STRIPE_END_KEY
argument_list|,
name|endKey
argument_list|)
expr_stmt|;
block|}
return|return
name|sf
return|;
block|}
specifier|private
specifier|static
name|MockStoreFile
name|createFile
parameter_list|(
name|long
name|size
parameter_list|,
name|long
name|seqNum
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|createFile
argument_list|(
name|size
argument_list|,
name|seqNum
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|MockStoreFile
name|createFile
parameter_list|(
name|byte
index|[]
name|startKey
parameter_list|,
name|byte
index|[]
name|endKey
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|createFile
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|MockStoreFile
name|createFile
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|createFile
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|StripeStoreFileManager
name|createManager
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|createManager
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|StripeStoreFileManager
name|createManager
parameter_list|(
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|sfs
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|createManager
argument_list|(
name|sfs
argument_list|,
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|StripeStoreFileManager
name|createManager
parameter_list|(
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|sfs
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|StripeStoreConfig
name|config
init|=
operator|new
name|StripeStoreConfig
argument_list|(
name|conf
argument_list|,
name|Mockito
operator|.
name|mock
argument_list|(
name|StoreConfigInformation
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
name|StripeStoreFileManager
name|result
init|=
operator|new
name|StripeStoreFileManager
argument_list|(
name|CellComparator
operator|.
name|COMPARATOR
argument_list|,
name|conf
argument_list|,
name|config
argument_list|)
decl_stmt|;
name|result
operator|.
name|loadFiles
argument_list|(
name|sfs
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|al
parameter_list|(
name|StoreFile
modifier|...
name|sfs
parameter_list|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|sfs
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|flattenLists
parameter_list|(
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
modifier|...
name|sfls
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ArrayList
argument_list|<
name|StoreFile
argument_list|>
name|sfl
range|:
name|sfls
control|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|sfl
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_class

end_unit

