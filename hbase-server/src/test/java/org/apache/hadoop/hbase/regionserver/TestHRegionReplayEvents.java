begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|TestHRegion
operator|.
name|assertGet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|TestHRegion
operator|.
name|putData
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|TestHRegion
operator|.
name|verifyData
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|ArgumentMatchers
operator|.
name|any
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|ArgumentMatchers
operator|.
name|anyBoolean
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|mock
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|spy
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|times
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|verify
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|when
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseClassTestRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ColumnFamilyDescriptorBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Durability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfoBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptorBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
operator|.
name|FlushResultImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
operator|.
name|PrepareFlushResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|throttle
operator|.
name|NoLimitThroughputController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|MediumTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManagerTestHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|AbstractFSWALProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WAL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALEdit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALKeyImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALSplitter
operator|.
name|MutationReplay
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|ClassRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|UnsafeByteOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|MutationProto
operator|.
name|MutationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|WALProtos
operator|.
name|BulkLoadDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|WALProtos
operator|.
name|CompactionDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|WALProtos
operator|.
name|FlushDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|WALProtos
operator|.
name|FlushDescriptor
operator|.
name|FlushAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|WALProtos
operator|.
name|FlushDescriptor
operator|.
name|StoreFlushDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|WALProtos
operator|.
name|RegionEventDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|WALProtos
operator|.
name|RegionEventDescriptor
operator|.
name|EventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|WALProtos
operator|.
name|StoreDescriptor
import|;
end_import

begin_comment
comment|/**  * Tests of HRegion methods for replaying flush, compaction, region open, etc events for secondary  * region replicas  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
name|MediumTests
operator|.
name|class
argument_list|)
specifier|public
class|class
name|TestHRegionReplayEvents
block|{
annotation|@
name|ClassRule
specifier|public
specifier|static
specifier|final
name|HBaseClassTestRule
name|CLASS_RULE
init|=
name|HBaseClassTestRule
operator|.
name|forClass
argument_list|(
name|TestHRegionReplayEvents
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestHRegion
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Rule
specifier|public
name|TestName
name|name
init|=
operator|new
name|TestName
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|HBaseTestingUtility
name|TEST_UTIL
decl_stmt|;
specifier|public
specifier|static
name|Configuration
name|CONF
decl_stmt|;
specifier|private
name|String
name|dir
decl_stmt|;
specifier|private
name|byte
index|[]
index|[]
name|families
init|=
operator|new
name|byte
index|[]
index|[]
block|{
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cf1"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cf2"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cf3"
argument_list|)
block|}
decl_stmt|;
comment|// Test names
specifier|protected
name|byte
index|[]
name|tableName
decl_stmt|;
specifier|protected
name|String
name|method
decl_stmt|;
specifier|protected
specifier|final
name|byte
index|[]
name|row
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"rowA"
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|byte
index|[]
name|row2
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"rowB"
argument_list|)
decl_stmt|;
specifier|protected
name|byte
index|[]
name|cq
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cq"
argument_list|)
decl_stmt|;
comment|// per test fields
specifier|private
name|Path
name|rootDir
decl_stmt|;
specifier|private
name|TableDescriptor
name|htd
decl_stmt|;
specifier|private
name|long
name|time
decl_stmt|;
specifier|private
name|RegionServerServices
name|rss
decl_stmt|;
specifier|private
name|RegionInfo
name|primaryHri
decl_stmt|,
name|secondaryHri
decl_stmt|;
specifier|private
name|HRegion
name|primaryRegion
decl_stmt|,
name|secondaryRegion
decl_stmt|;
specifier|private
name|WALFactory
name|wals
decl_stmt|;
specifier|private
name|WAL
name|walPrimary
decl_stmt|,
name|walSecondary
decl_stmt|;
specifier|private
name|WAL
operator|.
name|Reader
name|reader
decl_stmt|;
annotation|@
name|Before
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|IOException
block|{
name|TEST_UTIL
operator|=
name|HBaseTestingUtility
operator|.
name|createLocalHTU
argument_list|()
expr_stmt|;
name|CONF
operator|=
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
name|dir
operator|=
name|TEST_UTIL
operator|.
name|getDataTestDir
argument_list|(
literal|"TestHRegionReplayEvents"
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
name|method
operator|=
name|name
operator|.
name|getMethodName
argument_list|()
expr_stmt|;
name|tableName
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|name
operator|.
name|getMethodName
argument_list|()
argument_list|)
expr_stmt|;
name|rootDir
operator|=
operator|new
name|Path
argument_list|(
name|dir
operator|+
name|method
argument_list|)
expr_stmt|;
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
operator|.
name|set
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|,
name|rootDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|method
operator|=
name|name
operator|.
name|getMethodName
argument_list|()
expr_stmt|;
name|TableDescriptorBuilder
name|builder
init|=
name|TableDescriptorBuilder
operator|.
name|newBuilder
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|method
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|family
range|:
name|families
control|)
block|{
name|builder
operator|.
name|setColumnFamily
argument_list|(
name|ColumnFamilyDescriptorBuilder
operator|.
name|of
argument_list|(
name|family
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|htd
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
name|time
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|ChunkCreator
operator|.
name|initialize
argument_list|(
name|MemStoreLABImpl
operator|.
name|CHUNK_SIZE_DEFAULT
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|primaryHri
operator|=
name|RegionInfoBuilder
operator|.
name|newBuilder
argument_list|(
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|.
name|setRegionId
argument_list|(
name|time
argument_list|)
operator|.
name|setReplicaId
argument_list|(
literal|0
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|secondaryHri
operator|=
name|RegionInfoBuilder
operator|.
name|newBuilder
argument_list|(
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|.
name|setRegionId
argument_list|(
name|time
argument_list|)
operator|.
name|setReplicaId
argument_list|(
literal|1
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|wals
operator|=
name|TestHRegion
operator|.
name|createWALFactory
argument_list|(
name|CONF
argument_list|,
name|rootDir
argument_list|)
expr_stmt|;
name|walPrimary
operator|=
name|wals
operator|.
name|getWAL
argument_list|(
name|primaryHri
argument_list|)
expr_stmt|;
name|walSecondary
operator|=
name|wals
operator|.
name|getWAL
argument_list|(
name|secondaryHri
argument_list|)
expr_stmt|;
name|rss
operator|=
name|mock
argument_list|(
name|RegionServerServices
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|rss
operator|.
name|getServerName
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
literal|"foo"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|rss
operator|.
name|getConfiguration
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|CONF
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|rss
operator|.
name|getRegionServerAccounting
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
operator|new
name|RegionServerAccounting
argument_list|(
name|CONF
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|string
init|=
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|EventType
operator|.
name|RS_COMPACTED_FILES_DISCHARGER
operator|.
name|toString
argument_list|()
decl_stmt|;
name|ExecutorService
name|es
init|=
operator|new
name|ExecutorService
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|es
operator|.
name|startExecutorService
argument_list|(
name|string
operator|+
literal|"-"
operator|+
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|rss
operator|.
name|getExecutorService
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|es
argument_list|)
expr_stmt|;
name|primaryRegion
operator|=
name|HRegion
operator|.
name|createHRegion
argument_list|(
name|primaryHri
argument_list|,
name|rootDir
argument_list|,
name|CONF
argument_list|,
name|htd
argument_list|,
name|walPrimary
argument_list|)
expr_stmt|;
name|primaryRegion
operator|.
name|close
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|HRegion
argument_list|>
name|regions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|regions
operator|.
name|add
argument_list|(
name|primaryRegion
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
name|regions
argument_list|)
operator|.
name|when
argument_list|(
name|rss
argument_list|)
operator|.
name|getRegions
argument_list|()
expr_stmt|;
name|primaryRegion
operator|=
name|HRegion
operator|.
name|openHRegion
argument_list|(
name|rootDir
argument_list|,
name|primaryHri
argument_list|,
name|htd
argument_list|,
name|walPrimary
argument_list|,
name|CONF
argument_list|,
name|rss
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|=
name|HRegion
operator|.
name|openHRegion
argument_list|(
name|secondaryHri
argument_list|,
name|htd
argument_list|,
literal|null
argument_list|,
name|CONF
argument_list|,
name|rss
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|reader
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|After
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|primaryRegion
operator|!=
literal|null
condition|)
block|{
name|HBaseTestingUtility
operator|.
name|closeRegionAndWAL
argument_list|(
name|primaryRegion
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secondaryRegion
operator|!=
literal|null
condition|)
block|{
name|HBaseTestingUtility
operator|.
name|closeRegionAndWAL
argument_list|(
name|secondaryRegion
argument_list|)
expr_stmt|;
block|}
name|EnvironmentEdgeManagerTestHelper
operator|.
name|reset
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning test directory: "
operator|+
name|TEST_UTIL
operator|.
name|getDataTestDir
argument_list|()
argument_list|)
expr_stmt|;
name|TEST_UTIL
operator|.
name|cleanupTestDir
argument_list|()
expr_stmt|;
block|}
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
operator|.
name|getMethodName
argument_list|()
return|;
block|}
comment|// Some of the test cases are as follows:
comment|// 1. replay flush start marker again
comment|// 2. replay flush with smaller seqId than what is there in memstore snapshot
comment|// 3. replay flush with larger seqId than what is there in memstore snapshot
comment|// 4. replay flush commit without flush prepare. non droppable memstore
comment|// 5. replay flush commit without flush prepare. droppable memstore
comment|// 6. replay open region event
comment|// 7. replay open region event after flush start
comment|// 8. replay flush form an earlier seqId (test ignoring seqIds)
comment|// 9. start flush does not prevent region from closing.
annotation|@
name|Test
specifier|public
name|void
name|testRegionReplicaSecondaryCannotFlush
parameter_list|()
throws|throws
name|IOException
block|{
comment|// load some data and flush ensure that the secondary replica will not execute the flush
comment|// load some data to secondary by replaying
name|putDataByReplay
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
comment|// flush region
name|FlushResultImpl
name|flush
init|=
operator|(
name|FlushResultImpl
operator|)
name|secondaryRegion
operator|.
name|flush
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|FlushResultImpl
operator|.
name|Result
operator|.
name|CANNOT_FLUSH
argument_list|,
name|flush
operator|.
name|result
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
comment|// close the region, and inspect that it has not flushed
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|HStoreFile
argument_list|>
argument_list|>
name|files
init|=
name|secondaryRegion
operator|.
name|close
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// assert that there are no files (due to flush)
for|for
control|(
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|f
range|:
name|files
operator|.
name|values
argument_list|()
control|)
block|{
name|assertTrue
argument_list|(
name|f
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tests a case where we replay only a flush start marker, then the region is closed. This region    * should not block indefinitely    */
annotation|@
name|Test
specifier|public
name|void
name|testOnlyReplayingFlushStartDoesNotHoldUpRegionClose
parameter_list|()
throws|throws
name|IOException
block|{
comment|// load some data to primary and flush
name|int
name|start
init|=
literal|0
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Writing some data to primary from "
operator|+
name|start
operator|+
literal|" to "
operator|+
operator|(
name|start
operator|+
literal|100
operator|)
argument_list|)
expr_stmt|;
name|putData
argument_list|(
name|primaryRegion
argument_list|,
name|Durability
operator|.
name|SYNC_WAL
argument_list|,
name|start
argument_list|,
literal|100
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Flushing primary, creating 3 files for 3 stores"
argument_list|)
expr_stmt|;
name|primaryRegion
operator|.
name|flush
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// now replay the edits and the flush marker
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying edits and flush events in secondary"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flushDesc
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushDesc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|START_FLUSH
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying flush start in secondary"
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|.
name|replayWALFlushStartMarker
argument_list|(
name|flushDesc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|COMMIT_FLUSH
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"-- NOT Replaying flush commit in secondary"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|replayEdit
argument_list|(
name|secondaryRegion
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|rss
operator|.
name|getRegionServerAccounting
argument_list|()
operator|.
name|getGlobalMemStoreDataSize
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// now close the region which should not cause hold because of un-committed flush
name|secondaryRegion
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// verify that the memstore size is back to what it was
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|rss
operator|.
name|getRegionServerAccounting
argument_list|()
operator|.
name|getGlobalMemStoreDataSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|replayEdit
parameter_list|(
name|HRegion
name|region
parameter_list|,
name|WAL
operator|.
name|Entry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|WALEdit
operator|.
name|isMetaEditFamily
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
comment|// handled elsewhere
block|}
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Cell
name|cell
range|:
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
control|)
name|put
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
name|put
operator|.
name|setDurability
argument_list|(
name|Durability
operator|.
name|SKIP_WAL
argument_list|)
expr_stmt|;
name|MutationReplay
name|mutation
init|=
operator|new
name|MutationReplay
argument_list|(
name|MutationType
operator|.
name|PUT
argument_list|,
name|put
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|region
operator|.
name|batchReplay
argument_list|(
operator|new
name|MutationReplay
index|[]
block|{
name|mutation
block|}
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|put
operator|.
name|getRow
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
name|WAL
operator|.
name|Reader
name|createWALReaderForPrimary
parameter_list|()
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
return|return
name|WALFactory
operator|.
name|createReader
argument_list|(
name|TEST_UTIL
operator|.
name|getTestFileSystem
argument_list|()
argument_list|,
name|AbstractFSWALProvider
operator|.
name|getCurrentFileName
argument_list|(
name|walPrimary
argument_list|)
argument_list|,
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBatchReplayWithMultipleNonces
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|MutationReplay
index|[]
name|mutations
init|=
operator|new
name|MutationReplay
index|[
literal|100
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|put
operator|.
name|setDurability
argument_list|(
name|Durability
operator|.
name|SYNC_WAL
argument_list|)
expr_stmt|;
for|for
control|(
name|byte
index|[]
name|familly
range|:
name|this
operator|.
name|families
control|)
block|{
name|put
operator|.
name|addColumn
argument_list|(
name|familly
argument_list|,
name|this
operator|.
name|cq
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|long
name|nonceNum
init|=
name|i
operator|/
literal|10
decl_stmt|;
name|mutations
index|[
name|i
index|]
operator|=
operator|new
name|MutationReplay
argument_list|(
name|MutationType
operator|.
name|PUT
argument_list|,
name|put
argument_list|,
name|nonceNum
argument_list|,
name|nonceNum
argument_list|)
expr_stmt|;
block|}
block|}
name|primaryRegion
operator|.
name|batchReplay
argument_list|(
name|mutations
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Error while replay of batch with multiple nonces. "
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|msg
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReplayFlushesAndCompactions
parameter_list|()
throws|throws
name|IOException
block|{
comment|// initiate a secondary region with some data.
comment|// load some data to primary and flush. 3 flushes and some more unflushed data
name|putDataWithFlushes
argument_list|(
name|primaryRegion
argument_list|,
literal|100
argument_list|,
literal|300
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|// compaction from primary
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Compacting primary, only 1 store"
argument_list|)
expr_stmt|;
name|primaryRegion
operator|.
name|compactStore
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cf1"
argument_list|)
argument_list|,
name|NoLimitThroughputController
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// now replay the edits and the flush marker
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying edits and flush events in secondary"
argument_list|)
expr_stmt|;
name|int
name|lastReplayed
init|=
literal|0
decl_stmt|;
name|int
name|expectedStoreFileCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flushDesc
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|CompactionDescriptor
name|compactionDesc
init|=
name|WALEdit
operator|.
name|getCompaction
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushDesc
operator|!=
literal|null
condition|)
block|{
comment|// first verify that everything is replayed and visible before flush event replay
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|lastReplayed
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|HStore
name|store
init|=
name|secondaryRegion
operator|.
name|getStore
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cf1"
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|storeMemstoreSize
init|=
name|store
operator|.
name|getMemStoreSize
argument_list|()
operator|.
name|getHeapSize
argument_list|()
decl_stmt|;
name|long
name|regionMemstoreSize
init|=
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
decl_stmt|;
name|long
name|storeFlushableSize
init|=
name|store
operator|.
name|getFlushableSize
argument_list|()
operator|.
name|getHeapSize
argument_list|()
decl_stmt|;
name|long
name|storeSize
init|=
name|store
operator|.
name|getSize
argument_list|()
decl_stmt|;
name|long
name|storeSizeUncompressed
init|=
name|store
operator|.
name|getStoreSizeUncompressed
argument_list|()
decl_stmt|;
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|START_FLUSH
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying flush start in secondary"
argument_list|)
expr_stmt|;
name|PrepareFlushResult
name|result
init|=
name|secondaryRegion
operator|.
name|replayWALFlushStartMarker
argument_list|(
name|flushDesc
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|result
operator|.
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|result
operator|.
name|flushOpSeqId
argument_list|,
name|flushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
comment|// assert that the store memstore is smaller now
name|long
name|newStoreMemstoreSize
init|=
name|store
operator|.
name|getMemStoreSize
argument_list|()
operator|.
name|getHeapSize
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Memstore size reduced by:"
operator|+
name|StringUtils
operator|.
name|humanReadableInt
argument_list|(
name|newStoreMemstoreSize
operator|-
name|storeMemstoreSize
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|storeMemstoreSize
operator|>
name|newStoreMemstoreSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|COMMIT_FLUSH
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying flush commit in secondary"
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|.
name|replayWALFlushCommitMarker
argument_list|(
name|flushDesc
argument_list|)
expr_stmt|;
comment|// assert that the flush files are picked
name|expectedStoreFileCount
operator|++
expr_stmt|;
for|for
control|(
name|HStore
name|s
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|s
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|newFlushableSize
init|=
name|store
operator|.
name|getFlushableSize
argument_list|()
operator|.
name|getHeapSize
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|storeFlushableSize
operator|>
name|newFlushableSize
argument_list|)
expr_stmt|;
comment|// assert that the region memstore is smaller now
name|long
name|newRegionMemstoreSize
init|=
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|regionMemstoreSize
operator|>
name|newRegionMemstoreSize
argument_list|)
expr_stmt|;
comment|// assert that the store sizes are bigger
name|assertTrue
argument_list|(
name|store
operator|.
name|getSize
argument_list|()
operator|>
name|storeSize
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|store
operator|.
name|getStoreSizeUncompressed
argument_list|()
operator|>
name|storeSizeUncompressed
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|store
operator|.
name|getSize
argument_list|()
argument_list|,
name|store
operator|.
name|getStorefilesSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// after replay verify that everything is still visible
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|lastReplayed
operator|+
literal|1
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compactionDesc
operator|!=
literal|null
condition|)
block|{
name|secondaryRegion
operator|.
name|replayWALCompactionMarker
argument_list|(
name|compactionDesc
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
comment|// assert that the compaction is applied
for|for
control|(
name|HStore
name|store
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
if|if
condition|(
name|store
operator|.
name|getColumnFamilyName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"cf1"
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|store
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|store
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|lastReplayed
operator|=
name|replayEdit
argument_list|(
name|secondaryRegion
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
literal|400
operator|-
literal|1
argument_list|,
name|lastReplayed
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from secondary"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
literal|400
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from primary. Ensuring that files are not deleted"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|primaryRegion
argument_list|,
literal|0
argument_list|,
name|lastReplayed
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
for|for
control|(
name|HStore
name|store
range|:
name|primaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
if|if
condition|(
name|store
operator|.
name|getColumnFamilyName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"cf1"
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|store
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|store
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Tests cases where we prepare a flush with some seqId and we receive other flush start markers    * equal to, greater or less than the previous flush start marker.    */
annotation|@
name|Test
specifier|public
name|void
name|testReplayFlushStartMarkers
parameter_list|()
throws|throws
name|IOException
block|{
comment|// load some data to primary and flush. 1 flush and some more unflushed data
name|putDataWithFlushes
argument_list|(
name|primaryRegion
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|int
name|numRows
init|=
literal|200
decl_stmt|;
comment|// now replay the edits and the flush marker
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying edits and flush events in secondary"
argument_list|)
expr_stmt|;
name|FlushDescriptor
name|startFlushDesc
init|=
literal|null
decl_stmt|;
name|int
name|lastReplayed
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flushDesc
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushDesc
operator|!=
literal|null
condition|)
block|{
comment|// first verify that everything is replayed and visible before flush event replay
name|HStore
name|store
init|=
name|secondaryRegion
operator|.
name|getStore
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cf1"
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|storeMemstoreSize
init|=
name|store
operator|.
name|getMemStoreSize
argument_list|()
operator|.
name|getHeapSize
argument_list|()
decl_stmt|;
name|long
name|regionMemstoreSize
init|=
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
decl_stmt|;
name|long
name|storeFlushableSize
init|=
name|store
operator|.
name|getFlushableSize
argument_list|()
operator|.
name|getHeapSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|START_FLUSH
condition|)
block|{
name|startFlushDesc
operator|=
name|flushDesc
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying flush start in secondary"
argument_list|)
expr_stmt|;
name|PrepareFlushResult
name|result
init|=
name|secondaryRegion
operator|.
name|replayWALFlushStartMarker
argument_list|(
name|startFlushDesc
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|result
operator|.
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|result
operator|.
name|flushOpSeqId
argument_list|,
name|startFlushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|regionMemstoreSize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|storeFlushableSize
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// assert that the store memstore is smaller now
name|long
name|newStoreMemstoreSize
init|=
name|store
operator|.
name|getMemStoreSize
argument_list|()
operator|.
name|getHeapSize
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Memstore size reduced by:"
operator|+
name|StringUtils
operator|.
name|humanReadableInt
argument_list|(
name|newStoreMemstoreSize
operator|-
name|storeMemstoreSize
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|storeMemstoreSize
operator|>
name|newStoreMemstoreSize
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|lastReplayed
operator|+
literal|1
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
comment|// after replay verify that everything is still visible
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|lastReplayed
operator|+
literal|1
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lastReplayed
operator|=
name|replayEdit
argument_list|(
name|secondaryRegion
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|// at this point, there should be some data (rows 0-100) in memstore snapshot
comment|// and some more data in memstores (rows 100-200)
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
comment|// Test case 1: replay the same flush start marker again
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying same flush start in secondary again"
argument_list|)
expr_stmt|;
name|PrepareFlushResult
name|result
init|=
name|secondaryRegion
operator|.
name|replayWALFlushStartMarker
argument_list|(
name|startFlushDesc
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|// this should return null. Ignoring the flush start marker
comment|// assert that we still have prepared flush with the previous setup.
name|assertNotNull
argument_list|(
name|secondaryRegion
operator|.
name|getPrepareFlushResult
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|secondaryRegion
operator|.
name|getPrepareFlushResult
argument_list|()
operator|.
name|flushOpSeqId
argument_list|,
name|startFlushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// memstore is not empty
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
comment|// Test case 2: replay a flush start marker with a smaller seqId
name|FlushDescriptor
name|startFlushDescSmallerSeqId
init|=
name|clone
argument_list|(
name|startFlushDesc
argument_list|,
name|startFlushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
operator|-
literal|50
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying same flush start in secondary again "
operator|+
name|startFlushDescSmallerSeqId
argument_list|)
expr_stmt|;
name|result
operator|=
name|secondaryRegion
operator|.
name|replayWALFlushStartMarker
argument_list|(
name|startFlushDescSmallerSeqId
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|// this should return null. Ignoring the flush start marker
comment|// assert that we still have prepared flush with the previous setup.
name|assertNotNull
argument_list|(
name|secondaryRegion
operator|.
name|getPrepareFlushResult
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|secondaryRegion
operator|.
name|getPrepareFlushResult
argument_list|()
operator|.
name|flushOpSeqId
argument_list|,
name|startFlushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// memstore is not empty
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
comment|// Test case 3: replay a flush start marker with a larger seqId
name|FlushDescriptor
name|startFlushDescLargerSeqId
init|=
name|clone
argument_list|(
name|startFlushDesc
argument_list|,
name|startFlushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
operator|+
literal|50
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying same flush start in secondary again "
operator|+
name|startFlushDescLargerSeqId
argument_list|)
expr_stmt|;
name|result
operator|=
name|secondaryRegion
operator|.
name|replayWALFlushStartMarker
argument_list|(
name|startFlushDescLargerSeqId
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|// this should return null. Ignoring the flush start marker
comment|// assert that we still have prepared flush with the previous setup.
name|assertNotNull
argument_list|(
name|secondaryRegion
operator|.
name|getPrepareFlushResult
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|secondaryRegion
operator|.
name|getPrepareFlushResult
argument_list|()
operator|.
name|flushOpSeqId
argument_list|,
name|startFlushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// memstore is not empty
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from secondary"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from primary."
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|primaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests the case where we prepare a flush with some seqId and we receive a flush commit marker    * less than the previous flush start marker.    */
annotation|@
name|Test
specifier|public
name|void
name|testReplayFlushCommitMarkerSmallerThanFlushStartMarker
parameter_list|()
throws|throws
name|IOException
block|{
comment|// load some data to primary and flush. 2 flushes and some more unflushed data
name|putDataWithFlushes
argument_list|(
name|primaryRegion
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|int
name|numRows
init|=
literal|300
decl_stmt|;
comment|// now replay the edits and the flush marker
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying edits and flush events in secondary"
argument_list|)
expr_stmt|;
name|FlushDescriptor
name|startFlushDesc
init|=
literal|null
decl_stmt|;
name|FlushDescriptor
name|commitFlushDesc
init|=
literal|null
decl_stmt|;
name|int
name|lastReplayed
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|lastReplayed
argument_list|)
expr_stmt|;
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flushDesc
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushDesc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|START_FLUSH
condition|)
block|{
comment|// don't replay the first flush start marker, hold on to it, replay the second one
if|if
condition|(
name|startFlushDesc
operator|==
literal|null
condition|)
block|{
name|startFlushDesc
operator|=
name|flushDesc
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying flush start in secondary"
argument_list|)
expr_stmt|;
name|startFlushDesc
operator|=
name|flushDesc
expr_stmt|;
name|PrepareFlushResult
name|result
init|=
name|secondaryRegion
operator|.
name|replayWALFlushStartMarker
argument_list|(
name|startFlushDesc
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|result
operator|.
name|result
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|COMMIT_FLUSH
condition|)
block|{
comment|// do not replay any flush commit yet
if|if
condition|(
name|commitFlushDesc
operator|==
literal|null
condition|)
block|{
name|commitFlushDesc
operator|=
name|flushDesc
expr_stmt|;
comment|// hold on to the first flush commit marker
block|}
block|}
comment|// after replay verify that everything is still visible
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|lastReplayed
operator|+
literal|1
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lastReplayed
operator|=
name|replayEdit
argument_list|(
name|secondaryRegion
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|// at this point, there should be some data (rows 0-200) in memstore snapshot
comment|// and some more data in memstores (rows 200-300)
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
comment|// no store files in the region
name|int
name|expectedStoreFileCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|HStore
name|s
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|s
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|regionMemstoreSize
init|=
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
decl_stmt|;
comment|// Test case 1: replay the a flush commit marker smaller than what we have prepared
name|LOG
operator|.
name|info
argument_list|(
literal|"Testing replaying flush COMMIT "
operator|+
name|commitFlushDesc
operator|+
literal|" on top of flush START"
operator|+
name|startFlushDesc
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|commitFlushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
operator|<
name|startFlushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying flush commit in secondary"
operator|+
name|commitFlushDesc
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|.
name|replayWALFlushCommitMarker
argument_list|(
name|commitFlushDesc
argument_list|)
expr_stmt|;
comment|// assert that the flush files are picked
name|expectedStoreFileCount
operator|++
expr_stmt|;
for|for
control|(
name|HStore
name|s
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|s
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|HStore
name|store
init|=
name|secondaryRegion
operator|.
name|getStore
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cf1"
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|newFlushableSize
init|=
name|store
operator|.
name|getFlushableSize
argument_list|()
operator|.
name|getHeapSize
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|newFlushableSize
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// assert that the memstore is not dropped
comment|// assert that the region memstore is same as before
name|long
name|newRegionMemstoreSize
init|=
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|regionMemstoreSize
argument_list|,
name|newRegionMemstoreSize
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|secondaryRegion
operator|.
name|getPrepareFlushResult
argument_list|()
argument_list|)
expr_stmt|;
comment|// not dropped
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from secondary"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from primary."
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|primaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests the case where we prepare a flush with some seqId and we receive a flush commit marker    * larger than the previous flush start marker.    */
annotation|@
name|Test
specifier|public
name|void
name|testReplayFlushCommitMarkerLargerThanFlushStartMarker
parameter_list|()
throws|throws
name|IOException
block|{
comment|// load some data to primary and flush. 1 flush and some more unflushed data
name|putDataWithFlushes
argument_list|(
name|primaryRegion
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|int
name|numRows
init|=
literal|200
decl_stmt|;
comment|// now replay the edits and the flush marker
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying edits and flush events in secondary"
argument_list|)
expr_stmt|;
name|FlushDescriptor
name|startFlushDesc
init|=
literal|null
decl_stmt|;
name|FlushDescriptor
name|commitFlushDesc
init|=
literal|null
decl_stmt|;
name|int
name|lastReplayed
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flushDesc
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushDesc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|START_FLUSH
condition|)
block|{
if|if
condition|(
name|startFlushDesc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying flush start in secondary"
argument_list|)
expr_stmt|;
name|startFlushDesc
operator|=
name|flushDesc
expr_stmt|;
name|PrepareFlushResult
name|result
init|=
name|secondaryRegion
operator|.
name|replayWALFlushStartMarker
argument_list|(
name|startFlushDesc
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|result
operator|.
name|result
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|COMMIT_FLUSH
condition|)
block|{
comment|// do not replay any flush commit yet
comment|// hold on to the flush commit marker but simulate a larger
comment|// flush commit seqId
name|commitFlushDesc
operator|=
name|FlushDescriptor
operator|.
name|newBuilder
argument_list|(
name|flushDesc
argument_list|)
operator|.
name|setFlushSequenceNumber
argument_list|(
name|flushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
operator|+
literal|50
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// after replay verify that everything is still visible
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|lastReplayed
operator|+
literal|1
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lastReplayed
operator|=
name|replayEdit
argument_list|(
name|secondaryRegion
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|// at this point, there should be some data (rows 0-100) in memstore snapshot
comment|// and some more data in memstores (rows 100-200)
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
comment|// no store files in the region
name|int
name|expectedStoreFileCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|HStore
name|s
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|s
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|regionMemstoreSize
init|=
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
decl_stmt|;
comment|// Test case 1: replay the a flush commit marker larger than what we have prepared
name|LOG
operator|.
name|info
argument_list|(
literal|"Testing replaying flush COMMIT "
operator|+
name|commitFlushDesc
operator|+
literal|" on top of flush START"
operator|+
name|startFlushDesc
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|commitFlushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
operator|>
name|startFlushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying flush commit in secondary"
operator|+
name|commitFlushDesc
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|.
name|replayWALFlushCommitMarker
argument_list|(
name|commitFlushDesc
argument_list|)
expr_stmt|;
comment|// assert that the flush files are picked
name|expectedStoreFileCount
operator|++
expr_stmt|;
for|for
control|(
name|HStore
name|s
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|s
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|HStore
name|store
init|=
name|secondaryRegion
operator|.
name|getStore
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cf1"
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|newFlushableSize
init|=
name|store
operator|.
name|getFlushableSize
argument_list|()
operator|.
name|getHeapSize
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|newFlushableSize
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// assert that the memstore is not dropped
comment|// assert that the region memstore is smaller than before, but not empty
name|long
name|newRegionMemstoreSize
init|=
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|newRegionMemstoreSize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|regionMemstoreSize
operator|>
name|newRegionMemstoreSize
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|secondaryRegion
operator|.
name|getPrepareFlushResult
argument_list|()
argument_list|)
expr_stmt|;
comment|// prepare snapshot should be dropped
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from secondary"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from primary."
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|primaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests the case where we receive a flush commit before receiving any flush prepare markers.    * The memstore edits should be dropped after the flush commit replay since they should be in    * flushed files    */
annotation|@
name|Test
specifier|public
name|void
name|testReplayFlushCommitMarkerWithoutFlushStartMarkerDroppableMemstore
parameter_list|()
throws|throws
name|IOException
block|{
name|testReplayFlushCommitMarkerWithoutFlushStartMarker
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests the case where we receive a flush commit before receiving any flush prepare markers.    * The memstore edits should be not dropped after the flush commit replay since not every edit    * will be in flushed files (based on seqId)    */
annotation|@
name|Test
specifier|public
name|void
name|testReplayFlushCommitMarkerWithoutFlushStartMarkerNonDroppableMemstore
parameter_list|()
throws|throws
name|IOException
block|{
name|testReplayFlushCommitMarkerWithoutFlushStartMarker
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests the case where we receive a flush commit before receiving any flush prepare markers    */
specifier|public
name|void
name|testReplayFlushCommitMarkerWithoutFlushStartMarker
parameter_list|(
name|boolean
name|droppableMemstore
parameter_list|)
throws|throws
name|IOException
block|{
comment|// load some data to primary and flush. 1 flushes and some more unflushed data.
comment|// write more data after flush depending on whether droppableSnapshot
name|putDataWithFlushes
argument_list|(
name|primaryRegion
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|,
name|droppableMemstore
condition|?
literal|0
else|:
literal|100
argument_list|)
expr_stmt|;
name|int
name|numRows
init|=
name|droppableMemstore
condition|?
literal|100
else|:
literal|200
decl_stmt|;
comment|// now replay the edits and the flush marker
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying edits and flush events in secondary"
argument_list|)
expr_stmt|;
name|FlushDescriptor
name|commitFlushDesc
init|=
literal|null
decl_stmt|;
name|int
name|lastReplayed
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flushDesc
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushDesc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|START_FLUSH
condition|)
block|{
comment|// do not replay flush start marker
block|}
elseif|else
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|COMMIT_FLUSH
condition|)
block|{
name|commitFlushDesc
operator|=
name|flushDesc
expr_stmt|;
comment|// hold on to the flush commit marker
block|}
comment|// after replay verify that everything is still visible
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|lastReplayed
operator|+
literal|1
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lastReplayed
operator|=
name|replayEdit
argument_list|(
name|secondaryRegion
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|// at this point, there should be some data (rows 0-200) in the memstore without snapshot
comment|// and some more data in memstores (rows 100-300)
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
comment|// no store files in the region
name|int
name|expectedStoreFileCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|HStore
name|s
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|s
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|regionMemstoreSize
init|=
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
decl_stmt|;
comment|// Test case 1: replay a flush commit marker without start flush marker
name|assertNull
argument_list|(
name|secondaryRegion
operator|.
name|getPrepareFlushResult
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|commitFlushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// ensure all files are visible in secondary
for|for
control|(
name|HStore
name|store
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
name|assertTrue
argument_list|(
name|store
operator|.
name|getMaxSequenceId
argument_list|()
operator|.
name|orElse
argument_list|(
literal|0L
argument_list|)
operator|<=
name|secondaryRegion
operator|.
name|getReadPoint
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying flush commit in secondary"
operator|+
name|commitFlushDesc
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|.
name|replayWALFlushCommitMarker
argument_list|(
name|commitFlushDesc
argument_list|)
expr_stmt|;
comment|// assert that the flush files are picked
name|expectedStoreFileCount
operator|++
expr_stmt|;
for|for
control|(
name|HStore
name|s
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|s
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|HStore
name|store
init|=
name|secondaryRegion
operator|.
name|getStore
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cf1"
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|newFlushableSize
init|=
name|store
operator|.
name|getFlushableSize
argument_list|()
operator|.
name|getHeapSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|droppableMemstore
condition|)
block|{
comment|// assert that the memstore is dropped
name|assertTrue
argument_list|(
name|newFlushableSize
operator|==
name|MutableSegment
operator|.
name|DEEP_OVERHEAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|newFlushableSize
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// assert that the memstore is not dropped
block|}
comment|// assert that the region memstore is same as before (we could not drop)
name|long
name|newRegionMemstoreSize
init|=
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|droppableMemstore
condition|)
block|{
name|assertTrue
argument_list|(
literal|0
operator|==
name|newRegionMemstoreSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|regionMemstoreSize
operator|==
name|newRegionMemstoreSize
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from secondary"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from primary."
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|primaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
specifier|private
name|FlushDescriptor
name|clone
parameter_list|(
name|FlushDescriptor
name|flush
parameter_list|,
name|long
name|flushSeqId
parameter_list|)
block|{
return|return
name|FlushDescriptor
operator|.
name|newBuilder
argument_list|(
name|flush
argument_list|)
operator|.
name|setFlushSequenceNumber
argument_list|(
name|flushSeqId
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Tests replaying region open markers from primary region. Checks whether the files are picked up    */
annotation|@
name|Test
specifier|public
name|void
name|testReplayRegionOpenEvent
parameter_list|()
throws|throws
name|IOException
block|{
name|putDataWithFlushes
argument_list|(
name|primaryRegion
argument_list|,
literal|100
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|// no flush
name|int
name|numRows
init|=
literal|100
decl_stmt|;
comment|// close the region and open again.
name|primaryRegion
operator|.
name|close
argument_list|()
expr_stmt|;
name|primaryRegion
operator|=
name|HRegion
operator|.
name|openHRegion
argument_list|(
name|rootDir
argument_list|,
name|primaryHri
argument_list|,
name|htd
argument_list|,
name|walPrimary
argument_list|,
name|CONF
argument_list|,
name|rss
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// now replay the edits and the flush marker
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|RegionEventDescriptor
argument_list|>
name|regionEvents
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying edits and region events in secondary"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flushDesc
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|RegionEventDescriptor
name|regionEventDesc
init|=
name|WALEdit
operator|.
name|getRegionEventDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushDesc
operator|!=
literal|null
condition|)
block|{
comment|// don't replay flush events
block|}
elseif|else
if|if
condition|(
name|regionEventDesc
operator|!=
literal|null
condition|)
block|{
name|regionEvents
operator|.
name|add
argument_list|(
name|regionEventDesc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// don't replay edits
block|}
block|}
comment|// we should have 1 open, 1 close and 1 open event
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|regionEvents
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// replay the first region open event.
name|secondaryRegion
operator|.
name|replayWALRegionEventMarker
argument_list|(
name|regionEvents
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// replay the close event as well
name|secondaryRegion
operator|.
name|replayWALRegionEventMarker
argument_list|(
name|regionEvents
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// no store files in the region
name|int
name|expectedStoreFileCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|HStore
name|s
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|s
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|regionMemstoreSize
init|=
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|regionMemstoreSize
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// now replay the region open event that should contain new file locations
name|LOG
operator|.
name|info
argument_list|(
literal|"Testing replaying region open event "
operator|+
name|regionEvents
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|.
name|replayWALRegionEventMarker
argument_list|(
name|regionEvents
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// assert that the flush files are picked
name|expectedStoreFileCount
operator|++
expr_stmt|;
for|for
control|(
name|HStore
name|s
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|s
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|HStore
name|store
init|=
name|secondaryRegion
operator|.
name|getStore
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cf1"
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|newFlushableSize
init|=
name|store
operator|.
name|getFlushableSize
argument_list|()
operator|.
name|getHeapSize
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|newFlushableSize
operator|==
name|MutableSegment
operator|.
name|DEEP_OVERHEAD
argument_list|)
expr_stmt|;
comment|// assert that the region memstore is empty
name|long
name|newRegionMemstoreSize
init|=
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|newRegionMemstoreSize
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|secondaryRegion
operator|.
name|getPrepareFlushResult
argument_list|()
argument_list|)
expr_stmt|;
comment|//prepare snapshot should be dropped if any
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from secondary"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from primary."
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|primaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests the case where we replay a region open event after a flush start but before receiving    * flush commit    */
annotation|@
name|Test
specifier|public
name|void
name|testReplayRegionOpenEventAfterFlushStart
parameter_list|()
throws|throws
name|IOException
block|{
name|putDataWithFlushes
argument_list|(
name|primaryRegion
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|int
name|numRows
init|=
literal|200
decl_stmt|;
comment|// close the region and open again.
name|primaryRegion
operator|.
name|close
argument_list|()
expr_stmt|;
name|primaryRegion
operator|=
name|HRegion
operator|.
name|openHRegion
argument_list|(
name|rootDir
argument_list|,
name|primaryHri
argument_list|,
name|htd
argument_list|,
name|walPrimary
argument_list|,
name|CONF
argument_list|,
name|rss
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// now replay the edits and the flush marker
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|RegionEventDescriptor
argument_list|>
name|regionEvents
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying edits and region events in secondary"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flushDesc
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|RegionEventDescriptor
name|regionEventDesc
init|=
name|WALEdit
operator|.
name|getRegionEventDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushDesc
operator|!=
literal|null
condition|)
block|{
comment|// only replay flush start
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|START_FLUSH
condition|)
block|{
name|secondaryRegion
operator|.
name|replayWALFlushStartMarker
argument_list|(
name|flushDesc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regionEventDesc
operator|!=
literal|null
condition|)
block|{
name|regionEvents
operator|.
name|add
argument_list|(
name|regionEventDesc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|replayEdit
argument_list|(
name|secondaryRegion
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|// at this point, there should be some data (rows 0-100) in the memstore snapshot
comment|// and some more data in memstores (rows 100-200)
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
comment|// we should have 1 open, 1 close and 1 open event
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|regionEvents
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// no store files in the region
name|int
name|expectedStoreFileCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|HStore
name|s
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|s
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// now replay the region open event that should contain new file locations
name|LOG
operator|.
name|info
argument_list|(
literal|"Testing replaying region open event "
operator|+
name|regionEvents
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|.
name|replayWALRegionEventMarker
argument_list|(
name|regionEvents
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// assert that the flush files are picked
name|expectedStoreFileCount
operator|=
literal|2
expr_stmt|;
comment|// two flushes happened
for|for
control|(
name|HStore
name|s
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
name|assertEquals
argument_list|(
name|expectedStoreFileCount
argument_list|,
name|s
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|HStore
name|store
init|=
name|secondaryRegion
operator|.
name|getStore
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"cf1"
argument_list|)
argument_list|)
decl_stmt|;
name|MemStoreSize
name|newSnapshotSize
init|=
name|store
operator|.
name|getSnapshotSize
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|newSnapshotSize
operator|.
name|getDataSize
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// assert that the region memstore is empty
name|long
name|newRegionMemstoreSize
init|=
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|newRegionMemstoreSize
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|secondaryRegion
operator|.
name|getPrepareFlushResult
argument_list|()
argument_list|)
expr_stmt|;
comment|//prepare snapshot should be dropped if any
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from secondary"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from primary."
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|primaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests whether edits coming in for replay are skipped which have smaller seq id than the seqId    * of the last replayed region open event.    */
annotation|@
name|Test
specifier|public
name|void
name|testSkippingEditsWithSmallerSeqIdAfterRegionOpenEvent
parameter_list|()
throws|throws
name|IOException
block|{
name|putDataWithFlushes
argument_list|(
name|primaryRegion
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int
name|numRows
init|=
literal|100
decl_stmt|;
comment|// close the region and open again.
name|primaryRegion
operator|.
name|close
argument_list|()
expr_stmt|;
name|primaryRegion
operator|=
name|HRegion
operator|.
name|openHRegion
argument_list|(
name|rootDir
argument_list|,
name|primaryHri
argument_list|,
name|htd
argument_list|,
name|walPrimary
argument_list|,
name|CONF
argument_list|,
name|rss
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// now replay the edits and the flush marker
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|RegionEventDescriptor
argument_list|>
name|regionEvents
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|WAL
operator|.
name|Entry
argument_list|>
name|edits
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying edits and region events in secondary"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flushDesc
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|RegionEventDescriptor
name|regionEventDesc
init|=
name|WALEdit
operator|.
name|getRegionEventDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushDesc
operator|!=
literal|null
condition|)
block|{
comment|// don't replay flushes
block|}
elseif|else
if|if
condition|(
name|regionEventDesc
operator|!=
literal|null
condition|)
block|{
name|regionEvents
operator|.
name|add
argument_list|(
name|regionEventDesc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|edits
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|// replay the region open of first open, but with the seqid of the second open
comment|// this way non of the flush files will be picked up.
name|secondaryRegion
operator|.
name|replayWALRegionEventMarker
argument_list|(
name|RegionEventDescriptor
operator|.
name|newBuilder
argument_list|(
name|regionEvents
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|setLogSequenceNumber
argument_list|(
name|regionEvents
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|getLogSequenceNumber
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
comment|// replay edits from the before region close. If replay does not
comment|// skip these the following verification will NOT fail.
for|for
control|(
name|WAL
operator|.
name|Entry
name|entry
range|:
name|edits
control|)
block|{
name|replayEdit
argument_list|(
name|secondaryRegion
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|boolean
name|expectedFail
init|=
literal|false
decl_stmt|;
try|try
block|{
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{
name|expectedFail
operator|=
literal|true
expr_stmt|;
comment|// expected
block|}
if|if
condition|(
operator|!
name|expectedFail
condition|)
block|{
name|fail
argument_list|(
literal|"Should have failed this verification"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReplayFlushSeqIds
parameter_list|()
throws|throws
name|IOException
block|{
comment|// load some data to primary and flush
name|int
name|start
init|=
literal|0
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Writing some data to primary from "
operator|+
name|start
operator|+
literal|" to "
operator|+
operator|(
name|start
operator|+
literal|100
operator|)
argument_list|)
expr_stmt|;
name|putData
argument_list|(
name|primaryRegion
argument_list|,
name|Durability
operator|.
name|SYNC_WAL
argument_list|,
name|start
argument_list|,
literal|100
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Flushing primary, creating 3 files for 3 stores"
argument_list|)
expr_stmt|;
name|primaryRegion
operator|.
name|flush
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// now replay the flush marker
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
name|long
name|flushSeqId
init|=
operator|-
literal|1
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying flush events in secondary"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flushDesc
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushDesc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|START_FLUSH
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying flush start in secondary"
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|.
name|replayWALFlushStartMarker
argument_list|(
name|flushDesc
argument_list|)
expr_stmt|;
name|flushSeqId
operator|=
name|flushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flushDesc
operator|.
name|getAction
argument_list|()
operator|==
name|FlushAction
operator|.
name|COMMIT_FLUSH
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying flush commit in secondary"
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|.
name|replayWALFlushCommitMarker
argument_list|(
name|flushDesc
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|flushSeqId
argument_list|,
name|flushDesc
operator|.
name|getFlushSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// else do not replay
block|}
comment|// TODO: what to do with this?
comment|// assert that the newly picked up flush file is visible
name|long
name|readPoint
init|=
name|secondaryRegion
operator|.
name|getMVCC
argument_list|()
operator|.
name|getReadPoint
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|flushSeqId
argument_list|,
name|readPoint
argument_list|)
expr_stmt|;
comment|// after replay verify that everything is still visible
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSeqIdsFromReplay
parameter_list|()
throws|throws
name|IOException
block|{
comment|// test the case where seqId's coming from replayed WALEdits are made persisted with their
comment|// original seqIds and they are made visible through mvcc read point upon replay
name|String
name|method
init|=
name|name
operator|.
name|getMethodName
argument_list|()
decl_stmt|;
name|byte
index|[]
name|tableName
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|method
argument_list|)
decl_stmt|;
name|byte
index|[]
name|family
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"family"
argument_list|)
decl_stmt|;
name|HRegion
name|region
init|=
name|initHRegion
argument_list|(
name|tableName
argument_list|,
name|method
argument_list|,
name|family
argument_list|)
decl_stmt|;
try|try
block|{
comment|// replay an entry that is bigger than current read point
name|long
name|readPoint
init|=
name|region
operator|.
name|getMVCC
argument_list|()
operator|.
name|getReadPoint
argument_list|()
decl_stmt|;
name|long
name|origSeqId
init|=
name|readPoint
operator|+
literal|100
decl_stmt|;
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|row
argument_list|)
operator|.
name|addColumn
argument_list|(
name|family
argument_list|,
name|row
argument_list|,
name|row
argument_list|)
decl_stmt|;
name|put
operator|.
name|setDurability
argument_list|(
name|Durability
operator|.
name|SKIP_WAL
argument_list|)
expr_stmt|;
comment|// we replay with skip wal
name|replay
argument_list|(
name|region
argument_list|,
name|put
argument_list|,
name|origSeqId
argument_list|)
expr_stmt|;
comment|// read point should have advanced to this seqId
name|assertGet
argument_list|(
name|region
argument_list|,
name|family
argument_list|,
name|row
argument_list|)
expr_stmt|;
comment|// region seqId should have advanced at least to this seqId
name|assertEquals
argument_list|(
name|origSeqId
argument_list|,
name|region
operator|.
name|getReadPoint
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// replay an entry that is smaller than current read point
comment|// caution: adding an entry below current read point might cause partial dirty reads. Normal
comment|// replay does not allow reads while replay is going on.
name|put
operator|=
operator|new
name|Put
argument_list|(
name|row2
argument_list|)
operator|.
name|addColumn
argument_list|(
name|family
argument_list|,
name|row2
argument_list|,
name|row2
argument_list|)
expr_stmt|;
name|put
operator|.
name|setDurability
argument_list|(
name|Durability
operator|.
name|SKIP_WAL
argument_list|)
expr_stmt|;
name|replay
argument_list|(
name|region
argument_list|,
name|put
argument_list|,
name|origSeqId
operator|-
literal|50
argument_list|)
expr_stmt|;
name|assertGet
argument_list|(
name|region
argument_list|,
name|family
argument_list|,
name|row2
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|region
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Tests that a region opened in secondary mode would not write region open / close    * events to its WAL.    * @throws IOException    */
annotation|@
name|Test
specifier|public
name|void
name|testSecondaryRegionDoesNotWriteRegionEventsToWAL
parameter_list|()
throws|throws
name|IOException
block|{
name|secondaryRegion
operator|.
name|close
argument_list|()
expr_stmt|;
name|walSecondary
operator|=
name|spy
argument_list|(
name|walSecondary
argument_list|)
expr_stmt|;
comment|// test for region open and close
name|secondaryRegion
operator|=
name|HRegion
operator|.
name|openHRegion
argument_list|(
name|secondaryHri
argument_list|,
name|htd
argument_list|,
name|walSecondary
argument_list|,
name|CONF
argument_list|,
name|rss
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|walSecondary
argument_list|,
name|times
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|any
argument_list|(
name|RegionInfo
operator|.
name|class
argument_list|)
argument_list|,
name|any
argument_list|(
name|WALKeyImpl
operator|.
name|class
argument_list|)
argument_list|,
name|any
argument_list|(
name|WALEdit
operator|.
name|class
argument_list|)
argument_list|,
name|anyBoolean
argument_list|()
argument_list|)
expr_stmt|;
comment|// test for replay prepare flush
name|putDataByReplay
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|.
name|replayWALFlushStartMarker
argument_list|(
name|FlushDescriptor
operator|.
name|newBuilder
argument_list|()
operator|.
name|setFlushSequenceNumber
argument_list|(
literal|10
argument_list|)
operator|.
name|setTableName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getTableDescriptor
argument_list|()
operator|.
name|getTableName
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setAction
argument_list|(
name|FlushAction
operator|.
name|START_FLUSH
argument_list|)
operator|.
name|setEncodedRegionName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setRegionName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|walSecondary
argument_list|,
name|times
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|any
argument_list|(
name|RegionInfo
operator|.
name|class
argument_list|)
argument_list|,
name|any
argument_list|(
name|WALKeyImpl
operator|.
name|class
argument_list|)
argument_list|,
name|any
argument_list|(
name|WALEdit
operator|.
name|class
argument_list|)
argument_list|,
name|anyBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|.
name|close
argument_list|()
expr_stmt|;
name|verify
argument_list|(
name|walSecondary
argument_list|,
name|times
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|any
argument_list|(
name|RegionInfo
operator|.
name|class
argument_list|)
argument_list|,
name|any
argument_list|(
name|WALKeyImpl
operator|.
name|class
argument_list|)
argument_list|,
name|any
argument_list|(
name|WALEdit
operator|.
name|class
argument_list|)
argument_list|,
name|anyBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests the reads enabled flag for the region. When unset all reads should be rejected    */
annotation|@
name|Test
specifier|public
name|void
name|testRegionReadsEnabledFlag
parameter_list|()
throws|throws
name|IOException
block|{
name|putDataByReplay
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
comment|// now disable reads
name|secondaryRegion
operator|.
name|setReadsEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Should have failed with IOException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// expected
block|}
comment|// verify that we can still replay data
name|putDataByReplay
argument_list|(
name|secondaryRegion
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
comment|// now enable reads again
name|secondaryRegion
operator|.
name|setReadsEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests the case where a request for flush cache is sent to the region, but region cannot flush.    * It should write the flush request marker instead.    */
annotation|@
name|Test
specifier|public
name|void
name|testWriteFlushRequestMarker
parameter_list|()
throws|throws
name|IOException
block|{
comment|// primary region is empty at this point. Request a flush with writeFlushRequestWalMarker=false
name|FlushResultImpl
name|result
init|=
name|primaryRegion
operator|.
name|flushcache
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
name|FlushLifeCycleTracker
operator|.
name|DUMMY
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|FlushResultImpl
operator|.
name|Result
operator|.
name|CANNOT_FLUSH_MEMSTORE_EMPTY
argument_list|,
name|result
operator|.
name|result
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|result
operator|.
name|wroteFlushWalMarker
argument_list|)
expr_stmt|;
comment|// request flush again, but this time with writeFlushRequestWalMarker = true
name|result
operator|=
name|primaryRegion
operator|.
name|flushcache
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
name|FlushLifeCycleTracker
operator|.
name|DUMMY
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|FlushResultImpl
operator|.
name|Result
operator|.
name|CANNOT_FLUSH_MEMSTORE_EMPTY
argument_list|,
name|result
operator|.
name|result
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|result
operator|.
name|wroteFlushWalMarker
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FlushDescriptor
argument_list|>
name|flushes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flush
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flush
operator|!=
literal|null
condition|)
block|{
name|flushes
operator|.
name|add
argument_list|(
name|flush
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|flushes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|flushes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|FlushDescriptor
operator|.
name|FlushAction
operator|.
name|CANNOT_FLUSH
argument_list|,
name|flushes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getAction
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the case where the secondary region replica is not in reads enabled state because it is    * waiting for a flush or region open marker from primary region. Replaying CANNOT_FLUSH    * flush marker entry should restore the reads enabled status in the region and allow the reads    * to continue.    */
annotation|@
name|Test
specifier|public
name|void
name|testReplayingFlushRequestRestoresReadsEnabledState
parameter_list|()
throws|throws
name|IOException
block|{
name|disableReads
argument_list|(
name|secondaryRegion
argument_list|)
expr_stmt|;
comment|// Test case 1: Test that replaying CANNOT_FLUSH request marker assuming this came from
comment|// triggered flush restores readsEnabled
name|primaryRegion
operator|.
name|flushcache
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
name|FlushLifeCycleTracker
operator|.
name|DUMMY
argument_list|)
expr_stmt|;
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flush
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flush
operator|!=
literal|null
condition|)
block|{
name|secondaryRegion
operator|.
name|replayWALFlushMarker
argument_list|(
name|flush
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now reads should be enabled
name|secondaryRegion
operator|.
name|get
argument_list|(
operator|new
name|Get
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the case where the secondary region replica is not in reads enabled state because it is    * waiting for a flush or region open marker from primary region. Replaying flush start and commit    * entries should restore the reads enabled status in the region and allow the reads    * to continue.    */
annotation|@
name|Test
specifier|public
name|void
name|testReplayingFlushRestoresReadsEnabledState
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Test case 2: Test that replaying FLUSH_START and FLUSH_COMMIT markers assuming these came
comment|// from triggered flush restores readsEnabled
name|disableReads
argument_list|(
name|secondaryRegion
argument_list|)
expr_stmt|;
comment|// put some data in primary
name|putData
argument_list|(
name|primaryRegion
argument_list|,
name|Durability
operator|.
name|SYNC_WAL
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|primaryRegion
operator|.
name|flush
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// I seem to need to push more edits through so the WAL flushes on local fs. This was not
comment|// needed before HBASE-15028. Not sure whats up. I can see that we have not flushed if I
comment|// look at the WAL if I pause the test here and then use WALPrettyPrinter to look at content..
comment|// Doing same check before HBASE-15028 I can see all edits flushed to the WAL. Somethings up
comment|// but can't figure it... and this is only test that seems to suffer this flush issue.
comment|// St.Ack 20160201
name|putData
argument_list|(
name|primaryRegion
argument_list|,
name|Durability
operator|.
name|SYNC_WAL
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|Objects
operator|.
name|toString
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flush
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flush
operator|!=
literal|null
condition|)
block|{
name|secondaryRegion
operator|.
name|replayWALFlushMarker
argument_list|(
name|flush
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|replayEdit
argument_list|(
name|secondaryRegion
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now reads should be enabled
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the case where the secondary region replica is not in reads enabled state because it is    * waiting for a flush or region open marker from primary region. Replaying flush start and commit    * entries should restore the reads enabled status in the region and allow the reads    * to continue.    */
annotation|@
name|Test
specifier|public
name|void
name|testReplayingFlushWithEmptyMemstoreRestoresReadsEnabledState
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Test case 2: Test that replaying FLUSH_START and FLUSH_COMMIT markers assuming these came
comment|// from triggered flush restores readsEnabled
name|disableReads
argument_list|(
name|secondaryRegion
argument_list|)
expr_stmt|;
comment|// put some data in primary
name|putData
argument_list|(
name|primaryRegion
argument_list|,
name|Durability
operator|.
name|SYNC_WAL
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|primaryRegion
operator|.
name|flush
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flush
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flush
operator|!=
literal|null
condition|)
block|{
name|secondaryRegion
operator|.
name|replayWALFlushMarker
argument_list|(
name|flush
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now reads should be enabled
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the case where the secondary region replica is not in reads enabled state because it is    * waiting for a flush or region open marker from primary region. Replaying region open event    * entry from primary should restore the reads enabled status in the region and allow the reads    * to continue.    */
annotation|@
name|Test
specifier|public
name|void
name|testReplayingRegionOpenEventRestoresReadsEnabledState
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Test case 3: Test that replaying region open event markers restores readsEnabled
name|disableReads
argument_list|(
name|secondaryRegion
argument_list|)
expr_stmt|;
name|primaryRegion
operator|.
name|close
argument_list|()
expr_stmt|;
name|primaryRegion
operator|=
name|HRegion
operator|.
name|openHRegion
argument_list|(
name|rootDir
argument_list|,
name|primaryHri
argument_list|,
name|htd
argument_list|,
name|walPrimary
argument_list|,
name|CONF
argument_list|,
name|rss
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|RegionEventDescriptor
name|regionEventDesc
init|=
name|WALEdit
operator|.
name|getRegionEventDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionEventDesc
operator|!=
literal|null
condition|)
block|{
name|secondaryRegion
operator|.
name|replayWALRegionEventMarker
argument_list|(
name|regionEventDesc
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now reads should be enabled
name|secondaryRegion
operator|.
name|get
argument_list|(
operator|new
name|Get
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRefresStoreFiles
parameter_list|()
throws|throws
name|IOException
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|primaryRegion
operator|.
name|getStoreFileList
argument_list|(
name|families
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|secondaryRegion
operator|.
name|getStoreFileList
argument_list|(
name|families
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Test case 1: refresh with an empty region
name|secondaryRegion
operator|.
name|refreshStoreFiles
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|secondaryRegion
operator|.
name|getStoreFileList
argument_list|(
name|families
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// do one flush
name|putDataWithFlushes
argument_list|(
name|primaryRegion
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int
name|numRows
init|=
literal|100
decl_stmt|;
comment|// refresh the store file list, and ensure that the files are picked up.
name|secondaryRegion
operator|.
name|refreshStoreFiles
argument_list|()
expr_stmt|;
name|assertPathListsEqual
argument_list|(
name|primaryRegion
operator|.
name|getStoreFileList
argument_list|(
name|families
argument_list|)
argument_list|,
name|secondaryRegion
operator|.
name|getStoreFileList
argument_list|(
name|families
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|families
operator|.
name|length
argument_list|,
name|secondaryRegion
operator|.
name|getStoreFileList
argument_list|(
name|families
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from secondary"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
comment|// Test case 2: 3 some more flushes
name|putDataWithFlushes
argument_list|(
name|primaryRegion
argument_list|,
literal|100
argument_list|,
literal|300
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|numRows
operator|=
literal|300
expr_stmt|;
comment|// refresh the store file list, and ensure that the files are picked up.
name|secondaryRegion
operator|.
name|refreshStoreFiles
argument_list|()
expr_stmt|;
name|assertPathListsEqual
argument_list|(
name|primaryRegion
operator|.
name|getStoreFileList
argument_list|(
name|families
argument_list|)
argument_list|,
name|secondaryRegion
operator|.
name|getStoreFileList
argument_list|(
name|families
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|families
operator|.
name|length
operator|*
literal|4
argument_list|,
name|secondaryRegion
operator|.
name|getStoreFileList
argument_list|(
name|families
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from secondary"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSUtils
operator|.
name|WINDOWS
condition|)
block|{
comment|// compaction cannot move files while they are open in secondary on windows. Skip remaining.
return|return;
block|}
comment|// Test case 3: compact primary files
name|primaryRegion
operator|.
name|compactStores
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|HRegion
argument_list|>
name|regions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|regions
operator|.
name|add
argument_list|(
name|primaryRegion
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
name|regions
argument_list|)
operator|.
name|when
argument_list|(
name|rss
argument_list|)
operator|.
name|getRegions
argument_list|()
expr_stmt|;
name|CompactedHFilesDischarger
name|cleaner
init|=
operator|new
name|CompactedHFilesDischarger
argument_list|(
literal|100
argument_list|,
literal|null
argument_list|,
name|rss
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|cleaner
operator|.
name|chore
argument_list|()
expr_stmt|;
name|secondaryRegion
operator|.
name|refreshStoreFiles
argument_list|()
expr_stmt|;
name|assertPathListsEqual
argument_list|(
name|primaryRegion
operator|.
name|getStoreFileList
argument_list|(
name|families
argument_list|)
argument_list|,
name|secondaryRegion
operator|.
name|getStoreFileList
argument_list|(
name|families
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|families
operator|.
name|length
argument_list|,
name|secondaryRegion
operator|.
name|getStoreFileList
argument_list|(
name|families
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from secondary"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying edits in secondary"
argument_list|)
expr_stmt|;
comment|// Test case 4: replay some edits, ensure that memstore is dropped.
name|assertTrue
argument_list|(
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|putDataWithFlushes
argument_list|(
name|primaryRegion
argument_list|,
literal|400
argument_list|,
literal|400
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|numRows
operator|=
literal|400
expr_stmt|;
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|FlushDescriptor
name|flush
init|=
name|WALEdit
operator|.
name|getFlushDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flush
operator|!=
literal|null
condition|)
block|{
comment|// do not replay flush
block|}
else|else
block|{
name|replayEdit
argument_list|(
name|secondaryRegion
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|secondaryRegion
operator|.
name|refreshStoreFiles
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|secondaryRegion
operator|.
name|getMemStoreDataSize
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from primary"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|primaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from secondary"
argument_list|)
expr_stmt|;
name|verifyData
argument_list|(
name|secondaryRegion
argument_list|,
literal|0
argument_list|,
name|numRows
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
comment|/**    * Paths can be qualified or not. This does the assertion using String->Path conversion.    */
specifier|private
name|void
name|assertPathListsEqual
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|list1
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|list2
parameter_list|)
block|{
name|List
argument_list|<
name|Path
argument_list|>
name|l1
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|list1
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|path
range|:
name|list1
control|)
block|{
name|l1
operator|.
name|add
argument_list|(
name|Path
operator|.
name|getPathWithoutSchemeAndAuthority
argument_list|(
operator|new
name|Path
argument_list|(
name|path
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Path
argument_list|>
name|l2
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|list2
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|path
range|:
name|list2
control|)
block|{
name|l2
operator|.
name|add
argument_list|(
name|Path
operator|.
name|getPathWithoutSchemeAndAuthority
argument_list|(
operator|new
name|Path
argument_list|(
name|path
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|l1
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|disableReads
parameter_list|(
name|HRegion
name|region
parameter_list|)
block|{
name|region
operator|.
name|setReadsEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|verifyData
argument_list|(
name|region
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Should have failed with IOException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// expected
block|}
block|}
specifier|private
name|void
name|replay
parameter_list|(
name|HRegion
name|region
parameter_list|,
name|Put
name|put
parameter_list|,
name|long
name|replaySeqId
parameter_list|)
throws|throws
name|IOException
block|{
name|put
operator|.
name|setDurability
argument_list|(
name|Durability
operator|.
name|SKIP_WAL
argument_list|)
expr_stmt|;
name|MutationReplay
name|mutation
init|=
operator|new
name|MutationReplay
argument_list|(
name|MutationType
operator|.
name|PUT
argument_list|,
name|put
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|region
operator|.
name|batchReplay
argument_list|(
operator|new
name|MutationReplay
index|[]
block|{
name|mutation
block|}
argument_list|,
name|replaySeqId
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests replaying region open markers from primary region. Checks whether the files are picked up    */
annotation|@
name|Test
specifier|public
name|void
name|testReplayBulkLoadEvent
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"testReplayBulkLoadEvent starts"
argument_list|)
expr_stmt|;
name|putDataWithFlushes
argument_list|(
name|primaryRegion
argument_list|,
literal|100
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|// no flush
comment|// close the region and open again.
name|primaryRegion
operator|.
name|close
argument_list|()
expr_stmt|;
name|primaryRegion
operator|=
name|HRegion
operator|.
name|openHRegion
argument_list|(
name|rootDir
argument_list|,
name|primaryHri
argument_list|,
name|htd
argument_list|,
name|walPrimary
argument_list|,
name|CONF
argument_list|,
name|rss
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// bulk load a file into primary region
name|Random
name|random
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|byte
index|[]
name|randomValues
init|=
operator|new
name|byte
index|[
literal|20
index|]
decl_stmt|;
name|random
operator|.
name|nextBytes
argument_list|(
name|randomValues
argument_list|)
expr_stmt|;
name|Path
name|testPath
init|=
name|TEST_UTIL
operator|.
name|getDataTestDirOnTestFS
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|String
argument_list|>
argument_list|>
name|familyPaths
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|expectedLoadFileCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|family
range|:
name|families
control|)
block|{
name|familyPaths
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<>
argument_list|(
name|family
argument_list|,
name|createHFileForFamilies
argument_list|(
name|testPath
argument_list|,
name|family
argument_list|,
name|randomValues
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expectedLoadFileCount
operator|++
expr_stmt|;
block|}
name|primaryRegion
operator|.
name|bulkLoadHFiles
argument_list|(
name|familyPaths
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// now replay the edits and the bulk load marker
name|reader
operator|=
name|createWALReaderForPrimary
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Replaying edits and region events in secondary"
argument_list|)
expr_stmt|;
name|BulkLoadDescriptor
name|bulkloadEvent
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|WAL
operator|.
name|Entry
name|entry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|bulkloadEvent
operator|=
name|WALEdit
operator|.
name|getBulkLoadDescriptor
argument_list|(
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bulkloadEvent
operator|!=
literal|null
condition|)
block|{
break|break;
block|}
block|}
comment|// we should have 1 bulk load event
name|assertTrue
argument_list|(
name|bulkloadEvent
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedLoadFileCount
argument_list|,
name|bulkloadEvent
operator|.
name|getStoresCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// replay the bulk load event
name|secondaryRegion
operator|.
name|replayWALBulkLoadEventMarker
argument_list|(
name|bulkloadEvent
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|storeFileName
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|StoreDescriptor
name|storeDesc
range|:
name|bulkloadEvent
operator|.
name|getStoresList
argument_list|()
control|)
block|{
name|storeFileName
operator|.
name|addAll
argument_list|(
name|storeDesc
operator|.
name|getStoreFileList
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// assert that the bulk loaded files are picked
for|for
control|(
name|HStore
name|s
range|:
name|secondaryRegion
operator|.
name|getStores
argument_list|()
control|)
block|{
for|for
control|(
name|HStoreFile
name|sf
range|:
name|s
operator|.
name|getStorefiles
argument_list|()
control|)
block|{
name|storeFileName
operator|.
name|remove
argument_list|(
name|sf
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
literal|"Found some store file isn't loaded:"
operator|+
name|storeFileName
argument_list|,
name|storeFileName
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Verifying edits from secondary"
argument_list|)
expr_stmt|;
for|for
control|(
name|byte
index|[]
name|family
range|:
name|families
control|)
block|{
name|assertGet
argument_list|(
name|secondaryRegion
argument_list|,
name|family
argument_list|,
name|randomValues
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReplayingFlushCommitWithFileAlreadyDeleted
parameter_list|()
throws|throws
name|IOException
block|{
comment|// tests replaying flush commit marker, but the flush file has already been compacted
comment|// from primary and also deleted from the archive directory
name|secondaryRegion
operator|.
name|replayWALFlushCommitMarker
argument_list|(
name|FlushDescriptor
operator|.
name|newBuilder
argument_list|()
operator|.
name|setFlushSequenceNumber
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
operator|.
name|setTableName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getTableDescriptor
argument_list|()
operator|.
name|getTableName
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setAction
argument_list|(
name|FlushAction
operator|.
name|COMMIT_FLUSH
argument_list|)
operator|.
name|setEncodedRegionName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setRegionName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|)
argument_list|)
operator|.
name|addStoreFlushes
argument_list|(
name|StoreFlushDescriptor
operator|.
name|newBuilder
argument_list|()
operator|.
name|setFamilyName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|families
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|.
name|setStoreHomeDir
argument_list|(
literal|"/store_home_dir"
argument_list|)
operator|.
name|addFlushOutput
argument_list|(
literal|"/foo/baz/bar"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReplayingCompactionWithFileAlreadyDeleted
parameter_list|()
throws|throws
name|IOException
block|{
comment|// tests replaying compaction marker, but the compaction output file has already been compacted
comment|// from primary and also deleted from the archive directory
name|secondaryRegion
operator|.
name|replayWALCompactionMarker
argument_list|(
name|CompactionDescriptor
operator|.
name|newBuilder
argument_list|()
operator|.
name|setTableName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getTableDescriptor
argument_list|()
operator|.
name|getTableName
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setEncodedRegionName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setFamilyName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|families
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|.
name|addCompactionInput
argument_list|(
literal|"/foo"
argument_list|)
operator|.
name|addCompactionOutput
argument_list|(
literal|"/bar"
argument_list|)
operator|.
name|setStoreHomeDir
argument_list|(
literal|"/store_home_dir"
argument_list|)
operator|.
name|setRegionName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReplayingRegionOpenEventWithFileAlreadyDeleted
parameter_list|()
throws|throws
name|IOException
block|{
comment|// tests replaying region open event marker, but the region files have already been compacted
comment|// from primary and also deleted from the archive directory
name|secondaryRegion
operator|.
name|replayWALRegionEventMarker
argument_list|(
name|RegionEventDescriptor
operator|.
name|newBuilder
argument_list|()
operator|.
name|setTableName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getTableDescriptor
argument_list|()
operator|.
name|getTableName
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setEncodedRegionName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setRegionName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setEventType
argument_list|(
name|EventType
operator|.
name|REGION_OPEN
argument_list|)
operator|.
name|setServer
argument_list|(
name|ProtobufUtil
operator|.
name|toServerName
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
literal|"foo"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|setLogSequenceNumber
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
operator|.
name|addStores
argument_list|(
name|StoreDescriptor
operator|.
name|newBuilder
argument_list|()
operator|.
name|setFamilyName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|families
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|.
name|setStoreHomeDir
argument_list|(
literal|"/store_home_dir"
argument_list|)
operator|.
name|addStoreFile
argument_list|(
literal|"/foo"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReplayingBulkLoadEventWithFileAlreadyDeleted
parameter_list|()
throws|throws
name|IOException
block|{
comment|// tests replaying bulk load event marker, but the bulk load files have already been compacted
comment|// from primary and also deleted from the archive directory
name|secondaryRegion
operator|.
name|replayWALBulkLoadEventMarker
argument_list|(
name|BulkLoadDescriptor
operator|.
name|newBuilder
argument_list|()
operator|.
name|setTableName
argument_list|(
name|ProtobufUtil
operator|.
name|toProtoTableName
argument_list|(
name|primaryRegion
operator|.
name|getTableDescriptor
argument_list|()
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setEncodedRegionName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|primaryRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setBulkloadSeqNum
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
operator|.
name|addStores
argument_list|(
name|StoreDescriptor
operator|.
name|newBuilder
argument_list|()
operator|.
name|setFamilyName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|families
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|.
name|setStoreHomeDir
argument_list|(
literal|"/store_home_dir"
argument_list|)
operator|.
name|addStoreFile
argument_list|(
literal|"/foo"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|createHFileForFamilies
parameter_list|(
name|Path
name|testPath
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|valueBytes
parameter_list|)
throws|throws
name|IOException
block|{
name|HFile
operator|.
name|WriterFactory
name|hFileFactory
init|=
name|HFile
operator|.
name|getWriterFactoryNoCache
argument_list|(
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
comment|// TODO We need a way to do this without creating files
name|Path
name|testFile
init|=
operator|new
name|Path
argument_list|(
name|testPath
argument_list|,
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|out
init|=
name|TEST_UTIL
operator|.
name|getTestFileSystem
argument_list|()
operator|.
name|create
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
try|try
block|{
name|hFileFactory
operator|.
name|withOutputStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|hFileFactory
operator|.
name|withFileContext
argument_list|(
operator|new
name|HFileContext
argument_list|()
argument_list|)
expr_stmt|;
name|HFile
operator|.
name|Writer
name|writer
init|=
name|hFileFactory
operator|.
name|create
argument_list|()
decl_stmt|;
try|try
block|{
name|writer
operator|.
name|append
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|CellUtil
operator|.
name|createCell
argument_list|(
name|valueBytes
argument_list|,
name|family
argument_list|,
name|valueBytes
argument_list|,
literal|0L
argument_list|,
name|KeyValue
operator|.
name|Type
operator|.
name|Put
operator|.
name|getCode
argument_list|()
argument_list|,
name|valueBytes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|testFile
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Puts a total of numRows + numRowsAfterFlush records indexed with numeric row keys. Does    * a flush every flushInterval number of records. Then it puts numRowsAfterFlush number of    * more rows but does not execute flush after    * @throws IOException */
specifier|private
name|void
name|putDataWithFlushes
parameter_list|(
name|HRegion
name|region
parameter_list|,
name|int
name|flushInterval
parameter_list|,
name|int
name|numRows
parameter_list|,
name|int
name|numRowsAfterFlush
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|start
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<
name|numRows
condition|;
name|start
operator|+=
name|flushInterval
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Writing some data to primary from "
operator|+
name|start
operator|+
literal|" to "
operator|+
operator|(
name|start
operator|+
name|flushInterval
operator|)
argument_list|)
expr_stmt|;
name|putData
argument_list|(
name|region
argument_list|,
name|Durability
operator|.
name|SYNC_WAL
argument_list|,
name|start
argument_list|,
name|flushInterval
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Flushing primary, creating 3 files for 3 stores"
argument_list|)
expr_stmt|;
name|region
operator|.
name|flush
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"-- Writing some more data to primary, not flushing"
argument_list|)
expr_stmt|;
name|putData
argument_list|(
name|region
argument_list|,
name|Durability
operator|.
name|SYNC_WAL
argument_list|,
name|start
argument_list|,
name|numRowsAfterFlush
argument_list|,
name|cq
argument_list|,
name|families
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|putDataByReplay
parameter_list|(
name|HRegion
name|region
parameter_list|,
name|int
name|startRow
parameter_list|,
name|int
name|numRows
parameter_list|,
name|byte
index|[]
name|qf
parameter_list|,
name|byte
index|[]
modifier|...
name|families
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
name|startRow
init|;
name|i
operator|<
name|startRow
operator|+
name|numRows
condition|;
name|i
operator|++
control|)
block|{
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|""
operator|+
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|put
operator|.
name|setDurability
argument_list|(
name|Durability
operator|.
name|SKIP_WAL
argument_list|)
expr_stmt|;
for|for
control|(
name|byte
index|[]
name|family
range|:
name|families
control|)
block|{
name|put
operator|.
name|addColumn
argument_list|(
name|family
argument_list|,
name|qf
argument_list|,
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|replay
argument_list|(
name|region
argument_list|,
name|put
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|HRegion
name|initHRegion
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|String
name|callingMethod
parameter_list|,
name|byte
index|[]
modifier|...
name|families
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|initHRegion
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|EMPTY_START_ROW
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|,
name|callingMethod
argument_list|,
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|,
literal|false
argument_list|,
name|Durability
operator|.
name|SYNC_WAL
argument_list|,
literal|null
argument_list|,
name|families
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|HRegion
name|initHRegion
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|byte
index|[]
name|startKey
parameter_list|,
name|byte
index|[]
name|stopKey
parameter_list|,
name|String
name|callingMethod
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|boolean
name|isReadOnly
parameter_list|,
name|Durability
name|durability
parameter_list|,
name|WAL
name|wal
parameter_list|,
name|byte
index|[]
modifier|...
name|families
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|TEST_UTIL
operator|.
name|createLocalHRegion
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|stopKey
argument_list|,
name|callingMethod
argument_list|,
name|conf
argument_list|,
name|isReadOnly
argument_list|,
name|durability
argument_list|,
name|wal
argument_list|,
name|families
argument_list|)
return|;
block|}
block|}
end_class

end_unit

