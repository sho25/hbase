begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MiniHBaseCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|FSHLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|LargeTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|RegionServerTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|JVMClusterUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WAL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_comment
comment|/**  * This test verifies the correctness of the Per Column Family flushing strategy  * when part of the memstores are compacted memstores  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
block|{
name|RegionServerTests
operator|.
name|class
block|,
name|LargeTests
operator|.
name|class
block|}
argument_list|)
specifier|public
class|class
name|TestWalAndCompactingMemStoreFlush
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestWalAndCompactingMemStoreFlush
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|HBaseTestingUtility
name|TEST_UTIL
init|=
operator|new
name|HBaseTestingUtility
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Path
name|DIR
init|=
name|TEST_UTIL
operator|.
name|getDataTestDir
argument_list|(
literal|"TestHRegion"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|TableName
name|TABLENAME
init|=
name|TableName
operator|.
name|valueOf
argument_list|(
literal|"TestWalAndCompactingMemStoreFlush"
argument_list|,
literal|"t1"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
index|[]
index|[]
name|FAMILIES
init|=
block|{
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"f1"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"f2"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"f3"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"f4"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"f5"
argument_list|)
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|FAMILY1
init|=
name|FAMILIES
index|[
literal|0
index|]
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|FAMILY2
init|=
name|FAMILIES
index|[
literal|1
index|]
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|FAMILY3
init|=
name|FAMILIES
index|[
literal|2
index|]
decl_stmt|;
specifier|private
name|HRegion
name|initHRegion
parameter_list|(
name|String
name|callingMethod
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|HTableDescriptor
name|htd
init|=
operator|new
name|HTableDescriptor
argument_list|(
name|TABLENAME
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|family
range|:
name|FAMILIES
control|)
block|{
name|HColumnDescriptor
name|hcd
init|=
operator|new
name|HColumnDescriptor
argument_list|(
name|family
argument_list|)
decl_stmt|;
comment|// even column families are going to have compacted memstore
if|if
condition|(
name|i
operator|%
literal|2
operator|==
literal|0
condition|)
name|hcd
operator|.
name|setInMemoryCompaction
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|htd
operator|.
name|addFamily
argument_list|(
name|hcd
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|HRegionInfo
name|info
init|=
operator|new
name|HRegionInfo
argument_list|(
name|TABLENAME
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|DIR
argument_list|,
name|callingMethod
argument_list|)
decl_stmt|;
return|return
name|HBaseTestingUtility
operator|.
name|createRegionAndWAL
argument_list|(
name|info
argument_list|,
name|path
argument_list|,
name|conf
argument_list|,
name|htd
argument_list|)
return|;
block|}
comment|// A helper function to create puts.
specifier|private
name|Put
name|createPut
parameter_list|(
name|int
name|familyNum
parameter_list|,
name|int
name|putNum
parameter_list|)
block|{
name|byte
index|[]
name|qf
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"q"
operator|+
name|familyNum
argument_list|)
decl_stmt|;
name|byte
index|[]
name|row
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"row"
operator|+
name|familyNum
operator|+
literal|"-"
operator|+
name|putNum
argument_list|)
decl_stmt|;
name|byte
index|[]
name|val
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"val"
operator|+
name|familyNum
operator|+
literal|"-"
operator|+
name|putNum
argument_list|)
decl_stmt|;
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|p
operator|.
name|addColumn
argument_list|(
name|FAMILIES
index|[
name|familyNum
operator|-
literal|1
index|]
argument_list|,
name|qf
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|// A helper function to create double puts, so something can be compacted later.
specifier|private
name|Put
name|createDoublePut
parameter_list|(
name|int
name|familyNum
parameter_list|,
name|int
name|putNum
parameter_list|)
block|{
name|byte
index|[]
name|qf
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"q"
operator|+
name|familyNum
argument_list|)
decl_stmt|;
name|byte
index|[]
name|row
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"row"
operator|+
name|familyNum
operator|+
literal|"-"
operator|+
name|putNum
argument_list|)
decl_stmt|;
name|byte
index|[]
name|val
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"val"
operator|+
name|familyNum
operator|+
literal|"-"
operator|+
name|putNum
argument_list|)
decl_stmt|;
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|row
argument_list|)
decl_stmt|;
comment|// add twice with different timestamps
name|p
operator|.
name|addColumn
argument_list|(
name|FAMILIES
index|[
name|familyNum
operator|-
literal|1
index|]
argument_list|,
name|qf
argument_list|,
literal|10
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|p
operator|.
name|addColumn
argument_list|(
name|FAMILIES
index|[
name|familyNum
operator|-
literal|1
index|]
argument_list|,
name|qf
argument_list|,
literal|20
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|// A helper function to create gets.
specifier|private
name|Get
name|createGet
parameter_list|(
name|int
name|familyNum
parameter_list|,
name|int
name|putNum
parameter_list|)
block|{
name|byte
index|[]
name|row
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"row"
operator|+
name|familyNum
operator|+
literal|"-"
operator|+
name|putNum
argument_list|)
decl_stmt|;
return|return
operator|new
name|Get
argument_list|(
name|row
argument_list|)
return|;
block|}
comment|// A helper function to verify edits.
name|void
name|verifyEdit
parameter_list|(
name|int
name|familyNum
parameter_list|,
name|int
name|putNum
parameter_list|,
name|Table
name|table
parameter_list|)
throws|throws
name|IOException
block|{
name|Result
name|r
init|=
name|table
operator|.
name|get
argument_list|(
name|createGet
argument_list|(
name|familyNum
argument_list|,
name|putNum
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|family
init|=
name|FAMILIES
index|[
name|familyNum
operator|-
literal|1
index|]
decl_stmt|;
name|byte
index|[]
name|qf
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"q"
operator|+
name|familyNum
argument_list|)
decl_stmt|;
name|byte
index|[]
name|val
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"val"
operator|+
name|familyNum
operator|+
literal|"-"
operator|+
name|putNum
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
operator|(
literal|"Missing Put#"
operator|+
name|putNum
operator|+
literal|" for CF# "
operator|+
name|familyNum
operator|)
argument_list|,
name|r
operator|.
name|getFamilyMap
argument_list|(
name|family
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
operator|(
literal|"Missing Put#"
operator|+
name|putNum
operator|+
literal|" for CF# "
operator|+
name|familyNum
operator|)
argument_list|,
name|r
operator|.
name|getFamilyMap
argument_list|(
name|family
argument_list|)
operator|.
name|get
argument_list|(
name|qf
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|(
literal|"Incorrect value for Put#"
operator|+
name|putNum
operator|+
literal|" for CF# "
operator|+
name|familyNum
operator|)
argument_list|,
name|Arrays
operator|.
name|equals
argument_list|(
name|r
operator|.
name|getFamilyMap
argument_list|(
name|family
argument_list|)
operator|.
name|get
argument_list|(
name|qf
argument_list|)
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|180000
argument_list|)
specifier|public
name|void
name|testSelectiveFlushWhenEnabled
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Set up the configuration
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|HConstants
operator|.
name|HREGION_MEMSTORE_FLUSH_SIZE
argument_list|,
literal|600
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|FlushPolicyFactory
operator|.
name|HBASE_FLUSH_POLICY_KEY
argument_list|,
name|FlushNonSloppyStoresFirstPolicy
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|FlushLargeStoresPolicy
operator|.
name|HREGION_COLUMNFAMILY_FLUSH_SIZE_LOWER_BOUND_MIN
argument_list|,
literal|200
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setDouble
argument_list|(
name|CompactingMemStore
operator|.
name|IN_MEMORY_FLUSH_THRESHOLD_FACTOR_KEY
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
comment|// Intialize the region
name|Region
name|region
init|=
name|initHRegion
argument_list|(
literal|"testSelectiveFlushWhenEnabled"
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// Add 1200 entries for CF1, 100 for CF2 and 50 for CF3
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|1200
condition|;
name|i
operator|++
control|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// compacted memstore
if|if
condition|(
name|i
operator|<=
literal|100
condition|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|50
condition|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createDoublePut
argument_list|(
literal|3
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// subject for in-memory compaction
block|}
block|}
block|}
comment|// Now add more puts for CF2, so that we only flush CF2 to disk
for|for
control|(
name|int
name|i
init|=
literal|100
init|;
name|i
operator|<
literal|2000
condition|;
name|i
operator|++
control|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|totalMemstoreSize
init|=
name|region
operator|.
name|getMemstoreSize
argument_list|()
decl_stmt|;
comment|// Find the smallest LSNs for edits wrt to each CF.
name|long
name|smallestSeqCF1PhaseI
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY1
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF2PhaseI
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY2
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF3PhaseI
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY3
argument_list|)
decl_stmt|;
comment|// Find the sizes of the memstores of each CF.
name|long
name|cf1MemstoreSizePhaseI
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY1
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|cf2MemstoreSizePhaseI
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY2
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|cf3MemstoreSizePhaseI
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY3
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
comment|// Get the overall smallest LSN in the region's memstores.
name|long
name|smallestSeqInRegionCurrentMemstorePhaseI
init|=
name|getWAL
argument_list|(
name|region
argument_list|)
operator|.
name|getEarliestMemstoreSeqNum
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|s
init|=
literal|"\n\n----------------------------------\n"
operator|+
literal|"Upon initial insert and before any flush, size of CF1 is:"
operator|+
name|cf1MemstoreSizePhaseI
operator|+
literal|", is CF1 compacted memstore?:"
operator|+
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY1
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|.
name|isSloppy
argument_list|()
operator|+
literal|". Size of CF2 is:"
operator|+
name|cf2MemstoreSizePhaseI
operator|+
literal|", is CF2 compacted memstore?:"
operator|+
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY2
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|.
name|isSloppy
argument_list|()
operator|+
literal|". Size of CF3 is:"
operator|+
name|cf3MemstoreSizePhaseI
operator|+
literal|", is CF3 compacted memstore?:"
operator|+
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY3
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|.
name|isSloppy
argument_list|()
operator|+
literal|"\n"
decl_stmt|;
comment|// The overall smallest LSN in the region's memstores should be the same as
comment|// the LSN of the smallest edit in CF1
name|assertEquals
argument_list|(
name|smallestSeqCF1PhaseI
argument_list|,
name|smallestSeqInRegionCurrentMemstorePhaseI
argument_list|)
expr_stmt|;
comment|// Some other sanity checks.
name|assertTrue
argument_list|(
name|smallestSeqCF1PhaseI
operator|<
name|smallestSeqCF2PhaseI
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|smallestSeqCF2PhaseI
operator|<
name|smallestSeqCF3PhaseI
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cf1MemstoreSizePhaseI
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cf2MemstoreSizePhaseI
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cf3MemstoreSizePhaseI
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// The total memstore size should be the same as the sum of the sizes of
comment|// memstores of CF1, CF2 and CF3.
name|String
name|msg
init|=
literal|"totalMemstoreSize="
operator|+
name|totalMemstoreSize
operator|+
literal|" DefaultMemStore.DEEP_OVERHEAD="
operator|+
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
operator|+
literal|" DEEP_OVERHEAD_PER_PIPELINE_ITEM="
operator|+
name|CompactingMemStore
operator|.
name|DEEP_OVERHEAD_PER_PIPELINE_ITEM
operator|+
literal|" cf1MemstoreSizePhaseI="
operator|+
name|cf1MemstoreSizePhaseI
operator|+
literal|" cf2MemstoreSizePhaseI="
operator|+
name|cf2MemstoreSizePhaseI
operator|+
literal|" cf3MemstoreSizePhaseI="
operator|+
name|cf3MemstoreSizePhaseI
decl_stmt|;
name|assertEquals
argument_list|(
name|msg
argument_list|,
name|totalMemstoreSize
operator|+
literal|3
operator|*
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
argument_list|,
name|cf1MemstoreSizePhaseI
operator|+
name|cf2MemstoreSizePhaseI
operator|+
name|cf3MemstoreSizePhaseI
argument_list|)
expr_stmt|;
comment|// Flush!!!!!!!!!!!!!!!!!!!!!!
comment|// We have big compacting memstore CF1 and two small memstores:
comment|// CF2 (not compacted) and CF3 (compacting)
comment|// All together they are above the flush size lower bound.
comment|// Since CF1 and CF3 should be flushed to memory (not to disk),
comment|// CF2 is going to be flushed to disk.
comment|// CF1 - nothing to compact, CF3 - should be twice compacted
operator|(
operator|(
name|CompactingMemStore
operator|)
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY1
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|)
operator|.
name|flushInMemory
argument_list|()
expr_stmt|;
operator|(
operator|(
name|CompactingMemStore
operator|)
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY3
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|)
operator|.
name|flushInMemory
argument_list|()
expr_stmt|;
name|region
operator|.
name|flush
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// CF3 should be compacted so wait here to be sure the compaction is done
while|while
condition|(
operator|(
operator|(
name|CompactingMemStore
operator|)
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY3
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|)
operator|.
name|isMemStoreFlushingInMemory
argument_list|()
condition|)
name|Threads
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|// Recalculate everything
name|long
name|cf1MemstoreSizePhaseII
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY1
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|cf2MemstoreSizePhaseII
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY2
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|cf3MemstoreSizePhaseII
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY3
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|smallestSeqInRegionCurrentMemstorePhaseII
init|=
name|getWAL
argument_list|(
name|region
argument_list|)
operator|.
name|getEarliestMemstoreSeqNum
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
decl_stmt|;
comment|// Find the smallest LSNs for edits wrt to each CF.
name|long
name|smallestSeqCF1PhaseII
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY1
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF2PhaseII
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY2
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF3PhaseII
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY3
argument_list|)
decl_stmt|;
name|s
operator|=
name|s
operator|+
literal|"DefaultMemStore DEEP_OVERHEAD is:"
operator|+
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
operator|+
literal|", CompactingMemStore DEEP_OVERHEAD is:"
operator|+
name|CompactingMemStore
operator|.
name|DEEP_OVERHEAD
operator|+
literal|", CompactingMemStore DEEP_OVERHEAD_PER_PIPELINE_ITEM is:"
operator|+
name|CompactingMemStore
operator|.
name|DEEP_OVERHEAD_PER_PIPELINE_ITEM
operator|+
literal|"\n----After first flush! CF1 should be flushed to memory, but not compacted.---\n"
operator|+
literal|"Size of CF1 is:"
operator|+
name|cf1MemstoreSizePhaseII
operator|+
literal|", size of CF2 is:"
operator|+
name|cf2MemstoreSizePhaseII
operator|+
literal|", size of CF3 is:"
operator|+
name|cf3MemstoreSizePhaseII
operator|+
literal|"\n"
expr_stmt|;
comment|// CF1 was flushed to memory, but there is nothing to compact, should
comment|// remain the same size plus renewed empty skip-list
name|assertEquals
argument_list|(
name|s
argument_list|,
name|cf1MemstoreSizePhaseII
argument_list|,
name|cf1MemstoreSizePhaseI
operator|+
name|CompactingMemStore
operator|.
name|DEEP_OVERHEAD_PER_PIPELINE_ITEM
argument_list|)
expr_stmt|;
comment|// CF2 should become empty
name|assertEquals
argument_list|(
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
argument_list|,
name|cf2MemstoreSizePhaseII
argument_list|)
expr_stmt|;
comment|// verify that CF3 was flushed to memory and was compacted (this is approximation check)
name|assertTrue
argument_list|(
name|cf3MemstoreSizePhaseI
operator|/
literal|2
operator|+
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
operator|+
name|CompactingMemStore
operator|.
name|DEEP_OVERHEAD_PER_PIPELINE_ITEM
operator|>
name|cf3MemstoreSizePhaseII
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cf3MemstoreSizePhaseI
operator|/
literal|2
operator|<
name|cf3MemstoreSizePhaseII
argument_list|)
expr_stmt|;
comment|// Now the smallest LSN in the region should be the same as the smallest
comment|// LSN in the memstore of CF1.
name|assertEquals
argument_list|(
name|smallestSeqInRegionCurrentMemstorePhaseII
argument_list|,
name|smallestSeqCF1PhaseI
argument_list|)
expr_stmt|;
comment|// Now add more puts for CF1, so that we also flush CF1 to disk instead of
comment|// memory in next flush
for|for
control|(
name|int
name|i
init|=
literal|1200
init|;
name|i
operator|<
literal|2000
condition|;
name|i
operator|++
control|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|+
literal|"The smallest sequence in region WAL is: "
operator|+
name|smallestSeqInRegionCurrentMemstorePhaseII
operator|+
literal|", the smallest sequence in CF1:"
operator|+
name|smallestSeqCF1PhaseII
operator|+
literal|", "
operator|+
literal|"the smallest sequence in CF2:"
operator|+
name|smallestSeqCF2PhaseII
operator|+
literal|", the smallest sequence in CF3:"
operator|+
name|smallestSeqCF3PhaseII
operator|+
literal|"\n"
expr_stmt|;
comment|// How much does the CF1 memstore occupy? Will be used later.
name|long
name|cf1MemstoreSizePhaseIII
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY1
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|smallestSeqCF1PhaseIII
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY1
argument_list|)
decl_stmt|;
name|s
operator|=
name|s
operator|+
literal|"----After more puts into CF1 its size is:"
operator|+
name|cf1MemstoreSizePhaseIII
operator|+
literal|", and its sequence is:"
operator|+
name|smallestSeqCF1PhaseIII
operator|+
literal|" ----\n"
expr_stmt|;
comment|// Flush!!!!!!!!!!!!!!!!!!!!!!
comment|// Flush again, CF1 is flushed to disk
comment|// CF2 is flushed to disk, because it is not in-memory compacted memstore
comment|// CF3 is flushed empty to memory (actually nothing happens to CF3)
name|region
operator|.
name|flush
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Recalculate everything
name|long
name|cf1MemstoreSizePhaseIV
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY1
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|cf2MemstoreSizePhaseIV
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY2
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|cf3MemstoreSizePhaseIV
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY3
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|smallestSeqInRegionCurrentMemstorePhaseIV
init|=
name|getWAL
argument_list|(
name|region
argument_list|)
operator|.
name|getEarliestMemstoreSeqNum
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF1PhaseIV
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY1
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF2PhaseIV
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY2
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF3PhaseIV
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY3
argument_list|)
decl_stmt|;
name|s
operator|=
name|s
operator|+
literal|"----After SECOND FLUSH, CF1 size is:"
operator|+
name|cf1MemstoreSizePhaseIV
operator|+
literal|", CF2 size is:"
operator|+
name|cf2MemstoreSizePhaseIV
operator|+
literal|" and CF3 size is:"
operator|+
name|cf3MemstoreSizePhaseIV
operator|+
literal|"\n"
expr_stmt|;
name|s
operator|=
name|s
operator|+
literal|"The smallest sequence in region WAL is: "
operator|+
name|smallestSeqInRegionCurrentMemstorePhaseIV
operator|+
literal|", the smallest sequence in CF1:"
operator|+
name|smallestSeqCF1PhaseIV
operator|+
literal|", "
operator|+
literal|"the smallest sequence in CF2:"
operator|+
name|smallestSeqCF2PhaseIV
operator|+
literal|", the smallest sequence in CF3:"
operator|+
name|smallestSeqCF3PhaseIV
operator|+
literal|"\n"
expr_stmt|;
comment|// CF1's pipeline component (inserted before first flush) should be flushed to disk
comment|// CF2 should be flushed to disk
name|assertEquals
argument_list|(
name|cf1MemstoreSizePhaseIII
operator|-
name|cf1MemstoreSizePhaseI
operator|+
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
argument_list|,
name|cf1MemstoreSizePhaseIV
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
argument_list|,
name|cf2MemstoreSizePhaseIV
argument_list|)
expr_stmt|;
comment|// CF3 shouldn't have been touched.
name|assertEquals
argument_list|(
name|cf3MemstoreSizePhaseIV
argument_list|,
name|cf3MemstoreSizePhaseII
argument_list|)
expr_stmt|;
comment|// the smallest LSN of CF3 shouldn't change
name|assertEquals
argument_list|(
name|smallestSeqCF3PhaseII
argument_list|,
name|smallestSeqCF3PhaseIV
argument_list|)
expr_stmt|;
comment|// CF3 should be bottleneck for WAL
name|assertEquals
argument_list|(
name|s
argument_list|,
name|smallestSeqInRegionCurrentMemstorePhaseIV
argument_list|,
name|smallestSeqCF3PhaseIV
argument_list|)
expr_stmt|;
comment|// Flush!!!!!!!!!!!!!!!!!!!!!!
comment|// Clearing the existing memstores, CF2 all flushed to disk. The single
comment|// memstore segment in the compaction pipeline of CF1 and CF3 should be flushed to disk.
comment|// Note that active sets of CF1 and CF3 are empty
name|region
operator|.
name|flush
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Recalculate everything
name|long
name|cf1MemstoreSizePhaseV
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY1
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|cf2MemstoreSizePhaseV
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY2
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|cf3MemstoreSizePhaseV
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY3
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|smallestSeqInRegionCurrentMemstorePhaseV
init|=
name|getWAL
argument_list|(
name|region
argument_list|)
operator|.
name|getEarliestMemstoreSeqNum
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
argument_list|,
name|cf1MemstoreSizePhaseV
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
argument_list|,
name|cf2MemstoreSizePhaseV
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
argument_list|,
name|cf3MemstoreSizePhaseV
argument_list|)
expr_stmt|;
comment|// Because there is nothing in any memstore the WAL's LSN should be -1
name|assertEquals
argument_list|(
name|smallestSeqInRegionCurrentMemstorePhaseV
argument_list|,
name|HConstants
operator|.
name|NO_SEQNUM
argument_list|)
expr_stmt|;
comment|// What happens when we hit the memstore limit, but we are not able to find
comment|// any Column Family above the threshold?
comment|// In that case, we should flush all the CFs.
comment|// The memstore limit is 200*1024 and the column family flush threshold is
comment|// around 50*1024. We try to just hit the memstore limit with each CF's
comment|// memstore being below the CF flush threshold.
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|300
condition|;
name|i
operator|++
control|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|3
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|4
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|5
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|region
operator|.
name|flush
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|+
literal|"----AFTER THIRD AND FORTH FLUSH, The smallest sequence in region WAL is: "
operator|+
name|smallestSeqInRegionCurrentMemstorePhaseV
operator|+
literal|". After additional inserts and last flush, the entire region size is:"
operator|+
name|region
operator|.
name|getMemstoreSize
argument_list|()
operator|+
literal|"\n----------------------------------\n"
expr_stmt|;
comment|// Since we won't find any CF above the threshold, and hence no specific
comment|// store to flush, we should flush all the memstores
comment|// Also compacted memstores are flushed to disk.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|region
operator|.
name|getMemstoreSize
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|HBaseTestingUtility
operator|.
name|closeRegionAndWAL
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|180000
argument_list|)
specifier|public
name|void
name|testSelectiveFlushWhenEnabledAndWALinCompaction
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Set up the configuration
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|HConstants
operator|.
name|HREGION_MEMSTORE_FLUSH_SIZE
argument_list|,
literal|600
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|FlushPolicyFactory
operator|.
name|HBASE_FLUSH_POLICY_KEY
argument_list|,
name|FlushNonSloppyStoresFirstPolicy
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setLong
argument_list|(
name|FlushLargeStoresPolicy
operator|.
name|HREGION_COLUMNFAMILY_FLUSH_SIZE_LOWER_BOUND_MIN
argument_list|,
literal|200
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setDouble
argument_list|(
name|CompactingMemStore
operator|.
name|IN_MEMORY_FLUSH_THRESHOLD_FACTOR_KEY
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
comment|// Intialize the HRegion
name|HRegion
name|region
init|=
name|initHRegion
argument_list|(
literal|"testSelectiveFlushWhenNotEnabled"
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// Add 1200 entries for CF1, 100 for CF2 and 50 for CF3
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|1200
condition|;
name|i
operator|++
control|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|100
condition|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|50
condition|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|3
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Now add more puts for CF2, so that we only flush CF2 to disk
for|for
control|(
name|int
name|i
init|=
literal|100
init|;
name|i
operator|<
literal|2000
condition|;
name|i
operator|++
control|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|totalMemstoreSize
init|=
name|region
operator|.
name|getMemstoreSize
argument_list|()
decl_stmt|;
comment|// Find the sizes of the memstores of each CF.
name|long
name|cf1MemstoreSizePhaseI
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY1
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|cf2MemstoreSizePhaseI
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY2
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|cf3MemstoreSizePhaseI
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY3
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
comment|// Some other sanity checks.
name|assertTrue
argument_list|(
name|cf1MemstoreSizePhaseI
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cf2MemstoreSizePhaseI
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|cf3MemstoreSizePhaseI
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// The total memstore size should be the same as the sum of the sizes of
comment|// memstores of CF1, CF2 and CF3.
name|String
name|msg
init|=
literal|"totalMemstoreSize="
operator|+
name|totalMemstoreSize
operator|+
literal|" DefaultMemStore.DEEP_OVERHEAD="
operator|+
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
operator|+
literal|" DEEP_OVERHEAD_PER_PIPELINE_ITEM="
operator|+
name|CompactingMemStore
operator|.
name|DEEP_OVERHEAD_PER_PIPELINE_ITEM
operator|+
literal|" cf1MemstoreSizePhaseI="
operator|+
name|cf1MemstoreSizePhaseI
operator|+
literal|" cf2MemstoreSizePhaseI="
operator|+
name|cf2MemstoreSizePhaseI
operator|+
literal|" cf3MemstoreSizePhaseI="
operator|+
name|cf3MemstoreSizePhaseI
decl_stmt|;
name|assertEquals
argument_list|(
name|msg
argument_list|,
name|totalMemstoreSize
operator|+
literal|3
operator|*
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
argument_list|,
name|cf1MemstoreSizePhaseI
operator|+
name|cf2MemstoreSizePhaseI
operator|+
name|cf3MemstoreSizePhaseI
argument_list|)
expr_stmt|;
comment|// Flush!
operator|(
operator|(
name|CompactingMemStore
operator|)
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY1
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|)
operator|.
name|flushInMemory
argument_list|()
expr_stmt|;
operator|(
operator|(
name|CompactingMemStore
operator|)
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY3
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|)
operator|.
name|flushInMemory
argument_list|()
expr_stmt|;
comment|// CF1 and CF3 should be compacted so wait here to be sure the compaction is done
while|while
condition|(
operator|(
operator|(
name|CompactingMemStore
operator|)
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY1
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|)
operator|.
name|isMemStoreFlushingInMemory
argument_list|()
condition|)
name|Threads
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|CompactingMemStore
operator|)
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY3
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|)
operator|.
name|isMemStoreFlushingInMemory
argument_list|()
condition|)
name|Threads
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|region
operator|.
name|flush
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|long
name|cf2MemstoreSizePhaseII
init|=
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY2
argument_list|)
operator|.
name|getMemStoreSize
argument_list|()
decl_stmt|;
name|long
name|smallestSeqInRegionCurrentMemstorePhaseII
init|=
name|region
operator|.
name|getWAL
argument_list|()
operator|.
name|getEarliestMemstoreSeqNum
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF1PhaseII
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY1
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF2PhaseII
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY2
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF3PhaseII
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY3
argument_list|)
decl_stmt|;
comment|// CF2 should have been cleared
name|assertEquals
argument_list|(
name|DefaultMemStore
operator|.
name|DEEP_OVERHEAD
argument_list|,
name|cf2MemstoreSizePhaseII
argument_list|)
expr_stmt|;
name|String
name|s
init|=
literal|"\n\n----------------------------------\n"
operator|+
literal|"Upon initial insert and flush, LSN of CF1 is:"
operator|+
name|smallestSeqCF1PhaseII
operator|+
literal|". LSN of CF2 is:"
operator|+
name|smallestSeqCF2PhaseII
operator|+
literal|". LSN of CF3 is:"
operator|+
name|smallestSeqCF3PhaseII
operator|+
literal|", smallestSeqInRegionCurrentMemstore:"
operator|+
name|smallestSeqInRegionCurrentMemstorePhaseII
operator|+
literal|"\n"
decl_stmt|;
comment|// Add same entries to compact them later
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|1200
condition|;
name|i
operator|++
control|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|1
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|100
condition|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|50
condition|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|3
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Now add more puts for CF2, so that we only flush CF2 to disk
for|for
control|(
name|int
name|i
init|=
literal|100
init|;
name|i
operator|<
literal|2000
condition|;
name|i
operator|++
control|)
block|{
name|region
operator|.
name|put
argument_list|(
name|createPut
argument_list|(
literal|2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|smallestSeqInRegionCurrentMemstorePhaseIII
init|=
name|region
operator|.
name|getWAL
argument_list|()
operator|.
name|getEarliestMemstoreSeqNum
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF1PhaseIII
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY1
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF2PhaseIII
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY2
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF3PhaseIII
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY3
argument_list|)
decl_stmt|;
name|s
operator|=
name|s
operator|+
literal|"The smallest sequence in region WAL is: "
operator|+
name|smallestSeqInRegionCurrentMemstorePhaseIII
operator|+
literal|", the smallest sequence in CF1:"
operator|+
name|smallestSeqCF1PhaseIII
operator|+
literal|", "
operator|+
literal|"the smallest sequence in CF2:"
operator|+
name|smallestSeqCF2PhaseIII
operator|+
literal|", the smallest sequence in CF3:"
operator|+
name|smallestSeqCF3PhaseIII
operator|+
literal|"\n"
expr_stmt|;
comment|// Flush!
operator|(
operator|(
name|CompactingMemStore
operator|)
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY1
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|)
operator|.
name|flushInMemory
argument_list|()
expr_stmt|;
operator|(
operator|(
name|CompactingMemStore
operator|)
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY3
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|)
operator|.
name|flushInMemory
argument_list|()
expr_stmt|;
comment|// CF1 and CF3 should be compacted so wait here to be sure the compaction is done
while|while
condition|(
operator|(
operator|(
name|CompactingMemStore
operator|)
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY1
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|)
operator|.
name|isMemStoreFlushingInMemory
argument_list|()
condition|)
name|Threads
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|CompactingMemStore
operator|)
name|region
operator|.
name|getStore
argument_list|(
name|FAMILY3
argument_list|)
operator|.
name|getMemStore
argument_list|()
operator|)
operator|.
name|isMemStoreFlushingInMemory
argument_list|()
condition|)
name|Threads
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|region
operator|.
name|flush
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|long
name|smallestSeqInRegionCurrentMemstorePhaseIV
init|=
name|region
operator|.
name|getWAL
argument_list|()
operator|.
name|getEarliestMemstoreSeqNum
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF1PhaseIV
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY1
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF2PhaseIV
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY2
argument_list|)
decl_stmt|;
name|long
name|smallestSeqCF3PhaseIV
init|=
name|region
operator|.
name|getOldestSeqIdOfStore
argument_list|(
name|FAMILY3
argument_list|)
decl_stmt|;
name|s
operator|=
name|s
operator|+
literal|"The smallest sequence in region WAL is: "
operator|+
name|smallestSeqInRegionCurrentMemstorePhaseIV
operator|+
literal|", the smallest sequence in CF1:"
operator|+
name|smallestSeqCF1PhaseIV
operator|+
literal|", "
operator|+
literal|"the smallest sequence in CF2:"
operator|+
name|smallestSeqCF2PhaseIV
operator|+
literal|", the smallest sequence in CF3:"
operator|+
name|smallestSeqCF3PhaseIV
operator|+
literal|"\n"
expr_stmt|;
comment|// now check that the LSN of the entire WAL, of CF1 and of CF3 has progressed due to compaction
name|assertTrue
argument_list|(
name|s
argument_list|,
name|smallestSeqInRegionCurrentMemstorePhaseIV
operator|>
name|smallestSeqInRegionCurrentMemstorePhaseIII
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|smallestSeqCF1PhaseIV
operator|>
name|smallestSeqCF1PhaseIII
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|smallestSeqCF3PhaseIV
operator|>
name|smallestSeqCF3PhaseIII
argument_list|)
expr_stmt|;
name|HBaseTestingUtility
operator|.
name|closeRegionAndWAL
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
comment|// Find the (first) region which has the specified name.
specifier|private
specifier|static
name|Pair
argument_list|<
name|Region
argument_list|,
name|HRegionServer
argument_list|>
name|getRegionWithName
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
name|MiniHBaseCluster
name|cluster
init|=
name|TEST_UTIL
operator|.
name|getMiniHBaseCluster
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|JVMClusterUtil
operator|.
name|RegionServerThread
argument_list|>
name|rsts
init|=
name|cluster
operator|.
name|getRegionServerThreads
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cluster
operator|.
name|getRegionServerThreads
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|HRegionServer
name|hrs
init|=
name|rsts
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getRegionServer
argument_list|()
decl_stmt|;
for|for
control|(
name|Region
name|region
range|:
name|hrs
operator|.
name|getOnlineRegions
argument_list|(
name|tableName
argument_list|)
control|)
block|{
return|return
name|Pair
operator|.
name|newPair
argument_list|(
name|region
argument_list|,
name|hrs
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|WAL
name|getWAL
parameter_list|(
name|Region
name|region
parameter_list|)
block|{
return|return
operator|(
operator|(
name|HRegion
operator|)
name|region
operator|)
operator|.
name|getWAL
argument_list|()
return|;
block|}
specifier|private
name|int
name|getNumRolledLogFiles
parameter_list|(
name|Region
name|region
parameter_list|)
block|{
return|return
operator|(
operator|(
name|FSHLog
operator|)
name|getWAL
argument_list|(
name|region
argument_list|)
operator|)
operator|.
name|getNumRolledLogFiles
argument_list|()
return|;
block|}
block|}
end_class

end_unit

