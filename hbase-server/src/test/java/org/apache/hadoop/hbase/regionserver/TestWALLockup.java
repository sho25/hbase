begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ChoreService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CoordinatedStateManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseClassTestRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|AsyncClusterConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Durability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|DamagedWALException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|FSHLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|WALActionsListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|MediumTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|RegionServerTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManagerTestHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WAL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALEdit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALKeyImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALProvider
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|ClassRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|Closeables
import|;
end_import

begin_comment
comment|/**  * Testing for lock up of FSHLog.  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
block|{
name|RegionServerTests
operator|.
name|class
block|,
name|MediumTests
operator|.
name|class
block|}
argument_list|)
specifier|public
class|class
name|TestWALLockup
block|{
annotation|@
name|ClassRule
specifier|public
specifier|static
specifier|final
name|HBaseClassTestRule
name|CLASS_RULE
init|=
name|HBaseClassTestRule
operator|.
name|forClass
argument_list|(
name|TestWALLockup
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestWALLockup
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Rule
specifier|public
name|TestName
name|name
init|=
operator|new
name|TestName
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|COLUMN_FAMILY
init|=
literal|"MyCF"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|COLUMN_FAMILY_BYTES
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|COLUMN_FAMILY
argument_list|)
decl_stmt|;
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
name|HBaseTestingUtility
name|TEST_UTIL
init|=
operator|new
name|HBaseTestingUtility
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|Configuration
name|CONF
decl_stmt|;
specifier|private
name|String
name|dir
decl_stmt|;
comment|// Test names
specifier|protected
name|TableName
name|tableName
decl_stmt|;
annotation|@
name|Before
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|IOException
block|{
name|CONF
operator|=
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
comment|// Disable block cache.
name|CONF
operator|.
name|setFloat
argument_list|(
name|HConstants
operator|.
name|HFILE_BLOCK_CACHE_SIZE_KEY
argument_list|,
literal|0f
argument_list|)
expr_stmt|;
name|dir
operator|=
name|TEST_UTIL
operator|.
name|getDataTestDir
argument_list|(
literal|"TestHRegion"
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
name|tableName
operator|=
name|TableName
operator|.
name|valueOf
argument_list|(
name|name
operator|.
name|getMethodName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|EnvironmentEdgeManagerTestHelper
operator|.
name|reset
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning test directory: "
operator|+
name|TEST_UTIL
operator|.
name|getDataTestDir
argument_list|()
argument_list|)
expr_stmt|;
name|TEST_UTIL
operator|.
name|cleanupTestDir
argument_list|()
expr_stmt|;
block|}
specifier|private
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
operator|.
name|getMethodName
argument_list|()
return|;
block|}
comment|// A WAL that we can have throw exceptions when a flag is set.
specifier|private
specifier|static
specifier|final
class|class
name|DodgyFSLog
extends|extends
name|FSHLog
block|{
comment|// Set this when want the WAL to start throwing exceptions.
specifier|volatile
name|boolean
name|throwException
init|=
literal|false
decl_stmt|;
comment|// Latch to hold up processing until after another operation has had time to run.
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|public
name|DodgyFSLog
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|root
parameter_list|,
name|String
name|logDir
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|fs
argument_list|,
name|root
argument_list|,
name|logDir
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|afterCreatingZigZagLatch
parameter_list|()
block|{
comment|// If throwException set, then append will throw an exception causing the WAL to be
comment|// rolled. We'll come in here. Hold up processing until a sync can get in before
comment|// the zigzag has time to complete its setup and get its own sync in. This is what causes
comment|// the lock up we've seen in production.
if|if
condition|(
name|throwException
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"LATCHED"
argument_list|)
expr_stmt|;
comment|// So, timing can have it that the test can run and the bad flush below happens
comment|// before we get here. In this case, we'll be stuck waiting on this latch but there
comment|// is nothing in the WAL pipeline to get us to the below beforeWaitOnSafePoint...
comment|// because all WALs have rolled. In this case, just give up on test.
if|if
condition|(
operator|!
name|this
operator|.
name|latch
operator|.
name|await
argument_list|(
literal|5
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"GIVE UP! Failed waiting on latch...Test is ABORTED!"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{         }
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|beforeWaitOnSafePoint
parameter_list|()
block|{
if|if
condition|(
name|throwException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"COUNTDOWN"
argument_list|)
expr_stmt|;
comment|// Don't countdown latch until someone waiting on it otherwise, the above
comment|// afterCreatingZigZagLatch will get to the latch and no one will ever free it and we'll
comment|// be stuck; test won't go down
while|while
condition|(
name|this
operator|.
name|latch
operator|.
name|getCount
argument_list|()
operator|<=
literal|0
condition|)
name|Threads
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|Writer
name|createWriterInstance
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Writer
name|w
init|=
name|super
operator|.
name|createWriterInstance
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|Writer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|(
name|boolean
name|forceSync
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|throwException
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"FAKE! Failed to replace a bad datanode...SYNC"
argument_list|)
throw|;
block|}
name|w
operator|.
name|sync
argument_list|(
name|forceSync
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|append
parameter_list|(
name|Entry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|throwException
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"FAKE! Failed to replace a bad datanode...APPEND"
argument_list|)
throw|;
block|}
name|w
operator|.
name|append
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLength
parameter_list|()
block|{
return|return
name|w
operator|.
name|getLength
argument_list|()
return|;
block|}
block|}
return|;
block|}
block|}
comment|/**    * Reproduce locking up that happens when we get an inopportune sync during setup for    * zigzaglatch wait. See HBASE-14317. If below is broken, we will see this test timeout because    * it is locked up.    *<p>First I need to set up some mocks for Server and RegionServerServices. I also need to    * set up a dodgy WAL that will throw an exception when we go to append to it.    */
annotation|@
name|Test
specifier|public
name|void
name|testLockupWhenSyncInMiddleOfZigZagSetup
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Mocked up server and regionserver services. Needed below.
name|Server
name|server
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|Server
operator|.
name|class
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|server
operator|.
name|getConfiguration
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|CONF
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|server
operator|.
name|isStopped
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|server
operator|.
name|isAborted
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|RegionServerServices
name|services
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|RegionServerServices
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// OK. Now I have my mocked up Server& RegionServerServices and dodgy WAL, go ahead with test.
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|CONF
argument_list|)
decl_stmt|;
name|Path
name|rootDir
init|=
operator|new
name|Path
argument_list|(
name|dir
operator|+
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|DodgyFSLog
name|dodgyWAL
init|=
operator|new
name|DodgyFSLog
argument_list|(
name|fs
argument_list|,
name|rootDir
argument_list|,
name|getName
argument_list|()
argument_list|,
name|CONF
argument_list|)
decl_stmt|;
name|dodgyWAL
operator|.
name|init
argument_list|()
expr_stmt|;
name|Path
name|originalWAL
init|=
name|dodgyWAL
operator|.
name|getCurrentFileName
argument_list|()
decl_stmt|;
comment|// I need a log roller running.
name|LogRoller
name|logRoller
init|=
operator|new
name|LogRoller
argument_list|(
name|server
argument_list|,
name|services
argument_list|)
decl_stmt|;
name|logRoller
operator|.
name|addWAL
argument_list|(
name|dodgyWAL
argument_list|)
expr_stmt|;
comment|// There is no 'stop' once a logRoller is running.. it just dies.
name|logRoller
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Now get a region and start adding in edits.
specifier|final
name|HRegion
name|region
init|=
name|initHRegion
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|dodgyWAL
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Integer
argument_list|>
name|scopes
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|COLUMN_FAMILY_BYTES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MultiVersionConcurrencyControl
name|mvcc
init|=
operator|new
name|MultiVersionConcurrencyControl
argument_list|()
decl_stmt|;
try|try
block|{
comment|// First get something into memstore. Make a Put and then pull the Cell out of it. Will
comment|// manage append and sync carefully in below to manufacture hang. We keep adding same
comment|// edit. WAL subsystem doesn't care.
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|put
operator|.
name|addColumn
argument_list|(
name|COLUMN_FAMILY_BYTES
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"1"
argument_list|)
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|WALKeyImpl
name|key
init|=
operator|new
name|WALKeyImpl
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|,
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|mvcc
argument_list|,
name|scopes
argument_list|)
decl_stmt|;
name|WALEdit
name|edit
init|=
operator|new
name|WALEdit
argument_list|()
decl_stmt|;
name|CellScanner
name|CellScanner
init|=
name|put
operator|.
name|cellScanner
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|CellScanner
operator|.
name|advance
argument_list|()
argument_list|)
expr_stmt|;
name|edit
operator|.
name|add
argument_list|(
name|CellScanner
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
comment|// Put something in memstore and out in the WAL. Do a big number of appends so we push
comment|// out other side of the ringbuffer. If small numbers, stuff doesn't make it to WAL
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|region
operator|.
name|put
argument_list|(
name|put
argument_list|)
expr_stmt|;
block|}
comment|// Set it so we start throwing exceptions.
name|LOG
operator|.
name|info
argument_list|(
literal|"SET throwing of exception on append"
argument_list|)
expr_stmt|;
name|dodgyWAL
operator|.
name|throwException
operator|=
literal|true
expr_stmt|;
comment|// This append provokes a WAL roll request
name|dodgyWAL
operator|.
name|append
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|key
argument_list|,
name|edit
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|boolean
name|exception
init|=
literal|false
decl_stmt|;
try|try
block|{
name|dodgyWAL
operator|.
name|sync
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|exception
operator|=
literal|true
expr_stmt|;
block|}
name|assertTrue
argument_list|(
literal|"Did not get sync exception"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
comment|// Get a memstore flush going too so we have same hung profile as up in the issue over
comment|// in HBASE-14317. Flush hangs trying to get sequenceid because the ringbuffer is held up
comment|// by the zigzaglatch waiting on syncs to come home.
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
literal|"Flusher"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|region
operator|.
name|getMemStoreDataSize
argument_list|()
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"memstore size="
operator|+
name|region
operator|.
name|getMemStoreDataSize
argument_list|()
argument_list|)
throw|;
block|}
name|region
operator|.
name|flush
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Can fail trying to flush in middle of a roll. Not a failure. Will succeed later
comment|// when roll completes.
name|LOG
operator|.
name|info
argument_list|(
literal|"In flush"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Exiting"
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Wait until
while|while
condition|(
name|dodgyWAL
operator|.
name|latch
operator|.
name|getCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Threads
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Now assert I got a new WAL file put in place even though loads of errors above.
name|assertTrue
argument_list|(
name|originalWAL
operator|!=
name|dodgyWAL
operator|.
name|getCurrentFileName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Can I append to it?
name|dodgyWAL
operator|.
name|throwException
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|region
operator|.
name|put
argument_list|(
name|put
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"In the put"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// To stop logRoller, its server has to say it is stopped.
name|Mockito
operator|.
name|when
argument_list|(
name|server
operator|.
name|isStopped
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Closeables
operator|.
name|close
argument_list|(
name|logRoller
argument_list|,
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|region
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dodgyWAL
operator|!=
literal|null
condition|)
block|{
name|dodgyWAL
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"On way out"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    *    * If below is broken, we will see this test timeout because RingBufferEventHandler was stuck in    * attainSafePoint. Everyone will wait for sync to finish forever. See HBASE-14317.    */
annotation|@
name|Test
specifier|public
name|void
name|testRingBufferEventHandlerStuckWhenSyncFailed
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// A WAL that we can have throw exceptions and slow FSHLog.replaceWriter down
class|class
name|DodgyFSLog
extends|extends
name|FSHLog
block|{
specifier|private
specifier|volatile
name|boolean
name|zigZagCreated
init|=
literal|false
decl_stmt|;
specifier|public
name|DodgyFSLog
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|root
parameter_list|,
name|String
name|logDir
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|fs
argument_list|,
name|root
argument_list|,
name|logDir
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|afterCreatingZigZagLatch
parameter_list|()
block|{
name|zigZagCreated
operator|=
literal|true
expr_stmt|;
comment|// Sleep a while to wait for RingBufferEventHandler to get stuck first.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignore
parameter_list|)
block|{         }
block|}
annotation|@
name|Override
specifier|protected
name|long
name|getSequenceOnRingBuffer
parameter_list|()
block|{
return|return
name|super
operator|.
name|getSequenceOnRingBuffer
argument_list|()
return|;
block|}
specifier|protected
name|void
name|publishSyncOnRingBufferAndBlock
parameter_list|(
name|long
name|sequence
parameter_list|)
block|{
try|try
block|{
name|super
operator|.
name|blockOnSync
argument_list|(
name|super
operator|.
name|publishSyncOnRingBuffer
argument_list|(
name|sequence
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|fail
argument_list|(
literal|"Expect an IOException here."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignore
parameter_list|)
block|{
comment|// Here, we will get an IOException.
block|}
block|}
annotation|@
name|Override
specifier|protected
name|Writer
name|createWriterInstance
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Writer
name|w
init|=
name|super
operator|.
name|createWriterInstance
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|Writer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|(
name|boolean
name|forceSync
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"FAKE! Failed to replace a bad datanode...SYNC"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|append
parameter_list|(
name|Entry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
name|w
operator|.
name|append
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLength
parameter_list|()
block|{
return|return
name|w
operator|.
name|getLength
argument_list|()
return|;
block|}
block|}
return|;
block|}
block|}
comment|// Mocked up server and regionserver services. Needed below.
specifier|final
name|Server
name|server
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|Server
operator|.
name|class
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|server
operator|.
name|getConfiguration
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|CONF
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|server
operator|.
name|isStopped
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|server
operator|.
name|isAborted
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|RegionServerServices
name|services
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|RegionServerServices
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// OK. Now I have my mocked up Server& RegionServerServices and dodgy WAL, go ahead with test.
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|CONF
argument_list|)
decl_stmt|;
name|Path
name|rootDir
init|=
operator|new
name|Path
argument_list|(
name|dir
operator|+
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DodgyFSLog
name|dodgyWAL
init|=
operator|new
name|DodgyFSLog
argument_list|(
name|fs
argument_list|,
name|rootDir
argument_list|,
name|getName
argument_list|()
argument_list|,
name|CONF
argument_list|)
decl_stmt|;
comment|// I need a log roller running.
name|LogRoller
name|logRoller
init|=
operator|new
name|LogRoller
argument_list|(
name|server
argument_list|,
name|services
argument_list|)
decl_stmt|;
name|logRoller
operator|.
name|addWAL
argument_list|(
name|dodgyWAL
argument_list|)
expr_stmt|;
comment|// There is no 'stop' once a logRoller is running.. it just dies.
name|logRoller
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|long
name|seqForSync
init|=
name|dodgyWAL
operator|.
name|getSequenceOnRingBuffer
argument_list|()
decl_stmt|;
comment|// This call provokes a WAL roll, and we will get a new RingBufferEventHandler.ZigZagLatch
comment|// in LogRoller.
comment|// After creating ZigZagLatch, RingBufferEventHandler would get stuck due to sync event,
comment|// as long as HBASE-14317 hasn't be fixed.
name|LOG
operator|.
name|info
argument_list|(
literal|"Trigger log roll for creating a ZigZagLatch."
argument_list|)
expr_stmt|;
name|logRoller
operator|.
name|requestRollAll
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|dodgyWAL
operator|.
name|zigZagCreated
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|// Send a sync event for RingBufferEventHandler,
comment|// and it gets blocked in RingBufferEventHandler.attainSafePoint
name|LOG
operator|.
name|info
argument_list|(
literal|"Send sync for RingBufferEventHandler"
argument_list|)
expr_stmt|;
name|Thread
name|syncThread
init|=
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|dodgyWAL
operator|.
name|publishSyncOnRingBufferAndBlock
argument_list|(
name|seqForSync
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|// Sync in another thread to avoid reset SyncFuture again.
name|syncThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|syncThread
operator|.
name|join
argument_list|()
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Call sync for testing whether RingBufferEventHandler is hanging."
argument_list|)
expr_stmt|;
name|dodgyWAL
operator|.
name|sync
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Should not get a hang here, otherwise we will see timeout in this test.
name|Assert
operator|.
name|fail
argument_list|(
literal|"Expect an IOException here."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignore
parameter_list|)
block|{       }
block|}
finally|finally
block|{
comment|// To stop logRoller, its server has to say it is stopped.
name|Mockito
operator|.
name|when
argument_list|(
name|server
operator|.
name|isStopped
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|logRoller
operator|!=
literal|null
condition|)
block|{
name|logRoller
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dodgyWAL
operator|!=
literal|null
condition|)
block|{
name|dodgyWAL
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|static
class|class
name|DummyServer
implements|implements
name|Server
block|{
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|String
name|serverName
decl_stmt|;
specifier|private
name|boolean
name|isAborted
init|=
literal|false
decl_stmt|;
specifier|public
name|DummyServer
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|serverName
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
annotation|@
name|Override
specifier|public
name|ZKWatcher
name|getZooKeeper
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|CoordinatedStateManager
name|getCoordinatedStateManager
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Connection
name|getConnection
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerName
name|getServerName
parameter_list|()
block|{
return|return
name|ServerName
operator|.
name|valueOf
argument_list|(
name|this
operator|.
name|serverName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|why
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Aborting "
operator|+
name|serverName
argument_list|)
expr_stmt|;
name|this
operator|.
name|isAborted
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAborted
parameter_list|()
block|{
return|return
name|this
operator|.
name|isAborted
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
name|String
name|why
parameter_list|)
block|{
name|this
operator|.
name|isAborted
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|this
operator|.
name|isAborted
return|;
block|}
annotation|@
name|Override
specifier|public
name|ChoreService
name|getChoreService
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|FileSystem
name|getFileSystem
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStopping
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Connection
name|createConnection
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|AsyncClusterConnection
name|getAsyncClusterConnection
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|static
class|class
name|DummyWALActionsListener
implements|implements
name|WALActionsListener
block|{
annotation|@
name|Override
specifier|public
name|void
name|visitLogEntryBeforeWrite
parameter_list|(
name|WALKey
name|logKey
parameter_list|,
name|WALEdit
name|logEdit
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|logKey
operator|.
name|getTableName
argument_list|()
operator|.
name|getNameAsString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"sleep"
argument_list|)
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|logKey
operator|.
name|getTableName
argument_list|()
operator|.
name|getNameAsString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"DamagedWALException"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DamagedWALException
argument_list|(
literal|"Failed appending"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * @return A region on which you must call {@link HBaseTestingUtility#closeRegionAndWAL(HRegion)}    *         when done.    */
specifier|private
specifier|static
name|HRegion
name|initHRegion
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|byte
index|[]
name|startKey
parameter_list|,
name|byte
index|[]
name|stopKey
parameter_list|,
name|WAL
name|wal
parameter_list|)
throws|throws
name|IOException
block|{
name|ChunkCreator
operator|.
name|initialize
argument_list|(
name|MemStoreLABImpl
operator|.
name|CHUNK_SIZE_DEFAULT
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|TEST_UTIL
operator|.
name|createLocalHRegion
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|stopKey
argument_list|,
literal|false
argument_list|,
name|Durability
operator|.
name|SYNC_WAL
argument_list|,
name|wal
argument_list|,
name|COLUMN_FAMILY_BYTES
argument_list|)
return|;
block|}
block|}
end_class

end_unit

