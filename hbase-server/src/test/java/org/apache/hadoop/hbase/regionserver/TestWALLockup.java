begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ChoreService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CoordinatedStateManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ClusterConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Durability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|DamagedWALException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|FSHLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|FailedLogCloseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|WALActionsListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALEdit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|MediumTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManagerTestHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WAL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALProvider
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MetaTableLocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_comment
comment|/**  * Testing for lock up of WAL subsystem.  * Copied from TestHRegion.  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
block|{
name|MediumTests
operator|.
name|class
block|}
argument_list|)
specifier|public
class|class
name|TestWALLockup
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestWALLockup
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Rule
specifier|public
name|TestName
name|name
init|=
operator|new
name|TestName
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|COLUMN_FAMILY
init|=
literal|"MyCF"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|COLUMN_FAMILY_BYTES
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|COLUMN_FAMILY
argument_list|)
decl_stmt|;
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
comment|// Do not run unit tests in parallel (? Why not?  It don't work?  Why not?  St.Ack)
specifier|private
specifier|static
name|HBaseTestingUtility
name|TEST_UTIL
decl_stmt|;
specifier|private
specifier|static
name|Configuration
name|CONF
decl_stmt|;
specifier|private
name|String
name|dir
decl_stmt|;
comment|// Test names
specifier|protected
name|TableName
name|tableName
decl_stmt|;
annotation|@
name|Before
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|IOException
block|{
name|TEST_UTIL
operator|=
name|HBaseTestingUtility
operator|.
name|createLocalHTU
argument_list|()
expr_stmt|;
name|CONF
operator|=
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
comment|// Disable block cache.
name|CONF
operator|.
name|setFloat
argument_list|(
name|HConstants
operator|.
name|HFILE_BLOCK_CACHE_SIZE_KEY
argument_list|,
literal|0f
argument_list|)
expr_stmt|;
name|dir
operator|=
name|TEST_UTIL
operator|.
name|getDataTestDir
argument_list|(
literal|"TestHRegion"
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
name|tableName
operator|=
name|TableName
operator|.
name|valueOf
argument_list|(
name|name
operator|.
name|getMethodName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|EnvironmentEdgeManagerTestHelper
operator|.
name|reset
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning test directory: "
operator|+
name|TEST_UTIL
operator|.
name|getDataTestDir
argument_list|()
argument_list|)
expr_stmt|;
name|TEST_UTIL
operator|.
name|cleanupTestDir
argument_list|()
expr_stmt|;
block|}
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
operator|.
name|getMethodName
argument_list|()
return|;
block|}
comment|/**    * Reproduce locking up that happens when we get an inopportune sync during setup for    * zigzaglatch wait. See HBASE-14317. If below is broken, we will see this test timeout because    * it is locked up.    *<p>First I need to set up some mocks for Server and RegionServerServices. I also need to    * set up a dodgy WAL that will throw an exception when we go to append to it.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|20000
argument_list|)
specifier|public
name|void
name|testLockupWhenSyncInMiddleOfZigZagSetup
parameter_list|()
throws|throws
name|IOException
block|{
comment|// A WAL that we can have throw exceptions when a flag is set.
class|class
name|DodgyFSLog
extends|extends
name|FSHLog
block|{
comment|// Set this when want the WAL to start throwing exceptions.
specifier|volatile
name|boolean
name|throwException
init|=
literal|false
decl_stmt|;
comment|// Latch to hold up processing until after another operation has had time to run.
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|public
name|DodgyFSLog
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|root
parameter_list|,
name|String
name|logDir
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|fs
argument_list|,
name|root
argument_list|,
name|logDir
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|afterCreatingZigZagLatch
parameter_list|()
block|{
comment|// If throwException set, then append will throw an exception causing the WAL to be
comment|// rolled. We'll come in here. Hold up processing until a sync can get in before
comment|// the zigzag has time to complete its setup and get its own sync in. This is what causes
comment|// the lock up we've seen in production.
if|if
condition|(
name|throwException
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"LATCHED"
argument_list|)
expr_stmt|;
comment|// So, timing can have it that the test can run and the bad flush below happens
comment|// before we get here. In this case, we'll be stuck waiting on this latch but there
comment|// is nothing in the WAL pipeline to get us to the below beforeWaitOnSafePoint...
comment|// because all WALs have rolled. In this case, just give up on test.
if|if
condition|(
operator|!
name|this
operator|.
name|latch
operator|.
name|await
argument_list|(
literal|5
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"GIVE UP! Failed waiting on latch...Test is ABORTED!"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// TODO Auto-generated catch block
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|beforeWaitOnSafePoint
parameter_list|()
block|{
if|if
condition|(
name|throwException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"COUNTDOWN"
argument_list|)
expr_stmt|;
comment|// Don't countdown latch until someone waiting on it otherwise, the above
comment|// afterCreatingZigZagLatch will get to the latch and no one will ever free it and we'll
comment|// be stuck; test won't go down
while|while
condition|(
name|this
operator|.
name|latch
operator|.
name|getCount
argument_list|()
operator|<=
literal|0
condition|)
name|Threads
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|Writer
name|createWriterInstance
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Writer
name|w
init|=
name|super
operator|.
name|createWriterInstance
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|Writer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|throwException
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"FAKE! Failed to replace a bad datanode...SYNC"
argument_list|)
throw|;
block|}
name|w
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|append
parameter_list|(
name|Entry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|throwException
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"FAKE! Failed to replace a bad datanode...APPEND"
argument_list|)
throw|;
block|}
name|w
operator|.
name|append
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLength
parameter_list|()
block|{
return|return
name|w
operator|.
name|getLength
argument_list|()
return|;
block|}
block|}
return|;
block|}
block|}
comment|// Mocked up server and regionserver services. Needed below.
name|Server
name|server
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|Server
operator|.
name|class
argument_list|)
decl_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|server
operator|.
name|getConfiguration
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|CONF
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|server
operator|.
name|isStopped
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|when
argument_list|(
name|server
operator|.
name|isAborted
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|RegionServerServices
name|services
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|RegionServerServices
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// OK. Now I have my mocked up Server& RegionServerServices and dodgy WAL, go ahead with test.
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|CONF
argument_list|)
decl_stmt|;
name|Path
name|rootDir
init|=
operator|new
name|Path
argument_list|(
name|dir
operator|+
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|DodgyFSLog
name|dodgyWAL
init|=
operator|new
name|DodgyFSLog
argument_list|(
name|fs
argument_list|,
name|rootDir
argument_list|,
name|getName
argument_list|()
argument_list|,
name|CONF
argument_list|)
decl_stmt|;
name|Path
name|originalWAL
init|=
name|dodgyWAL
operator|.
name|getCurrentFileName
argument_list|()
decl_stmt|;
comment|// I need a log roller running.
name|LogRoller
name|logRoller
init|=
operator|new
name|LogRoller
argument_list|(
name|server
argument_list|,
name|services
argument_list|)
decl_stmt|;
name|logRoller
operator|.
name|addWAL
argument_list|(
name|dodgyWAL
argument_list|)
expr_stmt|;
comment|// There is no 'stop' once a logRoller is running.. it just dies.
name|logRoller
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Now get a region and start adding in edits.
name|HTableDescriptor
name|htd
init|=
operator|new
name|HTableDescriptor
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
specifier|final
name|HRegion
name|region
init|=
name|initHRegion
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|dodgyWAL
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Integer
argument_list|>
name|scopes
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|COLUMN_FAMILY_BYTES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MultiVersionConcurrencyControl
name|mvcc
init|=
operator|new
name|MultiVersionConcurrencyControl
argument_list|()
decl_stmt|;
try|try
block|{
comment|// First get something into memstore. Make a Put and then pull the Cell out of it. Will
comment|// manage append and sync carefully in below to manufacture hang. We keep adding same
comment|// edit. WAL subsystem doesn't care.
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|put
operator|.
name|addColumn
argument_list|(
name|COLUMN_FAMILY_BYTES
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"1"
argument_list|)
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|WALKey
name|key
init|=
operator|new
name|WALKey
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|,
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|mvcc
argument_list|,
name|scopes
argument_list|)
decl_stmt|;
name|WALEdit
name|edit
init|=
operator|new
name|WALEdit
argument_list|()
decl_stmt|;
name|CellScanner
name|CellScanner
init|=
name|put
operator|.
name|cellScanner
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|CellScanner
operator|.
name|advance
argument_list|()
argument_list|)
expr_stmt|;
name|edit
operator|.
name|add
argument_list|(
name|CellScanner
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
comment|// Put something in memstore and out in the WAL. Do a big number of appends so we push
comment|// out other side of the ringbuffer. If small numbers, stuff doesn't make it to WAL
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|region
operator|.
name|put
argument_list|(
name|put
argument_list|)
expr_stmt|;
block|}
comment|// Set it so we start throwing exceptions.
name|LOG
operator|.
name|info
argument_list|(
literal|"SET throwing of exception on append"
argument_list|)
expr_stmt|;
name|dodgyWAL
operator|.
name|throwException
operator|=
literal|true
expr_stmt|;
comment|// This append provokes a WAL roll request
name|dodgyWAL
operator|.
name|append
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|key
argument_list|,
name|edit
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|boolean
name|exception
init|=
literal|false
decl_stmt|;
try|try
block|{
name|dodgyWAL
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|exception
operator|=
literal|true
expr_stmt|;
block|}
name|assertTrue
argument_list|(
literal|"Did not get sync exception"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
comment|// Get a memstore flush going too so we have same hung profile as up in the issue over
comment|// in HBASE-14317. Flush hangs trying to get sequenceid because the ringbuffer is held up
comment|// by the zigzaglatch waiting on syncs to come home.
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
literal|"Flusher"
argument_list|)
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|region
operator|.
name|getMemStoreSize
argument_list|()
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"memstore size="
operator|+
name|region
operator|.
name|getMemStoreSize
argument_list|()
argument_list|)
throw|;
block|}
name|region
operator|.
name|flush
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Can fail trying to flush in middle of a roll. Not a failure. Will succeed later
comment|// when roll completes.
name|LOG
operator|.
name|info
argument_list|(
literal|"In flush"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Exiting"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
decl_stmt|;
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Wait until
while|while
condition|(
name|dodgyWAL
operator|.
name|latch
operator|.
name|getCount
argument_list|()
operator|>
literal|0
condition|)
name|Threads
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Now assert I got a new WAL file put in place even though loads of errors above.
name|assertTrue
argument_list|(
name|originalWAL
operator|!=
name|dodgyWAL
operator|.
name|getCurrentFileName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Can I append to it?
name|dodgyWAL
operator|.
name|throwException
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|region
operator|.
name|put
argument_list|(
name|put
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"In the put"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// To stop logRoller, its server has to say it is stopped.
name|Mockito
operator|.
name|when
argument_list|(
name|server
operator|.
name|isStopped
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|logRoller
operator|!=
literal|null
condition|)
name|logRoller
operator|.
name|close
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|region
operator|!=
literal|null
condition|)
name|region
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|dodgyWAL
operator|!=
literal|null
condition|)
name|dodgyWAL
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"On way out"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Reproduce locking up that happens when there's no further syncs after    * append fails, and causing an isolated sync then infinite wait. See    * HBASE-16960. If below is broken, we will see this test timeout because it    * is locked up.    *<p/>    * Steps for reproduce:<br/>    * 1. Trigger server abort through dodgyWAL1<br/>    * 2. Add a {@link DummyWALActionsListener} to dodgyWAL2 to cause ringbuffer    * event handler thread sleep for a while thus keeping {@code endOfBatch}    * false<br/>    * 3. Publish a sync then an append which will throw exception, check whether    * the sync could return    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|20000
argument_list|)
specifier|public
name|void
name|testLockup16960
parameter_list|()
throws|throws
name|IOException
block|{
comment|// A WAL that we can have throw exceptions when a flag is set.
class|class
name|DodgyFSLog
extends|extends
name|FSHLog
block|{
comment|// Set this when want the WAL to start throwing exceptions.
specifier|volatile
name|boolean
name|throwException
init|=
literal|false
decl_stmt|;
specifier|public
name|DodgyFSLog
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|root
parameter_list|,
name|String
name|logDir
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|fs
argument_list|,
name|root
argument_list|,
name|logDir
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|Writer
name|createWriterInstance
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Writer
name|w
init|=
name|super
operator|.
name|createWriterInstance
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|Writer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|throwException
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"FAKE! Failed to replace a bad datanode...SYNC"
argument_list|)
throw|;
block|}
name|w
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|append
parameter_list|(
name|Entry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|throwException
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"FAKE! Failed to replace a bad datanode...APPEND"
argument_list|)
throw|;
block|}
name|w
operator|.
name|append
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLength
parameter_list|()
block|{
return|return
name|w
operator|.
name|getLength
argument_list|()
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|protected
name|long
name|doReplaceWriter
parameter_list|(
name|Path
name|oldPath
parameter_list|,
name|Path
name|newPath
parameter_list|,
name|Writer
name|nextWriter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|throwException
condition|)
block|{
throw|throw
operator|new
name|FailedLogCloseException
argument_list|(
literal|"oldPath="
operator|+
name|oldPath
operator|+
literal|", newPath="
operator|+
name|newPath
argument_list|)
throw|;
block|}
name|long
name|oldFileLen
init|=
literal|0L
decl_stmt|;
name|oldFileLen
operator|=
name|super
operator|.
name|doReplaceWriter
argument_list|(
name|oldPath
argument_list|,
name|newPath
argument_list|,
name|nextWriter
argument_list|)
expr_stmt|;
return|return
name|oldFileLen
return|;
block|}
block|}
comment|// Mocked up server and regionserver services. Needed below.
name|Server
name|server
init|=
operator|new
name|DummyServer
argument_list|(
name|CONF
argument_list|,
name|ServerName
operator|.
name|valueOf
argument_list|(
literal|"hostname1.example.org"
argument_list|,
literal|1234
argument_list|,
literal|1L
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|RegionServerServices
name|services
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|RegionServerServices
operator|.
name|class
argument_list|)
decl_stmt|;
name|CONF
operator|.
name|setLong
argument_list|(
literal|"hbase.regionserver.hlog.sync.timeout"
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
comment|// OK. Now I have my mocked up Server& RegionServerServices and dodgy WAL,
comment|// go ahead with test.
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|CONF
argument_list|)
decl_stmt|;
name|Path
name|rootDir
init|=
operator|new
name|Path
argument_list|(
name|dir
operator|+
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|DodgyFSLog
name|dodgyWAL1
init|=
operator|new
name|DodgyFSLog
argument_list|(
name|fs
argument_list|,
name|rootDir
argument_list|,
name|getName
argument_list|()
argument_list|,
name|CONF
argument_list|)
decl_stmt|;
name|Path
name|rootDir2
init|=
operator|new
name|Path
argument_list|(
name|dir
operator|+
name|getName
argument_list|()
operator|+
literal|"2"
argument_list|)
decl_stmt|;
specifier|final
name|DodgyFSLog
name|dodgyWAL2
init|=
operator|new
name|DodgyFSLog
argument_list|(
name|fs
argument_list|,
name|rootDir2
argument_list|,
name|getName
argument_list|()
operator|+
literal|"2"
argument_list|,
name|CONF
argument_list|)
decl_stmt|;
comment|// Add a listener to force ringbuffer event handler sleep for a while
name|dodgyWAL2
operator|.
name|registerWALActionsListener
argument_list|(
operator|new
name|DummyWALActionsListener
argument_list|()
argument_list|)
expr_stmt|;
comment|// I need a log roller running.
name|LogRoller
name|logRoller
init|=
operator|new
name|LogRoller
argument_list|(
name|server
argument_list|,
name|services
argument_list|)
decl_stmt|;
name|logRoller
operator|.
name|addWAL
argument_list|(
name|dodgyWAL1
argument_list|)
expr_stmt|;
name|logRoller
operator|.
name|addWAL
argument_list|(
name|dodgyWAL2
argument_list|)
expr_stmt|;
comment|// There is no 'stop' once a logRoller is running.. it just dies.
name|logRoller
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Now get a region and start adding in edits.
name|HTableDescriptor
name|htd
init|=
operator|new
name|HTableDescriptor
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
specifier|final
name|HRegion
name|region
init|=
name|initHRegion
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|dodgyWAL1
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Integer
argument_list|>
name|scopes
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|COLUMN_FAMILY_BYTES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MultiVersionConcurrencyControl
name|mvcc
init|=
operator|new
name|MultiVersionConcurrencyControl
argument_list|()
decl_stmt|;
try|try
block|{
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|put
operator|.
name|addColumn
argument_list|(
name|COLUMN_FAMILY_BYTES
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"1"
argument_list|)
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|WALKey
name|key
init|=
operator|new
name|WALKey
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|,
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|mvcc
argument_list|,
name|scopes
argument_list|)
decl_stmt|;
name|WALEdit
name|edit
init|=
operator|new
name|WALEdit
argument_list|()
decl_stmt|;
name|CellScanner
name|CellScanner
init|=
name|put
operator|.
name|cellScanner
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|CellScanner
operator|.
name|advance
argument_list|()
argument_list|)
expr_stmt|;
name|edit
operator|.
name|add
argument_list|(
name|CellScanner
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"SET throwing of exception on append"
argument_list|)
expr_stmt|;
name|dodgyWAL1
operator|.
name|throwException
operator|=
literal|true
expr_stmt|;
comment|// This append provokes a WAL roll request
name|dodgyWAL1
operator|.
name|append
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|key
argument_list|,
name|edit
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|boolean
name|exception
init|=
literal|false
decl_stmt|;
try|try
block|{
name|dodgyWAL1
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|exception
operator|=
literal|true
expr_stmt|;
block|}
name|assertTrue
argument_list|(
literal|"Did not get sync exception"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
comment|// LogRoller call dodgyWAL1.rollWriter get FailedLogCloseException and
comment|// cause server abort.
try|try
block|{
comment|// wait LogRoller exit.
name|Thread
operator|.
name|sleep
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
specifier|final
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// make RingBufferEventHandler sleep 1s, so the following sync
comment|// endOfBatch=false
name|key
operator|=
operator|new
name|WALKey
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
literal|"sleep"
argument_list|)
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|mvcc
argument_list|,
name|scopes
argument_list|)
expr_stmt|;
name|dodgyWAL2
operator|.
name|append
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|key
argument_list|,
name|edit
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
literal|"Sync"
argument_list|)
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|dodgyWAL2
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"In sync"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Sync exiting"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
decl_stmt|;
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
comment|// make sure sync have published.
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
name|e1
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
comment|// make append throw DamagedWALException
name|key
operator|=
operator|new
name|WALKey
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
literal|"DamagedWALException"
argument_list|)
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|mvcc
argument_list|,
name|scopes
argument_list|)
expr_stmt|;
name|dodgyWAL2
operator|.
name|append
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|key
argument_list|,
name|edit
argument_list|,
literal|true
argument_list|)
expr_stmt|;
while|while
condition|(
name|latch
operator|.
name|getCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Threads
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|server
operator|.
name|isAborted
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|logRoller
operator|!=
literal|null
condition|)
block|{
name|logRoller
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|region
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dodgyWAL1
operator|!=
literal|null
condition|)
block|{
name|dodgyWAL1
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dodgyWAL2
operator|!=
literal|null
condition|)
block|{
name|dodgyWAL2
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"On way out"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
class|class
name|DummyServer
implements|implements
name|Server
block|{
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|String
name|serverName
decl_stmt|;
specifier|private
name|boolean
name|isAborted
init|=
literal|false
decl_stmt|;
specifier|public
name|DummyServer
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|serverName
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
annotation|@
name|Override
specifier|public
name|ZooKeeperWatcher
name|getZooKeeper
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|CoordinatedStateManager
name|getCoordinatedStateManager
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|ClusterConnection
name|getConnection
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|MetaTableLocator
name|getMetaTableLocator
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerName
name|getServerName
parameter_list|()
block|{
return|return
name|ServerName
operator|.
name|valueOf
argument_list|(
name|this
operator|.
name|serverName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|why
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Aborting "
operator|+
name|serverName
argument_list|)
expr_stmt|;
name|this
operator|.
name|isAborted
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAborted
parameter_list|()
block|{
return|return
name|this
operator|.
name|isAborted
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
name|String
name|why
parameter_list|)
block|{
name|this
operator|.
name|isAborted
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|this
operator|.
name|isAborted
return|;
block|}
annotation|@
name|Override
specifier|public
name|ChoreService
name|getChoreService
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|ClusterConnection
name|getClusterConnection
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|FileSystem
name|getFileSystem
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStopping
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|static
class|class
name|DummyWALActionsListener
extends|extends
name|WALActionsListener
operator|.
name|Base
block|{
annotation|@
name|Override
specifier|public
name|void
name|visitLogEntryBeforeWrite
parameter_list|(
name|WALKey
name|logKey
parameter_list|,
name|WALEdit
name|logEdit
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|logKey
operator|.
name|getTablename
argument_list|()
operator|.
name|getNameAsString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"sleep"
argument_list|)
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|logKey
operator|.
name|getTablename
argument_list|()
operator|.
name|getNameAsString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"DamagedWALException"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DamagedWALException
argument_list|(
literal|"Failed appending"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * @return A region on which you must call    *         {@link HBaseTestingUtility#closeRegionAndWAL(HRegion)} when done.    */
specifier|public
specifier|static
name|HRegion
name|initHRegion
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|byte
index|[]
name|startKey
parameter_list|,
name|byte
index|[]
name|stopKey
parameter_list|,
name|WAL
name|wal
parameter_list|)
throws|throws
name|IOException
block|{
name|ChunkCreator
operator|.
name|initialize
argument_list|(
name|MemStoreLABImpl
operator|.
name|CHUNK_SIZE_DEFAULT
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|TEST_UTIL
operator|.
name|createLocalHRegion
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|stopKey
argument_list|,
literal|false
argument_list|,
name|Durability
operator|.
name|SYNC_WAL
argument_list|,
name|wal
argument_list|,
name|COLUMN_FAMILY_BYTES
argument_list|)
return|;
block|}
block|}
end_class

end_unit

