begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|compress
operator|.
name|Compression
operator|.
name|Algorithm
operator|.
name|GZ
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|compress
operator|.
name|Compression
operator|.
name|Algorithm
operator|.
name|NONE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValueUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|fs
operator|.
name|HFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|FSDataInputStreamWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|compress
operator|.
name|Compression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|HFileBlockDefaultEncodingContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|HFileBlockEncodingContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFileBlock
operator|.
name|BlockWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|IOTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|SmallTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ChecksumType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|Compressor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
operator|.
name|Parameters
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * This class has unit tests to prove that older versions of  * HFiles (without checksums) are compatible with current readers.  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
block|{
name|IOTests
operator|.
name|class
block|,
name|SmallTests
operator|.
name|class
block|}
argument_list|)
annotation|@
name|RunWith
argument_list|(
name|Parameterized
operator|.
name|class
argument_list|)
specifier|public
class|class
name|TestHFileBlockCompatibility
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestHFileBlockCompatibility
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Compression
operator|.
name|Algorithm
index|[]
name|COMPRESSION_ALGORITHMS
init|=
block|{
name|NONE
block|,
name|GZ
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|HBaseTestingUtility
name|TEST_UTIL
init|=
operator|new
name|HBaseTestingUtility
argument_list|()
decl_stmt|;
specifier|private
name|HFileSystem
name|fs
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|includesMemstoreTS
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|includesTag
decl_stmt|;
specifier|public
name|TestHFileBlockCompatibility
parameter_list|(
name|boolean
name|includesMemstoreTS
parameter_list|,
name|boolean
name|includesTag
parameter_list|)
block|{
name|this
operator|.
name|includesMemstoreTS
operator|=
name|includesMemstoreTS
expr_stmt|;
name|this
operator|.
name|includesTag
operator|=
name|includesTag
expr_stmt|;
block|}
annotation|@
name|Parameters
specifier|public
specifier|static
name|Collection
argument_list|<
name|Object
index|[]
argument_list|>
name|parameters
parameter_list|()
block|{
return|return
name|HBaseTestingUtility
operator|.
name|MEMSTORETS_TAGS_PARAMETRIZED
return|;
block|}
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|IOException
block|{
name|fs
operator|=
operator|(
name|HFileSystem
operator|)
name|HFileSystem
operator|.
name|get
argument_list|(
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|byte
index|[]
name|createTestV1Block
parameter_list|(
name|Compression
operator|.
name|Algorithm
name|algo
parameter_list|)
throws|throws
name|IOException
block|{
name|Compressor
name|compressor
init|=
name|algo
operator|.
name|getCompressor
argument_list|()
decl_stmt|;
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|OutputStream
name|os
init|=
name|algo
operator|.
name|createCompressionStream
argument_list|(
name|baos
argument_list|,
name|compressor
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|DataOutputStream
name|dos
init|=
operator|new
name|DataOutputStream
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|BlockType
operator|.
name|META
operator|.
name|write
argument_list|(
name|dos
argument_list|)
expr_stmt|;
comment|// Let's make this a meta block.
name|TestHFileBlock
operator|.
name|writeTestBlockContents
argument_list|(
name|dos
argument_list|)
expr_stmt|;
name|dos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|algo
operator|.
name|returnCompressor
argument_list|(
name|compressor
argument_list|)
expr_stmt|;
return|return
name|baos
operator|.
name|toByteArray
argument_list|()
return|;
block|}
specifier|private
name|Writer
name|createTestV2Block
parameter_list|(
name|Compression
operator|.
name|Algorithm
name|algo
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BlockType
name|blockType
init|=
name|BlockType
operator|.
name|DATA
decl_stmt|;
name|Writer
name|hbw
init|=
operator|new
name|Writer
argument_list|(
name|algo
argument_list|,
literal|null
argument_list|,
name|includesMemstoreTS
argument_list|,
name|includesTag
argument_list|)
decl_stmt|;
name|DataOutputStream
name|dos
init|=
name|hbw
operator|.
name|startWriting
argument_list|(
name|blockType
argument_list|)
decl_stmt|;
name|TestHFileBlock
operator|.
name|writeTestBlockContents
argument_list|(
name|dos
argument_list|)
expr_stmt|;
comment|// make sure the block is ready by calling hbw.getHeaderAndData()
name|hbw
operator|.
name|getHeaderAndData
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|1000
operator|*
literal|4
argument_list|,
name|hbw
operator|.
name|getUncompressedSizeWithoutHeader
argument_list|()
argument_list|)
expr_stmt|;
name|hbw
operator|.
name|releaseCompressor
argument_list|()
expr_stmt|;
return|return
name|hbw
return|;
block|}
specifier|private
name|String
name|createTestBlockStr
parameter_list|(
name|Compression
operator|.
name|Algorithm
name|algo
parameter_list|,
name|int
name|correctLength
parameter_list|)
throws|throws
name|IOException
block|{
name|Writer
name|hbw
init|=
name|createTestV2Block
argument_list|(
name|algo
argument_list|)
decl_stmt|;
name|byte
index|[]
name|testV2Block
init|=
name|hbw
operator|.
name|getHeaderAndData
argument_list|()
decl_stmt|;
name|int
name|osOffset
init|=
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE_NO_CHECKSUM
operator|+
literal|9
decl_stmt|;
if|if
condition|(
name|testV2Block
operator|.
name|length
operator|==
name|correctLength
condition|)
block|{
comment|// Force-set the "OS" field of the gzip header to 3 (Unix) to avoid
comment|// variations across operating systems.
comment|// See http://www.gzip.org/zlib/rfc-gzip.html for gzip format.
name|testV2Block
index|[
name|osOffset
index|]
operator|=
literal|3
expr_stmt|;
block|}
return|return
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|testV2Block
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNoCompression
parameter_list|()
throws|throws
name|IOException
block|{
name|assertEquals
argument_list|(
literal|4000
argument_list|,
name|createTestV2Block
argument_list|(
name|NONE
argument_list|)
operator|.
name|getBlockForCaching
argument_list|()
operator|.
name|getUncompressedSizeWithoutHeader
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGzipCompression
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|String
name|correctTestBlockStr
init|=
literal|"DATABLK*\\x00\\x00\\x00:\\x00\\x00\\x0F\\xA0\\xFF\\xFF\\xFF\\xFF"
operator|+
literal|"\\xFF\\xFF\\xFF\\xFF"
comment|// gzip-compressed block: http://www.gzip.org/zlib/rfc-gzip.html
operator|+
literal|"\\x1F\\x8B"
comment|// gzip magic signature
operator|+
literal|"\\x08"
comment|// Compression method: 8 = "deflate"
operator|+
literal|"\\x00"
comment|// Flags
operator|+
literal|"\\x00\\x00\\x00\\x00"
comment|// mtime
operator|+
literal|"\\x00"
comment|// XFL (extra flags)
comment|// OS (0 = FAT filesystems, 3 = Unix). However, this field
comment|// sometimes gets set to 0 on Linux and Mac, so we reset it to 3.
operator|+
literal|"\\x03"
operator|+
literal|"\\xED\\xC3\\xC1\\x11\\x00 \\x08\\xC00DD\\xDD\\x7Fa"
operator|+
literal|"\\xD6\\xE8\\xA3\\xB9K\\x84`\\x96Q\\xD3\\xA8\\xDB\\xA8e\\xD4c"
operator|+
literal|"\\xD46\\xEA5\\xEA3\\xEA7\\xE7\\x00LI\\x5Cs\\xA0\\x0F\\x00\\x00"
decl_stmt|;
specifier|final
name|int
name|correctGzipBlockLength
init|=
literal|82
decl_stmt|;
name|String
name|returnedStr
init|=
name|createTestBlockStr
argument_list|(
name|GZ
argument_list|,
name|correctGzipBlockLength
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|correctTestBlockStr
argument_list|,
name|returnedStr
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReaderV2
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|includesTag
condition|)
block|{
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
literal|"hfile.format.version"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Compression
operator|.
name|Algorithm
name|algo
range|:
name|COMPRESSION_ALGORITHMS
control|)
block|{
for|for
control|(
name|boolean
name|pread
range|:
operator|new
name|boolean
index|[]
block|{
literal|false
block|,
literal|true
block|}
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"testReaderV2: Compression algorithm: "
operator|+
name|algo
operator|+
literal|", pread="
operator|+
name|pread
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|TEST_UTIL
operator|.
name|getDataTestDir
argument_list|()
argument_list|,
literal|"blocks_v2_"
operator|+
name|algo
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|os
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Writer
name|hbw
init|=
operator|new
name|Writer
argument_list|(
name|algo
argument_list|,
literal|null
argument_list|,
name|includesMemstoreTS
argument_list|,
name|includesTag
argument_list|)
decl_stmt|;
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|blockId
init|=
literal|0
init|;
name|blockId
operator|<
literal|2
condition|;
operator|++
name|blockId
control|)
block|{
name|DataOutputStream
name|dos
init|=
name|hbw
operator|.
name|startWriting
argument_list|(
name|BlockType
operator|.
name|DATA
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|1234
condition|;
operator|++
name|i
control|)
name|dos
operator|.
name|writeInt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|hbw
operator|.
name|writeHeaderAndData
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|totalSize
operator|+=
name|hbw
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
expr_stmt|;
block|}
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
name|FSDataInputStream
name|is
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|HFileContext
name|meta
init|=
operator|new
name|HFileContextBuilder
argument_list|()
operator|.
name|withHBaseCheckSum
argument_list|(
literal|false
argument_list|)
operator|.
name|withIncludesMvcc
argument_list|(
name|includesMemstoreTS
argument_list|)
operator|.
name|withIncludesTags
argument_list|(
name|includesTag
argument_list|)
operator|.
name|withCompression
argument_list|(
name|algo
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HFileBlock
operator|.
name|FSReader
name|hbr
init|=
operator|new
name|HFileBlock
operator|.
name|FSReaderV2
argument_list|(
operator|new
name|FSDataInputStreamWrapper
argument_list|(
name|is
argument_list|)
argument_list|,
name|totalSize
argument_list|,
name|fs
argument_list|,
name|path
argument_list|,
name|meta
argument_list|)
decl_stmt|;
name|HFileBlock
name|b
init|=
name|hbr
operator|.
name|readBlockData
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|pread
argument_list|)
decl_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
name|b
operator|.
name|sanityCheck
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|4936
argument_list|,
name|b
operator|.
name|getUncompressedSizeWithoutHeader
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|algo
operator|==
name|GZ
condition|?
literal|2173
else|:
literal|4936
argument_list|,
name|b
operator|.
name|getOnDiskSizeWithoutHeader
argument_list|()
operator|-
name|b
operator|.
name|totalChecksumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|HFileBlock
name|expected
init|=
name|b
decl_stmt|;
if|if
condition|(
name|algo
operator|==
name|GZ
condition|)
block|{
name|is
operator|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|hbr
operator|=
operator|new
name|HFileBlock
operator|.
name|FSReaderV2
argument_list|(
operator|new
name|FSDataInputStreamWrapper
argument_list|(
name|is
argument_list|)
argument_list|,
name|totalSize
argument_list|,
name|fs
argument_list|,
name|path
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|b
operator|=
name|hbr
operator|.
name|readBlockData
argument_list|(
literal|0
argument_list|,
literal|2173
operator|+
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE_NO_CHECKSUM
operator|+
name|b
operator|.
name|totalChecksumBytes
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|pread
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|int
name|wrongCompressedSize
init|=
literal|2172
decl_stmt|;
try|try
block|{
name|b
operator|=
name|hbr
operator|.
name|readBlockData
argument_list|(
literal|0
argument_list|,
name|wrongCompressedSize
operator|+
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE_NO_CHECKSUM
argument_list|,
operator|-
literal|1
argument_list|,
name|pread
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Exception expected"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|String
name|expectedPrefix
init|=
literal|"On-disk size without header provided is "
operator|+
name|wrongCompressedSize
operator|+
literal|", but block header contains "
operator|+
name|b
operator|.
name|getOnDiskSizeWithoutHeader
argument_list|()
operator|+
literal|"."
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Invalid exception message: '"
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
operator|+
literal|"'.\nMessage is expected to start with: '"
operator|+
name|expectedPrefix
operator|+
literal|"'"
argument_list|,
name|ex
operator|.
name|getMessage
argument_list|()
operator|.
name|startsWith
argument_list|(
name|expectedPrefix
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Test encoding/decoding data blocks.    * @throws IOException a bug or a problem with temporary files.    */
annotation|@
name|Test
specifier|public
name|void
name|testDataBlockEncoding
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|includesTag
condition|)
block|{
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
literal|"hfile.format.version"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|numBlocks
init|=
literal|5
decl_stmt|;
for|for
control|(
name|Compression
operator|.
name|Algorithm
name|algo
range|:
name|COMPRESSION_ALGORITHMS
control|)
block|{
for|for
control|(
name|boolean
name|pread
range|:
operator|new
name|boolean
index|[]
block|{
literal|false
block|,
literal|true
block|}
control|)
block|{
for|for
control|(
name|DataBlockEncoding
name|encoding
range|:
name|DataBlockEncoding
operator|.
name|values
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"testDataBlockEncoding algo "
operator|+
name|algo
operator|+
literal|" pread = "
operator|+
name|pread
operator|+
literal|" encoding "
operator|+
name|encoding
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|TEST_UTIL
operator|.
name|getDataTestDir
argument_list|()
argument_list|,
literal|"blocks_v2_"
operator|+
name|algo
operator|+
literal|"_"
operator|+
name|encoding
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|os
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|HFileDataBlockEncoder
name|dataBlockEncoder
init|=
operator|(
name|encoding
operator|!=
name|DataBlockEncoding
operator|.
name|NONE
operator|)
condition|?
operator|new
name|HFileDataBlockEncoderImpl
argument_list|(
name|encoding
argument_list|)
else|:
name|NoOpDataBlockEncoder
operator|.
name|INSTANCE
decl_stmt|;
name|TestHFileBlockCompatibility
operator|.
name|Writer
name|hbw
init|=
operator|new
name|TestHFileBlockCompatibility
operator|.
name|Writer
argument_list|(
name|algo
argument_list|,
name|dataBlockEncoder
argument_list|,
name|includesMemstoreTS
argument_list|,
name|includesTag
argument_list|)
decl_stmt|;
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|encodedSizes
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|encodedBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|ByteBuffer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|blockId
init|=
literal|0
init|;
name|blockId
operator|<
name|numBlocks
condition|;
operator|++
name|blockId
control|)
block|{
name|hbw
operator|.
name|startWriting
argument_list|(
name|BlockType
operator|.
name|DATA
argument_list|)
expr_stmt|;
name|TestHFileBlock
operator|.
name|writeTestKeyValues
argument_list|(
name|hbw
argument_list|,
name|blockId
argument_list|,
name|pread
argument_list|,
name|includesTag
argument_list|)
expr_stmt|;
name|hbw
operator|.
name|writeHeaderAndData
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|int
name|headerLen
init|=
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE_NO_CHECKSUM
decl_stmt|;
name|byte
index|[]
name|encodedResultWithHeader
init|=
name|hbw
operator|.
name|getUncompressedDataWithHeader
argument_list|()
decl_stmt|;
specifier|final
name|int
name|encodedSize
init|=
name|encodedResultWithHeader
operator|.
name|length
operator|-
name|headerLen
decl_stmt|;
if|if
condition|(
name|encoding
operator|!=
name|DataBlockEncoding
operator|.
name|NONE
condition|)
block|{
comment|// We need to account for the two-byte encoding algorithm ID that
comment|// comes after the 24-byte block header but before encoded KVs.
name|headerLen
operator|+=
name|DataBlockEncoding
operator|.
name|ID_SIZE
expr_stmt|;
block|}
name|byte
index|[]
name|encodedDataSection
init|=
operator|new
name|byte
index|[
name|encodedResultWithHeader
operator|.
name|length
operator|-
name|headerLen
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|encodedResultWithHeader
argument_list|,
name|headerLen
argument_list|,
name|encodedDataSection
argument_list|,
literal|0
argument_list|,
name|encodedDataSection
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|ByteBuffer
name|encodedBuf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|encodedDataSection
argument_list|)
decl_stmt|;
name|encodedSizes
operator|.
name|add
argument_list|(
name|encodedSize
argument_list|)
expr_stmt|;
name|encodedBlocks
operator|.
name|add
argument_list|(
name|encodedBuf
argument_list|)
expr_stmt|;
name|totalSize
operator|+=
name|hbw
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
expr_stmt|;
block|}
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
name|FSDataInputStream
name|is
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|HFileContext
name|meta
init|=
operator|new
name|HFileContextBuilder
argument_list|()
operator|.
name|withHBaseCheckSum
argument_list|(
literal|false
argument_list|)
operator|.
name|withIncludesMvcc
argument_list|(
name|includesMemstoreTS
argument_list|)
operator|.
name|withIncludesTags
argument_list|(
name|includesTag
argument_list|)
operator|.
name|withCompression
argument_list|(
name|algo
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HFileBlock
operator|.
name|FSReaderV2
name|hbr
init|=
operator|new
name|HFileBlock
operator|.
name|FSReaderV2
argument_list|(
operator|new
name|FSDataInputStreamWrapper
argument_list|(
name|is
argument_list|)
argument_list|,
name|totalSize
argument_list|,
name|fs
argument_list|,
name|path
argument_list|,
name|meta
argument_list|)
decl_stmt|;
name|hbr
operator|.
name|setDataBlockEncoder
argument_list|(
name|dataBlockEncoder
argument_list|)
expr_stmt|;
name|hbr
operator|.
name|setIncludesMemstoreTS
argument_list|(
name|includesMemstoreTS
argument_list|)
expr_stmt|;
name|HFileBlock
name|b
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|blockId
init|=
literal|0
init|;
name|blockId
operator|<
name|numBlocks
condition|;
operator|++
name|blockId
control|)
block|{
name|b
operator|=
name|hbr
operator|.
name|readBlockData
argument_list|(
name|pos
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|pread
argument_list|)
expr_stmt|;
name|b
operator|.
name|sanityCheck
argument_list|()
expr_stmt|;
if|if
condition|(
name|meta
operator|.
name|isCompressedOrEncrypted
argument_list|()
condition|)
block|{
name|assertFalse
argument_list|(
name|b
operator|.
name|isUnpacked
argument_list|()
argument_list|)
expr_stmt|;
name|b
operator|=
name|b
operator|.
name|unpack
argument_list|(
name|meta
argument_list|,
name|hbr
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
name|b
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|int
operator|)
name|encodedSizes
operator|.
name|get
argument_list|(
name|blockId
argument_list|)
argument_list|,
name|b
operator|.
name|getUncompressedSizeWithoutHeader
argument_list|()
argument_list|)
expr_stmt|;
name|ByteBuffer
name|actualBuffer
init|=
name|b
operator|.
name|getBufferWithoutHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|encoding
operator|!=
name|DataBlockEncoding
operator|.
name|NONE
condition|)
block|{
comment|// We expect a two-byte big-endian encoding id.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|actualBuffer
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|encoding
operator|.
name|getId
argument_list|()
argument_list|,
name|actualBuffer
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|actualBuffer
operator|.
name|position
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|actualBuffer
operator|=
name|actualBuffer
operator|.
name|slice
argument_list|()
expr_stmt|;
block|}
name|ByteBuffer
name|expectedBuffer
init|=
name|encodedBlocks
operator|.
name|get
argument_list|(
name|blockId
argument_list|)
decl_stmt|;
name|expectedBuffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
comment|// test if content matches, produce nice message
name|TestHFileBlock
operator|.
name|assertBuffersEqual
argument_list|(
name|expectedBuffer
argument_list|,
name|actualBuffer
argument_list|,
name|algo
argument_list|,
name|encoding
argument_list|,
name|pread
argument_list|)
expr_stmt|;
block|}
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * This is the version of the HFileBlock.Writer that is used to    * create V2 blocks with minor version 0. These blocks do not    * have hbase-level checksums. The code is here to test    * backward compatibility. The reason we do not inherit from    * HFileBlock.Writer is because we never ever want to change the code    * in this class but the code in HFileBlock.Writer will continually    * evolve.    */
specifier|public
specifier|static
specifier|final
class|class
name|Writer
extends|extends
name|HFileBlock
operator|.
name|Writer
block|{
comment|// These constants are as they were in minorVersion 0.
specifier|private
specifier|static
specifier|final
name|int
name|HEADER_SIZE
init|=
name|HConstants
operator|.
name|HFILEBLOCK_HEADER_SIZE_NO_CHECKSUM
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|DONT_FILL_HEADER
init|=
name|HFileBlock
operator|.
name|DONT_FILL_HEADER
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|DUMMY_HEADER
init|=
name|HFileBlock
operator|.
name|DUMMY_HEADER_NO_CHECKSUM
decl_stmt|;
specifier|private
enum|enum
name|State
block|{
name|INIT
block|,
name|WRITING
block|,
name|BLOCK_READY
block|}
empty_stmt|;
comment|/** Writer state. Used to ensure the correct usage protocol. */
specifier|private
name|State
name|state
init|=
name|State
operator|.
name|INIT
decl_stmt|;
comment|/** Compression algorithm for all blocks this instance writes. */
specifier|private
specifier|final
name|Compression
operator|.
name|Algorithm
name|compressAlgo
decl_stmt|;
comment|/** Data block encoder used for data blocks */
specifier|private
specifier|final
name|HFileDataBlockEncoder
name|dataBlockEncoder
decl_stmt|;
specifier|private
name|HFileBlockEncodingContext
name|dataBlockEncodingCtx
decl_stmt|;
comment|/** block encoding context for non-data blocks */
specifier|private
name|HFileBlockDefaultEncodingContext
name|defaultBlockEncodingCtx
decl_stmt|;
comment|/**      * The stream we use to accumulate data in uncompressed format for each      * block. We reset this stream at the end of each block and reuse it. The      * header is written as the first {@link #HEADER_SIZE} bytes into this      * stream.      */
specifier|private
name|ByteArrayOutputStream
name|baosInMemory
decl_stmt|;
comment|/** Compressor, which is also reused between consecutive blocks. */
specifier|private
name|Compressor
name|compressor
decl_stmt|;
comment|/**      * Current block type. Set in {@link #startWriting(BlockType)}. Could be      * changed in {@link #encodeDataBlockForDisk()} from {@link BlockType#DATA}      * to {@link BlockType#ENCODED_DATA}.      */
specifier|private
name|BlockType
name|blockType
decl_stmt|;
comment|/**      * A stream that we write uncompressed bytes to, which compresses them and      * writes them to {@link #baosInMemory}.      */
specifier|private
name|DataOutputStream
name|userDataStream
decl_stmt|;
comment|/**      * Bytes to be written to the file system, including the header. Compressed      * if compression is turned on.      */
specifier|private
name|byte
index|[]
name|onDiskBytesWithHeader
decl_stmt|;
comment|/**      * Valid in the READY state. Contains the header and the uncompressed (but      * potentially encoded, if this is a data block) bytes, so the length is      * {@link #uncompressedSizeWithoutHeader} + {@link org.apache.hadoop.hbase.HConstants#HFILEBLOCK_HEADER_SIZE}.      */
specifier|private
name|byte
index|[]
name|uncompressedBytesWithHeader
decl_stmt|;
comment|/**      * Current block's start offset in the {@link HFile}. Set in      * {@link #writeHeaderAndData(FSDataOutputStream)}.      */
specifier|private
name|long
name|startOffset
decl_stmt|;
comment|/**      * Offset of previous block by block type. Updated when the next block is      * started.      */
specifier|private
name|long
index|[]
name|prevOffsetByType
decl_stmt|;
comment|/** The offset of the previous block of the same type */
specifier|private
name|long
name|prevOffset
decl_stmt|;
specifier|private
name|int
name|unencodedDataSizeWritten
decl_stmt|;
specifier|public
name|Writer
parameter_list|(
name|Compression
operator|.
name|Algorithm
name|compressionAlgorithm
parameter_list|,
name|HFileDataBlockEncoder
name|dataBlockEncoder
parameter_list|,
name|boolean
name|includesMemstoreTS
parameter_list|,
name|boolean
name|includesTag
parameter_list|)
block|{
name|this
argument_list|(
name|dataBlockEncoder
argument_list|,
operator|new
name|HFileContextBuilder
argument_list|()
operator|.
name|withHBaseCheckSum
argument_list|(
literal|false
argument_list|)
operator|.
name|withIncludesMvcc
argument_list|(
name|includesMemstoreTS
argument_list|)
operator|.
name|withIncludesTags
argument_list|(
name|includesTag
argument_list|)
operator|.
name|withCompression
argument_list|(
name|compressionAlgorithm
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Writer
parameter_list|(
name|HFileDataBlockEncoder
name|dataBlockEncoder
parameter_list|,
name|HFileContext
name|meta
parameter_list|)
block|{
name|super
argument_list|(
name|dataBlockEncoder
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|compressAlgo
operator|=
name|meta
operator|.
name|getCompression
argument_list|()
operator|==
literal|null
condition|?
name|NONE
else|:
name|meta
operator|.
name|getCompression
argument_list|()
expr_stmt|;
name|this
operator|.
name|dataBlockEncoder
operator|=
name|dataBlockEncoder
operator|!=
literal|null
condition|?
name|dataBlockEncoder
else|:
name|NoOpDataBlockEncoder
operator|.
name|INSTANCE
expr_stmt|;
name|defaultBlockEncodingCtx
operator|=
operator|new
name|HFileBlockDefaultEncodingContext
argument_list|(
literal|null
argument_list|,
name|DUMMY_HEADER
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|dataBlockEncodingCtx
operator|=
name|this
operator|.
name|dataBlockEncoder
operator|.
name|newDataBlockEncodingContext
argument_list|(
name|DUMMY_HEADER
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|baosInMemory
operator|=
operator|new
name|ByteArrayOutputStream
argument_list|()
expr_stmt|;
name|prevOffsetByType
operator|=
operator|new
name|long
index|[
name|BlockType
operator|.
name|values
argument_list|()
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|prevOffsetByType
operator|.
name|length
condition|;
operator|++
name|i
control|)
name|prevOffsetByType
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/**      * Starts writing into the block. The previous block's data is discarded.      *      * @return the stream the user can write their data into      * @throws IOException      */
specifier|public
name|DataOutputStream
name|startWriting
parameter_list|(
name|BlockType
name|newBlockType
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|BLOCK_READY
operator|&&
name|startOffset
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// We had a previous block that was written to a stream at a specific
comment|// offset. Save that offset as the last offset of a block of that type.
name|prevOffsetByType
index|[
name|blockType
operator|.
name|getId
argument_list|()
index|]
operator|=
name|startOffset
expr_stmt|;
block|}
name|startOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|blockType
operator|=
name|newBlockType
expr_stmt|;
name|baosInMemory
operator|.
name|reset
argument_list|()
expr_stmt|;
name|baosInMemory
operator|.
name|write
argument_list|(
name|DUMMY_HEADER
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|WRITING
expr_stmt|;
comment|// We will compress it later in finishBlock()
name|userDataStream
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|baosInMemory
argument_list|)
expr_stmt|;
if|if
condition|(
name|newBlockType
operator|==
name|BlockType
operator|.
name|DATA
condition|)
block|{
name|this
operator|.
name|dataBlockEncoder
operator|.
name|startBlockEncoding
argument_list|(
name|dataBlockEncodingCtx
argument_list|,
name|userDataStream
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|unencodedDataSizeWritten
operator|=
literal|0
expr_stmt|;
return|return
name|userDataStream
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|Cell
name|c
parameter_list|)
throws|throws
name|IOException
block|{
name|KeyValue
name|kv
init|=
name|KeyValueUtil
operator|.
name|ensureKeyValue
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|expectState
argument_list|(
name|State
operator|.
name|WRITING
argument_list|)
expr_stmt|;
name|this
operator|.
name|dataBlockEncoder
operator|.
name|encode
argument_list|(
name|kv
argument_list|,
name|dataBlockEncodingCtx
argument_list|,
name|this
operator|.
name|userDataStream
argument_list|)
expr_stmt|;
name|this
operator|.
name|unencodedDataSizeWritten
operator|+=
name|kv
operator|.
name|getLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|dataBlockEncodingCtx
operator|.
name|getHFileContext
argument_list|()
operator|.
name|isIncludesMvcc
argument_list|()
condition|)
block|{
name|this
operator|.
name|unencodedDataSizeWritten
operator|+=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|kv
operator|.
name|getMvccVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the stream for the user to write to. The block writer takes care      * of handling compression and buffering for caching on write. Can only be      * called in the "writing" state.      *      * @return the data output stream for the user to write to      */
name|DataOutputStream
name|getUserDataStream
parameter_list|()
block|{
name|expectState
argument_list|(
name|State
operator|.
name|WRITING
argument_list|)
expr_stmt|;
return|return
name|userDataStream
return|;
block|}
comment|/**      * Transitions the block writer from the "writing" state to the "block      * ready" state.  Does nothing if a block is already finished.      */
name|void
name|ensureBlockReady
parameter_list|()
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|!=
name|State
operator|.
name|INIT
argument_list|,
literal|"Unexpected state: "
operator|+
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|BLOCK_READY
condition|)
return|return;
comment|// This will set state to BLOCK_READY.
name|finishBlock
argument_list|()
expr_stmt|;
block|}
comment|/**      * An internal method that flushes the compressing stream (if using      * compression), serializes the header, and takes care of the separate      * uncompressed stream for caching on write, if applicable. Sets block      * write state to "block ready".      */
name|void
name|finishBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|DATA
condition|)
block|{
name|this
operator|.
name|dataBlockEncoder
operator|.
name|endBlockEncoding
argument_list|(
name|dataBlockEncodingCtx
argument_list|,
name|userDataStream
argument_list|,
name|baosInMemory
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|blockType
argument_list|)
expr_stmt|;
name|blockType
operator|=
name|dataBlockEncodingCtx
operator|.
name|getBlockType
argument_list|()
expr_stmt|;
block|}
name|userDataStream
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// This does an array copy, so it is safe to cache this byte array.
name|uncompressedBytesWithHeader
operator|=
name|baosInMemory
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
name|prevOffset
operator|=
name|prevOffsetByType
index|[
name|blockType
operator|.
name|getId
argument_list|()
index|]
expr_stmt|;
comment|// We need to set state before we can package the block up for
comment|// cache-on-write. In a way, the block is ready, but not yet encoded or
comment|// compressed.
name|state
operator|=
name|State
operator|.
name|BLOCK_READY
expr_stmt|;
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|DATA
operator|||
name|blockType
operator|==
name|BlockType
operator|.
name|ENCODED_DATA
condition|)
block|{
name|onDiskBytesWithHeader
operator|=
name|dataBlockEncodingCtx
operator|.
name|compressAndEncrypt
argument_list|(
name|uncompressedBytesWithHeader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|onDiskBytesWithHeader
operator|=
name|defaultBlockEncodingCtx
operator|.
name|compressAndEncrypt
argument_list|(
name|uncompressedBytesWithHeader
argument_list|)
expr_stmt|;
block|}
comment|// put the header for on disk bytes
name|putHeader
argument_list|(
name|onDiskBytesWithHeader
argument_list|,
literal|0
argument_list|,
name|onDiskBytesWithHeader
operator|.
name|length
argument_list|,
name|uncompressedBytesWithHeader
operator|.
name|length
argument_list|)
expr_stmt|;
comment|//set the header for the uncompressed bytes (for cache-on-write)
name|putHeader
argument_list|(
name|uncompressedBytesWithHeader
argument_list|,
literal|0
argument_list|,
name|onDiskBytesWithHeader
operator|.
name|length
argument_list|,
name|uncompressedBytesWithHeader
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**      * Put the header into the given byte array at the given offset.      * @param onDiskSize size of the block on disk      * @param uncompressedSize size of the block after decompression (but      *          before optional data block decoding)      */
specifier|private
name|void
name|putHeader
parameter_list|(
name|byte
index|[]
name|dest
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|onDiskSize
parameter_list|,
name|int
name|uncompressedSize
parameter_list|)
block|{
name|offset
operator|=
name|blockType
operator|.
name|put
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|,
name|onDiskSize
operator|-
name|HEADER_SIZE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|,
name|uncompressedSize
operator|-
name|HEADER_SIZE
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|putLong
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|,
name|prevOffset
argument_list|)
expr_stmt|;
block|}
comment|/**      * Similar to {@link #writeHeaderAndData(FSDataOutputStream)}, but records      * the offset of this block so that it can be referenced in the next block      * of the same type.      *      * @param out      * @throws IOException      */
specifier|public
name|void
name|writeHeaderAndData
parameter_list|(
name|FSDataOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|offset
init|=
name|out
operator|.
name|getPos
argument_list|()
decl_stmt|;
if|if
condition|(
name|startOffset
operator|!=
operator|-
literal|1
operator|&&
name|offset
operator|!=
name|startOffset
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"A "
operator|+
name|blockType
operator|+
literal|" block written to a "
operator|+
literal|"stream twice, first at offset "
operator|+
name|startOffset
operator|+
literal|", then at "
operator|+
name|offset
argument_list|)
throw|;
block|}
name|startOffset
operator|=
name|offset
expr_stmt|;
name|writeHeaderAndData
argument_list|(
operator|(
name|DataOutputStream
operator|)
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes the header and the compressed data of this block (or uncompressed      * data when not using compression) into the given stream. Can be called in      * the "writing" state or in the "block ready" state. If called in the      * "writing" state, transitions the writer to the "block ready" state.      *      * @param out the output stream to write the      * @throws IOException      */
specifier|private
name|void
name|writeHeaderAndData
parameter_list|(
name|DataOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureBlockReady
argument_list|()
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|onDiskBytesWithHeader
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the header or the compressed data (or uncompressed data when not      * using compression) as a byte array. Can be called in the "writing" state      * or in the "block ready" state. If called in the "writing" state,      * transitions the writer to the "block ready" state.      *      * @return header and data as they would be stored on disk in a byte array      * @throws IOException      */
specifier|public
name|byte
index|[]
name|getHeaderAndData
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureBlockReady
argument_list|()
expr_stmt|;
return|return
name|onDiskBytesWithHeader
return|;
block|}
comment|/**      * Releases the compressor this writer uses to compress blocks into the      * compressor pool. Needs to be called before the writer is discarded.      */
specifier|public
name|void
name|releaseCompressor
parameter_list|()
block|{
if|if
condition|(
name|compressor
operator|!=
literal|null
condition|)
block|{
name|compressAlgo
operator|.
name|returnCompressor
argument_list|(
name|compressor
argument_list|)
expr_stmt|;
name|compressor
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**      * Returns the on-disk size of the data portion of the block. This is the      * compressed size if compression is enabled. Can only be called in the      * "block ready" state. Header is not compressed, and its size is not      * included in the return value.      *      * @return the on-disk size of the block, not including the header.      */
specifier|public
name|int
name|getOnDiskSizeWithoutHeader
parameter_list|()
block|{
name|expectState
argument_list|(
name|State
operator|.
name|BLOCK_READY
argument_list|)
expr_stmt|;
return|return
name|onDiskBytesWithHeader
operator|.
name|length
operator|-
name|HEADER_SIZE
return|;
block|}
comment|/**      * Returns the on-disk size of the block. Can only be called in the      * "block ready" state.      *      * @return the on-disk size of the block ready to be written, including the      *         header size      */
specifier|public
name|int
name|getOnDiskSizeWithHeader
parameter_list|()
block|{
name|expectState
argument_list|(
name|State
operator|.
name|BLOCK_READY
argument_list|)
expr_stmt|;
return|return
name|onDiskBytesWithHeader
operator|.
name|length
return|;
block|}
comment|/**      * The uncompressed size of the block data. Does not include header size.      */
specifier|public
name|int
name|getUncompressedSizeWithoutHeader
parameter_list|()
block|{
name|expectState
argument_list|(
name|State
operator|.
name|BLOCK_READY
argument_list|)
expr_stmt|;
return|return
name|uncompressedBytesWithHeader
operator|.
name|length
operator|-
name|HEADER_SIZE
return|;
block|}
comment|/**      * The uncompressed size of the block data, including header size.      */
specifier|public
name|int
name|getUncompressedSizeWithHeader
parameter_list|()
block|{
name|expectState
argument_list|(
name|State
operator|.
name|BLOCK_READY
argument_list|)
expr_stmt|;
return|return
name|uncompressedBytesWithHeader
operator|.
name|length
return|;
block|}
comment|/** @return true if a block is being written  */
specifier|public
name|boolean
name|isWriting
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|WRITING
return|;
block|}
comment|/**      * Returns the number of bytes written into the current block so far, or      * zero if not writing the block at the moment. Note that this will return      * zero in the "block ready" state as well.      *      * @return the number of bytes written      */
specifier|public
name|int
name|blockSizeWritten
parameter_list|()
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|WRITING
condition|)
return|return
literal|0
return|;
return|return
name|this
operator|.
name|unencodedDataSizeWritten
return|;
block|}
comment|/**      * Returns the header followed by the uncompressed data, even if using      * compression. This is needed for storing uncompressed blocks in the block      * cache. Can be called in the "writing" state or the "block ready" state.      *      * @return uncompressed block bytes for caching on write      */
specifier|private
name|byte
index|[]
name|getUncompressedDataWithHeader
parameter_list|()
block|{
name|expectState
argument_list|(
name|State
operator|.
name|BLOCK_READY
argument_list|)
expr_stmt|;
return|return
name|uncompressedBytesWithHeader
return|;
block|}
specifier|private
name|void
name|expectState
parameter_list|(
name|State
name|expectedState
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|expectedState
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Expected state: "
operator|+
name|expectedState
operator|+
literal|", actual state: "
operator|+
name|state
argument_list|)
throw|;
block|}
block|}
comment|/**      * Similar to {@link #getUncompressedBufferWithHeader()} but returns a byte      * buffer.      *      * @return uncompressed block for caching on write in the form of a buffer      */
specifier|public
name|ByteBuffer
name|getUncompressedBufferWithHeader
parameter_list|()
block|{
name|byte
index|[]
name|b
init|=
name|getUncompressedDataWithHeader
argument_list|()
decl_stmt|;
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**      * Takes the given {@link BlockWritable} instance, creates a new block of      * its appropriate type, writes the writable into this block, and flushes      * the block into the output stream. The writer is instructed not to buffer      * uncompressed bytes for cache-on-write.      *      * @param bw the block-writable object to write as a block      * @param out the file system output stream      * @throws IOException      */
specifier|public
name|void
name|writeBlock
parameter_list|(
name|BlockWritable
name|bw
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|bw
operator|.
name|writeToBlock
argument_list|(
name|startWriting
argument_list|(
name|bw
operator|.
name|getBlockType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeHeaderAndData
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new HFileBlock.      */
specifier|public
name|HFileBlock
name|getBlockForCaching
parameter_list|()
block|{
name|HFileContext
name|meta
init|=
operator|new
name|HFileContextBuilder
argument_list|()
operator|.
name|withHBaseCheckSum
argument_list|(
literal|false
argument_list|)
operator|.
name|withChecksumType
argument_list|(
name|ChecksumType
operator|.
name|NULL
argument_list|)
operator|.
name|withBytesPerCheckSum
argument_list|(
literal|0
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
operator|new
name|HFileBlock
argument_list|(
name|blockType
argument_list|,
name|getOnDiskSizeWithoutHeader
argument_list|()
argument_list|,
name|getUncompressedSizeWithoutHeader
argument_list|()
argument_list|,
name|prevOffset
argument_list|,
name|getUncompressedBufferWithHeader
argument_list|()
argument_list|,
name|DONT_FILL_HEADER
argument_list|,
name|startOffset
argument_list|,
name|getOnDiskSizeWithoutHeader
argument_list|()
argument_list|,
name|meta
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

