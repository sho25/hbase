begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|fs
operator|.
name|HFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|compress
operator|.
name|Compression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFileBlockIndex
operator|.
name|BlockIndexChunk
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFileBlockIndex
operator|.
name|BlockIndexReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|IOTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|MediumTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|RunWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|Parameterized
operator|.
name|Parameters
import|;
end_import

begin_class
annotation|@
name|RunWith
argument_list|(
name|Parameterized
operator|.
name|class
argument_list|)
annotation|@
name|Category
argument_list|(
block|{
name|IOTests
operator|.
name|class
block|,
name|MediumTests
operator|.
name|class
block|}
argument_list|)
specifier|public
class|class
name|TestHFileBlockIndex
block|{
annotation|@
name|Parameters
specifier|public
specifier|static
name|Collection
argument_list|<
name|Object
index|[]
argument_list|>
name|compressionAlgorithms
parameter_list|()
block|{
return|return
name|HBaseTestingUtility
operator|.
name|COMPRESSION_ALGORITHMS_PARAMETERIZED
return|;
block|}
specifier|public
name|TestHFileBlockIndex
parameter_list|(
name|Compression
operator|.
name|Algorithm
name|compr
parameter_list|)
block|{
name|this
operator|.
name|compr
operator|=
name|compr
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestHFileBlockIndex
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|NUM_DATA_BLOCKS
init|=
literal|1000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|HBaseTestingUtility
name|TEST_UTIL
init|=
operator|new
name|HBaseTestingUtility
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SMALL_BLOCK_SIZE
init|=
literal|4096
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|NUM_KV
init|=
literal|10000
decl_stmt|;
specifier|private
specifier|static
name|FileSystem
name|fs
decl_stmt|;
specifier|private
name|Path
name|path
decl_stmt|;
specifier|private
name|Random
name|rand
decl_stmt|;
specifier|private
name|long
name|rootIndexOffset
decl_stmt|;
specifier|private
name|int
name|numRootEntries
decl_stmt|;
specifier|private
name|int
name|numLevels
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Compression
operator|.
name|Algorithm
name|compr
decl_stmt|;
specifier|private
name|byte
index|[]
name|firstKeyInFile
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|INDEX_CHUNK_SIZES
init|=
block|{
literal|4096
block|,
literal|512
block|,
literal|384
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|EXPECTED_NUM_LEVELS
init|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|UNCOMPRESSED_INDEX_SIZES
init|=
block|{
literal|19187
block|,
literal|21813
block|,
literal|23086
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|includesMemstoreTS
init|=
literal|true
decl_stmt|;
static|static
block|{
assert|assert
name|INDEX_CHUNK_SIZES
operator|.
name|length
operator|==
name|EXPECTED_NUM_LEVELS
operator|.
name|length
assert|;
assert|assert
name|INDEX_CHUNK_SIZES
operator|.
name|length
operator|==
name|UNCOMPRESSED_INDEX_SIZES
operator|.
name|length
assert|;
block|}
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|IOException
block|{
name|keys
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rand
operator|=
operator|new
name|Random
argument_list|(
literal|2389757
argument_list|)
expr_stmt|;
name|firstKeyInFile
operator|=
literal|null
expr_stmt|;
name|conf
operator|=
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
comment|// This test requires at least HFile format version 2.
name|conf
operator|.
name|setInt
argument_list|(
name|HFile
operator|.
name|FORMAT_VERSION_KEY
argument_list|,
name|HFile
operator|.
name|MAX_FORMAT_VERSION
argument_list|)
expr_stmt|;
name|fs
operator|=
name|HFileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBlockIndex
parameter_list|()
throws|throws
name|IOException
block|{
name|testBlockIndexInternals
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|testBlockIndexInternals
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|clear
parameter_list|()
throws|throws
name|IOException
block|{
name|keys
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rand
operator|=
operator|new
name|Random
argument_list|(
literal|2389757
argument_list|)
expr_stmt|;
name|firstKeyInFile
operator|=
literal|null
expr_stmt|;
name|conf
operator|=
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
comment|// This test requires at least HFile format version 2.
name|conf
operator|.
name|setInt
argument_list|(
name|HFile
operator|.
name|FORMAT_VERSION_KEY
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|fs
operator|=
name|HFileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|testBlockIndexInternals
parameter_list|(
name|boolean
name|useTags
parameter_list|)
throws|throws
name|IOException
block|{
name|path
operator|=
operator|new
name|Path
argument_list|(
name|TEST_UTIL
operator|.
name|getDataTestDir
argument_list|()
argument_list|,
literal|"block_index_"
operator|+
name|compr
operator|+
name|useTags
argument_list|)
expr_stmt|;
name|writeWholeIndex
argument_list|(
name|useTags
argument_list|)
expr_stmt|;
name|readIndex
argument_list|(
name|useTags
argument_list|)
expr_stmt|;
block|}
comment|/**    * A wrapper around a block reader which only caches the results of the last    * operation. Not thread-safe.    */
specifier|private
specifier|static
class|class
name|BlockReaderWrapper
implements|implements
name|HFile
operator|.
name|CachingBlockReader
block|{
specifier|private
name|HFileBlock
operator|.
name|FSReader
name|realReader
decl_stmt|;
specifier|private
name|long
name|prevOffset
decl_stmt|;
specifier|private
name|long
name|prevOnDiskSize
decl_stmt|;
specifier|private
name|boolean
name|prevPread
decl_stmt|;
specifier|private
name|HFileBlock
name|prevBlock
decl_stmt|;
specifier|public
name|int
name|hitCount
init|=
literal|0
decl_stmt|;
specifier|public
name|int
name|missCount
init|=
literal|0
decl_stmt|;
specifier|public
name|BlockReaderWrapper
parameter_list|(
name|HFileBlock
operator|.
name|FSReader
name|realReader
parameter_list|)
block|{
name|this
operator|.
name|realReader
operator|=
name|realReader
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|HFileBlock
name|readBlock
parameter_list|(
name|long
name|offset
parameter_list|,
name|long
name|onDiskSize
parameter_list|,
name|boolean
name|cacheBlock
parameter_list|,
name|boolean
name|pread
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|boolean
name|updateCacheMetrics
parameter_list|,
name|BlockType
name|expectedBlockType
parameter_list|,
name|DataBlockEncoding
name|expectedDataBlockEncoding
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|offset
operator|==
name|prevOffset
operator|&&
name|onDiskSize
operator|==
name|prevOnDiskSize
operator|&&
name|pread
operator|==
name|prevPread
condition|)
block|{
name|hitCount
operator|+=
literal|1
expr_stmt|;
return|return
name|prevBlock
return|;
block|}
name|missCount
operator|+=
literal|1
expr_stmt|;
name|prevBlock
operator|=
name|realReader
operator|.
name|readBlockData
argument_list|(
name|offset
argument_list|,
name|onDiskSize
argument_list|,
operator|-
literal|1
argument_list|,
name|pread
argument_list|)
expr_stmt|;
name|prevOffset
operator|=
name|offset
expr_stmt|;
name|prevOnDiskSize
operator|=
name|onDiskSize
expr_stmt|;
name|prevPread
operator|=
name|pread
expr_stmt|;
return|return
name|prevBlock
return|;
block|}
block|}
specifier|private
name|void
name|readIndex
parameter_list|(
name|boolean
name|useTags
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|fileSize
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Size of "
operator|+
name|path
operator|+
literal|": "
operator|+
name|fileSize
argument_list|)
expr_stmt|;
name|FSDataInputStream
name|istream
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|HFileContext
name|meta
init|=
operator|new
name|HFileContextBuilder
argument_list|()
operator|.
name|withHBaseCheckSum
argument_list|(
literal|true
argument_list|)
operator|.
name|withIncludesMvcc
argument_list|(
name|includesMemstoreTS
argument_list|)
operator|.
name|withIncludesTags
argument_list|(
name|useTags
argument_list|)
operator|.
name|withCompression
argument_list|(
name|compr
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HFileBlock
operator|.
name|FSReader
name|blockReader
init|=
operator|new
name|HFileBlock
operator|.
name|FSReaderImpl
argument_list|(
name|istream
argument_list|,
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|,
name|meta
argument_list|)
decl_stmt|;
name|BlockReaderWrapper
name|brw
init|=
operator|new
name|BlockReaderWrapper
argument_list|(
name|blockReader
argument_list|)
decl_stmt|;
name|HFileBlockIndex
operator|.
name|BlockIndexReader
name|indexReader
init|=
operator|new
name|HFileBlockIndex
operator|.
name|BlockIndexReader
argument_list|(
name|KeyValue
operator|.
name|RAW_COMPARATOR
argument_list|,
name|numLevels
argument_list|,
name|brw
argument_list|)
decl_stmt|;
name|indexReader
operator|.
name|readRootIndex
argument_list|(
name|blockReader
operator|.
name|blockRange
argument_list|(
name|rootIndexOffset
argument_list|,
name|fileSize
argument_list|)
operator|.
name|nextBlockWithBlockType
argument_list|(
name|BlockType
operator|.
name|ROOT_INDEX
argument_list|)
argument_list|,
name|numRootEntries
argument_list|)
expr_stmt|;
name|long
name|prevOffset
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|expectedHitCount
init|=
literal|0
decl_stmt|;
name|int
name|expectedMissCount
init|=
literal|0
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Total number of keys: "
operator|+
name|keys
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|byte
index|[]
name|key
range|:
name|keys
control|)
block|{
name|assertTrue
argument_list|(
name|key
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|indexReader
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|HFileBlock
name|b
init|=
name|indexReader
operator|.
name|seekToDataBlock
argument_list|(
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|KeyValue
operator|.
name|COMPARATOR
operator|.
name|compareFlatKey
argument_list|(
name|key
argument_list|,
name|firstKeyInFile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|assertTrue
argument_list|(
name|b
operator|==
literal|null
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
name|String
name|keyStr
init|=
literal|"key #"
operator|+
name|i
operator|+
literal|", "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"seekToDataBlock failed for "
operator|+
name|keyStr
argument_list|,
name|b
operator|!=
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevOffset
operator|==
name|b
operator|.
name|getOffset
argument_list|()
condition|)
block|{
name|assertEquals
argument_list|(
operator|++
name|expectedHitCount
argument_list|,
name|brw
operator|.
name|hitCount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"First key in a new block: "
operator|+
name|keyStr
operator|+
literal|", block offset: "
operator|+
name|b
operator|.
name|getOffset
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|b
operator|.
name|getOffset
argument_list|()
operator|>
name|prevOffset
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|++
name|expectedMissCount
argument_list|,
name|brw
operator|.
name|missCount
argument_list|)
expr_stmt|;
name|prevOffset
operator|=
name|b
operator|.
name|getOffset
argument_list|()
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
name|istream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|writeWholeIndex
parameter_list|(
name|boolean
name|useTags
parameter_list|)
throws|throws
name|IOException
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|keys
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|HFileContext
name|meta
init|=
operator|new
name|HFileContextBuilder
argument_list|()
operator|.
name|withHBaseCheckSum
argument_list|(
literal|true
argument_list|)
operator|.
name|withIncludesMvcc
argument_list|(
name|includesMemstoreTS
argument_list|)
operator|.
name|withIncludesTags
argument_list|(
name|useTags
argument_list|)
operator|.
name|withCompression
argument_list|(
name|compr
argument_list|)
operator|.
name|withBytesPerCheckSum
argument_list|(
name|HFile
operator|.
name|DEFAULT_BYTES_PER_CHECKSUM
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HFileBlock
operator|.
name|Writer
name|hbw
init|=
operator|new
name|HFileBlock
operator|.
name|Writer
argument_list|(
literal|null
argument_list|,
name|meta
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|outputStream
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|HFileBlockIndex
operator|.
name|BlockIndexWriter
name|biw
init|=
operator|new
name|HFileBlockIndex
operator|.
name|BlockIndexWriter
argument_list|(
name|hbw
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_DATA_BLOCKS
condition|;
operator|++
name|i
control|)
block|{
name|hbw
operator|.
name|startWriting
argument_list|(
name|BlockType
operator|.
name|DATA
argument_list|)
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|rand
operator|.
name|nextInt
argument_list|(
literal|1000
argument_list|)
argument_list|)
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|blockOffset
init|=
name|outputStream
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|hbw
operator|.
name|writeHeaderAndData
argument_list|(
name|outputStream
argument_list|)
expr_stmt|;
name|byte
index|[]
name|firstKey
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|family
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"f"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|qualifier
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"q"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
operator|++
name|j
control|)
block|{
name|byte
index|[]
name|k
init|=
operator|new
name|KeyValue
argument_list|(
name|TestHFileWriterV2
operator|.
name|randomOrderedKey
argument_list|(
name|rand
argument_list|,
name|i
operator|*
literal|16
operator|+
name|j
argument_list|)
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
argument_list|,
name|KeyValue
operator|.
name|Type
operator|.
name|Put
argument_list|)
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|keys
operator|.
name|add
argument_list|(
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|8
condition|)
block|{
name|firstKey
operator|=
name|k
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|firstKey
operator|!=
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstKeyInFile
operator|==
literal|null
condition|)
block|{
name|firstKeyInFile
operator|=
name|firstKey
expr_stmt|;
block|}
name|biw
operator|.
name|addEntry
argument_list|(
name|firstKey
argument_list|,
name|blockOffset
argument_list|,
name|hbw
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
argument_list|)
expr_stmt|;
name|writeInlineBlocks
argument_list|(
name|hbw
argument_list|,
name|outputStream
argument_list|,
name|biw
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|writeInlineBlocks
argument_list|(
name|hbw
argument_list|,
name|outputStream
argument_list|,
name|biw
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|rootIndexOffset
operator|=
name|biw
operator|.
name|writeIndexBlocks
argument_list|(
name|outputStream
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|close
argument_list|()
expr_stmt|;
name|numLevels
operator|=
name|biw
operator|.
name|getNumLevels
argument_list|()
expr_stmt|;
name|numRootEntries
operator|=
name|biw
operator|.
name|getNumRootEntries
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Index written: numLevels="
operator|+
name|numLevels
operator|+
literal|", numRootEntries="
operator|+
name|numRootEntries
operator|+
literal|", rootIndexOffset="
operator|+
name|rootIndexOffset
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|writeInlineBlocks
parameter_list|(
name|HFileBlock
operator|.
name|Writer
name|hbw
parameter_list|,
name|FSDataOutputStream
name|outputStream
parameter_list|,
name|HFileBlockIndex
operator|.
name|BlockIndexWriter
name|biw
parameter_list|,
name|boolean
name|isClosing
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|biw
operator|.
name|shouldWriteBlock
argument_list|(
name|isClosing
argument_list|)
condition|)
block|{
name|long
name|offset
init|=
name|outputStream
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|biw
operator|.
name|writeInlineBlock
argument_list|(
name|hbw
operator|.
name|startWriting
argument_list|(
name|biw
operator|.
name|getInlineBlockType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|hbw
operator|.
name|writeHeaderAndData
argument_list|(
name|outputStream
argument_list|)
expr_stmt|;
name|biw
operator|.
name|blockWritten
argument_list|(
name|offset
argument_list|,
name|hbw
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
argument_list|,
name|hbw
operator|.
name|getUncompressedSizeWithoutHeader
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Wrote an inline index block at "
operator|+
name|offset
operator|+
literal|", size "
operator|+
name|hbw
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|long
name|getDummyFileOffset
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|i
operator|*
literal|185
operator|+
literal|379
return|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|getDummyOnDiskSize
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|i
operator|*
name|i
operator|*
literal|37
operator|+
name|i
operator|*
literal|19
operator|+
literal|13
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSecondaryIndexBinarySearch
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|numTotalKeys
init|=
literal|99
decl_stmt|;
name|assertTrue
argument_list|(
name|numTotalKeys
operator|%
literal|2
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|// Ensure no one made this even.
comment|// We only add odd-index keys into the array that we will binary-search.
name|int
name|numSearchedKeys
init|=
operator|(
name|numTotalKeys
operator|-
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|DataOutputStream
name|dos
init|=
operator|new
name|DataOutputStream
argument_list|(
name|baos
argument_list|)
decl_stmt|;
name|dos
operator|.
name|writeInt
argument_list|(
name|numSearchedKeys
argument_list|)
expr_stmt|;
name|int
name|curAllEntriesSize
init|=
literal|0
decl_stmt|;
name|int
name|numEntriesAdded
init|=
literal|0
decl_stmt|;
comment|// Only odd-index elements of this array are used to keep the secondary
comment|// index entries of the corresponding keys.
name|int
name|secondaryIndexEntries
index|[]
init|=
operator|new
name|int
index|[
name|numTotalKeys
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTotalKeys
condition|;
operator|++
name|i
control|)
block|{
name|byte
index|[]
name|k
init|=
name|TestHFileWriterV2
operator|.
name|randomOrderedKey
argument_list|(
name|rand
argument_list|,
name|i
operator|*
literal|2
argument_list|)
decl_stmt|;
name|KeyValue
name|cell
init|=
operator|new
name|KeyValue
argument_list|(
name|k
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"f"
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"q"
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"val"
argument_list|)
argument_list|)
decl_stmt|;
comment|//KeyValue cell = new KeyValue.KeyOnlyKeyValue(k, 0, k.length);
name|keys
operator|.
name|add
argument_list|(
name|cell
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|msgPrefix
init|=
literal|"Key #"
operator|+
name|i
operator|+
literal|" ("
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|k
argument_list|)
operator|+
literal|"): "
decl_stmt|;
name|StringBuilder
name|padding
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|msgPrefix
operator|.
name|length
argument_list|()
operator|+
name|padding
operator|.
name|length
argument_list|()
operator|<
literal|70
condition|)
name|padding
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|msgPrefix
operator|+=
name|padding
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|2
operator|==
literal|1
condition|)
block|{
name|dos
operator|.
name|writeInt
argument_list|(
name|curAllEntriesSize
argument_list|)
expr_stmt|;
name|secondaryIndexEntries
index|[
name|i
index|]
operator|=
name|curAllEntriesSize
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|msgPrefix
operator|+
literal|"secondary index entry #"
operator|+
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|/
literal|2
operator|)
operator|+
literal|", offset "
operator|+
name|curAllEntriesSize
argument_list|)
expr_stmt|;
name|curAllEntriesSize
operator|+=
name|cell
operator|.
name|getKey
argument_list|()
operator|.
name|length
operator|+
name|HFileBlockIndex
operator|.
name|SECONDARY_INDEX_ENTRY_OVERHEAD
expr_stmt|;
operator|++
name|numEntriesAdded
expr_stmt|;
block|}
else|else
block|{
name|secondaryIndexEntries
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|msgPrefix
operator|+
literal|"not in the searched array"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Make sure the keys are increasing.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
operator|++
name|i
control|)
name|assertTrue
argument_list|(
name|KeyValue
operator|.
name|COMPARATOR
operator|.
name|compare
argument_list|(
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|length
argument_list|)
argument_list|,
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|keys
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|keys
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|.
name|length
argument_list|)
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
name|dos
operator|.
name|writeInt
argument_list|(
name|curAllEntriesSize
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|numSearchedKeys
argument_list|,
name|numEntriesAdded
argument_list|)
expr_stmt|;
name|int
name|secondaryIndexOffset
init|=
name|dos
operator|.
name|size
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Bytes
operator|.
name|SIZEOF_INT
operator|*
operator|(
name|numSearchedKeys
operator|+
literal|2
operator|)
argument_list|,
name|secondaryIndexOffset
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|numTotalKeys
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|assertEquals
argument_list|(
name|dos
operator|.
name|size
argument_list|()
argument_list|,
name|secondaryIndexOffset
operator|+
name|secondaryIndexEntries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|long
name|dummyFileOffset
init|=
name|getDummyFileOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|dummyOnDiskSize
init|=
name|getDummyOnDiskSize
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing file offset="
operator|+
name|dummyFileOffset
operator|+
literal|" and onDiskSize="
operator|+
name|dummyOnDiskSize
operator|+
literal|" at offset "
operator|+
name|dos
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|dos
operator|.
name|writeLong
argument_list|(
name|dummyFileOffset
argument_list|)
expr_stmt|;
name|dos
operator|.
name|writeInt
argument_list|(
name|dummyOnDiskSize
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stored key "
operator|+
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|/
literal|2
operator|)
operator|+
literal|" at offset "
operator|+
name|dos
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|dos
operator|.
name|write
argument_list|(
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dos
operator|.
name|writeInt
argument_list|(
name|curAllEntriesSize
argument_list|)
expr_stmt|;
name|ByteBuffer
name|nonRootIndex
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTotalKeys
condition|;
operator|++
name|i
control|)
block|{
name|byte
index|[]
name|searchKey
init|=
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|byte
index|[]
name|arrayHoldingKey
init|=
operator|new
name|byte
index|[
name|searchKey
operator|.
name|length
operator|+
name|searchKey
operator|.
name|length
operator|/
literal|2
index|]
decl_stmt|;
comment|// To make things a bit more interesting, store the key we are looking
comment|// for at a non-zero offset in a new array.
name|System
operator|.
name|arraycopy
argument_list|(
name|searchKey
argument_list|,
literal|0
argument_list|,
name|arrayHoldingKey
argument_list|,
name|searchKey
operator|.
name|length
operator|/
literal|2
argument_list|,
name|searchKey
operator|.
name|length
argument_list|)
expr_stmt|;
name|KeyValue
operator|.
name|KeyOnlyKeyValue
name|cell
init|=
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|arrayHoldingKey
argument_list|,
name|searchKey
operator|.
name|length
operator|/
literal|2
argument_list|,
name|searchKey
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|searchResult
init|=
name|BlockIndexReader
operator|.
name|binarySearchNonRootIndex
argument_list|(
name|cell
argument_list|,
name|nonRootIndex
argument_list|,
name|KeyValue
operator|.
name|COMPARATOR
argument_list|)
decl_stmt|;
name|String
name|lookupFailureMsg
init|=
literal|"Failed to look up key #"
operator|+
name|i
operator|+
literal|" ("
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|searchKey
argument_list|)
operator|+
literal|")"
decl_stmt|;
name|int
name|expectedResult
decl_stmt|;
name|int
name|referenceItem
decl_stmt|;
if|if
condition|(
name|i
operator|%
literal|2
operator|==
literal|1
condition|)
block|{
comment|// This key is in the array we search as the element (i - 1) / 2. Make
comment|// sure we find it.
name|expectedResult
operator|=
operator|(
name|i
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|referenceItem
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
comment|// This key is not in the array but between two elements on the array,
comment|// in the beginning, or in the end. The result should be the previous
comment|// key in the searched array, or -1 for i = 0.
name|expectedResult
operator|=
name|i
operator|/
literal|2
operator|-
literal|1
expr_stmt|;
name|referenceItem
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|lookupFailureMsg
argument_list|,
name|expectedResult
argument_list|,
name|searchResult
argument_list|)
expr_stmt|;
comment|// Now test we can get the offset and the on-disk-size using a
comment|// higher-level API function.s
name|boolean
name|locateBlockResult
init|=
operator|(
name|BlockIndexReader
operator|.
name|locateNonRootIndexEntry
argument_list|(
name|nonRootIndex
argument_list|,
name|cell
argument_list|,
name|KeyValue
operator|.
name|COMPARATOR
argument_list|)
operator|!=
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|assertFalse
argument_list|(
name|locateBlockResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|locateBlockResult
argument_list|)
expr_stmt|;
name|String
name|errorMsg
init|=
literal|"i="
operator|+
name|i
operator|+
literal|", position="
operator|+
name|nonRootIndex
operator|.
name|position
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|errorMsg
argument_list|,
name|getDummyFileOffset
argument_list|(
name|referenceItem
argument_list|)
argument_list|,
name|nonRootIndex
operator|.
name|getLong
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|errorMsg
argument_list|,
name|getDummyOnDiskSize
argument_list|(
name|referenceItem
argument_list|)
argument_list|,
name|nonRootIndex
operator|.
name|getInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBlockIndexChunk
parameter_list|()
throws|throws
name|IOException
block|{
name|BlockIndexChunk
name|c
init|=
operator|new
name|BlockIndexChunk
argument_list|()
decl_stmt|;
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|int
name|N
init|=
literal|1000
decl_stmt|;
name|int
index|[]
name|numSubEntriesAt
init|=
operator|new
name|int
index|[
name|N
index|]
decl_stmt|;
name|int
name|numSubEntries
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|N
condition|;
operator|++
name|i
control|)
block|{
name|baos
operator|.
name|reset
argument_list|()
expr_stmt|;
name|DataOutputStream
name|dos
init|=
operator|new
name|DataOutputStream
argument_list|(
name|baos
argument_list|)
decl_stmt|;
name|c
operator|.
name|writeNonRoot
argument_list|(
name|dos
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|c
operator|.
name|getNonRootSize
argument_list|()
argument_list|,
name|dos
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|baos
operator|.
name|reset
argument_list|()
expr_stmt|;
name|dos
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|baos
argument_list|)
expr_stmt|;
name|c
operator|.
name|writeRoot
argument_list|(
name|dos
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|c
operator|.
name|getRootSize
argument_list|()
argument_list|,
name|dos
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|k
init|=
name|TestHFileWriterV2
operator|.
name|randomOrderedKey
argument_list|(
name|rand
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|numSubEntries
operator|+=
name|rand
operator|.
name|nextInt
argument_list|(
literal|5
argument_list|)
operator|+
literal|1
expr_stmt|;
name|keys
operator|.
name|add
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|c
operator|.
name|add
argument_list|(
name|k
argument_list|,
name|getDummyFileOffset
argument_list|(
name|i
argument_list|)
argument_list|,
name|getDummyOnDiskSize
argument_list|(
name|i
argument_list|)
argument_list|,
name|numSubEntries
argument_list|)
expr_stmt|;
block|}
comment|// Test the ability to look up the entry that contains a particular
comment|// deeper-level index block's entry ("sub-entry"), assuming a global
comment|// 0-based ordering of sub-entries. This is needed for mid-key calculation.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|N
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
name|i
operator|==
literal|0
condition|?
literal|0
else|:
name|numSubEntriesAt
index|[
name|i
operator|-
literal|1
index|]
init|;
name|j
operator|<
name|numSubEntriesAt
index|[
name|i
index|]
condition|;
operator|++
name|j
control|)
block|{
name|assertEquals
argument_list|(
name|i
argument_list|,
name|c
operator|.
name|getEntryBySubEntry
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the HeapSize calculator is within reason */
annotation|@
name|Test
specifier|public
name|void
name|testHeapSizeForBlockIndex
parameter_list|()
throws|throws
name|IOException
block|{
name|Class
argument_list|<
name|HFileBlockIndex
operator|.
name|BlockIndexReader
argument_list|>
name|cl
init|=
name|HFileBlockIndex
operator|.
name|BlockIndexReader
operator|.
name|class
decl_stmt|;
name|long
name|expected
init|=
name|ClassSize
operator|.
name|estimateBase
argument_list|(
name|cl
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|HFileBlockIndex
operator|.
name|BlockIndexReader
name|bi
init|=
operator|new
name|HFileBlockIndex
operator|.
name|BlockIndexReader
argument_list|(
name|KeyValue
operator|.
name|RAW_COMPARATOR
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|long
name|actual
init|=
name|bi
operator|.
name|heapSize
argument_list|()
decl_stmt|;
comment|// Since the arrays in BlockIndex(byte [][] blockKeys, long [] blockOffsets,
comment|// int [] blockDataSizes) are all null they are not going to show up in the
comment|// HeapSize calculation, so need to remove those array costs from expected.
name|expected
operator|-=
name|ClassSize
operator|.
name|align
argument_list|(
literal|3
operator|*
name|ClassSize
operator|.
name|ARRAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected
operator|!=
name|actual
condition|)
block|{
name|ClassSize
operator|.
name|estimateBase
argument_list|(
name|cl
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Testing block index through the HFile writer/reader APIs. Allows to test    * setting index block size through configuration, intermediate-level index    * blocks, and caching index blocks on write.    *    * @throws IOException    */
annotation|@
name|Test
specifier|public
name|void
name|testHFileWriterAndReader
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|hfilePath
init|=
operator|new
name|Path
argument_list|(
name|TEST_UTIL
operator|.
name|getDataTestDir
argument_list|()
argument_list|,
literal|"hfile_for_block_index"
argument_list|)
decl_stmt|;
name|CacheConfig
name|cacheConf
init|=
operator|new
name|CacheConfig
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|BlockCache
name|blockCache
init|=
name|cacheConf
operator|.
name|getBlockCache
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|testI
init|=
literal|0
init|;
name|testI
operator|<
name|INDEX_CHUNK_SIZES
operator|.
name|length
condition|;
operator|++
name|testI
control|)
block|{
name|int
name|indexBlockSize
init|=
name|INDEX_CHUNK_SIZES
index|[
name|testI
index|]
decl_stmt|;
name|int
name|expectedNumLevels
init|=
name|EXPECTED_NUM_LEVELS
index|[
name|testI
index|]
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Index block size: "
operator|+
name|indexBlockSize
operator|+
literal|", compression: "
operator|+
name|compr
argument_list|)
expr_stmt|;
comment|// Evict all blocks that were cached-on-write by the previous invocation.
name|blockCache
operator|.
name|evictBlocksByHfileName
argument_list|(
name|hfilePath
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|HFileBlockIndex
operator|.
name|MAX_CHUNK_SIZE_KEY
argument_list|,
name|indexBlockSize
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|keyStrSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|byte
index|[]
index|[]
name|keys
init|=
operator|new
name|byte
index|[
name|NUM_KV
index|]
index|[]
decl_stmt|;
name|byte
index|[]
index|[]
name|values
init|=
operator|new
name|byte
index|[
name|NUM_KV
index|]
index|[]
decl_stmt|;
comment|// Write the HFile
block|{
name|HFileContext
name|meta
init|=
operator|new
name|HFileContextBuilder
argument_list|()
operator|.
name|withBlockSize
argument_list|(
name|SMALL_BLOCK_SIZE
argument_list|)
operator|.
name|withCompression
argument_list|(
name|compr
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HFile
operator|.
name|Writer
name|writer
init|=
name|HFile
operator|.
name|getWriterFactory
argument_list|(
name|conf
argument_list|,
name|cacheConf
argument_list|)
operator|.
name|withPath
argument_list|(
name|fs
argument_list|,
name|hfilePath
argument_list|)
operator|.
name|withFileContext
argument_list|(
name|meta
argument_list|)
operator|.
name|create
argument_list|()
decl_stmt|;
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
literal|19231737
argument_list|)
decl_stmt|;
name|byte
index|[]
name|family
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"f"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|qualifier
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"q"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_KV
condition|;
operator|++
name|i
control|)
block|{
name|byte
index|[]
name|row
init|=
name|TestHFileWriterV2
operator|.
name|randomOrderedKey
argument_list|(
name|rand
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|// Key will be interpreted by KeyValue.KEY_COMPARATOR
name|KeyValue
name|kv
init|=
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
argument_list|,
name|TestHFileWriterV2
operator|.
name|randomValue
argument_list|(
name|rand
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|k
init|=
name|kv
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|writer
operator|.
name|append
argument_list|(
name|kv
argument_list|)
expr_stmt|;
name|keys
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
name|values
index|[
name|i
index|]
operator|=
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|kv
argument_list|)
expr_stmt|;
name|keyStrSet
operator|.
name|add
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|assertTrue
argument_list|(
name|KeyValue
operator|.
name|COMPARATOR
operator|.
name|compareFlatKey
argument_list|(
name|keys
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Read the HFile
name|HFile
operator|.
name|Reader
name|reader
init|=
name|HFile
operator|.
name|createReader
argument_list|(
name|fs
argument_list|,
name|hfilePath
argument_list|,
name|cacheConf
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedNumLevels
argument_list|,
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getNumDataIndexLevels
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Bytes
operator|.
name|equals
argument_list|(
name|keys
index|[
literal|0
index|]
argument_list|,
name|reader
operator|.
name|getFirstKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Bytes
operator|.
name|equals
argument_list|(
name|keys
index|[
name|NUM_KV
operator|-
literal|1
index|]
argument_list|,
name|reader
operator|.
name|getLastKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Last key: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|keys
index|[
name|NUM_KV
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|boolean
name|pread
range|:
operator|new
name|boolean
index|[]
block|{
literal|false
block|,
literal|true
block|}
control|)
block|{
name|HFileScanner
name|scanner
init|=
name|reader
operator|.
name|getScanner
argument_list|(
literal|true
argument_list|,
name|pread
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_KV
condition|;
operator|++
name|i
control|)
block|{
name|checkSeekTo
argument_list|(
name|keys
argument_list|,
name|scanner
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|checkKeyValue
argument_list|(
literal|"i="
operator|+
name|i
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|scanner
operator|.
name|getKey
argument_list|()
argument_list|,
name|scanner
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|scanner
operator|.
name|seekTo
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|NUM_KV
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|checkSeekTo
argument_list|(
name|keys
argument_list|,
name|scanner
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|checkKeyValue
argument_list|(
literal|"i="
operator|+
name|i
argument_list|,
name|keys
index|[
name|i
index|]
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|scanner
operator|.
name|getKey
argument_list|()
argument_list|,
name|scanner
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Manually compute the mid-key and validate it.
name|HFileReaderV2
name|reader2
init|=
operator|(
name|HFileReaderV2
operator|)
name|reader
decl_stmt|;
name|HFileBlock
operator|.
name|FSReader
name|fsReader
init|=
name|reader2
operator|.
name|getUncachedBlockReader
argument_list|()
decl_stmt|;
name|HFileBlock
operator|.
name|BlockIterator
name|iter
init|=
name|fsReader
operator|.
name|blockRange
argument_list|(
literal|0
argument_list|,
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getLoadOnOpenDataOffset
argument_list|()
argument_list|)
decl_stmt|;
name|HFileBlock
name|block
decl_stmt|;
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|blockKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|block
operator|=
name|iter
operator|.
name|nextBlock
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|block
operator|.
name|getBlockType
argument_list|()
operator|!=
name|BlockType
operator|.
name|LEAF_INDEX
condition|)
return|return;
name|ByteBuffer
name|b
init|=
name|block
operator|.
name|getBufferReadOnly
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|b
operator|.
name|getInt
argument_list|()
decl_stmt|;
comment|// One int for the number of items, and n + 1 for the secondary index.
name|int
name|entriesOffset
init|=
name|Bytes
operator|.
name|SIZEOF_INT
operator|*
operator|(
name|n
operator|+
literal|2
operator|)
decl_stmt|;
comment|// Get all the keys from the leaf index block. S
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|int
name|keyRelOffset
init|=
name|b
operator|.
name|getInt
argument_list|(
name|Bytes
operator|.
name|SIZEOF_INT
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
name|int
name|nextKeyRelOffset
init|=
name|b
operator|.
name|getInt
argument_list|(
name|Bytes
operator|.
name|SIZEOF_INT
operator|*
operator|(
name|i
operator|+
literal|2
operator|)
argument_list|)
decl_stmt|;
name|int
name|keyLen
init|=
name|nextKeyRelOffset
operator|-
name|keyRelOffset
decl_stmt|;
name|int
name|keyOffset
init|=
name|b
operator|.
name|arrayOffset
argument_list|()
operator|+
name|entriesOffset
operator|+
name|keyRelOffset
operator|+
name|HFileBlockIndex
operator|.
name|SECONDARY_INDEX_ENTRY_OVERHEAD
decl_stmt|;
name|byte
index|[]
name|blockKey
init|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|b
operator|.
name|array
argument_list|()
argument_list|,
name|keyOffset
argument_list|,
name|keyOffset
operator|+
name|keyLen
argument_list|)
decl_stmt|;
name|String
name|blockKeyStr
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|blockKey
argument_list|)
decl_stmt|;
name|blockKeys
operator|.
name|add
argument_list|(
name|blockKey
argument_list|)
expr_stmt|;
comment|// If the first key of the block is not among the keys written, we
comment|// are not parsing the non-root index block format correctly.
name|assertTrue
argument_list|(
literal|"Invalid block key from leaf-level block: "
operator|+
name|blockKeyStr
argument_list|,
name|keyStrSet
operator|.
name|contains
argument_list|(
name|blockKeyStr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Validate the mid-key.
name|assertEquals
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|blockKeys
operator|.
name|get
argument_list|(
operator|(
name|blockKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
operator|/
literal|2
argument_list|)
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|reader
operator|.
name|midkey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|UNCOMPRESSED_INDEX_SIZES
index|[
name|testI
index|]
argument_list|,
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getUncompressedDataIndexSize
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|reader2
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkSeekTo
parameter_list|(
name|byte
index|[]
index|[]
name|keys
parameter_list|,
name|HFileScanner
name|scanner
parameter_list|,
name|int
name|i
parameter_list|)
throws|throws
name|IOException
block|{
name|assertEquals
argument_list|(
literal|"Failed to seek to key #"
operator|+
name|i
operator|+
literal|" ("
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
operator|+
literal|")"
argument_list|,
literal|0
argument_list|,
name|scanner
operator|.
name|seekTo
argument_list|(
name|KeyValue
operator|.
name|createKeyValueFromKey
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|assertArrayEqualsBuffer
parameter_list|(
name|String
name|msgPrefix
parameter_list|,
name|byte
index|[]
name|arr
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|msgPrefix
operator|+
literal|": expected "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|arr
argument_list|)
operator|+
literal|", actual "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Bytes
operator|.
name|compareTo
argument_list|(
name|arr
argument_list|,
literal|0
argument_list|,
name|arr
operator|.
name|length
argument_list|,
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|buf
operator|.
name|limit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Check a key/value pair after it was read by the reader */
specifier|private
name|void
name|checkKeyValue
parameter_list|(
name|String
name|msgPrefix
parameter_list|,
name|byte
index|[]
name|expectedKey
parameter_list|,
name|byte
index|[]
name|expectedValue
parameter_list|,
name|ByteBuffer
name|keyRead
parameter_list|,
name|ByteBuffer
name|valueRead
parameter_list|)
block|{
if|if
condition|(
operator|!
name|msgPrefix
operator|.
name|isEmpty
argument_list|()
condition|)
name|msgPrefix
operator|+=
literal|". "
expr_stmt|;
name|assertArrayEqualsBuffer
argument_list|(
name|msgPrefix
operator|+
literal|"Invalid key"
argument_list|,
name|expectedKey
argument_list|,
name|keyRead
argument_list|)
expr_stmt|;
name|assertArrayEqualsBuffer
argument_list|(
name|msgPrefix
operator|+
literal|"Invalid value"
argument_list|,
name|expectedValue
argument_list|,
name|valueRead
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

