begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|exception
operator|.
name|ExceptionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|impl
operator|.
name|Log4JLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CoordinatedStateManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTestConst
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ResultScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ScannerCallable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|FilterBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|ScanRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|ScanResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
operator|.
name|RegionScannerImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|MediumTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WAL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcController
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ServiceException
import|;
end_import

begin_comment
comment|/**  * Here we test to make sure that scans return the expected Results when the server is sending the  * Client heartbeat messages. Heartbeat messages are essentially keep-alive messages (they prevent  * the scanner on the client side from timing out). A heartbeat message is sent from the server to  * the client when the server has exceeded the time limit during the processing of the scan. When  * the time limit is reached, the server will return to the Client whatever Results it has  * accumulated (potentially empty).  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
name|MediumTests
operator|.
name|class
argument_list|)
specifier|public
class|class
name|TestScannerHeartbeatMessages
block|{
specifier|private
specifier|final
specifier|static
name|HBaseTestingUtility
name|TEST_UTIL
init|=
operator|new
name|HBaseTestingUtility
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|Table
name|TABLE
init|=
literal|null
decl_stmt|;
comment|/**    * Table configuration    */
specifier|private
specifier|static
name|TableName
name|TABLE_NAME
init|=
name|TableName
operator|.
name|valueOf
argument_list|(
literal|"testScannerHeartbeatMessagesTable"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|int
name|NUM_ROWS
init|=
literal|5
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
name|ROW
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"testRow"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
index|[]
name|ROWS
init|=
name|HTestConst
operator|.
name|makeNAscii
argument_list|(
name|ROW
argument_list|,
name|NUM_ROWS
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|int
name|NUM_FAMILIES
init|=
literal|3
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
name|FAMILY
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"testFamily"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
index|[]
name|FAMILIES
init|=
name|HTestConst
operator|.
name|makeNAscii
argument_list|(
name|FAMILY
argument_list|,
name|NUM_FAMILIES
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|int
name|NUM_QUALIFIERS
init|=
literal|3
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
name|QUALIFIER
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"testQualifier"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
index|[]
name|QUALIFIERS
init|=
name|HTestConst
operator|.
name|makeNAscii
argument_list|(
name|QUALIFIER
argument_list|,
name|NUM_QUALIFIERS
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|int
name|VALUE_SIZE
init|=
literal|128
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
name|VALUE
init|=
name|Bytes
operator|.
name|createMaxByteArray
argument_list|(
name|VALUE_SIZE
argument_list|)
decl_stmt|;
comment|// Time, in milliseconds, that the client will wait for a response from the server before timing
comment|// out. This value is used server side to determine when it is necessary to send a heartbeat
comment|// message to the client
specifier|private
specifier|static
name|int
name|CLIENT_TIMEOUT
init|=
literal|2000
decl_stmt|;
comment|// The server limits itself to running for half of the CLIENT_TIMEOUT value.
specifier|private
specifier|static
name|int
name|SERVER_TIME_LIMIT
init|=
name|CLIENT_TIMEOUT
operator|/
literal|2
decl_stmt|;
comment|// By default, at most one row's worth of cells will be retrieved before the time limit is reached
specifier|private
specifier|static
name|int
name|DEFAULT_ROW_SLEEP_TIME
init|=
name|SERVER_TIME_LIMIT
operator|/
literal|2
decl_stmt|;
comment|// By default, at most cells for two column families are retrieved before the time limit is
comment|// reached
specifier|private
specifier|static
name|int
name|DEFAULT_CF_SLEEP_TIME
init|=
name|DEFAULT_ROW_SLEEP_TIME
operator|/
name|NUM_FAMILIES
decl_stmt|;
annotation|@
name|BeforeClass
specifier|public
specifier|static
name|void
name|setUpBeforeClass
parameter_list|()
throws|throws
name|Exception
block|{
operator|(
operator|(
name|Log4JLogger
operator|)
name|ScannerCallable
operator|.
name|LOG
operator|)
operator|.
name|getLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|ALL
argument_list|)
expr_stmt|;
operator|(
operator|(
name|Log4JLogger
operator|)
name|HeartbeatRPCServices
operator|.
name|LOG
operator|)
operator|.
name|getLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|ALL
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|TEST_UTIL
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setStrings
argument_list|(
name|HConstants
operator|.
name|REGION_IMPL
argument_list|,
name|HeartbeatHRegion
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setStrings
argument_list|(
name|HConstants
operator|.
name|REGION_SERVER_IMPL
argument_list|,
name|HeartbeatHRegionServer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_SCANNER_TIMEOUT_PERIOD
argument_list|,
name|CLIENT_TIMEOUT
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|HBASE_RPC_TIMEOUT_KEY
argument_list|,
name|CLIENT_TIMEOUT
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_PAUSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Check the timeout condition after every cell
name|conf
operator|.
name|setLong
argument_list|(
name|StoreScanner
operator|.
name|HBASE_CELLS_SCANNED_PER_HEARTBEAT_CHECK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TEST_UTIL
operator|.
name|startMiniCluster
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|TABLE
operator|=
name|createTestTable
argument_list|(
name|TABLE_NAME
argument_list|,
name|ROWS
argument_list|,
name|FAMILIES
argument_list|,
name|QUALIFIERS
argument_list|,
name|VALUE
argument_list|)
expr_stmt|;
block|}
specifier|static
name|Table
name|createTestTable
parameter_list|(
name|TableName
name|name
parameter_list|,
name|byte
index|[]
index|[]
name|rows
parameter_list|,
name|byte
index|[]
index|[]
name|families
parameter_list|,
name|byte
index|[]
index|[]
name|qualifiers
parameter_list|,
name|byte
index|[]
name|cellValue
parameter_list|)
throws|throws
name|IOException
block|{
name|Table
name|ht
init|=
name|TEST_UTIL
operator|.
name|createTable
argument_list|(
name|name
argument_list|,
name|families
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Put
argument_list|>
name|puts
init|=
name|createPuts
argument_list|(
name|rows
argument_list|,
name|families
argument_list|,
name|qualifiers
argument_list|,
name|cellValue
argument_list|)
decl_stmt|;
name|ht
operator|.
name|put
argument_list|(
name|puts
argument_list|)
expr_stmt|;
return|return
name|ht
return|;
block|}
comment|/**    * Make puts to put the input value into each combination of row, family, and qualifier    * @param rows    * @param families    * @param qualifiers    * @param value    * @return    * @throws IOException    */
specifier|static
name|ArrayList
argument_list|<
name|Put
argument_list|>
name|createPuts
parameter_list|(
name|byte
index|[]
index|[]
name|rows
parameter_list|,
name|byte
index|[]
index|[]
name|families
parameter_list|,
name|byte
index|[]
index|[]
name|qualifiers
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|Put
name|put
decl_stmt|;
name|ArrayList
argument_list|<
name|Put
argument_list|>
name|puts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|rows
operator|.
name|length
condition|;
name|row
operator|++
control|)
block|{
name|put
operator|=
operator|new
name|Put
argument_list|(
name|rows
index|[
name|row
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|fam
init|=
literal|0
init|;
name|fam
operator|<
name|families
operator|.
name|length
condition|;
name|fam
operator|++
control|)
block|{
for|for
control|(
name|int
name|qual
init|=
literal|0
init|;
name|qual
operator|<
name|qualifiers
operator|.
name|length
condition|;
name|qual
operator|++
control|)
block|{
name|KeyValue
name|kv
init|=
operator|new
name|KeyValue
argument_list|(
name|rows
index|[
name|row
index|]
argument_list|,
name|families
index|[
name|fam
index|]
argument_list|,
name|qualifiers
index|[
name|qual
index|]
argument_list|,
name|qual
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|put
operator|.
name|add
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
block|}
name|puts
operator|.
name|add
argument_list|(
name|put
argument_list|)
expr_stmt|;
block|}
return|return
name|puts
return|;
block|}
annotation|@
name|AfterClass
specifier|public
specifier|static
name|void
name|tearDownAfterClass
parameter_list|()
throws|throws
name|Exception
block|{
name|TEST_UTIL
operator|.
name|deleteTable
argument_list|(
name|TABLE_NAME
argument_list|)
expr_stmt|;
name|TEST_UTIL
operator|.
name|shutdownMiniCluster
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Before
specifier|public
name|void
name|setupBeforeTest
parameter_list|()
throws|throws
name|Exception
block|{
name|disableSleeping
argument_list|()
expr_stmt|;
block|}
annotation|@
name|After
specifier|public
name|void
name|teardownAfterTest
parameter_list|()
throws|throws
name|Exception
block|{
name|disableSleeping
argument_list|()
expr_stmt|;
block|}
comment|/**    * Test a variety of scan configurations to ensure that they return the expected Results when    * heartbeat messages are necessary. These tests are accumulated under one test case to ensure    * that they don't run in parallel. If the tests ran in parallel, they may conflict with each    * other due to changing static variables    */
annotation|@
name|Test
specifier|public
name|void
name|testScannerHeartbeatMessages
parameter_list|()
throws|throws
name|Exception
block|{
name|testImportanceOfHeartbeats
argument_list|(
name|testHeartbeatBetweenRows
argument_list|()
argument_list|)
expr_stmt|;
name|testImportanceOfHeartbeats
argument_list|(
name|testHeartbeatBetweenColumnFamilies
argument_list|()
argument_list|)
expr_stmt|;
name|testImportanceOfHeartbeats
argument_list|(
name|testHeartbeatWithSparseFilter
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run the test callable when heartbeats are enabled/disabled. We expect all tests to only pass    * when heartbeat messages are enabled (otherwise the test is pointless). When heartbeats are    * disabled, the test should throw an exception.    * @param testCallable    * @throws InterruptedException    */
specifier|public
name|void
name|testImportanceOfHeartbeats
parameter_list|(
name|Callable
argument_list|<
name|Void
argument_list|>
name|testCallable
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|HeartbeatRPCServices
operator|.
name|heartbeatsEnabled
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|testCallable
operator|.
name|call
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Heartbeat messages are enabled, exceptions should NOT be thrown. Exception trace:"
operator|+
name|ExceptionUtils
operator|.
name|getStackTrace
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HeartbeatRPCServices
operator|.
name|heartbeatsEnabled
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|testCallable
operator|.
name|call
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return;
block|}
finally|finally
block|{
name|HeartbeatRPCServices
operator|.
name|heartbeatsEnabled
operator|=
literal|true
expr_stmt|;
block|}
name|fail
argument_list|(
literal|"Heartbeats messages are disabled, an exception should be thrown. If an exception "
operator|+
literal|" is not thrown, the test case is not testing the importance of heartbeat messages"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the case that the time limit for the scan is reached after each full row of cells is    * fetched.    * @throws Exception    */
specifier|public
name|Callable
argument_list|<
name|Void
argument_list|>
name|testHeartbeatBetweenRows
parameter_list|()
throws|throws
name|Exception
block|{
return|return
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Configure the scan so that it can read the entire table in a single RPC. We want to test
comment|// the case where a scan stops on the server side due to a time limit
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|setMaxResultSize
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setCaching
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|testEquivalenceOfScanWithHeartbeats
argument_list|(
name|scan
argument_list|,
name|DEFAULT_ROW_SLEEP_TIME
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
comment|/**    * Test the case that the time limit for scans is reached in between column families    * @throws Exception    */
specifier|public
name|Callable
argument_list|<
name|Void
argument_list|>
name|testHeartbeatBetweenColumnFamilies
parameter_list|()
throws|throws
name|Exception
block|{
return|return
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Configure the scan so that it can read the entire table in a single RPC. We want to test
comment|// the case where a scan stops on the server side due to a time limit
name|Scan
name|baseScan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|baseScan
operator|.
name|setMaxResultSize
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|baseScan
operator|.
name|setCaching
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
comment|// Copy the scan before each test. When a scan object is used by a scanner, some of its
comment|// fields may be changed such as start row
name|Scan
name|scanCopy
init|=
operator|new
name|Scan
argument_list|(
name|baseScan
argument_list|)
decl_stmt|;
name|testEquivalenceOfScanWithHeartbeats
argument_list|(
name|scanCopy
argument_list|,
operator|-
literal|1
argument_list|,
name|DEFAULT_CF_SLEEP_TIME
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|scanCopy
operator|=
operator|new
name|Scan
argument_list|(
name|baseScan
argument_list|)
expr_stmt|;
name|testEquivalenceOfScanWithHeartbeats
argument_list|(
name|scanCopy
argument_list|,
operator|-
literal|1
argument_list|,
name|DEFAULT_CF_SLEEP_TIME
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
specifier|public
specifier|static
class|class
name|SparseFilter
extends|extends
name|FilterBase
block|{
annotation|@
name|Override
specifier|public
name|ReturnCode
name|filterKeyValue
parameter_list|(
name|Cell
name|v
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|SERVER_TIME_LIMIT
operator|+
literal|10
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|v
argument_list|)
argument_list|,
name|ROWS
index|[
name|NUM_ROWS
operator|-
literal|1
index|]
argument_list|)
condition|?
name|ReturnCode
operator|.
name|INCLUDE
else|:
name|ReturnCode
operator|.
name|SKIP
return|;
block|}
specifier|public
specifier|static
name|Filter
name|parseFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|pbBytes
parameter_list|)
block|{
return|return
operator|new
name|SparseFilter
argument_list|()
return|;
block|}
block|}
comment|/**    * Test the case that there is a filter which filters most of cells    * @throws Exception    */
specifier|public
name|Callable
argument_list|<
name|Void
argument_list|>
name|testHeartbeatWithSparseFilter
parameter_list|()
throws|throws
name|Exception
block|{
return|return
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|setMaxResultSize
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setCaching
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setFilter
argument_list|(
operator|new
name|SparseFilter
argument_list|()
argument_list|)
expr_stmt|;
name|ResultScanner
name|scanner
init|=
name|TABLE
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|scanner
operator|.
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|num
operator|++
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
name|scan
operator|=
operator|new
name|Scan
argument_list|()
expr_stmt|;
name|scan
operator|.
name|setMaxResultSize
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setCaching
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setFilter
argument_list|(
operator|new
name|SparseFilter
argument_list|()
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setAllowPartialResults
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|scanner
operator|=
name|TABLE
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|scanner
operator|.
name|next
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|num
operator|++
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|NUM_FAMILIES
operator|*
name|NUM_QUALIFIERS
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
comment|/**    * Test the equivalence of a scan versus the same scan executed when heartbeat messages are    * necessary    * @param scan The scan configuration being tested    * @param rowSleepTime The time to sleep between fetches of row cells    * @param cfSleepTime The time to sleep between fetches of column family cells    * @param sleepBeforeCf set to true when column family sleeps should occur before the cells for    *          that column family are fetched    * @throws Exception    */
specifier|public
name|void
name|testEquivalenceOfScanWithHeartbeats
parameter_list|(
specifier|final
name|Scan
name|scan
parameter_list|,
name|int
name|rowSleepTime
parameter_list|,
name|int
name|cfSleepTime
parameter_list|,
name|boolean
name|sleepBeforeCf
parameter_list|)
throws|throws
name|Exception
block|{
name|disableSleeping
argument_list|()
expr_stmt|;
specifier|final
name|ResultScanner
name|scanner
init|=
name|TABLE
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
specifier|final
name|ResultScanner
name|scannerWithHeartbeats
init|=
name|TABLE
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|Result
name|r1
init|=
literal|null
decl_stmt|;
name|Result
name|r2
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|r1
operator|=
name|scanner
operator|.
name|next
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// Enforce the specified sleep conditions during calls to the heartbeat scanner
name|configureSleepTime
argument_list|(
name|rowSleepTime
argument_list|,
name|cfSleepTime
argument_list|,
name|sleepBeforeCf
argument_list|)
expr_stmt|;
name|r2
operator|=
name|scannerWithHeartbeats
operator|.
name|next
argument_list|()
expr_stmt|;
name|disableSleeping
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|r2
operator|!=
literal|null
argument_list|)
expr_stmt|;
try|try
block|{
name|Result
operator|.
name|compareResults
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|fail
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|scannerWithHeartbeats
operator|.
name|next
argument_list|()
operator|==
literal|null
argument_list|)
expr_stmt|;
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
name|scannerWithHeartbeats
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Helper method for setting the time to sleep between rows and column families. If a sleep time    * is negative then that sleep will be disabled    * @param rowSleepTime    * @param cfSleepTime    */
specifier|private
specifier|static
name|void
name|configureSleepTime
parameter_list|(
name|int
name|rowSleepTime
parameter_list|,
name|int
name|cfSleepTime
parameter_list|,
name|boolean
name|sleepBeforeCf
parameter_list|)
block|{
name|HeartbeatHRegion
operator|.
name|sleepBetweenRows
operator|=
name|rowSleepTime
operator|>
literal|0
expr_stmt|;
name|HeartbeatHRegion
operator|.
name|rowSleepTime
operator|=
name|rowSleepTime
expr_stmt|;
name|HeartbeatHRegion
operator|.
name|sleepBetweenColumnFamilies
operator|=
name|cfSleepTime
operator|>
literal|0
expr_stmt|;
name|HeartbeatHRegion
operator|.
name|columnFamilySleepTime
operator|=
name|cfSleepTime
expr_stmt|;
name|HeartbeatHRegion
operator|.
name|sleepBeforeColumnFamily
operator|=
name|sleepBeforeCf
expr_stmt|;
block|}
comment|/**    * Disable the sleeping mechanism server side.    */
specifier|private
specifier|static
name|void
name|disableSleeping
parameter_list|()
block|{
name|HeartbeatHRegion
operator|.
name|sleepBetweenRows
operator|=
literal|false
expr_stmt|;
name|HeartbeatHRegion
operator|.
name|sleepBetweenColumnFamilies
operator|=
literal|false
expr_stmt|;
block|}
comment|/**    * Custom HRegionServer instance that instantiates {@link HeartbeatRPCServices} in place of    * {@link RSRpcServices} to allow us to toggle support for heartbeat messages    */
specifier|private
specifier|static
class|class
name|HeartbeatHRegionServer
extends|extends
name|HRegionServer
block|{
specifier|public
name|HeartbeatHRegionServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
specifier|public
name|HeartbeatHRegionServer
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|CoordinatedStateManager
name|csm
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|csm
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|RSRpcServices
name|createRpcServices
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|HeartbeatRPCServices
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Custom RSRpcServices instance that allows heartbeat support to be toggled    */
specifier|private
specifier|static
class|class
name|HeartbeatRPCServices
extends|extends
name|RSRpcServices
block|{
specifier|private
specifier|static
name|boolean
name|heartbeatsEnabled
init|=
literal|true
decl_stmt|;
specifier|public
name|HeartbeatRPCServices
parameter_list|(
name|HRegionServer
name|rs
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|ScanResponse
name|scan
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|ScanRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
name|ScanRequest
operator|.
name|Builder
name|builder
init|=
name|ScanRequest
operator|.
name|newBuilder
argument_list|(
name|request
argument_list|)
decl_stmt|;
name|builder
operator|.
name|setClientHandlesHeartbeats
argument_list|(
name|heartbeatsEnabled
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|scan
argument_list|(
name|controller
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Custom HRegion class that instantiates {@link RegionScanner}s with configurable sleep times    * between fetches of row Results and/or column family cells. Useful for emulating an instance    * where the server is taking a long time to process a client's scan request    */
specifier|private
specifier|static
class|class
name|HeartbeatHRegion
extends|extends
name|HRegion
block|{
comment|// Row sleeps occur AFTER each row worth of cells is retrieved.
specifier|private
specifier|static
name|int
name|rowSleepTime
init|=
name|DEFAULT_ROW_SLEEP_TIME
decl_stmt|;
specifier|private
specifier|static
name|boolean
name|sleepBetweenRows
init|=
literal|false
decl_stmt|;
comment|// The sleep for column families can be initiated before or after we fetch the cells for the
comment|// column family. If the sleep occurs BEFORE then the time limits will be reached inside
comment|// StoreScanner while we are fetching individual cells. If the sleep occurs AFTER then the time
comment|// limit will be reached inside RegionScanner after all the cells for a column family have been
comment|// retrieved.
specifier|private
specifier|static
name|boolean
name|sleepBeforeColumnFamily
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
name|int
name|columnFamilySleepTime
init|=
name|DEFAULT_CF_SLEEP_TIME
decl_stmt|;
specifier|private
specifier|static
name|boolean
name|sleepBetweenColumnFamilies
init|=
literal|false
decl_stmt|;
specifier|public
name|HeartbeatHRegion
parameter_list|(
name|Path
name|tableDir
parameter_list|,
name|WAL
name|wal
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|confParam
parameter_list|,
name|HRegionInfo
name|regionInfo
parameter_list|,
name|HTableDescriptor
name|htd
parameter_list|,
name|RegionServerServices
name|rsServices
parameter_list|)
block|{
name|super
argument_list|(
name|tableDir
argument_list|,
name|wal
argument_list|,
name|fs
argument_list|,
name|confParam
argument_list|,
name|regionInfo
argument_list|,
name|htd
argument_list|,
name|rsServices
argument_list|)
expr_stmt|;
block|}
specifier|public
name|HeartbeatHRegion
parameter_list|(
name|HRegionFileSystem
name|fs
parameter_list|,
name|WAL
name|wal
parameter_list|,
name|Configuration
name|confParam
parameter_list|,
name|HTableDescriptor
name|htd
parameter_list|,
name|RegionServerServices
name|rsServices
parameter_list|)
block|{
name|super
argument_list|(
name|fs
argument_list|,
name|wal
argument_list|,
name|confParam
argument_list|,
name|htd
argument_list|,
name|rsServices
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|columnFamilySleep
parameter_list|()
block|{
if|if
condition|(
name|HeartbeatHRegion
operator|.
name|sleepBetweenColumnFamilies
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|HeartbeatHRegion
operator|.
name|columnFamilySleepTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{         }
block|}
block|}
specifier|private
specifier|static
name|void
name|rowSleep
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|HeartbeatHRegion
operator|.
name|sleepBetweenRows
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|HeartbeatHRegion
operator|.
name|rowSleepTime
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{       }
block|}
comment|// Instantiate the custom heartbeat region scanners
annotation|@
name|Override
specifier|protected
name|RegionScanner
name|instantiateRegionScanner
parameter_list|(
name|Scan
name|scan
parameter_list|,
name|List
argument_list|<
name|KeyValueScanner
argument_list|>
name|additionalScanners
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|scan
operator|.
name|isReversed
argument_list|()
condition|)
block|{
if|if
condition|(
name|scan
operator|.
name|getFilter
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|scan
operator|.
name|getFilter
argument_list|()
operator|.
name|setReversed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|HeartbeatReversedRegionScanner
argument_list|(
name|scan
argument_list|,
name|additionalScanners
argument_list|,
name|this
argument_list|)
return|;
block|}
return|return
operator|new
name|HeartbeatRegionScanner
argument_list|(
name|scan
argument_list|,
name|additionalScanners
argument_list|,
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Custom ReversedRegionScanner that can be configured to sleep between retrievals of row Results    * and/or column family cells    */
specifier|private
specifier|static
class|class
name|HeartbeatReversedRegionScanner
extends|extends
name|ReversedRegionScannerImpl
block|{
name|HeartbeatReversedRegionScanner
parameter_list|(
name|Scan
name|scan
parameter_list|,
name|List
argument_list|<
name|KeyValueScanner
argument_list|>
name|additionalScanners
parameter_list|,
name|HRegion
name|region
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|scan
argument_list|,
name|additionalScanners
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|nextRaw
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|outResults
parameter_list|,
name|ScannerContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|moreRows
init|=
name|super
operator|.
name|nextRaw
argument_list|(
name|outResults
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|HeartbeatHRegion
operator|.
name|rowSleep
argument_list|()
expr_stmt|;
return|return
name|moreRows
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|initializeKVHeap
parameter_list|(
name|List
argument_list|<
name|KeyValueScanner
argument_list|>
name|scanners
parameter_list|,
name|List
argument_list|<
name|KeyValueScanner
argument_list|>
name|joinedScanners
parameter_list|,
name|HRegion
name|region
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|storeHeap
operator|=
operator|new
name|HeartbeatReversedKVHeap
argument_list|(
name|scanners
argument_list|,
name|region
operator|.
name|getCellCompartor
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|joinedScanners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|joinedHeap
operator|=
operator|new
name|HeartbeatReversedKVHeap
argument_list|(
name|joinedScanners
argument_list|,
name|region
operator|.
name|getCellCompartor
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Custom RegionScanner that can be configured to sleep between retrievals of row Results and/or    * column family cells    */
specifier|private
specifier|static
class|class
name|HeartbeatRegionScanner
extends|extends
name|RegionScannerImpl
block|{
name|HeartbeatRegionScanner
parameter_list|(
name|Scan
name|scan
parameter_list|,
name|List
argument_list|<
name|KeyValueScanner
argument_list|>
name|additionalScanners
parameter_list|,
name|HRegion
name|region
parameter_list|)
throws|throws
name|IOException
block|{
name|region
operator|.
name|super
argument_list|(
name|scan
argument_list|,
name|additionalScanners
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|nextRaw
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|outResults
parameter_list|,
name|ScannerContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|moreRows
init|=
name|super
operator|.
name|nextRaw
argument_list|(
name|outResults
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|HeartbeatHRegion
operator|.
name|rowSleep
argument_list|()
expr_stmt|;
return|return
name|moreRows
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|initializeKVHeap
parameter_list|(
name|List
argument_list|<
name|KeyValueScanner
argument_list|>
name|scanners
parameter_list|,
name|List
argument_list|<
name|KeyValueScanner
argument_list|>
name|joinedScanners
parameter_list|,
name|HRegion
name|region
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|storeHeap
operator|=
operator|new
name|HeartbeatKVHeap
argument_list|(
name|scanners
argument_list|,
name|region
operator|.
name|getCellCompartor
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|joinedScanners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|joinedHeap
operator|=
operator|new
name|HeartbeatKVHeap
argument_list|(
name|joinedScanners
argument_list|,
name|region
operator|.
name|getCellCompartor
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Custom KV Heap that can be configured to sleep/wait in between retrievals of column family    * cells. Useful for testing    */
specifier|private
specifier|static
specifier|final
class|class
name|HeartbeatKVHeap
extends|extends
name|KeyValueHeap
block|{
specifier|public
name|HeartbeatKVHeap
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|KeyValueScanner
argument_list|>
name|scanners
parameter_list|,
name|CellComparator
name|comparator
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|scanners
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
name|HeartbeatKVHeap
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|KeyValueScanner
argument_list|>
name|scanners
parameter_list|,
name|KVScannerComparator
name|comparator
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|scanners
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|next
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|result
parameter_list|,
name|ScannerContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|HeartbeatHRegion
operator|.
name|sleepBeforeColumnFamily
condition|)
name|HeartbeatHRegion
operator|.
name|columnFamilySleep
argument_list|()
expr_stmt|;
name|boolean
name|moreRows
init|=
name|super
operator|.
name|next
argument_list|(
name|result
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|HeartbeatHRegion
operator|.
name|sleepBeforeColumnFamily
condition|)
name|HeartbeatHRegion
operator|.
name|columnFamilySleep
argument_list|()
expr_stmt|;
return|return
name|moreRows
return|;
block|}
block|}
comment|/**    * Custom reversed KV Heap that can be configured to sleep in between retrievals of column family    * cells.    */
specifier|private
specifier|static
specifier|final
class|class
name|HeartbeatReversedKVHeap
extends|extends
name|ReversedKeyValueHeap
block|{
specifier|public
name|HeartbeatReversedKVHeap
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|KeyValueScanner
argument_list|>
name|scanners
parameter_list|,
name|CellComparator
name|comparator
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|scanners
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|next
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|result
parameter_list|,
name|ScannerContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|HeartbeatHRegion
operator|.
name|sleepBeforeColumnFamily
condition|)
name|HeartbeatHRegion
operator|.
name|columnFamilySleep
argument_list|()
expr_stmt|;
name|boolean
name|moreRows
init|=
name|super
operator|.
name|next
argument_list|(
name|result
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|HeartbeatHRegion
operator|.
name|sleepBeforeColumnFamily
condition|)
name|HeartbeatHRegion
operator|.
name|columnFamilySleep
argument_list|()
expr_stmt|;
return|return
name|moreRows
return|;
block|}
block|}
block|}
end_class

end_unit

