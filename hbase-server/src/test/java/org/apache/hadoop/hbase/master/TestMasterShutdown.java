begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|Duration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseClassTestRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|LocalHBaseCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MiniHBaseCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|StartMiniClusterOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Waiter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|AsyncConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|LargeTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|MasterTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|JVMClusterUtil
operator|.
name|MasterThread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ReadOnlyZKClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|ClassRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections4
operator|.
name|CollectionUtils
import|;
end_import

begin_class
annotation|@
name|Category
argument_list|(
block|{
name|MasterTests
operator|.
name|class
block|,
name|LargeTests
operator|.
name|class
block|}
argument_list|)
specifier|public
class|class
name|TestMasterShutdown
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestMasterShutdown
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|ClassRule
specifier|public
specifier|static
specifier|final
name|HBaseClassTestRule
name|CLASS_RULE
init|=
name|HBaseClassTestRule
operator|.
name|forClass
argument_list|(
name|TestMasterShutdown
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|HBaseTestingUtility
name|htu
decl_stmt|;
annotation|@
name|Before
specifier|public
name|void
name|shutdownCluster
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|htu
operator|!=
literal|null
condition|)
block|{
comment|// an extra check in case the test cluster was not terminated after HBaseClassTestRule's
comment|// Timeout interrupted the test thread.
name|LOG
operator|.
name|warn
argument_list|(
literal|"found non-null TestingUtility -- previous test did not terminate cleanly."
argument_list|)
expr_stmt|;
name|htu
operator|.
name|shutdownMiniCluster
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Simple test of shutdown.    *<p>    * Starts with three masters.  Tells the active master to shutdown the cluster.    * Verifies that all masters are properly shutdown.    */
annotation|@
name|Test
specifier|public
name|void
name|testMasterShutdown
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Create config to use for this cluster
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
comment|// Start the cluster
try|try
block|{
name|htu
operator|=
operator|new
name|HBaseTestingUtility
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|StartMiniClusterOption
name|option
init|=
name|StartMiniClusterOption
operator|.
name|builder
argument_list|()
operator|.
name|numMasters
argument_list|(
literal|3
argument_list|)
operator|.
name|numRegionServers
argument_list|(
literal|3
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|3
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|MiniHBaseCluster
name|cluster
init|=
name|htu
operator|.
name|startMiniCluster
argument_list|(
name|option
argument_list|)
decl_stmt|;
comment|// wait for all master thread to spawn and start their run loop.
specifier|final
name|long
name|thirtySeconds
init|=
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMillis
argument_list|(
literal|30
argument_list|)
decl_stmt|;
specifier|final
name|long
name|oneSecond
init|=
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMillis
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertNotEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|htu
operator|.
name|waitFor
argument_list|(
name|thirtySeconds
argument_list|,
name|oneSecond
argument_list|,
parameter_list|()
lambda|->
block|{
specifier|final
name|List
argument_list|<
name|MasterThread
argument_list|>
name|masterThreads
init|=
name|cluster
operator|.
name|getMasterThreads
argument_list|()
decl_stmt|;
return|return
name|masterThreads
operator|!=
literal|null
operator|&&
name|masterThreads
operator|.
name|size
argument_list|()
operator|>=
literal|3
operator|&&
name|masterThreads
operator|.
name|stream
argument_list|()
operator|.
name|allMatch
argument_list|(
name|Thread
operator|::
name|isAlive
argument_list|)
return|;
block|}
argument_list|)
argument_list|)
expr_stmt|;
comment|// find the active master
specifier|final
name|HMaster
name|active
init|=
name|cluster
operator|.
name|getMaster
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
name|active
argument_list|)
expr_stmt|;
comment|// make sure the other two are backup masters
name|ClusterMetrics
name|status
init|=
name|active
operator|.
name|getClusterMetrics
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|status
operator|.
name|getBackupMasterNames
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// tell the active master to shutdown the cluster
name|active
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|assertNotEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|htu
operator|.
name|waitFor
argument_list|(
name|thirtySeconds
argument_list|,
name|oneSecond
argument_list|,
parameter_list|()
lambda|->
name|CollectionUtils
operator|.
name|isEmpty
argument_list|(
name|cluster
operator|.
name|getLiveMasterThreads
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertNotEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|htu
operator|.
name|waitFor
argument_list|(
name|thirtySeconds
argument_list|,
name|oneSecond
argument_list|,
parameter_list|()
lambda|->
name|CollectionUtils
operator|.
name|isEmpty
argument_list|(
name|cluster
operator|.
name|getLiveRegionServerThreads
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|htu
operator|!=
literal|null
condition|)
block|{
name|htu
operator|.
name|shutdownMiniCluster
argument_list|()
expr_stmt|;
name|htu
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/**    * This test appears to be an intentional race between a thread that issues a shutdown RPC to the    * master, while the master is concurrently realizing it cannot initialize because there are no    * region servers available to it. The expected behavior is that master initialization is    * interruptable via said shutdown RPC.    */
annotation|@
name|Test
specifier|public
name|void
name|testMasterShutdownBeforeStartingAnyRegionServer
parameter_list|()
throws|throws
name|Exception
block|{
name|LocalHBaseCluster
name|hbaseCluster
init|=
literal|null
decl_stmt|;
try|try
block|{
name|htu
operator|=
operator|new
name|HBaseTestingUtility
argument_list|(
name|createMasterShutdownBeforeStartingAnyRegionServerConfiguration
argument_list|()
argument_list|)
expr_stmt|;
comment|// configure a cluster with
specifier|final
name|StartMiniClusterOption
name|options
init|=
name|StartMiniClusterOption
operator|.
name|builder
argument_list|()
operator|.
name|numDataNodes
argument_list|(
literal|1
argument_list|)
operator|.
name|numMasters
argument_list|(
literal|1
argument_list|)
operator|.
name|numRegionServers
argument_list|(
literal|0
argument_list|)
operator|.
name|masterClass
argument_list|(
name|HMaster
operator|.
name|class
argument_list|)
operator|.
name|rsClass
argument_list|(
name|MiniHBaseCluster
operator|.
name|MiniHBaseClusterRegionServer
operator|.
name|class
argument_list|)
operator|.
name|createRootDir
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Can't simply `htu.startMiniCluster(options)` because that method waits for the master to
comment|// start completely. However, this test's premise is that a partially started master should
comment|// still respond to a shutdown RPC. So instead, we manage each component lifecycle
comment|// independently.
comment|// I think it's not worth refactoring HTU's helper methods just for this class.
name|htu
operator|.
name|startMiniDFSCluster
argument_list|(
name|options
operator|.
name|getNumDataNodes
argument_list|()
argument_list|)
expr_stmt|;
name|htu
operator|.
name|startMiniZKCluster
argument_list|(
name|options
operator|.
name|getNumZkServers
argument_list|()
argument_list|)
expr_stmt|;
name|htu
operator|.
name|createRootDir
argument_list|()
expr_stmt|;
name|hbaseCluster
operator|=
operator|new
name|LocalHBaseCluster
argument_list|(
name|htu
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|options
operator|.
name|getNumMasters
argument_list|()
argument_list|,
name|options
operator|.
name|getNumRegionServers
argument_list|()
argument_list|,
name|options
operator|.
name|getMasterClass
argument_list|()
argument_list|,
name|options
operator|.
name|getRsClass
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|MasterThread
name|masterThread
init|=
name|hbaseCluster
operator|.
name|getMasters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|shutdownFuture
init|=
name|CompletableFuture
operator|.
name|runAsync
argument_list|(
parameter_list|()
lambda|->
block|{
comment|// Switching to master registry exacerbated a race in the master bootstrap that can result
comment|// in a lost shutdown command (HBASE-8422, HBASE-23836). The race is essentially because
comment|// the server manager in HMaster is not initialized by the time shutdown() RPC (below) is
comment|// made to the master. The suspected reason as to why it was uncommon before HBASE-18095
comment|// is because the connection creation with ZK registry is so slow that by then the server
comment|// manager is usually init'ed in time for the RPC to be made. For now, adding an explicit
comment|// wait() in the test, waiting for the server manager to become available.
specifier|final
name|long
name|timeout
init|=
name|TimeUnit
operator|.
name|MINUTES
operator|.
name|toMillis
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|assertNotEquals
argument_list|(
literal|"timeout waiting for server manager to become available."
argument_list|,
operator|-
literal|1
argument_list|,
name|Waiter
operator|.
name|waitFor
argument_list|(
name|htu
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|timeout
argument_list|,
parameter_list|()
lambda|->
name|masterThread
operator|.
name|getMaster
argument_list|()
operator|.
name|getServerManager
argument_list|()
operator|!=
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// Master has come up far enough that we can terminate it without creating a zombie.
specifier|final
name|long
name|result
init|=
name|Waiter
operator|.
name|waitFor
argument_list|(
name|htu
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|timeout
argument_list|,
literal|500
argument_list|,
parameter_list|()
lambda|->
block|{
specifier|final
name|Configuration
name|conf
init|=
name|createResponsiveZkConfig
argument_list|(
name|htu
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to establish connection."
argument_list|)
expr_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|AsyncConnection
argument_list|>
name|connFuture
init|=
name|ConnectionFactory
operator|.
name|createAsyncConnection
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
init|(
specifier|final
name|AsyncConnection
name|conn
init|=
name|connFuture
operator|.
name|join
argument_list|()
init|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sending shutdown RPC."
argument_list|)
expr_stmt|;
try|try
block|{
name|conn
operator|.
name|getAdmin
argument_list|()
operator|.
name|shutdown
argument_list|()
operator|.
name|join
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Shutdown RPC sent."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|CompletionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failure sending shutdown RPC."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|CompletionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to establish connection."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Something unexpected happened."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
argument_list|)
decl_stmt|;
name|assertNotEquals
argument_list|(
literal|"Failed to issue shutdown RPC after "
operator|+
name|Duration
operator|.
name|ofMillis
argument_list|(
name|timeout
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
argument_list|)
decl_stmt|;
name|masterThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|shutdownFuture
operator|.
name|join
argument_list|()
expr_stmt|;
name|masterThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|hbaseCluster
operator|!=
literal|null
condition|)
block|{
name|hbaseCluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|htu
operator|!=
literal|null
condition|)
block|{
name|htu
operator|.
name|shutdownMiniCluster
argument_list|()
expr_stmt|;
name|htu
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Create a cluster configuration suitable for    * {@link #testMasterShutdownBeforeStartingAnyRegionServer()}.    */
specifier|private
specifier|static
name|Configuration
name|createMasterShutdownBeforeStartingAnyRegionServerConfiguration
parameter_list|()
block|{
specifier|final
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
comment|// make sure the master will wait forever in the absence of a RS.
name|conf
operator|.
name|setInt
argument_list|(
name|ServerManager
operator|.
name|WAIT_ON_REGIONSERVERS_MINTOSTART
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// don't need a long write pipeline for this test.
name|conf
operator|.
name|setInt
argument_list|(
literal|"dfs.replication"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
comment|/**    * Create a new {@link Configuration} based on {@code baseConf} that has ZooKeeper connection    * settings tuned very aggressively. The resulting client is used within a retry loop, so there's    * no value in having the client itself do the retries. We want to iterate on the base    * configuration because we're waiting for the mini-cluster to start and set it's ZK client port.    *    * @return a new, configured {@link Configuration} instance.    */
specifier|private
specifier|static
name|Configuration
name|createResponsiveZkConfig
parameter_list|(
specifier|final
name|Configuration
name|baseConf
parameter_list|)
block|{
specifier|final
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|(
name|baseConf
argument_list|)
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|ReadOnlyZKClient
operator|.
name|RECOVERY_RETRY
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|ReadOnlyZKClient
operator|.
name|RECOVERY_RETRY_INTERVAL_MILLIS
argument_list|,
literal|100
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
block|}
end_class

end_unit

