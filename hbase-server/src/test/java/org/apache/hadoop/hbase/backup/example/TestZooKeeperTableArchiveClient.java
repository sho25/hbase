begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|backup
operator|.
name|example
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|LargeTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|HFileCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|TimeToLiveHFileCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|CheckedArchivingHFileCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegionServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HFileArchiveTestingUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HFileArchiveUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|BaseMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|Description
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_comment
comment|/**  * Spin up a small cluster and check that the hfiles of region are properly long-term archived as  * specified via the {@link ZKTableArchiveClient}.  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
name|LargeTests
operator|.
name|class
argument_list|)
specifier|public
class|class
name|TestZooKeeperTableArchiveClient
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestZooKeeperTableArchiveClient
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|HBaseTestingUtility
name|UTIL
init|=
operator|new
name|HBaseTestingUtility
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|STRING_TABLE_NAME
init|=
literal|"test"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|TEST_FAM
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"fam"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|TABLE_NAME
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|STRING_TABLE_NAME
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|numRS
init|=
literal|2
decl_stmt|;
comment|/** time in ms to let hfiles live in the archive */
specifier|private
specifier|static
specifier|final
name|long
name|ttl
init|=
literal|1000
decl_stmt|;
comment|/** ms to wait for the archiver to realize it needs to change archiving state */
specifier|private
specifier|static
specifier|final
name|long
name|WAIT_FOR_ZK_ARCHIVE_STATE_CHANGE
init|=
literal|100
decl_stmt|;
specifier|private
specifier|static
name|ZKTableArchiveClient
name|archivingClient
decl_stmt|;
comment|/**    * Setup the config for the cluster    * @throws Exception on failure    */
annotation|@
name|BeforeClass
specifier|public
specifier|static
name|void
name|setupCluster
parameter_list|()
throws|throws
name|Exception
block|{
name|setupConf
argument_list|(
name|UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|UTIL
operator|.
name|startMiniCluster
argument_list|(
name|numRS
argument_list|)
expr_stmt|;
name|archivingClient
operator|=
operator|new
name|ZKTableArchiveClient
argument_list|(
name|UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|UTIL
operator|.
name|getHBaseAdmin
argument_list|()
operator|.
name|getConnection
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|setupConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// disable the ui
name|conf
operator|.
name|setInt
argument_list|(
literal|"hbase.regionsever.info.port"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// change the flush size to a small amount, regulating number of store files
name|conf
operator|.
name|setInt
argument_list|(
literal|"hbase.hregion.memstore.flush.size"
argument_list|,
literal|25000
argument_list|)
expr_stmt|;
comment|// so make sure we get a compaction when doing a load, but keep around some
comment|// files in the store
name|conf
operator|.
name|setInt
argument_list|(
literal|"hbase.hstore.compaction.min"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
literal|"hbase.hstore.compactionThreshold"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|// block writes if we get to 12 store files
name|conf
operator|.
name|setInt
argument_list|(
literal|"hbase.hstore.blockingStoreFiles"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
comment|// drop the number of attempts for the hbase admin
name|conf
operator|.
name|setInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// set the ttl on the hfiles
name|conf
operator|.
name|setLong
argument_list|(
name|TimeToLiveHFileCleaner
operator|.
name|TTL_CONF_KEY
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setStrings
argument_list|(
name|HFileCleaner
operator|.
name|MASTER_HFILE_CLEANER_PLUGINS
argument_list|,
name|CheckedArchivingHFileCleaner
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
argument_list|,
name|LongTermArchivingHFileCleaner
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Before
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|UTIL
operator|.
name|createTable
argument_list|(
name|TABLE_NAME
argument_list|,
name|TEST_FAM
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|UTIL
operator|.
name|deleteTable
argument_list|(
name|TABLE_NAME
argument_list|)
expr_stmt|;
comment|// and cleanup the archive directory
try|try
block|{
name|UTIL
operator|.
name|getTestFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|UTIL
operator|.
name|getDefaultRootDirPath
argument_list|()
argument_list|,
literal|".archive"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failure to delete archive directory"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// make sure that backups are off for all tables
name|archivingClient
operator|.
name|disableHFileBackup
argument_list|()
expr_stmt|;
block|}
annotation|@
name|AfterClass
specifier|public
specifier|static
name|void
name|cleanupTest
parameter_list|()
throws|throws
name|Exception
block|{
name|UTIL
operator|.
name|shutdownMiniCluster
argument_list|()
expr_stmt|;
block|}
comment|/**    * Test turning on/off archiving    * @throws Exception on failure    */
annotation|@
name|Test
specifier|public
name|void
name|testArchivingEnableDisable
parameter_list|()
throws|throws
name|Exception
block|{
comment|// 1. turn on hfile backups
name|LOG
operator|.
name|debug
argument_list|(
literal|"----Starting archiving"
argument_list|)
expr_stmt|;
name|archivingClient
operator|.
name|enableHFileBackupAsync
argument_list|(
name|TABLE_NAME
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Archving didn't get turned on"
argument_list|,
name|archivingClient
operator|.
name|getArchivingEnabled
argument_list|(
name|TABLE_NAME
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. Turn off archiving and make sure its off
name|archivingClient
operator|.
name|disableHFileBackup
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Archving didn't get turned off."
argument_list|,
name|archivingClient
operator|.
name|getArchivingEnabled
argument_list|(
name|TABLE_NAME
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3. Check enable/disable on a single table
name|archivingClient
operator|.
name|enableHFileBackupAsync
argument_list|(
name|TABLE_NAME
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Archving didn't get turned on"
argument_list|,
name|archivingClient
operator|.
name|getArchivingEnabled
argument_list|(
name|TABLE_NAME
argument_list|)
argument_list|)
expr_stmt|;
comment|// 4. Turn off archiving and make sure its off
name|archivingClient
operator|.
name|disableHFileBackup
argument_list|(
name|TABLE_NAME
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Archving didn't get turned off for "
operator|+
name|STRING_TABLE_NAME
argument_list|,
name|archivingClient
operator|.
name|getArchivingEnabled
argument_list|(
name|TABLE_NAME
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testArchivingOnSingleTable
parameter_list|()
throws|throws
name|Exception
block|{
comment|// turn on archiving for our table
name|enableArchiving
argument_list|(
name|STRING_TABLE_NAME
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|FSUtils
operator|.
name|getCurrentFileSystem
argument_list|(
name|UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
comment|// make sure there are files to archive
name|int
name|archived
init|=
name|loadAndEnsureArchivedStoreFiles
argument_list|(
name|STRING_TABLE_NAME
argument_list|,
name|TEST_FAM
argument_list|)
decl_stmt|;
name|waitForFilesToExpire
argument_list|()
expr_stmt|;
name|ensureAllTableFilesinArchive
argument_list|(
name|STRING_TABLE_NAME
argument_list|,
name|TEST_FAM
argument_list|,
name|fs
argument_list|,
name|archived
argument_list|)
expr_stmt|;
comment|// turn off archiving
name|disableArchiving
argument_list|(
name|STRING_TABLE_NAME
argument_list|)
expr_stmt|;
comment|// then ensure that those files are deleted after the timeout
name|waitForFilesToExpire
argument_list|()
expr_stmt|;
name|ensureAllTableFilesinArchive
argument_list|(
name|STRING_TABLE_NAME
argument_list|,
name|TEST_FAM
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// but that we still have the archive directory around
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|HFileArchiveUtil
operator|.
name|getArchivePath
argument_list|(
name|UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test archiving/cleaning across multiple tables, where some are retained, and others aren't    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testMultipleTables
parameter_list|()
throws|throws
name|Exception
block|{
comment|// create the another table that we don't archive
name|String
name|otherTable
init|=
literal|"otherTable"
decl_stmt|;
name|UTIL
operator|.
name|createTable
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|otherTable
argument_list|)
argument_list|,
name|TEST_FAM
argument_list|)
expr_stmt|;
comment|// archive the primary table
name|enableArchiving
argument_list|(
name|STRING_TABLE_NAME
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|FSUtils
operator|.
name|getCurrentFileSystem
argument_list|(
name|UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
comment|// make sure there are files to archive for both tables
name|int
name|primaryArchived
init|=
name|loadAndEnsureArchivedStoreFiles
argument_list|(
name|STRING_TABLE_NAME
argument_list|,
name|TEST_FAM
argument_list|)
decl_stmt|;
name|loadAndEnsureArchivedStoreFiles
argument_list|(
name|otherTable
argument_list|,
name|TEST_FAM
argument_list|)
expr_stmt|;
name|Path
name|otherStoreArchive
init|=
name|HFileArchiveTestingUtil
operator|.
name|getStoreArchivePath
argument_list|(
name|UTIL
argument_list|,
name|otherTable
argument_list|,
name|TEST_FAM
argument_list|)
decl_stmt|;
comment|// make sure we archive the primary table
name|ensureAllTableFilesinArchive
argument_list|(
name|STRING_TABLE_NAME
argument_list|,
name|TEST_FAM
argument_list|,
name|fs
argument_list|,
name|primaryArchived
argument_list|)
expr_stmt|;
name|waitForFilesToExpire
argument_list|()
expr_stmt|;
comment|// make sure that we didn't long-term archive the non-archive table
name|assertThat
argument_list|(
literal|0
argument_list|,
operator|new
name|HasExactFiles
argument_list|(
name|fs
argument_list|,
name|otherStoreArchive
argument_list|)
argument_list|)
expr_stmt|;
comment|// make sure we still archive the primary table
name|ensureAllTableFilesinArchive
argument_list|(
name|STRING_TABLE_NAME
argument_list|,
name|TEST_FAM
argument_list|,
name|fs
argument_list|,
name|primaryArchived
argument_list|)
expr_stmt|;
block|}
comment|/**    * Turn on hfile archiving and ensure its enabled    * @param tableName name of the table to enable    */
specifier|private
name|void
name|enableArchiving
parameter_list|(
name|String
name|tableName
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"----Starting archiving on table:"
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|archivingClient
operator|.
name|enableHFileBackupAsync
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Archving didn't get turned on"
argument_list|,
name|archivingClient
operator|.
name|getArchivingEnabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|waitForCleanerToChangeState
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Turn off hfile archiving and ensure its enabled    * @param tableName name of the table to enable    */
specifier|private
name|void
name|disableArchiving
parameter_list|(
name|String
name|tableName
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"----Disable archiving on table:"
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|archivingClient
operator|.
name|disableHFileBackup
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Archving didn't get turned of"
argument_list|,
name|archivingClient
operator|.
name|getArchivingEnabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|waitForCleanerToChangeState
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|waitForCleanerToChangeState
parameter_list|(
name|boolean
name|wasArchiving
parameter_list|)
throws|throws
name|InterruptedException
block|{
comment|// get the cleaner from the master
name|LongTermArchivingHFileCleaner
name|cleaner
init|=
operator|(
name|LongTermArchivingHFileCleaner
operator|)
name|UTIL
operator|.
name|getMiniHBaseCluster
argument_list|()
operator|.
name|getMaster
argument_list|()
operator|.
name|getHFileCleaner
argument_list|()
operator|.
name|getCleanerChain
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// wait for it to switch state
while|while
condition|(
name|cleaner
operator|.
name|isArchiving
argument_list|(
name|STRING_TABLE_NAME
argument_list|)
operator|==
name|wasArchiving
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|WAIT_FOR_ZK_ARCHIVE_STATE_CHANGE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Wait for files in the archive to expire    */
specifier|private
name|void
name|waitForFilesToExpire
parameter_list|()
throws|throws
name|Exception
block|{
comment|// sleep long enough for archived files to expire
name|Thread
operator|.
name|sleep
argument_list|(
name|ttl
operator|+
literal|10
argument_list|)
expr_stmt|;
comment|// make sure we clean the archive
name|ensureHFileCleanersRun
argument_list|()
expr_stmt|;
block|}
comment|/**    * Make sure all the {@link HFileCleaner} run.    *<p>    * Blocking operation up to 3x ttl    * @throws InterruptedException    */
specifier|private
name|void
name|ensureHFileCleanersRun
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting on archive cleaners to run..."
argument_list|)
expr_stmt|;
name|CheckedArchivingHFileCleaner
operator|.
name|resetCheck
argument_list|()
expr_stmt|;
do|do
block|{
name|UTIL
operator|.
name|getHBaseCluster
argument_list|()
operator|.
name|getMaster
argument_list|()
operator|.
name|getHFileCleaner
argument_list|()
operator|.
name|triggerNow
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Triggered, sleeping an amount until we can pass the check."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|CheckedArchivingHFileCleaner
operator|.
name|getChecked
argument_list|()
condition|)
do|;
block|}
comment|/**    * Load a table with a single region and compact the files (ensuring that there are some files in    * the archived directory).    * @param tableName name of the table to load    * @return the number of archived store files    * @throws Exception on failure    */
specifier|private
name|int
name|loadAndEnsureArchivedStoreFiles
parameter_list|(
name|String
name|tableName
parameter_list|,
name|byte
index|[]
name|family
parameter_list|)
throws|throws
name|Exception
block|{
name|byte
index|[]
name|table
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
comment|// get the RS and region serving our table
name|List
argument_list|<
name|HRegion
argument_list|>
name|servingRegions
init|=
name|UTIL
operator|.
name|getHBaseCluster
argument_list|()
operator|.
name|getRegions
argument_list|(
name|table
argument_list|)
decl_stmt|;
comment|// make sure we only have 1 region serving this table
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|servingRegions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|HRegion
name|region
init|=
name|servingRegions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// get the parent RS and monitor
name|HRegionServer
name|hrs
init|=
name|UTIL
operator|.
name|getRSForFirstRegionInTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|hrs
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
comment|// put some data on the region
name|LOG
operator|.
name|debug
argument_list|(
literal|"-------Loading table"
argument_list|)
expr_stmt|;
comment|// load the region with data
name|UTIL
operator|.
name|loadRegion
argument_list|(
name|region
argument_list|,
name|family
argument_list|)
expr_stmt|;
comment|// wait for the flushes/compactions to finish
name|region
operator|.
name|waitForFlushesAndCompactions
argument_list|()
expr_stmt|;
comment|// then trigger a compaction to be sure we have files in the archive
name|Store
name|store
init|=
name|region
operator|.
name|getStore
argument_list|(
name|family
argument_list|)
decl_stmt|;
try|try
block|{
name|store
operator|.
name|compactRecentForTesting
argument_list|(
name|store
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// we can ignore this, as long as we have some archived files, which is checked below
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to compact store:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|", current store files:"
operator|+
name|store
operator|.
name|getStorefilesCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// check that we actually have some store files that were archived
name|Path
name|storeArchiveDir
init|=
name|HFileArchiveTestingUtil
operator|.
name|getStoreArchivePath
argument_list|(
name|UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|region
argument_list|,
name|store
argument_list|)
decl_stmt|;
comment|// check to make sure we archived some files
name|int
name|storeFiles
init|=
name|FSUtils
operator|.
name|listStatus
argument_list|(
name|fs
argument_list|,
name|storeArchiveDir
argument_list|,
literal|null
argument_list|)
operator|.
name|length
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Didn't create a store archive directory"
argument_list|,
name|fs
operator|.
name|exists
argument_list|(
name|storeArchiveDir
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
literal|null
argument_list|,
operator|new
name|HasAnyFiles
argument_list|(
name|fs
argument_list|,
name|storeArchiveDir
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|storeFiles
return|;
block|}
comment|/**    * Compact all the store files in a given region. If there is only a single store file, ensures    * that there are some archived store files (from a previous compaction) on which to test    * archiving.    */
specifier|private
name|void
name|compactRegion
parameter_list|(
name|HRegion
name|region
parameter_list|,
name|byte
index|[]
name|family
parameter_list|)
throws|throws
name|IOException
block|{    }
specifier|private
name|void
name|ensureAllTableFilesinArchive
parameter_list|(
name|String
name|tablename
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|int
name|expectedArchiveFiles
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|HRegion
argument_list|>
name|servingRegions
init|=
name|UTIL
operator|.
name|getHBaseCluster
argument_list|()
operator|.
name|getRegions
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tablename
argument_list|)
argument_list|)
decl_stmt|;
comment|// make sure we only have 1 region serving this table
name|assertEquals
argument_list|(
literal|"Test doesn't support more than 1 region serving table: "
operator|+
name|tablename
operator|+
literal|""
argument_list|,
literal|1
argument_list|,
name|servingRegions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|HRegion
name|region
init|=
name|servingRegions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Store
name|store
init|=
name|region
operator|.
name|getStore
argument_list|(
name|TEST_FAM
argument_list|)
decl_stmt|;
name|Path
name|storeArchiveDir
init|=
name|HFileArchiveTestingUtil
operator|.
name|getStoreArchivePath
argument_list|(
name|UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|region
argument_list|,
name|store
argument_list|)
decl_stmt|;
comment|// log the current fs state for the archive dir
name|Path
name|regionArchiveDir
init|=
name|HFileArchiveUtil
operator|.
name|getArchivePath
argument_list|(
name|UTIL
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|FSUtils
operator|.
name|logFileSystemState
argument_list|(
name|fs
argument_list|,
name|regionArchiveDir
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
comment|// if we don't have store files, we shouldn't have the directory, but otherwise should have the
comment|// store archive directory to store the archived files
name|assertEquals
argument_list|(
literal|"Didn't create a store archive directory:"
operator|+
name|storeArchiveDir
argument_list|,
name|expectedArchiveFiles
operator|!=
literal|0
argument_list|,
name|fs
operator|.
name|exists
argument_list|(
name|storeArchiveDir
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|expectedArchiveFiles
argument_list|,
operator|new
name|HasExactFiles
argument_list|(
name|fs
argument_list|,
name|storeArchiveDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
class|class
name|HasAnyFiles
extends|extends
name|BaseMatcher
argument_list|<
name|Object
argument_list|>
block|{
specifier|protected
name|FileSystem
name|fs
decl_stmt|;
specifier|protected
name|Path
name|storeArchiveDir
decl_stmt|;
specifier|public
name|HasAnyFiles
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|storeArchiveDir
parameter_list|)
block|{
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|storeArchiveDir
operator|=
name|storeArchiveDir
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|Object
name|arg0
parameter_list|)
block|{
try|try
block|{
return|return
name|FSUtils
operator|.
name|listStatus
argument_list|(
name|fs
argument_list|,
name|storeArchiveDir
argument_list|,
literal|null
argument_list|)
operator|.
name|length
operator|>
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to read the FS!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|describeTo
parameter_list|(
name|Description
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|appendText
argument_list|(
literal|"No store files in archive"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|HasExactFiles
extends|extends
name|BaseMatcher
argument_list|<
name|Integer
argument_list|>
block|{
specifier|protected
name|FileSystem
name|fs
decl_stmt|;
specifier|protected
name|Path
name|storeArchiveDir
decl_stmt|;
specifier|public
name|HasExactFiles
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|storeArchiveDir
parameter_list|)
block|{
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|storeArchiveDir
operator|=
name|storeArchiveDir
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|Object
name|arg0
parameter_list|)
block|{
try|try
block|{
name|int
name|expected
init|=
operator|(
operator|(
name|Integer
operator|)
name|arg0
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|FileStatus
index|[]
name|files
init|=
name|FSUtils
operator|.
name|listStatus
argument_list|(
name|fs
argument_list|,
name|storeArchiveDir
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|expected
operator|==
literal|0
operator|&&
name|files
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Directory '"
operator|+
name|storeArchiveDir
operator|+
literal|"' doesn't exist, therefore 0 files!"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|expected
operator|==
name|files
operator|.
name|length
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to read the FS!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|describeTo
parameter_list|(
name|Description
name|desc
parameter_list|)
block|{
name|desc
operator|.
name|appendText
argument_list|(
literal|"Store files in archive doesn't match expected"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

